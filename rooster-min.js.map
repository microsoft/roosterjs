{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/safeInstanceOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/toArray.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/isNodeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/arrayPush.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/normalizeRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VList.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getListTypeFromNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectionRangeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/getStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/setStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/getAllFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getInnerHTML.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListItem.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getRootListNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/collapseNodesInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/mergeBlocksInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getPredefinedCssForElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isModifierKey.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentCommitListChains.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/toggleListType.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockWrap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/readFile.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/createVListFromRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/regionTypeData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/addRangeToSelection.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/deleteSelectedContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canUndoAutoComplete.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/commitEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntityFromElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntitySelector.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCharacterValue.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCtrlOrMetaPressed.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/rotateElement.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeCapitalization.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/cursorFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/entityFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/structuredNodeFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/coreApiMap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/addUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/createPasteFragment.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/ensureTypeInContainer.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getStyleBasedFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/restoreUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/selectRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/setContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/switchShadowEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/transformColor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/createCorePlugins.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CopyPastePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EntityPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/LifecyclePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/PendingFormatStatePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeAfterLinkPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/UndoPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/teamsConverter/convertPastedContentFromTeams.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/lineMerge/handleLineMerge.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Picker.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","default","Browser","getBrowserInfo","getComputedStyle","PendableFormatCommandMap","splitBalancedNodeRange","getNextLeafSibling","getPreviousLeafSibling","getFirstLeafNode","getLastLeafNode","node","nodeType","tagName","toUpperCase","container","contained","treatSameNodeAsContain","commonAncestorContainer","parentNode","contains","internalContains","getTargetWindow","source","document","ownerDocument","toString","apply","defaultView","window","obj","typeName","targetWindow","targetType","mainWindow","mainWindowType","nodeOrPosition","offsetOrPosType","isFromEndOfRange","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","nextNode","lastChild","childNodes","Position","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","collapsed","endContainer","previousSibling","nodeValue","length","collection","slice","FONT_SIZES","getElementBasedFormatState","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","getLeafSibling","startNode","isNext","skipTags","ignoreSpace","getSibling","getChild","curNode","shouldContinue","indexOf","pendableFormatCommands","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","addUndoSnapshot","keys","map","isPendableFormatCommand","triggerPluginEvent","formatState","getPendableFormatState","getFocusablePosition","isNodePosition","arg","getPositionFromPath","path","arg1","arg2","arg3","arg4","start","end","Array","isArray","createRange","setStart","setEnd","callback","getTagOfNode","createTextNode","insertNode","applyTextStyle","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","inlineElement","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","isInnerNode","node1","node2","compareDocumentPosition","wrapper","test","createElement","insertBefore","appendChild","parent","parentBlock","nodeChain","push","currentNode","tag","resolveInlineElement","checkPosition","targets","some","target","selector","forEachCallback","scope","elements","querySelectorAll","child","filter","endNode","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","forEach","collapse","root","ref","isStart","canSplitParent","startIndex","endIndex","splitParentNode","splitBefore","newParent","cloneNode","removeAttribute","innerHTML","temp","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","style","display","closest","matches","msMatchesSelector","parentElement","CRLF","CRLFSPACE","shouldSkipNode","textContent","replace","region","nodeBefore","nodeAfter","html","scoper","createBodyTraverser","ContentTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","getEndNode","getStartNode","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","getStartPosition","getParentBlock","getContainerNode","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","containerNode","getTextContent","getEndPosition","isTextualInlineElement","pos","styler","getDecoratedInline","PartialInlineElement","thisStart","otherEnd","from","to","previousNode","userAgent","appVersion","isIE11OrGreater","isIE","isChrome","isFirefox","isSafari","isEdge","isWebKit","isMac","isWin","isIEOrEdge","navigator","newTag","newElement","attributes","attr","setAttribute","marginTop","marginBottom","replaceChild","beforeRunCallback","regions","getSelectedRegions","VListChain","createListChains","STYLETAGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","shift","removeChild","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","getComputedStyles","styleNames","styles","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","isPartial","mainArray","itemsArray","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","ZERO_WIDTH_SPACE","trim","trimContent","clientRect","left","right","top","bottom","rootList","items","Error","moveChildNodesToLi","moveLiToList","populateItems","item","getLastItemNumber","undefined","getListType","getLevel","writeBack","lastList","doc","listStack","createDocumentFragment","placeholder","topList","setIndentation","indentation","findListItems","outdent","indent","changeListType","needChangeType","appendItem","type","nodeTag","mergeVList","list","originalLength","splice","mergeOrphanNodesAfter","isOrphanItem","canMerge","mergeItems","listStartPos","getNode","listEndPos","index","listTypes","newListTypes","isListElement","currentItem","li","furtherNodes","getListTypeFromNode","regionBase","regionRange","fullSelectionEnd","fullSelectionStart","isRegion","regionStart","regionEnd","getAttribute","pair","valueIndex","x","snapshots","step","newIndex","currentIndex","allFeatures","ListFeatures","QuoteFeatures","TableFeatures","StructuredNodeFeatures","AutoLinkFeatures","ShortcutFeatures","CursorFeatures","MarkdownFeatures","EntityFeatures","collapseToSingleElement","equals","blockElement","HTML_VOID_ELEMENTS","isFirst","getLeafNode","tempNode","orderListStyles","wrapIfNotBlockNode","listType","pop","originalRoot","nextLevel","newList","createListElement","newRoot","listStyleType","checkFirst","checkLast","ancestor","createBlockIfEmpty","blocks","traverser","block","getRegionCreator","fullRange","firstNodeOfRegion","lastNodeOfRegion","firstNodeValid","lastNodeValid","bothValid","areNodesValid","innerSelector","boundaryTree","allBoundaries","innerNode","children","outerSelector","inSelectionOuterNode","thisInnerNode","thisOuterNode","boundary","outerNode","boundaries","buildBoundaryTree","iterateNodes","creator","started","ended","previousOuterNode","newRegions","concat","nodesOrBlockElements","refNode","targetNode","blockRoot","commonContainer","safeInstanceOf","nodeToRemove","nodeToMerge","PREDEFINED_CSS_FOR_ELEMENT","B","EM","I","U","P","PRE","S","STRIKE","SUB","SUP","additionalPredefinedCssForElement","getPositionPath","unshift","isPreviousText","removedSize","totalSize","autoCompleteIndex","INHERITABLE_PROPERTIES","win","cloneObject","assign","existingObj","event","isCtrlKey","ctrlKey","isAltKey","altKey","isMetaKey","metaKey","chains","chain","commit","color","backgroundColor","isDarkMode","darkModeColor","lightModeColor","dataset","fontName","fontFamily","fontSize","lineHeight","startNumber","canAppendAtCursor","vList","createVListAtBlock","getBlockElementAtNode","createVListFromRegion","wrapFunction","getSelectedBlockElementsInRegion","collapseNodesInRegion","NodeTag","wrap","toArray","isNodeInRegion","hasFocus","core","activeElement","contentDiv","getAndSetNodeId","wordCustomData","id","nextNodeId","dict","listsMetadata","currentUniqueListId","WORD_ORDERED_LIST_SELECTOR","WORD_UNORDERED_LIST_SELECTOR","WORD_ONLINE_IDENTIFYING_SELECTOR","LIST_CONTAINER_ELEMENT_CLASS_NAME","UNORDERED_LIST_TAG_NAME","ORDERED_LIST_TAG_NAME","WAC_IDENTIFING_SELECTOR","additionalPlugins","initialContent","plugins","HyperLink","Paste","ContentEdit","options","defaultFormat","textColor","Editor","settingsOverride","additionalFeatures","getName","initialize","features","feature","hasSettingForKey","defaultDisabled","addContentEditFeature","dispose","TRAILING_PUNCTUATION_REGEX","AutoLink","shouldHandleEvent","cacheGetLinkData","handleEvent","anchor","linkData","searcher","getContentSearcherOfCursor","originalUrl","href","normalizedUrl","runAsync","replaceWithNode","clearEventDataCache","UnlinkWhenBackspaceAfterLink","getInlineElementBefore","LinkInlineElement","rawEvent","preventDefault","removeLink","eventType","cacheGetEventData","clipboardData","data","link","matchLink","text","getRangeFromText","word","getWordBefore","trailingPunctuation","match","substring","str","autoLink","unlinkWhenBackspaceAfterLink","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","STRUCTURE_NODE_TAGS","StartEndBlockElement","blockContext","getFirstInlineElement","startFrom","blockNode","getLastInlineElement","getFirstLastInlineElementFromBlockElement","startInline","getInlineElementAfter","startBlock","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","inlineElements","traverse","inlineBefore","inlineAfter","getSubStringBefore","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","exec","format","elementStyle","textColors","backgroundColors","bold","italic","underline","fontWeight","fontStyle","textDecoration","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","getAsFile","files","file","getAsString","Promise","resolve","types","getData","image","rawHtml","customValues","handlers","TEXT_TYPE_PREFIX","promise","headerValues","parseInt","workaroundForEdge","allowLinkPreview","linkPreview","JSON","parse","allowedCustomPasteType","all","handler","then","values","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","FileReader","onload","onerror","readAsDataURL","trs","table","td","getTableFromTd","rows","cells","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","moveChildren","cell","recalcSpans","applyFormat","borderCollapse","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","cloneCell","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","getCellsWithBorder","borderPos","getLeftCells","closestIndex","closestValue","Number","MAX_SAFE_INTEGER","j","cellRect","getBoundingClientRect","found","forEachCellOfRow","getCurrentTd","isNaN","fromNode","toNode","tryIncludeSiblingNode","includeSiblingLists","nodeForItem","listNode","createVListFromItemNode","lastChainIndex","lastNumber","lastNumberBeforeCursor","nameGenerator","ol","canAppendToTail","createListChainName","afterCurrentNode","append","applyChainName","lists","getLists","vlist","isAfterCurrentNode","regionTypeData","rect","rects","getClientRects","span","areAllPrevousNodesEmpty","isDOMChanged","tbody","content","selectionPath","stringify","pathComment","skipSameRange","selection","getSelection","needAddRange","rangeCount","currentRange","getRangeAt","removeAllRanges","e","addRange","ensureBeforeAndAfter","emptyNode","nodesToDelete","nodesPairToMerge","beforeEnd","afterEnd","beforeStart","afterStart","snapshot","isAutoCompleteSnapshot","removeCount","maxSize","elementCallbacks","styleCallbacks","getStyleCallbacks","cssStyleCallbacks","attributeCallbacks","tagReplacements","getTagReplacement","additionalTagReplacements","allowedAttributes","getAllowedAttributes","additionalAllowedAttributes","allowedCssClassesRegex","getAllowedCssClassesRegex","additionalAllowedCssClasses","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","unknownTagReplacement","convertInlineCss","additionalStyleNodes","HtmlSanitizer","sanitizeHtml","sanitizer","currentStyles","currentElementOrStyle","convertCssOnly","DOMParser","parseFromString","body","convertGlobalCssToInlineCss","sanitize","processNode","styleNodes","reverse","sheet","styleSheet","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","isText","isFragment","shouldKeep","replacement","whiteSpace","thisStyle","processAttributes","preprocessCss","processCss","next","predefinedStyles","isInheritable","keep","attribute","newValue","processCssClass","originalValue","calculatedValue","originalClasses","calculatedClasses","className","HTML_TAG_REPLACEMENT","a","abbr","address","area","article","aside","b","bdi","bdo","blockquote","br","button","canvas","caption","center","cite","code","colgroup","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","fieldset","figcaption","figure","font","footer","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","img","input","ins","kbd","label","legend","main","mark","menu","menuitem","meter","nav","optgroup","option","output","picture","pre","progress","q","rp","rt","ruby","samp","section","small","strike","strong","sub","summary","sup","template","textarea","tfoot","th","thead","time","tt","u","ul","var","wbr","xmp","form","applet","audio","base","basefont","embed","frame","frameset","iframe","meta","noscript","param","script","slot","title","track","video","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","overflow","padding","border","float","ALLOWED_CSS_CLASSES","removeValue","removeWidthForLiAndDiv","additionalReplacements","replacements","additionalAttributes","array","self","toLocaleLowerCase","additionalCssClasses","patterns","additionalDefaultStyles","callbacks","width","newCallback","args","isReadonly","contentEditable","isEntity","eventDataCache","isCtrlOrMetaPressed","TAGS_TO_UNWRAP","ATTRIBUTES_TO_PRESERVE","TAGS_TO_STOP_UNWRAP","clearNodeFormat","areAllChildrenBlock","returnBlockElement","isBlockElement","isVoidHtmlElement","unwrap","isTableCell","removeNonBorderStyles","clearAttribute","getStyles","setStyles","nonborderStyles","STYLES_TO_REMOVE","queryElements","getDefaultFormat","isDefaultFormatEmpty","removeProperty","URI_REGEX","MAILTO_REGEX","FTP_REGEX","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","santizer","checkXss","prefix","search","applyLinkPrefix","listTag","getElementAtCursor","headerTag","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","getStyleBasedFormatState","getUndoState","contentNode","isBlock","commitEntity","contentPosition","existingEntity","getEntitySelector","updateCursor","insertOnNewLine","replaceSelection","entity","getEntityFromElement","triggerContentChangedEvent","insertImageWithSrc","src","maxWidth","imageFile","readFile","dataUrl","isDisposed","getTableCellWidth","columns","fragment","cellSpacing","cellPadding","vtable","VTable","cellToSelect","currentCol","newRow","newCol","calculateCellToSelect","textOrRange","backupRange","angle","transform","alignment","align","textAlign","direction","isEmptyBlockUnderTR","quote","findClosestElementAncestor","blockGroups","group","capitalization","language","getCapitalizedText","originalText","toLocaleUpperCase","wordArray","charAt","regex","DEFAULT_STYLER","borderColor","paddingLeft","PRE_TAG","level","wrapped","replaceNode","NoCycleCursorMove","allowFunctionKeys","ctrlOrMeta","isPositionAtBeginning","rtl","which","noCycleCursorMove","ClickOnEntityFeature","cacheGetReadonlyEntityElement","EscapeFromEntityFeature","entityElement","isContentEditable","EnterBeforeReadonlyEntityFeature","cacheGetNeighborEntityElement","newContainer","deleteContents","BackspaceAfterEntityFeature","DeleteBeforeEntityFeature","collapseOnly","entityNode","getBodyTraverser","clickOnEntity","escapeFromEntity","enterBeforeReadonlyEntity","backspaceAfterEntity","deleteBeforeEntity","IndentWhenTab","shiftKey","cacheGetListElement","OutdentWhenShiftTab","MergeInNewLine","isPositionAtBeginningOf","getListChains","experimentCommitListChains","toggleListAndPreventDefault","OutdentWhenBackOn1stEmptyLine","isNodeEmpty","OutdentWhenEnterOnEmptyLine","AutoBullet","textBeforeCursor","rangeToDelete","prepareAutoBullet","toggleBullet","toggleNumbering","num","MaintainListChain","listInfo","listElement","autoBullet","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","maintainListChain","generateBasicMarkdownFeature","triggerCharacter","elementTag","useShiftKey","cacheGetRangeForMarkdownOperation","textContentRange","cloneRange","elementToWrap","extractContents","nonPrintedSpaceTextNode","handleMarkdownEvent","textInlineElement","inlineTextContent","contentIndex","MarkdownBold","MarkdownItalic","MarkdownStrikethru","MarkdownInlineCode","markdownBold","markdownItalic","markdownStrikethru","markdownInlineCode","QUOTE_TAG","STRUCTURED_TAGS","UnquoteWhenBackOnEmpty1stLine","childOfQuote","cacheGetQuoteChild","splitQuote","UnquoteWhenEnterOnEmptyLine","getFocusedPosition","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","createCommand","winKey","macKey","action","commands","toggleBold","toggleItalic","toggleUnderline","undo","redo","changeFontSize","DefaultShortcut","cacheGetCommand","stopPropagation","cmd","defaultShortcut","NEWLINE_HTML","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","InsertLineBeforeStructuredNodeFeature","cacheGetStructuredElement","fromHtml","insertLineBeforeStructuredNodeFeature","TabInTable","cacheGetTableCell","editTable","UpDownInTable","isUp","hasShiftKey","targetTd","anchorNode","anchorOffset","newPos","setBaseAndExtent","firstTd","tabInTable","upDownInTable","corePlugins","PLACEHOLDER_PLUGIN_NAME","arrayPush","api","coreApiMap","coreApiOverride","getPluginState","plugin","ensureTypeInContainer","deleteNode","existingNode","transformColorForDarkMode","transformColor","scopeOrCallback","Function","collapseNodes","isEmpty","getContent","setContent","insertContent","allNodes","deleteSelectedContent","paste","pasteAsText","applyCurrentFormat","snapshotBeforePaste","createPasteFragment","tryGetFromCache","getSelectionPath","selectRange","sel","focusNode","focusOffset","getRegionsFromRange","addDomEventHandler","nameOrMap","eventsToMap","attachDomEvent","broadcast","triggerEvent","restoreUndoSnapshot","changeSource","canUndoByBackspace","hasNewContent","snapshotsService","canUndo","canMove","canRedo","getScrollContainer","domEvent","scrollContainer","getCustomData","disposer","lifecycle","customData","isInIME","getBlockTraverser","PositionContentSearcher","requestAnimationFrame","setEditorDomAttribute","getEditorDomAttribute","keyboardEvent","setDarkModeState","nextDarkMode","currentContent","startShadowEdit","switchShadowEdit","stopShadowEdit","isInShadowEdit","shadowEditFragment","isFeatureEnabled","experimentalFeatures","undoState","isNested","isShadowEdit","addSnapshot","autoCompletePosition","eventMap","disposers","eventName","handlerObj","pluginEventType","beforeDispatch","onEvent","addEventListener","removeEventListener","processStyles","applyCurrentStyle","sanitizingOption","createDefaultHtmlSanitizerOptions","htmlBefore","htmlAfter","htmlAttributes","createBeforePasteEvent","imageDataUri","querySelector","attrs","lastIndexOf","pendableFormat","styleBasedForamt","getCurrentFormat","line","lines","getInheritableStyles","shouldSetNodeStyles","innerText","wasNodeJustCreatedByKeyboardEvent","selectionRange","triggerExtractContentEvent","includeSelectionMarker","clonedRoot","clonedNode","originalRange","shadowEditSelectionPath","getHtmlWithSelectionPath","ogTextColorNode","ogBackgroundColorNode","adjustSteps","nodeToInsert","safeRemove","normalizedPosition","splitTextNode","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listItem","tdNode","trNode","newTable","currentTable","shouldInsertListAsText","changeElementTag","isBegin","getFirstLastBlockElement","insertedNode","rangeToRestore","nodeForCursor","isRestoring","addRangeToSelection","pendingFormatState","pendableFormatState","pendableFormatPosition","restorePendingFormatState","contentChanged","setHtmlWithSelectionPath","isOn","wasInShadowEdit","STYLE_DATASET_MAP","ATTR_DATASET_MAP","getValueOrDefault","defualtValue","includeSelf","elementsToTransform","allChildren","getElementsByTagName","getAll","onExternalContentTransform","pluginEvent","onPluginEvent","willHandleEventExclusively","handledExclusively","corePluginOverride","typeInContainer","_placeholder","typeAfterLink","mouseUp","copyPaste","getState","onPaste","extractClipboardEvent","getTempDiv","cleanUpAndRestoreSelection","copy","onCutCopy","cut","isCut","newRange","forceInLightMode","tempDiv","onDrop","onFocus","onBlur","onScroll","onKeybaordEvent","isCharacterValue","onInputEvent","onContextMenuEvent","allItems","elementBeforeCursor","eventTargetNode","contextMenuProviders","provider","getContextMenuItems","stopPrintableKeyboardEventPropagation","allowKeyboardEventPropagation","isContextMenuProvider","keypress","getEventHandler","keydown","keyup","mousedown","contextmenu","compositionstart","compositionend","drop","hasFunctionKey","ENTITY_ID_REGEX","handleCutEvent","checkRemoveEntityForRange","clickingPoint","knownEntityElements","handleMouseDownEvent","handleMouseUpEvent","handleKeyDownEvent","handleBeforePasteEvent","handleContentChangedEvent","handleExtractContentWithDomEvent","handleContextMenuEvent","pageX","pageY","workaroundSelectionIssueForIE","resetAll","allId","hydrateEntity","editableEntityElements","isFullyCovered","knownIds","baseId","newId","workaroundButton","height","onblur","COMMANDS","DARK_MODE_DEFAULT_FORMAT","contentDivFormat","initializer","setSelectStyle","inDarkMode","recalculateDefaultFormat","adjustBrowserBehavior","userSelect","msUserSelect","webkitUserSelect","baseFormat","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","clear","getCurrentPosition","inlineElementBefore","inlineElementAfter","undoSnapshotService","createSnapshots","delta","canMoveCurrentSnapshot","moveCurrentSnapsnot","clearRedo","clearProceedingSnapshots","canUndoAutoComplete","onKeyDown","onKeyPress","clearRedoForInput","evt","lastKeyPress","getTooltipCallback","onLinkClick","trackedLink","onMouse","tryGetHref","updateLinkHrefIfShouldUpdate","resetLinkTracking","mouseover","mouseout","blur","isContentEditValue","shouldCheckUpdateLink","originalHref","doesLinkDisplayMatchHref","srcElement","open","updateLinkHref","escapedDisplay","wacListElements","el","margin","isWordOnlineWithList","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","excelHandler","trMatch","tableMatch","chainSanitizerCallback","borderStyle","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","nextUniqueId","numBulletsConverted","numNumberedConverted","createCustomData","listItems","currentListIdsByLevels","createLevelLists","lastProcessedItem","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","getObject","uniqueListId","setObject","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","resetCurrentLists","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","processBlock","checkAndAddBr","insertConvertedListToDoc","convertedListElement","listItemBlock","insertPositionNode","startElement","replaceRegex","prevParent","nextParent","sanitizeListItemContainer","curListItemBlock","listElements","curItem","listItemContainers","lastItemInCurBlock","endElement","createListItemBlock","getListItemBlocks","itemBlock","flattenListBlock","listItemContainer","getContainerListType","itemLevel","listRootElement","itemToInsert","curListLevel","lastElementChild","lastChildTag","firstElementChild","insertListItem","parentContainer","onDismiss","isMenuShowing","dismiss","allowDefaultMenu","initContainer","render","y","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","updateReplacements","newReplacements","longestReplacementLength","replacementEndCharacters","endChars","Set","lastChar","add","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","cacheListChains","expectedChangeSource","ENTITY_TYPE","CORNER_HANDLE_POSITIONS","ALL_HANDLE_POSITIONS","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","getSelectedImage","startPageX","startPageY","startWidth","clientWidth","startHeight","clientHeight","doResize","finishResize","stopEvent","widthChange","heightChange","newWidth","calculateNewWidth","newHeight","calculateNewHeight","shouldPreserveRatio","isSingleDirectionNS","isSingleDirectionWE","ratio","resizeDiv","removeResizeDiv","hideResizeHandle","onDragStart","dragstart","currentImg","showResizeHandle","createResizeDiv","selectImageAfterUnSelect","isWest","isNorth","selectedImage","divWithImage","ESC_CHARCODE","LEFT_ARROW_CHARCODE","UP_ARROW_CHARCODE","RIGHT_ARROW_CHARCODE","DOWN_ARROW_CHARCODE","DELETE_CHARCODE","UNIDENTIFIED_CODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIdPrefix","eventHandledOnKeyDown","isAndroidKeyboardEvent","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","isModifierKey","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","bufferZone","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix","charCode","tableRectMap","currentCellsToResize","nextCellsToResize","resizingState","insertingState","onMouseMove","cacheRects","isRTL","setCurrentTable","tdRect","normalizeRect","verticalInserterTd","preTd","previousElementSibling","setCurrentTd","setCurrentInsertTd","horizontalInserterTd","insertTd","currentInsertTd","startHorizontalResizeTable","startResizeTable","startVerticalResizeTable","currentTd","frameAnimateResizeTable","resizeTable","leftBoundary","rightBoundary","wordBreak","boxSizing","tdWidth","endResizeTable","setupResizerContainer","onMouseMoveDisposer","destoryRectMap","removeResizerContainer","resizerContainer","tableRect","inserter","createInserter","inserterBackgroundColor","inserterColor","HORIZONTAL_INSERTER_HTML","VERTICAL_INSERTER_HTML","resizerPosX","horizontalResizer","verticalResizer","createResizer","horizontal","watermark","showHideWatermark","watermarks","isShowing","removeWatermark","insertEntity","spellcheck"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 83);\n","export { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as arrayPush } from './utils/arrayPush';\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport {\r\n    default as getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from './utils/getPendableFormatState';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\nexport { default as getTextContent } from './utils/getTextContent';\r\nexport { default as splitTextNode } from './utils/splitTextNode';\r\nexport { default as normalizeRect } from './utils/normalizeRect';\r\nexport { default as toArray } from './utils/toArray';\r\nexport { default as safeInstanceOf } from './utils/safeInstanceOf';\r\nexport { default as readFile } from './utils/readFile';\r\nexport { default as getInnerHTML } from './utils/getInnerHTML';\r\n\r\nexport { default as VTable } from './table/VTable';\r\nexport { default as VList } from './list/VList';\r\nexport { default as VListItem } from './list/VListItem';\r\nexport { default as createVListFromRegion } from './list/createVListFromRegion';\r\nexport { default as VListChain } from './list/VListChain';\r\n\r\nexport { default as getRegionsFromRange } from './region/getRegionsFromRange';\r\nexport { default as getSelectedBlockElementsInRegion } from './region/getSelectedBlockElementsInRegion';\r\nexport { default as collapseNodesInRegion } from './region/collapseNodesInRegion';\r\nexport { default as isNodeInRegion } from './region/isNodeInRegion';\r\nexport { default as getSelectionRangeInRegion } from './region/getSelectionRangeInRegion';\r\nexport { default as mergeBlocksInRegion } from './region/mergeBlocksInRegion';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport { default as getSelectionPath } from './selection/getSelectionPath';\r\nexport { default as getHtmlWithSelectionPath } from './selection/getHtmlWithSelectionPath';\r\nexport { default as setHtmlWithSelectionPath } from './selection/setHtmlWithSelectionPath';\r\nexport { default as addRangeToSelection } from './selection/addRangeToSelection';\r\nexport { default as deleteSelectedContent } from './selection/deleteSelectedContent';\r\n\r\nexport { default as addSnapshot } from './snapshots/addSnapshot';\r\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\r\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\r\nexport { default as moveCurrentSnapsnot } from './snapshots/moveCurrentSnapsnot';\r\nexport { default as createSnapshots } from './snapshots/createSnapshots';\r\nexport { default as canUndoAutoComplete } from './snapshots/canUndoAutoComplete';\r\n\r\nexport { default as HtmlSanitizer } from './htmlSanitizer/HtmlSanitizer';\r\nexport { default as getInheritableStyles } from './htmlSanitizer/getInheritableStyles';\r\nexport { default as createDefaultHtmlSanitizerOptions } from './htmlSanitizer/createDefaultHtmlSanitizerOptions';\r\nexport { default as chainSanitizerCallback } from './htmlSanitizer/chainSanitizerCallback';\r\n\r\nexport { default as commitEntity } from './entity/commitEntity';\r\nexport { default as getEntityFromElement } from './entity/getEntityFromElement';\r\nexport { default as getEntitySelector } from './entity/getEntitySelector';\r\n\r\nexport { default as cacheGetEventData } from './event/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './event/clearEventDataCache';\r\nexport { default as isModifierKey } from './event/isModifierKey';\r\nexport { default as isCharacterValue } from './event/isCharacterValue';\r\nexport { default as isCtrlOrMetaPressed } from './event/isCtrlOrMetaPressed';\r\n\r\nexport { default as getStyles } from './style/getStyles';\r\nexport { default as setStyles } from './style/setStyles';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (safeInstanceOf(contained, 'Range')) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element && container.nodeType != NodeType.DocumentFragment) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return (\r\n        !!(treatSameNodeAsContain || container != contained) &&\r\n        internalContains(container, contained)\r\n    );\r\n}\r\n\r\nfunction internalContains(container: Node, contained: Node): boolean {\r\n    if (container.contains) {\r\n        return container.contains(contained);\r\n    } else {\r\n        while (contained) {\r\n            if (contained == container) {\r\n                return true;\r\n            }\r\n\r\n            contained = contained.parentNode;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import { TargetWindow } from 'roosterjs-editor-types';\n\n// NOTE: Type TargetWindow is an auto-generated type.\n// Run node ./tools/generateTargetWindow.js to generate it.\n\n/**\n * @internal Export for test only\n * Try get window from the given node or range\n * @param source Source node or range\n */\nexport function getTargetWindow(source: Node | Range): TargetWindow {\n    const node = source && ((<Range>source).commonAncestorContainer || <Node>source);\n    const document =\n        node &&\n        (node.ownerDocument ||\n            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'\n                ? <Document>node\n                : null));\n\n    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead\n    const targetWindow = document && ((document.defaultView || window) as any);\n    return targetWindow as TargetWindow;\n}\n\n/**\n * Check if the given object is instance of the target type\n * @param obj Object to check\n * @param typeName Target type name\n */\nexport default function safeInstanceOf<T extends keyof TargetWindow>(\n    obj: any,\n    typeName: T\n): obj is TargetWindow[T] {\n    const targetWindow = getTargetWindow(obj);\n    const targetType = targetWindow && (targetWindow[typeName] as any);\n    const mainWindow = (window as any) as TargetWindow;\n    const mainWindowType = mainWindow && (mainWindow[typeName] as any);\n    return (\n        (mainWindowType && obj instanceof mainWindowType) ||\n        (targetType && obj instanceof targetType)\n    );\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType?: number,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport default function toArray<T>(array: readonly T[]): T[];\n\nexport default function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport { default as clearBlockFormat } from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport { default as getFormatState, getElementBasedFormatState } from './format/getFormatState';\r\nexport { default as insertEntity } from './format/insertEntity';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as rotateElement } from './format/rotateElement';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as changeCapitalization } from './format/changeCapitalization';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n\r\nexport { default as experimentCommitListChains } from './experiment/experimentCommitListChains';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else if (parentNode != rootNode) {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, PluginEventType } from 'roosterjs-editor-types';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * @internal\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: IEditor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (safeInstanceOf(arg1, 'Node')) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = safeInstanceOf(arg3, 'Node') ? new Position(arg3, arg4) : null;\r\n        } else if (safeInstanceOf(arg2, 'Node') || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, IEditor, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * @internal\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: IEditor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import fromHtml from './fromHtml';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : safeInstanceOf(nodes, 'Node') ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!safeInstanceOf(wrapper, 'HTMLElement')) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = safeInstanceOf(parent, 'Node') ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import toArray from './toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: ParentNode,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        let { startContainer, startOffset, endContainer, endOffset } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(startNode);\r\n    let endPosition = node.compareDocumentPosition(endNode);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from './toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes: Node[] = toArray(start.parentNode.childNodes);\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\n/**\r\n * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node\r\n * @param root Root node, traversing will be limited under this scope\r\n * @param node The node to collapse\r\n * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node\r\n * @param isStart Whether the given node is start of the sequence of nodes to collapse\r\n * @param canSplitParent Whether splitting parent node is allowed\r\n * @returns The common ancestor node of the given node ref node\r\n */\r\nexport function collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): node is HTMLElement {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\nconst CRLFSPACE = /[\\t\\r\\n\\u0020\\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n * - it is just <div></div>\r\n * @param node The node to check\r\n * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.\r\n * If the value of a node value is only space, set this to true will treat this node as skippable.\r\n * Default value is false\r\n */\r\nexport default function shouldSkipNode(node: Node, ignoreSpace?: boolean): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {\r\n            return true;\r\n        } else if (ignoreSpace && node.nodeValue.replace(CRLFSPACE, '') == '') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        if (getComputedStyle(node, 'display') == 'none') {\r\n            return true;\r\n        }\r\n\r\n        const tag = getTagOfNode(node);\r\n\r\n        if (tag == 'DIV' || tag == 'SPAN') {\r\n            // Empty SPAN/DIV or SPAN/DIV with only unmeaningful children is unmeaningful,\r\n            // because it can render nothing. If we keep them here, there may be unexpected\r\n            // LI elements added for those unmeaningful nodes.\r\n            for (let child = node.firstChild; !!child; child = child.nextSibling) {\r\n                if (!shouldSkipNode(child, ignoreSpace)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            // There may still be other cases that the node is not meaningful.\r\n            // We can add those cases here once we hit them.\r\n            return false;\r\n        }\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import contains from '../utils/contains';\nimport { DocumentPosition, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Check if a given node is contained by the given region\n * @param region The region to check from\n * @param node The node or block element to check\n */\nexport default function isNodeInRegion(region: RegionBase, node: Node): boolean {\n    return !!(\n        region &&\n        contains(region.rootNode, node) &&\n        (!region.nodeBefore ||\n            region.nodeBefore.compareDocumentPosition(node) == DocumentPosition.Following) &&\n        (!region.nodeAfter ||\n            region.nodeAfter.compareDocumentPosition(node) == DocumentPosition.Preceding)\n    );\n}\n","import toArray from './toArray';\r\n\r\n/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return toArray(element.childNodes);\r\n}\r\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport {\r\n    BlockElement,\r\n    ContentPosition,\r\n    IContentTraverser,\r\n    InlineElement,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser implements IContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system informations of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import experimentCommitListChains from '../experiment/experimentCommitListChains';\nimport { ChangeSource, IEditor, NodePosition, Region } from 'roosterjs-editor-types';\nimport { VListChain } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Split selection into regions, and perform a block-wise formatting action for each region.\n */\nexport default function blockFormat(\n    editor: IEditor,\n    callback: (\n        region: Region,\n        start: NodePosition,\n        end: NodePosition,\n        chains: VListChain[]\n    ) => void,\n    beforeRunCallback?: () => boolean\n) {\n    editor.focus();\n    editor.addUndoSnapshot((start, end) => {\n        if (!beforeRunCallback || beforeRunCallback()) {\n            const regions = editor.getSelectedRegions();\n            const chains = VListChain.createListChains(regions, start?.node);\n            regions.forEach(region => callback(region, start, end, chains));\n            experimentCommitListChains(editor, chains);\n        }\n        editor.select(start, end);\n    }, ChangeSource.Format);\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","/**\n * A type-safe wrapper for Array.prototype.push.apply()\n * @param mainArray The main array to push items into\n * @param itemsArray The items to push to main array\n */\nexport default function arrayPush<T>(mainArray: T[], itemsArray: T[]) {\n    Array.prototype.push.apply(mainArray, itemsArray);\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import { Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n * We validate that and only return a rect when the passed in ClientRect is valid\r\n */\r\nexport default function normalizeRect(clientRect: ClientRect): Rect {\r\n    let { left, right, top, bottom } =\r\n        clientRect || <ClientRect>{ left: 0, right: 0, top: 0, bottom: 0 };\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import changeElementTag from '../utils/changeElementTag';\nimport getListTypeFromNode, { isListElement } from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport isNodeEmpty from '../utils/isNodeEmpty';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitParentNode from '../utils/splitParentNode';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport VListItem from './VListItem';\nimport wrap from '../utils/wrap';\nimport {\n    Indentation,\n    ListType,\n    NodePosition,\n    PositionType,\n    NodeType,\n} from 'roosterjs-editor-types';\n\n/**\n * Represent a bullet or a numbering list\n *\n * @example\n * A VList is a logical representation of list items, it contains an item array with node and list type stack.\n * e.g. We have a list like this\n * ```html\n * <ol>\n *   <li>item 1</li>\n *   <li>item 2</li>\n *   <ul>\n *     <li>item 2.1</li>\n *     <li>item 2.2</li>\n *   <ul>\n * </ol>\n * ```\n *\n * A VList of this list will be like this:\n * ```javascript\n * {\n *   rootList: (OL node),\n *   items: [{\n *       node: (LI node with 'item 1'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2.1),\n *       listTypes: [null, OL, UL],\n *     }, {\n *       node: (LI node with 'item 2.2'),\n *       listTypes: [null, OL, UL],\n *     }\n *   ]\n * }\n * ```\n *\n * When we want to outdent item 2.1, we just need to remove the last \"UL\" from listTypes of item 2.1, then\n * the writeBack() function will handle everything related to DOM change\n */\nexport default class VList {\n    public readonly items: VListItem[] = [];\n\n    /**\n     * Create a new instance of VList class\n     * @param rootList The root list element, can be either OL or UL tag\n     */\n    constructor(private rootList: HTMLOListElement | HTMLUListElement) {\n        if (!rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        // Before populate items, we need to normalize the list to make sure it is in a correct format\n        // otherwise further action may mass thing up.\n        //\n        // There are two kinds of normalization to perform.\n        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node\n        // Please see comment for VListItem.isOrphanItem() for more information about orphan node\n        // e.g.:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>item 2</div>\n        // </ol>\n        // ```\n        // After this step, it should become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>item 2</div>\n        //   <li>\n        // </ol>\n        // ```\n        moveChildNodesToLi(this.rootList);\n        queryElements(this.rootList, 'ol,ul', moveChildNodesToLi);\n\n        // 2. Move LI node embeded into another LI node out to directly under OL/UL node\n        // Ideally browser we do this for us automatically when out the HTML into DOM. However after\n        // step 1, it is possible that we move some LI node into another one. e.g:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>\n        //     item 1.1\n        //     <li>item 3</li>\n        //   </div>\n        // </ol>\n        // ```\n        // See that the second LI tag is not directly under OL, so after step 1, this will become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>\n        //       item 1.1\n        //       <li>item 2</li>\n        //     </div>\n        //   <li>\n        // </ol>\n        // ```\n        // Now we have a LI tag embeded into another LI tag. So we need step 2 to move the inner LI tag out to be:\n        // ```html\n        // <ol>\n        //   <li>item1\n        //     <div>item 1.1</div>\n        //   </li>\n        //   <li><div>item2</div></li>\n        // </ol>\n        // ```\n        queryElements(this.rootList, 'li', moveLiToList);\n\n        this.populateItems(this.rootList);\n    }\n\n    /**\n     * Check if this list contains the given node\n     * @param node The node to check\n     */\n    contains(node: Node) {\n        // We don't check if the node is contained by this.rootList here, because after some operation,\n        // it is possible a node is logically contained by this list but the container list item hasn't\n        // been put under this.rootList in DOM tree yet.\n        return this.items.some(item => item.contains(node));\n    }\n\n    /**\n     * Get list number of the last item in this VList.\n     * If there is no order list item, result will be undefined\n     */\n    getLastItemNumber(): number | undefined {\n        const start = getStart(this.rootList);\n\n        return start === undefined\n            ? start\n            : start -\n                  1 +\n                  this.items.filter(\n                      item => item.getListType() == ListType.Ordered && item.getLevel() == 1\n                  ).length;\n    }\n\n    /**\n     * Write the result back into DOM tree\n     * After that, this VList becomes unavailable because we set this.rootList to null\n     */\n    writeBack() {\n        if (!this.rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        const doc = this.rootList.ownerDocument;\n        const listStack: Node[] = [doc.createDocumentFragment()];\n        const placeholder = doc.createTextNode('');\n        let start = getStart(this.rootList) || 1;\n        let lastList: Node;\n\n        // Use a placeholder to hold the position since the root list may be moved into document fragment later\n        this.rootList.parentNode.replaceChild(placeholder, this.rootList);\n\n        this.items.forEach(item => {\n            item.writeBack(listStack, this.rootList);\n            const topList = listStack[1];\n\n            if (safeInstanceOf(topList, 'HTMLOListElement')) {\n                if (lastList != topList) {\n                    if (start == 1) {\n                        topList.removeAttribute('start');\n                    } else {\n                        topList.start = start;\n                    }\n                }\n\n                if (item.getLevel() == 1) {\n                    start++;\n                }\n            }\n\n            lastList = topList;\n        });\n\n        // Restore the content to the positioni of placeholder\n        placeholder.parentNode.replaceChild(listStack[0], placeholder);\n\n        // Set rootList to null to avoid this to be called again for the same VList, because\n        // after change the rootList may not be available any more (e.g. outdent all items).\n        this.rootList = null;\n    }\n\n    /**\n     * Set indentation of the given range of this list\n     * @param start Start position to operate from\n     * @param end End positon to operate to\n     * @param indentation Indent or outdent\n     */\n    setIndentation(start: NodePosition, end: NodePosition, indentation: Indentation) {\n        this.findListItems(start, end, item =>\n            indentation == Indentation.Decrease ? item.outdent() : item.indent()\n        );\n    }\n\n    /**\n     * Change list type of the given range of this list.\n     * If some of the items are not real list item yet, this will make them to be list item with given type\n     * If all items in the given range are already in the type to change to, this becomes an outdent operation\n     * @param start Start position to operate from\n     * @param end End position to operate to\n     * @param targetType Target list type\n     */\n    changeListType(start: NodePosition, end: NodePosition, targetType: ListType) {\n        let needChangeType = false;\n\n        this.findListItems(start, end, item => {\n            needChangeType = needChangeType || item.getListType() != targetType;\n        });\n        this.findListItems(start, end, item =>\n            needChangeType ? item.changeListType(targetType) : item.outdent()\n        );\n    }\n\n    /**\n     * Append a new item to this VList\n     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped\n     * @param type Type of this list item, can be ListType.None\n     */\n    appendItem(node: Node, type: ListType) {\n        const nodeTag = getTagOfNode(node);\n\n        // Change DIV tag to SPAN. Otherwise we can create new list item by Enter key in Safari\n        if (nodeTag == 'DIV') {\n            node = changeElementTag(<HTMLElement>node, 'LI');\n        } else if (nodeTag != 'LI') {\n            node = wrap(node, 'LI');\n        }\n\n        this.items.push(type == ListType.None ? new VListItem(node) : new VListItem(node, type));\n    }\n\n    /**\n     * Merge the given VList into current VList.\n     * - All list items will be removed from the given VList and added into this list.\n     * - The root node of the given VList will be removed from DOM tree\n     * - If there are orphan items in the given VList, they will be merged into the last item\n     *   of this list if any.\n     * @param list The vList to merge from\n     */\n    mergeVList(list: VList) {\n        if (list && list != this) {\n            const originalLength = this.items.length;\n            list.items.forEach(item => this.items.push(item));\n            list.items.splice(0, list.items.length);\n\n            this.mergeOrphanNodesAfter(originalLength - 1);\n            list.rootList.parentNode?.removeChild(list.rootList);\n        }\n    }\n\n    private mergeOrphanNodesAfter(startIndex: number) {\n        const item = this.items[startIndex];\n\n        if (item && !item.isOrphanItem()) {\n            for (let i = startIndex + 1; i <= this.items.length; i++) {\n                if (!item || !item.canMerge(this.items[i])) {\n                    item.mergeItems(this.items.splice(startIndex + 1, i - startIndex - 1));\n                    break;\n                }\n            }\n        }\n    }\n\n    private findListItems(\n        start: NodePosition,\n        end: NodePosition,\n        callback?: (item: VListItem) => any\n    ): VListItem[] {\n        if (this.items.length == 0) {\n            return [];\n        }\n\n        const listStartPos = new Position(this.items[0].getNode(), PositionType.Begin);\n        const listEndPos = new Position(\n            this.items[this.items.length - 1].getNode(),\n            PositionType.End\n        );\n\n        let startIndex = listStartPos.isAfter(start) ? 0 : -1;\n        let endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);\n\n        this.items.forEach((item, index) => {\n            startIndex = item.contains(start.node) ? index : startIndex;\n            endIndex = item.contains(end.node) ? index : endIndex;\n        });\n\n        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;\n        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;\n\n        const result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];\n\n        if (callback) {\n            result.forEach(callback);\n            this.mergeOrphanNodesAfter(endIndex);\n        }\n\n        return result;\n    }\n\n    private populateItems(\n        list: HTMLOListElement | HTMLUListElement,\n        listTypes: (ListType.Ordered | ListType.Unordered)[] = []\n    ) {\n        const type = getListTypeFromNode(list);\n\n        for (let item = list.firstChild; !!item; item = item.nextSibling) {\n            const newListTypes = [...listTypes, type];\n\n            if (isListElement(item)) {\n                this.populateItems(item as HTMLOListElement | HTMLUListElement, newListTypes);\n            } else if (item.nodeType != NodeType.Text || item.nodeValue.trim() != '') {\n                this.items.push(new VListItem(item, ...newListTypes));\n            }\n        }\n    }\n}\n\n//Normalization\n\n// Step 1: Move all non-LI direct children under list into LI\n// e.g.\n// From: <ul><li>line 1</li>line 2</ul>\n// To:   <ul><li>line 1<div>line 2</div></li></ul>\nfunction moveChildNodesToLi(list: HTMLOListElement | HTMLUListElement) {\n    let currentItem: HTMLLIElement = null;\n\n    toArray(list.childNodes).forEach(child => {\n        if (getTagOfNode(child) == 'LI') {\n            currentItem = child as HTMLLIElement;\n        } else if (isListElement(child)) {\n            currentItem = null;\n        } else if (currentItem && !isNodeEmpty(child, true /*trimContent*/)) {\n            currentItem.appendChild(isBlockElement(child) ? child : wrap(child));\n        }\n    });\n}\n\n// Step 2: Move nested LI up to under list directly\n// e.g.\n// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>\n// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>\nfunction moveLiToList(li: HTMLLIElement) {\n    while (!isListElement(li.parentNode)) {\n        splitParentNode(li, true /*splitBefore*/);\n        let furtherNodes: Node[] = toArray(li.parentNode.childNodes).slice(1);\n\n        if (furtherNodes.length > 0) {\n            if (!isBlockElement(furtherNodes[0])) {\n                furtherNodes = [wrap(furtherNodes)];\n            }\n            furtherNodes.forEach(node => li.appendChild(node));\n        }\n\n        unwrap(li.parentNode);\n    }\n}\n\nfunction getStart(list: HTMLOListElement | HTMLUListElement): number | undefined {\n    return safeInstanceOf(list, 'HTMLOListElement') ? list.start : undefined;\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get list type from a list element. The result will be either Ordered or Unordered ListType\n * @param listElement the element to get list type from\n */\nexport default function getListTypeFromNode(\n    listElement: HTMLOListElement | HTMLUListElement\n): ListType.Ordered | ListType.Unordered;\n\n/**\n * Get list type from a DOM node. It is possible to return ListType.None\n * @param node the node to get list type from\n */\nexport default function getListTypeFromNode(node: Node): ListType;\n\nexport default function getListTypeFromNode(node: Node): ListType {\n    switch (getTagOfNode(node)) {\n        case 'OL':\n            return ListType.Ordered;\n        case 'UL':\n            return ListType.Unordered;\n        default:\n            return ListType.None;\n    }\n}\n\n/**\n * @internal\n * Check if the given DOM node is a list element (OL or UL)\n * @param node The node to check\n */\nexport function isListElement(node: Node): node is HTMLUListElement | HTMLOListElement {\n    return getListTypeFromNode(node) != ListType.None;\n}\n","import createRange from '../selection/createRange';\nimport Position from '../selection/Position';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { Region, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get the selection range in the given region.\n * The original range can cover multiple regions, this function will narrow the origianl selection\n * of a region into current region\n * @param regionBase The region to get range from\n */\nexport default function getSelectionRangeInRegion(regionBase: RegionBase): Range | null {\n    if (!regionBase) {\n        return null;\n    }\n\n    const { nodeBefore, nodeAfter, rootNode, skipTags } = regionBase;\n    const startNode = nodeBefore\n        ? getNextLeafSibling(regionBase.rootNode, nodeBefore, regionBase.skipTags)\n        : rootNode.firstChild;\n    const endNode = nodeAfter\n        ? getPreviousLeafSibling(rootNode, nodeAfter, skipTags)\n        : rootNode.lastChild;\n    const regionRange = startNode && endNode && createRange(startNode, endNode);\n\n    if (!isRegion(regionBase)) {\n        return regionRange;\n    } else if (regionRange) {\n        const regionStart = Position.getStart(regionRange).normalize();\n        const regionEnd = Position.getEnd(regionRange).normalize();\n        const { fullSelectionEnd, fullSelectionStart } = regionBase;\n\n        if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {\n            const start = fullSelectionStart.isAfter(regionStart)\n                ? fullSelectionStart\n                : regionStart;\n            const end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;\n\n            return createRange(start, end);\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction isRegion(regionBase: RegionBase): regionBase is Region {\n    const region = regionBase as Region;\n    return !!region.fullSelectionEnd && !!region.fullSelectionStart;\n}\n","/**\n * Get CSS styles of a given element in name-value pair format\n * @param element The element to get styles from\n */\nexport default function getStyles(element: HTMLElement): Record<string, string> {\n    const result: Record<string, string> = {};\n    const style = element?.getAttribute('style') || '';\n    style.split(';').forEach(pair => {\n        const valueIndex = pair.indexOf(':');\n        const name = pair.slice(0, valueIndex);\n        const value = pair.slice(valueIndex + 1);\n        if (name && value) {\n            result[name.trim()] = value.trim();\n        }\n    });\n    return result;\n}\n","/**\n * Set styles to an HTML element. If styles are empty, remove 'style' attribute\n * @param element The element to set styles\n * @param styles The styles to set, in name-value pair format\n */\nexport default function setStyles(element: HTMLElement, styles: Record<string, string>) {\n    if (element) {\n        const style = Object.keys(styles || {})\n            .map(name => {\n                let value = styles[name];\n                name = name ? name.trim() : null;\n                value = value ? value.trim() : null;\n                return name && value ? `${name}:${value}` : null;\n            })\n            .filter(x => x)\n            .join(';');\n        if (style) {\n            element.setAttribute('style', style);\n        } else {\n            element.removeAttribute('style');\n        }\n    }\n}\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","export * from './plugins/ContentEdit/index';\n","import { AutoLinkFeatures } from './features/autoLinkFeatures';\nimport { CursorFeatures } from './features/cursorFeatures';\nimport { EntityFeatures } from './features/entityFeatures';\nimport { ListFeatures } from './features/listFeatures';\nimport { MarkdownFeatures } from './features/markdownFeatures';\nimport { QuoteFeatures } from './features/quoteFeatures';\nimport { ShortcutFeatures } from './features/shortcutFeatures';\nimport { StructuredNodeFeatures } from './features/structuredNodeFeatures';\nimport { TableFeatures } from './features/tableFeatures';\nimport {\n    BuildInEditFeature,\n    ContentEditFeatureSettings,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\nconst allFeatures = {\n    ...ListFeatures,\n    ...QuoteFeatures,\n    ...TableFeatures,\n    ...StructuredNodeFeatures,\n    ...AutoLinkFeatures,\n    ...ShortcutFeatures,\n    ...CursorFeatures,\n    ...MarkdownFeatures,\n    ...EntityFeatures,\n};\n\n/**\n * Get all content edit features provided by roosterjs\n */\nexport default function getAllFeatures(): Record<\n    keyof ContentEditFeatureSettings,\n    BuildInEditFeature<PluginEvent>\n> {\n    return allFeatures;\n}\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element ? this.element.textContent : '';\r\n    }\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\n\n/**\n * Get innerHTML of the given node\n * @param node The DOM node to get innerHTML from\n */\nexport default function getInnerHTML(node: HTMLElement | DocumentFragment) {\n    if (safeInstanceOf(node, 'HTMLElement')) {\n        return node.innerHTML;\n    } else if (node) {\n        const tempNode = node.ownerDocument.createElement('span');\n        tempNode.appendChild(node.cloneNode(true /*deep*/));\n        return tempNode.innerHTML;\n    } else {\n        return '';\n    }\n}\n","import contains from '../utils/contains';\nimport getListTypeFromNode from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { ListType } from 'roosterjs-editor-types';\n\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\n\n/**\n * @internal\n * !!! Never directly create instance of this class. It should be created within VList class !!!\n *\n * Represent a list item.\n *\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\n * @internal\n */\nexport default class VListItem {\n    private listTypes: ListType[];\n\n    /**\n     * Construct a new instance of VListItem class\n     * @param node The DOM node for this item\n     * @param listTypes An array represnets list types of all parent and current level.\n     * Skip this parameter for a non-list item.\n     */\n    constructor(private node: Node, ...listTypes: (ListType.Ordered | ListType.Unordered)[]) {\n        if (!node) {\n            throw new Error('node must not be null');\n        }\n\n        // Always add a None list type in front of all other types to represent non-list scenario.\n        this.listTypes = [ListType.None, ...listTypes];\n    }\n\n    /**\n     * Get type of current list item\n     */\n    getListType(): ListType {\n        return this.listTypes[this.listTypes.length - 1];\n    }\n\n    /**\n     * Get the levels of this list item.\n     */\n    getLevel(): number {\n        return this.listTypes.length - 1;\n    }\n\n    /**\n     * Get DOM node of this list item\n     */\n    getNode(): Node {\n        return this.node;\n    }\n\n    /**\n     * Check if a given node is contained by this list item\n     * @param node The node to check\n     */\n    contains(node: Node): boolean {\n        return contains(this.node, node, true /*treateSameNodeAsContain*/);\n    }\n\n    /**\n     * Check if this item is an orphan item.\n     *\n     * Orphan item is not a normal case but could happen. It represents the DOM nodes directly under OL/UL tag\n     * and are in front of all other LI tags so that they cannot be merged into any existing LI tags.\n     *\n     * For example:\n     * ```html\n     * <ol>\n     *   <div>Orphan node</div>\n     *   <li>first item</li>\n     * </ol>\n     * ```\n     * Here the first DIV tag is an orphan item.\n     *\n     * There can also be nodes directly under OL/UL but between other LI tags in source HTML which should not be\n     * treated as orphan item because they can be merged into their previous LI tag. But when we build VList,\n     * those nodes will be merged into LI, so that ideally here they should not exist.\n     */\n    isOrphanItem(): boolean {\n        return getTagOfNode(this.node) != 'LI';\n    }\n\n    /**\n     * Check if the given item can be merged into this item.\n     * An item can be merged when it is an orphan item and its list type stack is exactly the same with current one.\n     * @param item The item to check\n     */\n    canMerge(item: VListItem): boolean {\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\n            return false;\n        }\n\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\n    }\n\n    /**\n     * Merge items into this item.\n     * @example Before merge:\n     * ```html\n     * <ol>\n     *   <li>Current item</li>\n     *   <div>line 1</div>\n     *   <div>line 2</div>\n     * </ol>\n     * ```\n     * After merge then two DIVs into LI:\n     * ```html\n     * <ol>\n     *   <li>Current item\n     *     <div>line 1</div>\n     *     <div>line 2</div>\n     *   </li>\n     * </ol>\n     * ```\n     * @param items The items to merge\n     */\n    mergeItems(items: VListItem[]) {\n        const nodesToWrap = items?.map(item => item.node) || [];\n        const targetNodes = wrapIfNotBlockNode(\n            nodesToWrap,\n            true /*checkFirst*/,\n            false /*checkLast*/\n        );\n        targetNodes.forEach(node => this.node.appendChild(node));\n    }\n\n    /**\n     * Indent this item\n     * If this is not an list item, it will be no op\n     */\n    indent() {\n        const listType = this.getListType();\n        if (listType != ListType.None) {\n            this.listTypes.push(listType);\n        }\n    }\n\n    /**\n     * Outdent this item\n     * If this item is already not an list item, it will be no op\n     */\n    outdent() {\n        if (this.listTypes.length > 1) {\n            this.listTypes.pop();\n        }\n    }\n\n    /**\n     * Change list type of this item\n     * @param targetType The target list type to change to\n     */\n    changeListType(targetType: ListType) {\n        if (targetType == ListType.None) {\n            this.listTypes = [targetType];\n        } else {\n            this.outdent();\n            this.listTypes.push(targetType);\n        }\n    }\n\n    /**\n     * Write the change result back into DOM\n     * @param listStack current stack of list elements\n     * @param originalRoot Original list root element. It will be reused when write back if possible\n     */\n    writeBack(listStack: Node[], originalRoot?: HTMLOListElement | HTMLUListElement) {\n        let nextLevel = 1;\n\n        // 1. Determine list elements that we can reuse\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL > OL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then Fragment > OL > UL can be reused\n        for (; nextLevel < listStack.length; nextLevel++) {\n            if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\n                listStack.splice(nextLevel);\n                break;\n            }\n        }\n\n        // 2. Add new list elements\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then we need to create a UL and a OL tag\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\n            const newList = createListElement(\n                listStack[0],\n                this.listTypes[nextLevel],\n                nextLevel,\n                originalRoot\n            );\n\n            listStack[listStack.length - 1].appendChild(newList);\n            listStack.push(newList);\n        }\n\n        // 3. Add current node into deepest list element\n        listStack[listStack.length - 1].appendChild(this.node);\n\n        // 4. If this is not a list item now, need to unwrap the LI node and do proper handling\n        if (this.listTypes.length <= 1) {\n            wrapIfNotBlockNode(\n                getTagOfNode(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node],\n                true /*checkFirst*/,\n                true /*checkLast*/\n            );\n        }\n    }\n}\n\nfunction createListElement(\n    newRoot: Node,\n    listType: ListType,\n    nextLevel: number,\n    originalRoot?: HTMLOListElement | HTMLUListElement\n): HTMLOListElement | HTMLUListElement {\n    const doc = newRoot.ownerDocument;\n    let result: HTMLOListElement | HTMLUListElement;\n\n    // Try to reuse the existing root element\n    // It can be reused when\n    // 1. Current list item is level 1 (top level), AND\n    // 2. Original root exists, AND\n    // 3. They have the same list type AND\n    // 4. The original root is not used yet\n    if (nextLevel == 1 && originalRoot && listType == getListTypeFromNode(originalRoot)) {\n        if (contains(newRoot, originalRoot)) {\n            // If it is already used, let's clone one and remove ID to avoid duplicating ID\n            result = originalRoot.cloneNode(false /*deep*/) as HTMLOListElement | HTMLUListElement;\n            (<HTMLOListElement>result).removeAttribute('id');\n        } else {\n            // Remove all child nodes, they will be added back later when write back other items\n            while (originalRoot.firstChild) {\n                originalRoot.removeChild(originalRoot.firstChild);\n            }\n            result = originalRoot;\n        }\n    } else {\n        // Can't be reused, can't clone, let's create a new one\n        result = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\n    }\n\n    if (listType == ListType.Ordered && nextLevel > 1) {\n        result.style.listStyleType = orderListStyles[(nextLevel - 1) % orderListStyles.length];\n    }\n\n    return result;\n}\n\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\n    if (\n        nodes.length > 0 &&\n        (!checkFirst || !isBlockElement(nodes[0])) &&\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\n    ) {\n        nodes = [wrap(nodes)];\n    }\n\n    return nodes;\n}\n\nfunction getChildrenAndUnwrap(node: Node): Node[] {\n    const result = toArray(node.childNodes);\n    unwrap(node);\n    return result;\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport { RegionBase } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * A type map from selector string to HTML element type\n */\nexport interface SelectorToTypeMap {\n    ol: HTMLOListElement;\n    ul: HTMLUListElement;\n    'ol,ul': HTMLOListElement | HTMLUListElement;\n}\n\n/**\n * @internal\n * Get Root list node from the given node within the given region\n * @param region Region to scope the search inot\n * @param selector The selector to search\n * @param node The start node\n */\nexport default function getRootListNode<TSelector extends keyof SelectorToTypeMap>(\n    region: RegionBase,\n    selector: TSelector,\n    node: Node\n): SelectorToTypeMap[TSelector] {\n    let list =\n        region &&\n        (findClosestElementAncestor(\n            node,\n            region.rootNode,\n            selector\n        ) as SelectorToTypeMap[TSelector]);\n\n    if (list) {\n        let ancestor: SelectorToTypeMap[TSelector];\n        while (\n            (ancestor = findClosestElementAncestor(\n                list.parentNode,\n                region.rootNode,\n                selector\n            ) as SelectorToTypeMap[TSelector])\n        ) {\n            list = ancestor;\n        }\n    }\n\n    return list;\n}\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\nimport fromHtml from '../utils/fromHtml';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getSelectionRangeInRegion from './getSelectionRangeInRegion';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get all block elements covered by the selection under this region\n * @param regionBase The region to get block elements from\n * @param createBlockIfEmpty When set to true, a new empty block element will be created if there is not\n * any blocks in the region. Default value is false\n */\nexport default function getSelectedBlockElementsInRegion(\n    regionBase: RegionBase,\n    createBlockIfEmpty?: boolean\n): BlockElement[] {\n    const range = getSelectionRangeInRegion(regionBase);\n    let blocks: BlockElement[] = [];\n\n    if (range) {\n        const { rootNode, skipTags } = regionBase;\n        const traverser = ContentTraverser.createSelectionTraverser(rootNode, range, skipTags);\n\n        for (\n            let block = traverser?.currentBlockElement;\n            !!block;\n            block = traverser.getNextBlockElement()\n        ) {\n            blocks.push(block);\n        }\n\n        // Remove unmeaningful nodes\n        blocks = blocks.filter(block => {\n            const startNode = block.getStartNode();\n            const endNode = block.getEndNode();\n\n            if (startNode == endNode && shouldSkipNode(startNode, true /*ignoreSpace*/)) {\n                startNode.parentNode?.removeChild(startNode);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n\n    if (blocks.length == 0 && regionBase && !regionBase.rootNode.firstChild && createBlockIfEmpty) {\n        const newNode = fromHtml('<div><br></div>', regionBase.rootNode.ownerDocument)[0];\n        regionBase.rootNode.appendChild(newNode);\n        blocks.push(getBlockElementAtNode(regionBase.rootNode, newNode));\n    }\n\n    return blocks;\n}\n","import contains from '../utils/contains';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport regionTypeData from './regionTypeData';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { QueryScope, Region, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Get regions impacted by the given range under the root node\n * @param root Root node to get regions from\n * @param range A selection range. Regions will be created acording to this range. Each region will be\n * fully or partially covered by this range.\n * @param type Type of region. Currently we only support TABLE region.\n */\nexport default function getRegionsFromRange(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType\n): Region[] {\n    let regions: Region[] = [];\n    if (root && range) {\n        const { innerSelector, skipTags } = regionTypeData[type];\n        const boundaryTree = buildBoundaryTree(root, range, type);\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\n        const creator = getRegionCreator(range, skipTags);\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\n    }\n\n    return regions.filter(r => !!r);\n}\n\n/**\n * @internal export for test only\n */\nexport function getRegionCreator(\n    fullRange: Range,\n    skipTags: string[]\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region {\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\n            ? {\n                  rootNode,\n                  nodeBefore,\n                  nodeAfter,\n                  skipTags,\n                  fullSelectionStart,\n                  fullSelectionEnd,\n              }\n            : null;\n    };\n}\n\n/**\n * This is a internal data structure used for build regions.\n * We firstly split the selection by some boundaries, then we can build region from these bundaries.\n */\ninterface Boundary {\n    /**\n     * inner node of this boundary\n     */\n    innerNode: HTMLElement;\n\n    /**\n     * Children of this boundary\n     */\n    children: {\n        /**\n         * Outer node of a boundary child\n         */\n        outerNode: Node;\n\n        /**\n         * Child bundaries\n         */\n        boundaries: Boundary[];\n    }[];\n}\n\n/**\n * Step 1: Build boundary tree\n * @param root Root node of the whole scope, normally this will be the root of editable scope\n * @param range Existing selected full range\n * @param type Type of region to create\n */\nfunction buildBoundaryTree(root: HTMLElement, range: Range, type: RegionType): Boundary {\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\n    const { outerSelector, innerSelector } = regionTypeData[type];\n    const inSelectionOuterNode = queryElements(\n        root,\n        outerSelector,\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\n    // is in document order, which is what we expect. So we don't need to sort the result here.\n    queryElements(\n        root,\n        innerSelector,\n        thisInnerNode => {\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\n\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\n                    const { innerNode, children } = allBoundaries[i];\n                    if (contains(innerNode, thisOuterNode)) {\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\n\n                        if (!child) {\n                            child = { outerNode: thisOuterNode, boundaries: [] };\n                            children.push(child);\n                        }\n\n                        child.boundaries.push(boundary);\n                        break;\n                    }\n                }\n                allBoundaries.push(boundary);\n            }\n        },\n        QueryScope.OnSelection,\n        range\n    );\n\n    return allBoundaries[0];\n}\n\n/**\n * Step 2: Recursively iterate all boundaries and create regions\n * @param creator A region creator function to help create region\n * @param boundary Current root boundary\n * @param start A node where full range start from. This may not be the direct node container of range.startContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param end A node where full range end from. This may not be the direct node container of range.endContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param started Whether we have already hit the start node\n */\nfunction iterateNodes(\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region,\n    boundary: Boundary,\n    start: Node,\n    end: Node,\n    started?: boolean\n): [Region[], boolean, boolean] {\n    started = started || boundary.innerNode == start;\n    let ended = false;\n    const { children, innerNode } = boundary;\n    let regions: Region[] = [];\n\n    if (children.length == 0) {\n        regions.push(creator(innerNode));\n    } else {\n        // Need to run one more time to add region after all children\n        for (let i = 0; i <= children.length && !ended; i++) {\n            const { outerNode, boundaries } = children[i] || {};\n            const previousOuterNode = children[i - 1]?.outerNode;\n            if (started) {\n                regions.push(creator(innerNode, previousOuterNode, outerNode));\n            }\n\n            boundaries?.forEach(child => {\n                let newRegions: Region[];\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\n                regions = regions.concat(newRegions);\n            });\n        }\n    }\n\n    return [regions, started, ended || innerNode == end];\n}\n\n/**\n * Check if the given nodes combination is valid to create a region.\n * A combination is valid when:\n * 1. Root node is not null and is not empty. And\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\n * node between them.\n * @param root Root node of region\n * @param nodeBefore The boundary node before the region under root\n * @param nodeAfter The boundary node after the region under root\n * @param skipTags Tags to skip\n */\nfunction areNodesValid(root: Node, nodeBefore: Node, nodeAfter: Node, skipTags: string[]) {\n    if (!root) {\n        return false;\n    } else {\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\n        const firstNodeValid =\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\n        const lastNodeValid =\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\n        const bothValid =\n            !nodeBefore ||\n            !nodeAfter ||\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\n        return firstNodeValid && lastNodeValid && bothValid;\n    }\n}\n","import collapseNode from '../utils/collapseNodes';\nimport isNodeInRegion from './isNodeInRegion';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Collapse nodes within this region to their common ascenstor node under this region\n * @param region The region to collapse nodes in.\n * @param nodesOrBlockElements Nodes or block elements to collapse. When take BlockElement[] as input,\n * start node of the first BlockElement and end node of the last BlockElement will be used as the nodes.\n * All nodes not contained by the given region will be ignored.\n */\nexport default function collapseNodesInRegion(\n    region: RegionBase,\n    nodesOrBlockElements: Node[] | BlockElement[]\n): Node[] {\n    if (!nodesOrBlockElements || nodesOrBlockElements.length == 0) {\n        return [];\n    }\n\n    let nodes = safeInstanceOf(nodesOrBlockElements[0], 'Node')\n        ? <Node[]>nodesOrBlockElements\n        : [\n              nodesOrBlockElements[0].getStartNode(),\n              (<BlockElement>nodesOrBlockElements[nodesOrBlockElements.length - 1]).getEndNode(),\n          ];\n\n    nodes = nodes && nodes.filter(node => isNodeInRegion(region, node));\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n\n    if (isNodeInRegion(region, firstNode) && isNodeInRegion(region, lastNode)) {\n        return collapseNode(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);\n    } else {\n        return [];\n    }\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport contains from '../utils/contains';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getPredefinedCssForElement from '../htmlSanitizer/getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport setStyles from '../style/setStyles';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\nimport { collapse } from '../utils/collapseNodes';\nimport { safeInstanceOf } from '..';\n\n/**\n * Merge a BlockElement of given node after another node\n * @param region Region to operate in\n * @param refNode The node to merge after\n * @param targetNode The node of target block element\n */\nexport default function mergeBlocksInRegion(region: RegionBase, refNode: Node, targetNode: Node) {\n    let block: BlockElement;\n\n    if (\n        !isNodeInRegion(region, refNode) ||\n        !isNodeInRegion(region, targetNode) ||\n        !(block = getBlockElementAtNode(region.rootNode, targetNode)) ||\n        block.contains(refNode)\n    ) {\n        return;\n    }\n\n    const blockRoot = block.collapseToSingleElement();\n    const commonContainer = collapse(\n        region.rootNode,\n        blockRoot,\n        refNode,\n        false /*isStart*/,\n        true /*canSplitParent*/\n    );\n\n    // Copy styles of parent nodes into blockRoot\n    for (let node: Node = blockRoot; contains(commonContainer, node); ) {\n        const parent = node.parentNode;\n        if (safeInstanceOf(parent, 'HTMLElement')) {\n            const styles = {\n                ...(getPredefinedCssForElement(parent) || {}),\n                ...getStyles(parent),\n                ...getStyles(blockRoot),\n            };\n            setStyles(blockRoot, styles);\n        }\n        node = parent;\n    }\n\n    let nodeToRemove: Node = null;\n    let nodeToMerge =\n        blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0\n            ? blockRoot.firstChild\n            : changeElementTag(blockRoot, 'SPAN');\n\n    // Remove empty node\n    for (\n        let node: Node = nodeToMerge;\n        contains(commonContainer, node) && node.parentNode.childNodes.length == 1;\n        node = node.parentNode\n    ) {\n        // If the only child is the one which is about to be removed, this node should also be removed\n        nodeToRemove = node.parentNode;\n    }\n\n    // Finally, merge blocks, and remove empty nodes\n    refNode.parentNode?.insertBefore(nodeToMerge, refNode.nextSibling);\n    nodeToRemove?.parentNode?.removeChild(nodeToRemove);\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { PredefinedCssMap, StringMap } from 'roosterjs-editor-types';\n\nconst PREDEFINED_CSS_FOR_ELEMENT: PredefinedCssMap = {\n    B: {\n        'font-weight': 'bold',\n    },\n    EM: {\n        'font-style': 'italic',\n    },\n    I: {\n        'font-style': 'italic',\n    },\n    U: {\n        'text-decoration': 'underline',\n    },\n    P: {\n        'margin-top': '1em',\n        'margin-bottom': '1em',\n    },\n    PRE: {\n        'white-space': 'pre',\n    },\n    S: {\n        'text-decoration': 'line-through',\n    },\n    STRIKE: {\n        'text-decoration': 'line-through',\n    },\n    SUB: {\n        'vertical-align': 'sub',\n        'font-size': 'smaller',\n    },\n    SUP: {\n        'vertical-align': 'super',\n        'font-size': 'smaller',\n    },\n};\n\n/**\n * @internal\n * Get a map for browser built-in CSS definations of elements\n */\nexport default function getPredefinedCssForElement(\n    element: HTMLElement,\n    additionalPredefinedCssForElement?: PredefinedCssMap\n): StringMap {\n    const tag = getTagOfNode(element);\n    return PREDEFINED_CSS_FOR_ELEMENT[tag] || (additionalPredefinedCssForElement || {})[tag];\n}\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: Node, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    // Merge sibling text nodes to avoid inaccuracy of text node offset\r\n    rootNode.normalize();\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: Node): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n        snapshots.autoCompleteIndex = -1;\r\n    }\r\n}\r\n","import { StringMap } from 'roosterjs-editor-types';\n\n// Inheritable CSS properties\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\nconst INHERITABLE_PROPERTIES = (\n    'border-spacing,caption-side,color,' +\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\n    'widows,word-spacing'\n).split(',');\n\n/**\n * Get inheritable CSS style values from the given element\n * @param element The element to get style from\n */\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\n    let styles = win && win.getComputedStyle(element);\n    let result: StringMap = {};\n    INHERITABLE_PROPERTIES.forEach(\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\n    );\n    return result;\n}\n","function nativeClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    return Object.assign(existingObj || {}, source);\n}\n\nfunction customClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    let result: Record<string, T> = existingObj || {};\n    if (source) {\n        for (let key of Object.keys(source)) {\n            result[key] = source[key];\n        }\n    }\n    return result;\n}\n\n/**\n * @internal\n */\nexport const cloneObject = Object.assign ? nativeClone : customClone;\n","const CTRL_CHARCODE = 'Control';\nconst ALT_CHARCODE = 'Alt';\nconst META_CHARCODE = 'Meta';\n\n/**\n * Returns true when the event was fired from a modifier key, otherwise false\n * @param event The keyboard event object\n */\nexport default function isModifierKey(event: KeyboardEvent): boolean {\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;\n    const isAltKey = event.altKey || event.key === ALT_CHARCODE;\n    const isMetaKey = event.metaKey || event.key === META_CHARCODE;\n\n    return isCtrlKey || isAltKey || isMetaKey;\n}\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Position, VListChain } from 'roosterjs-editor-dom';\n\n/**\n * Commit changes of all list changes when experiment features are allowed\n * @param editor The Editor object\n * @param chains List chains to commit\n */\nexport default function experimentCommitListChains(editor: IEditor, chains: VListChain[]) {\n    if (chains?.length > 0) {\n        const range = editor.getSelectionRange();\n        const start = range && Position.getStart(range);\n        const end = range && Position.getEnd(range);\n        chains.forEach(chain => chain.commit());\n        editor.select(start, end);\n    }\n}\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: IEditor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: IEditor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import blockFormat from '../utils/blockFormat';\nimport { createVListFromRegion, getBlockElementAtNode } from 'roosterjs-editor-dom';\nimport { IEditor, ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport default function toggleListType(editor: IEditor, listType: ListType): void;\nexport default function toggleListType(\n    editor: IEditor,\n    listType: ListType.Ordered,\n    startNumber: number\n): void;\n\nexport default function toggleListType(editor: IEditor, listType: ListType, startNumber?: number) {\n    blockFormat(editor, (region, start, end, chains) => {\n        const chain =\n            startNumber > 0 && chains.filter(chain => chain.canAppendAtCursor(startNumber))[0];\n        const vList =\n            chain && start.equalTo(end)\n                ? chain.createVListAtBlock(\n                      getBlockElementAtNode(region.rootNode, start.node)?.collapseToSingleElement(),\n                      startNumber\n                  )\n                : createVListFromRegion(region, true /*includeSiblingLists*/);\n\n        if (vList) {\n            vList.changeListType(start, end, listType);\n            vList.writeBack();\n        }\n    });\n}\n","import blockFormat from './blockFormat';\nimport { IEditor } from 'roosterjs-editor-types';\nimport {\n    collapseNodesInRegion,\n    getSelectedBlockElementsInRegion,\n    getTagOfNode,\n    isNodeInRegion,\n    splitBalancedNodeRange,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Toggle a tag at selection, if selection already contains elements of such tag,\n * the elements will be untagge and other elements will take no affect\n * @param editor The editor instance\n * @param wrapFunction  The wrap function\n * @param beforeRunCallback A callback function to run before looping all regions. If it returns false,\n * the loop for regions will be skipped\n */\nexport default function blockWrap(\n    editor: IEditor,\n    wrapFunction: (nodes: Node[]) => void,\n    beforeRunCallback: () => boolean\n): void {\n    blockFormat(\n        editor,\n        region => {\n            const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\n            let nodes = collapseNodesInRegion(region, blocks);\n            if (nodes.length > 0) {\n                if (nodes.length == 1) {\n                    const NodeTag = getTagOfNode(nodes[0]);\n                    if (NodeTag == 'BR') {\n                        nodes = [wrap(nodes[0])];\n                    } else if (NodeTag == 'LI' || NodeTag == 'TD') {\n                        nodes = toArray(nodes[0].childNodes);\n                    }\n                }\n\n                while (\n                    nodes[0] &&\n                    isNodeInRegion(region, nodes[0].parentNode) &&\n                    nodes.some(node => getTagOfNode(node) == 'LI')\n                ) {\n                    nodes = [splitBalancedNodeRange(nodes)];\n                }\n\n                wrapFunction(nodes);\n            }\n        },\n        beforeRunCallback\n    );\n}\n","// Classes\r\nexport { default as Editor } from './editor/Editor';\r\n","import { contains } from 'roosterjs-editor-dom';\nimport { EditorCore, HasFocus } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Check if the editor has focus now\n * @param core The EditorCore object\n * @returns True if the editor has focus, otherwise false\n */\nexport const hasFocus: HasFocus = (core: EditorCore) => {\n    let activeElement = core.contentDiv.ownerDocument.activeElement;\n    return (\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\n    );\n};\n","export * from './plugins/HyperLink/index';\n","export * from './plugins/Paste/index';\n","import { NodeType } from 'roosterjs-editor-types';\n\n/** NodeId attribute */\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\n\n/**\n * @internal\n * Custom data for dom elements\n */\nexport default interface WordCustomData {\n    /** The dict storing custom data, key is element Id, value is dictionary */\n    dict: { [key: string]: { [key: string]: number } };\n\n    /** Next node Id to use */\n    nextNodeId: number;\n}\n\n/**\n * @internal\n * Create an empty WordCustomData\n */\nexport function createCustomData(): WordCustomData {\n    return {\n        dict: {},\n        nextNodeId: 1,\n    };\n}\n\n/**\n * @internal\n * Sets the specified object data\n */\nexport function setObject(wordCustomData: WordCustomData, element: Node, key: string, value: any) {\n    // Get the id for the element\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            // Get the values for the element\n            if (!wordCustomData.dict[id]) {\n                // First time dictionary creation\n                wordCustomData.dict[id] = {};\n            }\n            wordCustomData.dict[id][key] = value;\n        }\n    }\n}\n\n/**\n * @internal\n * Reads the specified object data\n */\nexport function getObject(wordCustomData: WordCustomData, element: Node, key: string): any {\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            return wordCustomData.dict[id] && wordCustomData.dict[id][key];\n        }\n    }\n\n    return null;\n}\n\n/**\n * Get the unique id for the specified node...\n */\nfunction getAndSetNodeId(wordCustomData: WordCustomData, element: HTMLElement): string {\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\n    if (!id) {\n        id = wordCustomData.nextNodeId.toString();\n        wordCustomData.nextNodeId++;\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\n    }\n    return id;\n}\n","import ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Holds the ids for the lists already seen for a specified level\n */\nexport default interface LevelLists {\n    /**\n     * The metadata for the lists seen at  this level\n     * key: word list id, value: list metadata\n     */\n    listsMetadata: { [key: string]: ListMetadata };\n\n    /** Unique id of the list currently at this level */\n    currentUniqueListId: number;\n}\n\n/**\n * @internal\n * create an empty LevelLists\n */\nexport function createLevelLists(): LevelLists {\n    return {\n        listsMetadata: {},\n        currentUniqueListId: -1,\n    };\n}\n","/**\n * @internal\n */\nexport const WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^=\"BulletListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_UNORDERED_LIST_SELECTOR =\n    'div.ListContainerWrapper > ol[class^=\"NumberListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_ONLINE_IDENTIFYING_SELECTOR = `${WORD_ORDERED_LIST_SELECTOR},${WORD_UNORDERED_LIST_SELECTOR}`;\n\n/**\n * @internal\n */\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\n\n/**\n * @internal\n */\nexport const UNORDERED_LIST_TAG_NAME = 'UL';\n\n/**\n * @internal\n */\nexport const ORDERED_LIST_TAG_NAME = 'OL';\n\nconst TEXT_CONTAINER_ELEMENT_CLASS_NAME = 'OutlineElement';\n\n/**\n * @internal\n */\nexport const WAC_IDENTIFING_SELECTOR = `ul[class^=\"BulletListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME},ol[class^=\"NumberListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME}`;\n","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\n","import { ContentEdit } from 'roosterjs-editor-plugins/lib/ContentEdit';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorOptions, EditorPlugin, IEditor } from 'roosterjs-editor-types';\r\nimport { HyperLink } from 'roosterjs-editor-plugins/lib/HyperLink';\r\nimport { Paste } from 'roosterjs-editor-plugins/lib/Paste';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * ContentEdit, HyperLink and Paste, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): IEditor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","export { default as ContentEdit } from './ContentEdit';\nexport { default as getAllFeatures } from './getAllFeatures';\n","import getAllFeatures from './getAllFeatures';\nimport {\n    ContentEditFeatureSettings,\n    EditorPlugin,\n    GenericContentEditFeature,\n    IEditor,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * An editor plugin to handle content edit event.\n * The following cases are included:\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\n * 2. Enter, Backspace on empty list item\n * 3. Enter, Backspace on empty blockquote line\n * 4. Auto bullet/numbering\n * 5. Auto link\n * 6. Tab in table\n * 7. Up/Down in table\n * 8. Manage list style\n */\nexport default class ContentEdit implements EditorPlugin {\n    /**\n     * Create instance of ContentEdit plugin\n     * @param settingsOverride An optional feature set to override default feature settings\n     * @param additionalFeatures Optional. More features to add\n     */\n    constructor(\n        private settingsOverride?: Partial<ContentEditFeatureSettings>,\n        private additionalFeatures?: GenericContentEditFeature<PluginEvent>[]\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContentEdit';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor): void {\n        const features: GenericContentEditFeature<PluginEvent>[] = [];\n        const allFeatures = getAllFeatures();\n\n        Object.keys(allFeatures).forEach((key: keyof typeof allFeatures) => {\n            const feature = allFeatures[key];\n            const hasSettingForKey =\n                this.settingsOverride && this.settingsOverride[key] !== undefined;\n\n            if (\n                (hasSettingForKey && this.settingsOverride[key]) ||\n                (!hasSettingForKey && !feature.defaultDisabled)\n            ) {\n                features.push(feature);\n            }\n        });\n\n        features\n            .concat(this.additionalFeatures || [])\n            .forEach(feature => editor.addContentEditFeature(feature));\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose(): void {}\n}\n","import { removeLink, replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    AutoLinkFeatureSettings,\n    BuildInEditFeature,\n    ChangeSource,\n    ClipboardData,\n    IEditor,\n    Keys,\n    LinkData,\n    PluginEvent,\n    PluginEventType,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    clearEventDataCache,\n    LinkInlineElement,\n    matchLink,\n} from 'roosterjs-editor-dom';\n\n/**\n * When user type, they may end a link with a puncatuation, i.e. www.bing.com;\n * we need to trim off the trailing puncatuation before turning it to link match\n */\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\nconst MINIMUM_LENGTH = 5;\n\n/**\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\n * in hyperlink format into a real hyperlink\n */\nconst AutoLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\n    shouldHandleEvent: cacheGetLinkData,\n    handleEvent: autoLink,\n};\n\n/**\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\n * if user presses BACKSPACE right after a hyperlink\n */\nconst UnlinkWhenBackspaceAfterLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: hasLinkBeforeCursor,\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n        removeLink(editor);\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetLinkData(event: PluginEvent, editor: IEditor): LinkData {\n    return event.eventType == PluginEventType.KeyDown ||\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\n              // First try to match link from the whole paste string from the plain text in clipboard.\n              // This helps when we paste a link next to some existing character, and the text we got\n              // from clipboard will only contain what we pasted, any existing characters will not\n              // be included.\n              let clipboardData =\n                  event.eventType == PluginEventType.ContentChanged &&\n                  event.source == ChangeSource.Paste &&\n                  (event.data as ClipboardData);\n              let link = matchLink((clipboardData.text || '').trim());\n              let searcher = editor.getContentSearcherOfCursor(event);\n\n              // In case the matched link is already inside a <A> tag, we do a range search.\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\n                  return link;\n              }\n\n              let word = searcher && searcher.getWordBefore();\n              if (word && word.length > MINIMUM_LENGTH) {\n                  // Check for trailing punctuation\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\n\n                  // Do special handling for ')', '}', ']'\n                  ['()', '{}', '[]'].forEach(str => {\n                      if (\n                          candidate[candidate.length - 1] == str[1] &&\n                          candidate.indexOf(str[0]) < 0\n                      ) {\n                          candidate = candidate.substr(0, candidate.length - 1);\n                      }\n                  });\n\n                  // Match and replace in editor\n                  return matchLink(candidate);\n              }\n              return null;\n          })\n        : null;\n}\n\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: IEditor): boolean {\n    let contentSearcher = editor.getContentSearcherOfCursor(event);\n    let inline = contentSearcher.getInlineElementBefore();\n    return inline instanceof LinkInlineElement;\n}\n\nfunction autoLink(event: PluginEvent, editor: IEditor) {\n    let anchor = editor.getDocument().createElement('a');\n    let linkData = cacheGetLinkData(event, editor);\n\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\n    // and at that time a new searcher won't be able to find the link text to replace\n    let searcher = editor.getContentSearcherOfCursor();\n    anchor.textContent = linkData.originalUrl;\n    anchor.href = linkData.normalizedUrl;\n\n    editor.runAsync(editor => {\n        editor.addUndoSnapshot(\n            () => {\n                replaceWithNode(\n                    editor,\n                    linkData.originalUrl,\n                    anchor,\n                    false /* exactMatch */,\n                    searcher\n                );\n\n                // The content at cursor has changed. Should also clear the cursor data cache\n                clearEventDataCache(event);\n                return anchor;\n            },\n            ChangeSource.AutoLink,\n            true /*canUndoByBackspace*/\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const AutoLinkFeatures: Record<\n    keyof AutoLinkFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoLink: AutoLink,\n    unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\n};\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { FontSizeChange, IEditor } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: IEditor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * @internal\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getFirstLastBlockElement from '../blockElements/getFirstLastBlockElement';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstLastBlockElement(this.rootNode, true /*isFirst*/);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = safeInstanceOf(position, 'Range') ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * @internal\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport {\r\n    IContentTraverser,\r\n    InlineElement,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher implements IPositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: IContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DarkModeDatasetNames, DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(\r\n    element: HTMLElement,\r\n    format: DefaultFormat,\r\n    isDarkMode?: boolean\r\n) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let {\r\n            fontFamily,\r\n            fontSize,\r\n            textColor,\r\n            textColors,\r\n            backgroundColor,\r\n            backgroundColors,\r\n            bold,\r\n            italic,\r\n            underline,\r\n        } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor || textColors) {\r\n            elementStyle.color =\r\n                (isDarkMode ? textColors?.darkModeColor : textColors?.lightModeColor) || textColor;\r\n\r\n            if (textColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] =\r\n                    textColors.lightModeColor;\r\n            }\r\n        }\r\n        if (backgroundColor || backgroundColors) {\r\n            elementStyle.backgroundColor =\r\n                (isDarkMode ? backgroundColors?.darkModeColor : backgroundColors?.lightModeColor) ||\r\n                backgroundColor;\r\n\r\n            if (backgroundColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    backgroundColors.lightModeColor;\r\n            }\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import toArray from './toArray';\r\nimport { Browser } from './Browser';\r\nimport {\r\n    ClipboardData,\r\n    EdgeLinkPreview,\r\n    ExtractClipboardEventOption,\r\n} from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\nconst TEXT_TYPE_PREFIX = 'text/';\r\nconst IMAGE_TYPE_PREFIX = 'image/';\r\nconst HTML_TYPE = TEXT_TYPE_PREFIX + 'html';\r\nconst LINKPREVIEW_TYPE = TEXT_TYPE_PREFIX + 'link-preview';\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardData) => void,\r\n    options?: ExtractClipboardEventOption\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardData = {\r\n        types: dataTransfer.types ? toArray(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        rawHtml: undefined,\r\n        customValues: {},\r\n    };\r\n\r\n    const handlers: {\r\n        promise: Promise<string>;\r\n        callback: (value: string) => void;\r\n    }[] = [];\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n\r\n        // Set rawHtml to null so that caller knows that we have tried\r\n        result.rawHtml = null;\r\n        const items = event.clipboardData.items;\r\n\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n\r\n            switch (item.type) {\r\n                case HTML_TYPE:\r\n                    handlers.push({\r\n                        promise: getAsString(item),\r\n                        callback: value => {\r\n                            result.rawHtml = Browser.isEdge ? workaroundForEdge(value) : value;\r\n                        },\r\n                    });\r\n                    break;\r\n                case LINKPREVIEW_TYPE:\r\n                    if (options?.allowLinkPreview) {\r\n                        handlers.push({\r\n                            promise: getAsString(item),\r\n                            callback: value => {\r\n                                try {\r\n                                    result.linkPreview = JSON.parse(value) as EdgeLinkPreview;\r\n                                } catch {}\r\n                            },\r\n                        });\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (item.type.indexOf(TEXT_TYPE_PREFIX) == 0) {\r\n                        const textType = item.type.substr(TEXT_TYPE_PREFIX.length);\r\n                        if (options?.allowedCustomPasteType?.indexOf(textType) >= 0) {\r\n                            handlers.push({\r\n                                promise: getAsString(item),\r\n                                callback: value => (result.customValues[textType] = value),\r\n                            });\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    Promise.all(handlers.map(handler => handler.promise)).then(values => {\r\n        for (let i = 0; i < handlers.length; i++) {\r\n            handlers[i].callback(values[i]);\r\n        }\r\n\r\n        callback(result);\r\n    });\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf(IMAGE_TYPE_PREFIX) == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf(IMAGE_TYPE_PREFIX) == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n\r\nfunction getAsString(item: DataTransferItem): Promise<string> {\r\n    return new Promise<string>(resolve => {\r\n        item.getAsString(value => {\r\n            resolve(value);\r\n        });\r\n    });\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce((state, key) => {\r\n        state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n        return state;\r\n    }, <PendableFormatState>{});\r\n}\r\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","/**\n * Read a file object and invoke a callback function with the data url of this file\n * @param file The file to read\n * @param callback the callback to invoke with data url of the file.\n * If fail to read, dataUrl will be null\n */\nexport default function readFile(file: File, callback: (dataUrl: string) => void) {\n    if (file && callback) {\n        const reader = new FileReader();\n        reader.onload = () => {\n            callback(reader.result as string);\n        };\n        reader.onerror = () => {\n            callback(null);\n        };\n        reader.readAsDataURL(file);\n    }\n}\n","import normalizeRect from '../utils/normalizeRect';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport toArray from '../utils/toArray';\r\nimport { TableFormat, TableOperation, VCell } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = safeInstanceOf(node, 'HTMLTableElement') ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = safeInstanceOf(node, 'HTMLTableElement') ? null : node;\r\n            let trs = toArray(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each table cell and get all the cells that share the same border from one side\r\n     * The result is an array of table cell elements where the first element is the narrowest td\r\n     * @param borderPos The position of the border\r\n     * @param getLeftCells Get left-hand-side or right-hand-side cells of the border\r\n     *\r\n     * Example, consider having a 3 by 4 table as below with merged and split cells\r\n     *\r\n     *     | 1 | 4 | 7 | 8 |\r\n     *     |   5   |   9   |\r\n     *     |   3   |   10  |\r\n     *\r\n     *  input => borderPos: the 3rd border, getLeftCells: true\r\n     *  output => [4, 5, 3], where the first element (4) is the narrowest cell\r\n     *\r\n     *  input => borderPos: the 3rd border, getLeftCells: false\r\n     *  output => [7, 9, 10], where the first element (7) is the narrowest cell\r\n     *\r\n     *  input => borderPos: the 2nd border, getLeftCells: true\r\n     *  output => [1], where the first element (1) is the narrowest (and only) cell\r\n     *\r\n     *  input => borderPos: the 2nd border, getLeftCells: false\r\n     *  output => [4], where the first element (4) is the narrowest (and only) cell\r\n     */\r\n    getCellsWithBorder(borderPos: number, getLeftCells: boolean): HTMLTableCellElement[] {\r\n        const cells: HTMLTableCellElement[] = [];\r\n        let closestIndex: number = 0;\r\n        let closestValue: number = getLeftCells ? -1 : Number.MAX_SAFE_INTEGER;\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            for (let j = 0; j < this.cells[i].length; j++) {\r\n                const cell = this.getCell(i, j);\r\n                if (cell.td) {\r\n                    const cellRect = normalizeRect(cell.td.getBoundingClientRect());\r\n                    let found: boolean = false;\r\n                    if (getLeftCells) {\r\n                        if (cellRect.right == borderPos) {\r\n                            found = true;\r\n                            if (cellRect.left > closestValue) {\r\n                                closestValue = cellRect.left;\r\n                                closestIndex = cells.length;\r\n                            }\r\n                            cell.td.setAttribute('originalLeftBorder', cellRect.left.toString());\r\n                            cells.push(cell.td);\r\n                        } else if (found) {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        if (cellRect.left == borderPos) {\r\n                            found = true;\r\n                            if (cellRect.right < closestValue) {\r\n                                closestValue = cellRect.right;\r\n                                closestIndex = cells.length;\r\n                            }\r\n                            cell.td.setAttribute('originalRightBorder', cellRect.right.toString());\r\n                            cells.push(cell.td);\r\n                        } else if (found) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (cells.length > 0) {\r\n            const temp = cells[0];\r\n            cells[0] = cells[closestIndex];\r\n            cells[closestIndex] = temp;\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;\r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                while (row >= 0 && col >= 0) {\r\n                    let cell = this.getCell(row, col);\r\n                    if (cell.td) {\r\n                        return cell.td;\r\n                    } else if (cell.spanLeft) {\r\n                        col--;\r\n                    } else if (cell.spanAbove) {\r\n                        row--;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (safeInstanceOf(newNode, 'HTMLTableCellElement')) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import fromHtml from '../utils/fromHtml';\nimport getRootListNode from './getRootListNode';\nimport getSelectedBlockElementsInRegion from '../region/getSelectedBlockElementsInRegion';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport Position from '../selection/Position';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport toArray from '../utils/toArray';\nimport VList from './VList';\nimport wrap from '../utils/wrap';\nimport { getLeafSibling } from '../utils/getLeafSibling';\nimport { isListElement } from './getListTypeFromNode';\nimport { ListType, Region } from 'roosterjs-editor-types';\nimport { PositionType } from 'roosterjs-editor-types';\n\nconst ListSelector = 'ol,ul';\n\n/**\n * @internal\n * @param region The region to get VList from\n * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,\n * false to only include the list for the selected blocks\n * @param startNode (Optional) When specified, try get VList which will contain this node.\n * If not specified, get VList from selection of this region\n */\nexport default function createVListFromRegion(\n    region: Region,\n    includeSiblingLists?: boolean,\n    startNode?: Node\n): VList {\n    if (!region) {\n        return null;\n    }\n\n    let nodes: Node[] = [];\n\n    if (startNode) {\n        const list = getRootListNode(region, ListSelector, startNode);\n        if (list) {\n            nodes.push(list);\n        }\n    } else {\n        const blocks = getSelectedBlockElementsInRegion(region);\n        blocks.forEach(block => {\n            const list = getRootListNode(region, ListSelector, block.getStartNode());\n\n            if (list) {\n                if (nodes[nodes.length - 1] != list) {\n                    nodes.push(list);\n                }\n                if (\n                    nodes.length == 1 &&\n                    safeInstanceOf(list, 'HTMLOListElement') &&\n                    list.start > 1\n                ) {\n                    // Do not include sibling lists if this list is not start from 1\n                    includeSiblingLists = false;\n                }\n            } else {\n                nodes.push(block.collapseToSingleElement());\n            }\n        });\n\n        if (nodes.length == 0 && !region.rootNode.firstChild) {\n            const newNode = fromHtml('<div><br></div>', region.rootNode.ownerDocument)[0];\n            region.rootNode.appendChild(newNode);\n            nodes.push(newNode);\n            region.fullSelectionStart = new Position(newNode, PositionType.Begin);\n            region.fullSelectionEnd = new Position(newNode, PositionType.End);\n        }\n\n        if (includeSiblingLists) {\n            tryIncludeSiblingNode(region, nodes, false /*isNext*/);\n            tryIncludeSiblingNode(region, nodes, true /*isNext*/);\n        }\n\n        nodes = nodes.filter(node => !shouldSkipNode(node, true /*ignoreSpace*/));\n    }\n\n    let vList: VList = null;\n\n    if (nodes.length > 0) {\n        const firstNode = nodes.shift();\n        vList = isListElement(firstNode)\n            ? new VList(firstNode)\n            : createVListFromItemNode(firstNode);\n\n        nodes.forEach(node => {\n            if (isListElement(node)) {\n                vList.mergeVList(new VList(node));\n            } else {\n                vList.appendItem(node, ListType.None);\n            }\n        });\n    }\n\n    return vList;\n}\n\nfunction tryIncludeSiblingNode(region: Region, nodes: Node[], isNext: boolean) {\n    let node = nodes[isNext ? nodes.length - 1 : 0];\n    node = getLeafSibling(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);\n    node = getRootListNode(region, ListSelector, node);\n    if (isNodeInRegion(region, node) && isListElement(node)) {\n        if (isNext) {\n            if (!safeInstanceOf(node, 'HTMLOListElement') || node.start == 1) {\n                // Only include sibling list when\n                // 1. This is a unordered list, OR\n                // 2. This list starts from 1\n                nodes.push(node);\n            }\n        } else {\n            nodes.unshift(node);\n        }\n    }\n}\n\nfunction createVListFromItemNode(node: Node): VList {\n    // Wrap all child nodes under a single one, and put the new list under original root node\n    // so that the list can carry over styles under the root node.\n    const childNodes = toArray(node.childNodes);\n    const nodeForItem = childNodes.length == 1 ? childNodes[0] : wrap(childNodes, 'SPAN');\n\n    // Create a temporary OL root element for this list.\n    const listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here\n    node.appendChild(listNode);\n\n    // Create the VList and append items\n    const vList = new VList(listNode);\n    vList.appendItem(nodeForItem, ListType.None);\n\n    return vList;\n}\n","import arrayPush from '../utils/arrayPush';\nimport getRootListNode from './getRootListNode';\nimport isNodeAfter from '../utils/isNodeAfter';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport queryElements from '../utils/queryElements';\nimport VList from './VList';\nimport { ListType, RegionBase } from 'roosterjs-editor-types';\n\nconst CHAIN_NAME_PREFIX = '__List_Chain_';\nconst CHAIN_DATASET_NAME = 'listchain';\nconst AFTER_CURSOR_DATASET_NAME = 'listchainafter';\nlet lastChainIndex = 0;\n\n/**\n * Represent a chain of list nodes.\n * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,\n * all others should also be updated in order to main the list number to be continuous.\n */\nexport default class VListChain {\n    private lastNumber = 0;\n    private lastNumberBeforeCursor = 0;\n\n    /**\n     * Create an array of VListChain from current region in editor\n     * @param region The region to create VListChain from\n     * @param currentNode Optional current node, used for mark lists that are after this node\n     * @param nameGenerator Used by test code only\n     */\n    static createListChains(\n        region: RegionBase | RegionBase[],\n        currentNode?: Node,\n        nameGenerator?: () => string\n    ): VListChain[] {\n        const regions = Array.isArray(region) ? region : region ? [region] : [];\n        const result: VListChain[] = [];\n        regions.forEach(region => {\n            const chains: VListChain[] = [];\n            let lastList: HTMLOListElement;\n\n            queryElements(region.rootNode, 'ol', ol => {\n                const list = getRootListNode(region, 'ol', ol);\n\n                if (lastList != list) {\n                    const chain =\n                        chains.filter(c => c.canAppendToTail(list))[0] ||\n                        new VListChain(region, (nameGenerator || createListChainName)());\n                    const index = chains.indexOf(chain);\n                    const afterCurrentNode = currentNode && isNodeAfter(list, currentNode);\n\n                    if (!afterCurrentNode) {\n                        // Make sure current one is at the front if current block has not been met, so that\n                        // the first chain is always the nearest one from current node\n                        if (index >= 0) {\n                            chains.splice(index, 1);\n                        }\n\n                        chains.unshift(chain);\n                    } else if (index < 0) {\n                        chains.push(chain);\n                    }\n\n                    chain.append(list, afterCurrentNode);\n                    lastList = list;\n                }\n            });\n\n            arrayPush(result, chains);\n        });\n\n        return result;\n    }\n\n    /**\n     * Check if a list with the given start number can be appended next to the last list before cursor\n     * @param startNumber The start number of the new list\n     */\n    canAppendAtCursor(startNumber: number): boolean {\n        return this.lastNumberBeforeCursor + 1 == startNumber;\n    }\n\n    /**\n     * Create a VList to wrap the block of the given node, and append to current chain\n     * @param container The container node to create list at\n     * @param startNumber Start number of the new list\n     */\n    createVListAtBlock(container: Node, startNumber: number): VList {\n        if (container) {\n            const list = container.ownerDocument.createElement('ol');\n\n            list.start = startNumber;\n            this.applyChainName(list);\n            container.parentNode.insertBefore(list, container);\n\n            const vList = new VList(list);\n\n            vList.appendItem(container, ListType.None);\n            return vList;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * After change the lists, commit the change to all lists in this chain to update the list number,\n     * and clear the temporary dataset values added to list node\n     */\n    commit() {\n        const lists = this.getLists();\n        let lastNumber = 0;\n\n        for (let i = 0; i < lists.length; i++) {\n            const list = lists[i];\n            list.start = lastNumber + 1;\n\n            const vlist = new VList(list);\n\n            lastNumber = vlist.getLastItemNumber();\n\n            delete list.dataset[CHAIN_DATASET_NAME];\n            delete list.dataset[AFTER_CURSOR_DATASET_NAME];\n\n            vlist.writeBack();\n        }\n    }\n\n    /**\n     * Contruct a new instance of VListChain class\n     * @param editor Editor object\n     */\n    private constructor(private region: RegionBase, private name: string) {}\n\n    /**\n     * Check if the given list node is can be appended into current list chain\n     * @param list The list node to check\n     */\n    private canAppendToTail(list: HTMLOListElement) {\n        return this.lastNumber + 1 == list.start;\n    }\n\n    /**\n     * Append the given list node into this VListChain\n     * @param list The list node to append\n     * @param isAfterCurrentNode Whether this list is after current node\n     */\n    private append(list: HTMLOListElement, isAfterCurrentNode: boolean) {\n        this.applyChainName(list);\n        this.lastNumber = new VList(list).getLastItemNumber();\n\n        if (isAfterCurrentNode) {\n            list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';\n        } else {\n            this.lastNumberBeforeCursor = this.lastNumber;\n        }\n    }\n\n    private applyChainName(list: HTMLOListElement) {\n        list.dataset[CHAIN_DATASET_NAME] = this.name;\n    }\n\n    private getLists() {\n        return queryElements(\n            this.region.rootNode,\n            `ol[data-${CHAIN_DATASET_NAME}=${this.name}]`\n        ).filter(node => isNodeInRegion(this.region, node)) as HTMLOListElement[];\n    }\n}\n\nfunction createListChainName() {\n    return CHAIN_NAME_PREFIX + lastChainIndex++;\n}\n","import { RegionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Constants for each region type\n */\nexport interface RegionTypeData {\n    /**\n     * Tags that child elements will be skipped\n     */\n    skipTags: string[];\n\n    /**\n     * Selector of outer node of a region\n     */\n    outerSelector: string;\n\n    /**\n     * Selector of inner node of a region\n     */\n    innerSelector: string;\n}\n\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\n    [RegionType.Table]: {\n        skipTags: ['TABLE'],\n        outerSelector: 'table',\n        innerSelector: 'td,th',\n    },\n};\n\n/**\n * @internal\n */\nexport default regionTypeData;\n","import createRange from './createRange';\r\nimport normalizeRect from '../utils/normalizeRect';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        const document = position.node.ownerDocument;\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import getInnerHTML from '../utils/getInnerHTML';\nimport getSelectionPath from './getSelectionPath';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport queryElements from '../utils/queryElements';\n\n/**\n * Get inner Html of a root node with a selection path which can be used for restore selection.\n * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.\n * @param rootNode Root node to get inner Html from\n * @param range The range of selection. If pass null, no selection path will be added\n * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid\n */\nexport default function getHtmlWithSelectionPath(\n    rootNode: HTMLElement | DocumentFragment,\n    range: Range\n): string {\n    if (!rootNode) {\n        return '';\n    }\n\n    const { startContainer, endContainer, startOffset, endOffset } = range || {};\n    let isDOMChanged = false;\n\n    queryElements(rootNode, 'table', table => {\n        let tbody: HTMLTableSectionElement = null;\n\n        for (let child = table.firstChild; child; child = child.nextSibling) {\n            if (getTagOfNode(child) == 'TR') {\n                if (!tbody) {\n                    tbody = table.ownerDocument.createElement('tbody');\n                    table.insertBefore(tbody, child);\n                }\n\n                tbody.appendChild(child);\n                child = tbody;\n\n                isDOMChanged = true;\n            } else {\n                tbody = null;\n            }\n        }\n    });\n\n    if (range && isDOMChanged) {\n        try {\n            range.setStart(startContainer, startOffset);\n            range.setEnd(endContainer, endOffset);\n        } catch {}\n    }\n\n    const content = getInnerHTML(rootNode);\n    const selectionPath = range && getSelectionPath(rootNode, range);\n\n    return selectionPath ? `${content}<!--${JSON.stringify(selectionPath)}-->` : content;\n}\n","import createRange from './createRange';\r\nimport { NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Restore inner Html of a root element from given html string. If the string contains selection path,\r\n * remove the selection path and return a range represented by the path\r\n * @param root The root element\r\n * @param html The html to restore\r\n * @returns A selection range if the html contains a valid selection path, otherwise null\r\n */\r\nexport default function setHtmlWithSelectionPath(rootNode: HTMLElement, html: string): Range {\r\n    rootNode.innerHTML = html || '';\r\n    let path: SelectionPath = null;\r\n    let pathComment = rootNode.lastChild;\r\n\r\n    try {\r\n        path =\r\n            pathComment &&\r\n            pathComment.nodeType == NodeType.Comment &&\r\n            (JSON.parse(pathComment.nodeValue) as SelectionPath);\r\n        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {\r\n            rootNode.removeChild(pathComment);\r\n        } else {\r\n            path = null;\r\n        }\r\n    } catch {}\r\n\r\n    return path && createRange(rootNode, path.start, path.end);\r\n}\r\n","import { Browser } from '../utils/Browser';\n\n/**\n * Add the given range into selection of the given document\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection,\n * otherwise it will always remove current selection ranage and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport default function addRangeToSelection(range: Range, skipSameRange?: boolean) {\n    const selection = range?.commonAncestorContainer?.ownerDocument?.defaultView?.getSelection();\n    if (selection) {\n        let needAddRange = true;\n\n        if (selection.rangeCount > 0) {\n            // Workaround IE exception 800a025e\n            try {\n                let currentRange: Range;\n                // Do not remove/add range if current selection is the same with target range\n                // Without this check, execCommand() may fail in Edge since we changed the selection\n                if (\n                    (skipSameRange || Browser.isEdge) &&\n                    (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\n                    currentRange.startContainer == range.startContainer &&\n                    currentRange.startOffset == range.startOffset &&\n                    currentRange.endContainer == range.endContainer &&\n                    currentRange.endOffset == range.endOffset\n                ) {\n                    needAddRange = false;\n                } else {\n                    selection.removeAllRanges();\n                }\n            } catch (e) {}\n        }\n\n        if (needAddRange) {\n            selection.addRange(range);\n        }\n    }\n}\n","import arrayPush from '../utils/arrayPush';\nimport collapseNodesInRegion from '../region/collapseNodesInRegion';\nimport getRegionsFromRange from '../region/getRegionsFromRange';\nimport getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';\nimport mergeBlocksInRegion from '../region/mergeBlocksInRegion';\nimport Position from './Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitTextNode from '../utils/splitTextNode';\nimport { PositionType, QueryScope, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Delete selected content, and return the new positon to select\n * @param core The EditorCore object.\n * @param range The range to delete\n */\nexport default function deleteSelectedContent(root: HTMLElement, range: Range) {\n    let nodeBefore: Node = null;\n\n    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detecte them from step 2\n    // since table cells will fall in to different regions\n    const nodesToDelete: Node[] = queryElements(\n        root,\n        'table,tr',\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.\n    // We don't delete them directly here because delete node from one region may cause selection range\n    // another region becomes invalid. So we delay the process of deletion.\n    const regions = getRegionsFromRange(root, range, RegionType.Table);\n    const nodesPairToMerge = regions\n        .map(region => {\n            const regionRange = getSelectionRangeInRegion(region);\n            if (!regionRange) {\n                return null;\n            }\n\n            const { startContainer, endContainer, startOffset, endOffset } = regionRange;\n\n            // Make sure there are node before and after the merging point.\n            // This is required by mergeBlocksInRegion API.\n            // This may create some empty text node as anchor\n            let [beforeEnd, afterEnd] = ensureBeforeAndAfter(\n                endContainer,\n                endOffset,\n                false /*isStart*/\n            );\n            let [beforeStart, afterStart] = ensureBeforeAndAfter(\n                startContainer,\n                startOffset,\n                true /*isStart*/\n            );\n            nodeBefore = nodeBefore || beforeStart;\n\n            // Find out all nodes to be deleted\n            const nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);\n            arrayPush(nodesToDelete, nodes);\n            return { region, beforeStart, afterEnd };\n        })\n        .filter(x => !!x);\n\n    // 3. Delete all nodes that we found\n    nodesToDelete.forEach(node => node.parentNode?.removeChild(node));\n\n    // 4. Merge lines for each region, so that after we don't see extra line breaks\n    nodesPairToMerge.forEach(nodes =>\n        mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd)\n    );\n\n    return nodeBefore && new Position(nodeBefore, PositionType.End);\n}\n\nfunction ensureBeforeAndAfter(node: Node, offset: number, isStart: boolean) {\n    if (safeInstanceOf(node, 'Text')) {\n        const newNode = splitTextNode(node, offset, isStart);\n        return isStart ? [newNode, node] : [node, newNode];\n    } else {\n        let nodeBefore: Node = node.childNodes[offset - 1];\n        let nodeAfter: Node = node.childNodes[offset];\n\n        // Condition 1: node child nodes\n        // (\"I\" means cursor; \"o\" means a DOM node, \"[ ]\" means a parent node)\n        // [ I ]\n        // need to use parent node instead to convert to condition 2\n        if (!nodeBefore && !nodeAfter) {\n            if (isStart) {\n                nodeAfter = node;\n                nodeBefore = nodeAfter.previousSibling;\n            } else {\n                nodeBefore = node;\n                nodeAfter = nodeBefore.nextSibling;\n            }\n        }\n\n        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)\n        // [ o I ]  or [ I o]\n        // need to add empty text node to convert to condition 3\n        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {\n            const emptyNode = node.ownerDocument.createTextNode('');\n            (nodeBefore || nodeAfter).parentNode?.insertBefore(emptyNode, nodeAfter);\n            if (nodeBefore) {\n                nodeAfter = emptyNode;\n            } else {\n                nodeBefore = emptyNode;\n            }\n        }\n\n        // Condition 3: Both nodeBefore and nodeAfter are not null\n        // [o I o]\n        // return the nodes\n        return [nodeBefore, nodeAfter];\n    }\n}\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n * @param isAutoCompleteSnapshot Whether this is a snapshot before auto complete action\r\n */\r\nexport default function addSnapshot(\r\n    snapshots: Snapshots,\r\n    snapshot: string,\r\n    isAutoCompleteSnapshot: boolean\r\n) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n            snapshots.autoCompleteIndex -= removeCount;\r\n        }\r\n\r\n        if (isAutoCompleteSnapshot) {\r\n            snapshots.autoCompleteIndex = snapshots.currentIndex;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n * @param snapshots The snapshots data structure to move\r\n * @param step The step to move\r\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n */\r\nexport default function moveCurrentSnapsnot(snapshots: Snapshots, step: number): string {\r\n    if (canMoveCurrentSnapshot(snapshots, step)) {\r\n        snapshots.currentIndex += step;\r\n        snapshots.autoCompleteIndex = -1;\r\n        return snapshots.snapshots[snapshots.currentIndex];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        autoCompleteIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\n\n/**\n * Whether there is a snapshot added before auto complete and it can be undone now\n */\nexport default function canUndoAutoComplete(snapshots: Snapshots): boolean {\n    return (\n        snapshots.autoCompleteIndex >= 0 &&\n        snapshots.currentIndex - snapshots.autoCompleteIndex == 1\n    );\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport getInheritableStyles from './getInheritableStyles';\nimport getPredefinedCssForElement from './getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport setStyles from '../style/setStyles';\nimport toArray from '../utils/toArray';\nimport { cloneObject } from './cloneObject';\nimport {\n    getAllowedAttributes,\n    getAllowedCssClassesRegex,\n    getTagReplacement,\n    getDefaultStyleValues,\n    getStyleCallbacks,\n} from './getAllowedValues';\nimport {\n    AttributeCallbackMap,\n    CssStyleCallbackMap,\n    ElementCallbackMap,\n    HtmlSanitizerOptions,\n    NodeType,\n    PredefinedCssMap,\n    SanitizeHtmlOptions,\n    StringMap,\n} from 'roosterjs-editor-types';\n\n/**\n * HTML sanitizer class provides two featuers:\n * 1. Convert global CSS to inline CSS\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\n */\nexport default class HtmlSanitizer {\n    /**\n     * Convert global CSS to inline CSS if any\n     * @param html HTML source\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\n     */\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\n        let sanitizer = new HtmlSanitizer({\n            additionalGlobalStyleNodes: additionalStyleNodes,\n        });\n        return sanitizer.exec(html, true /*convertCssOnly*/);\n    }\n\n    /**\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\n     * @param html HTML source string\n     * @param options Options used for this sanitizing process\n     */\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\n        options = options || {};\n        let sanitizer = new HtmlSanitizer(options);\n        let currentStyles = safeInstanceOf(options.currentElementOrStyle, 'HTMLElement')\n            ? getInheritableStyles(options.currentElementOrStyle)\n            : options.currentElementOrStyle;\n        return sanitizer.exec(html, options.convertCssOnly, currentStyles);\n    }\n\n    private elementCallbacks: ElementCallbackMap;\n    private styleCallbacks: CssStyleCallbackMap;\n    private attributeCallbacks: AttributeCallbackMap;\n    private tagReplacements: Record<string, string>;\n    private allowedAttributes: string[];\n    private allowedCssClassesRegex: RegExp;\n    private defaultStyleValues: StringMap;\n    private additionalPredefinedCssForElement: PredefinedCssMap;\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\n    private unknownTagReplacement: string;\n\n    /**\n     * Construct a new instance of HtmlSanitizer\n     * @param options Options for HtmlSanitizer\n     */\n    constructor(options?: HtmlSanitizerOptions) {\n        options = options || {};\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\n        this.styleCallbacks = getStyleCallbacks(options.cssStyleCallbacks);\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\n        this.tagReplacements = getTagReplacement(options.additionalTagReplacements);\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowedAttributes);\n        this.allowedCssClassesRegex = getAllowedCssClassesRegex(\n            options.additionalAllowedCssClasses\n        );\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\n        this.additionalPredefinedCssForElement = options.additionalPredefinedCssForElement;\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\n        this.unknownTagReplacement = options.unknownTagReplacement;\n    }\n\n    /**\n     * Sanitize HTML string\n     * This function will do the following work:\n     * 1. Convert global CSS into inline CSS\n     * 2. Remove dangerous HTML tags and attributes\n     * 3. Remove useless CSS properties\n     * @param html The input HTML\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\n     * @param currentStyles Current inheritable CSS styles\n     */\n    exec(html: string, convertCssOnly?: boolean, currentStyles?: StringMap): string {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html || '', 'text/html');\n\n        if (doc && doc.body && doc.body.firstChild) {\n            this.convertGlobalCssToInlineCss(doc);\n            if (!convertCssOnly) {\n                this.sanitize(doc.body, currentStyles);\n            }\n        }\n        return (doc && doc.body && doc.body.innerHTML) || '';\n    }\n\n    /**\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\n     * @param rootNode Root node to sanitize\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\n     * the same value with current styles will be ignored.\n     */\n    sanitize(rootNode: Node, currentStyles?: StringMap) {\n        if (!rootNode) {\n            return '';\n        }\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\n        this.processNode(rootNode, currentStyles, {});\n    }\n\n    /**\n     * Convert global CSS into inline CSS\n     * @param rootNode The HTML Document\n     */\n    convertGlobalCssToInlineCss(rootNode: ParentNode) {\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\n        let styleSheets = this.additionalGlobalStyleNodes\n            .reverse()\n            .map(node => node.sheet as CSSStyleSheet)\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\n            .filter(sheet => sheet);\n        for (let styleSheet of styleSheets) {\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\n                // Skip any none-style rule, i.e. @page\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\n                    continue;\n                }\n                // Make sure the selector is not empty\n                for (let selector of styleRule.selectorText.split(',')) {\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\n                        continue;\n                    }\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\n                    // Always put existing styles after so that they have higher priority\n                    // Which means if both global style and inline style apply to the same element,\n                    // inline style will have higher priority\n                    nodes.forEach(node =>\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\n                    );\n                }\n            }\n        }\n\n        styleNodes.forEach(node => {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        });\n    }\n\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\n        const nodeType = node.nodeType;\n        const isElement = nodeType == NodeType.Element;\n        const isText = nodeType == NodeType.Text;\n        const isFragment = nodeType == NodeType.DocumentFragment;\n\n        let shouldKeep = false;\n\n        if (isElement) {\n            const tag = getTagOfNode(node);\n            const callback = this.elementCallbacks[tag];\n            let replacement = this.tagReplacements[tag.toLowerCase()];\n\n            if (replacement === undefined) {\n                replacement = this.unknownTagReplacement;\n            }\n\n            if (callback) {\n                shouldKeep = callback(node as HTMLElement, context);\n            } else if (tag.indexOf(':') > 0) {\n                shouldKeep = true;\n            } else if (tag == replacement || replacement == '*') {\n                shouldKeep = true;\n            } else if (replacement && /^[a-zA-Z][\\w\\-]*$/.test(replacement)) {\n                node = changeElementTag(node as HTMLElement, replacement);\n                shouldKeep = true;\n            }\n        } else if (isText) {\n            const whiteSpace = currentStyle['white-space'];\n            shouldKeep =\n                whiteSpace == 'pre' ||\n                whiteSpace == 'pre-line' ||\n                whiteSpace == 'pre-wrap' ||\n                !/^[\\r\\n]*$/g.test(node.nodeValue);\n        } else if (isFragment) {\n            shouldKeep = true;\n        } else {\n            shouldKeep = false;\n        }\n\n        if (!shouldKeep) {\n            node.parentNode.removeChild(node);\n        } else if (\n            isText &&\n            (currentStyle['white-space'] == 'pre' || currentStyle['white-space'] == 'pre-wrap')\n        ) {\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\n        } else if (isElement || isFragment) {\n            let thisStyle = cloneObject(currentStyle);\n            let element = <HTMLElement>node;\n            if (isElement) {\n                this.processAttributes(element, context);\n                this.preprocessCss(element, thisStyle);\n                this.processCss(element, thisStyle, context);\n            }\n\n            let child: Node = element.firstChild;\n            let next: Node;\n            for (; child; child = next) {\n                next = child.nextSibling;\n                this.processNode(child, thisStyle, context);\n            }\n        }\n    }\n\n    private preprocessCss(element: HTMLElement, thisStyle: StringMap) {\n        const predefinedStyles = getPredefinedCssForElement(\n            element,\n            this.additionalPredefinedCssForElement\n        );\n        if (predefinedStyles) {\n            Object.keys(predefinedStyles).forEach(name => {\n                thisStyle[name] = predefinedStyles[name];\n            });\n        }\n    }\n\n    private processCss(element: HTMLElement, thisStyle: StringMap, context: Object) {\n        const styles = getStyles(element);\n        Object.keys(styles).forEach(name => {\n            const value = styles[name];\n            let callback = this.styleCallbacks[name];\n            let isInheritable = thisStyle[name] != undefined;\n            let keep =\n                (!callback || callback(value, element, thisStyle, context)) &&\n                value != 'inherit' &&\n                value.indexOf('expression') < 0 &&\n                name.substr(0, 1) != '-' &&\n                this.defaultStyleValues[name] != value &&\n                ((isInheritable && value != thisStyle[name]) ||\n                    (!isInheritable && value != 'initial' && value != 'normal'));\n            if (keep && isInheritable) {\n                thisStyle[name] = value;\n            }\n\n            if (!keep) {\n                delete styles[name];\n            }\n        });\n\n        setStyles(element, styles);\n    }\n\n    private processAttributes(element: HTMLElement, context: Object) {\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\n            let attribute = element.attributes[i];\n            let name = attribute.name.toLowerCase().trim();\n            let value = attribute.value;\n            let callback = this.attributeCallbacks[name];\n\n            let newValue = callback\n                ? callback(value, element, context)\n                : this.allowedAttributes.indexOf(name) >= 0 || name.indexOf('data-') == 0\n                ? value\n                : null;\n\n            if (name == 'class' && this.allowedCssClassesRegex) {\n                newValue = this.processCssClass(value, newValue);\n            }\n\n            if (\n                newValue === null ||\n                newValue === undefined ||\n                newValue.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\n            ) {\n                element.removeAttribute(name);\n            } else {\n                attribute.value = newValue;\n            }\n        }\n    }\n\n    private processCssClass(originalValue: string, calculatedValue: string): string {\n        const originalClasses = originalValue ? originalValue.split(' ') : [];\n        const calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];\n\n        originalClasses.forEach(className => {\n            if (\n                this.allowedCssClassesRegex.test(className) &&\n                calculatedClasses.indexOf(className) < 0\n            ) {\n                calculatedClasses.push(className);\n            }\n        });\n\n        return calculatedClasses.length > 0 ? calculatedClasses.join(' ') : null;\n    }\n}\n","import { cloneObject } from './cloneObject';\nimport { CssStyleCallbackMap, StringMap } from 'roosterjs-editor-types';\n\nconst HTML_TAG_REPLACEMENT: Record<string, string> = {\n    // Allowed tags\n    a: '*',\n    abbr: '*',\n    address: '*',\n    area: '*',\n    article: '*',\n    aside: '*',\n    b: '*',\n    bdi: '*',\n    bdo: '*',\n    blockquote: '*',\n    body: '*',\n    br: '*',\n    button: '*',\n    canvas: '*',\n    caption: '*',\n    center: '*',\n    cite: '*',\n    code: '*',\n    col: '*',\n    colgroup: '*',\n    data: '*',\n    datalist: '*',\n    dd: '*',\n    del: '*',\n    details: '*',\n    dfn: '*',\n    dialog: '*',\n    dir: '*',\n    div: '*',\n    dl: '*',\n    dt: '*',\n    em: '*',\n    fieldset: '*',\n    figcaption: '*',\n    figure: '*',\n    font: '*',\n    footer: '*',\n    h1: '*',\n    h2: '*',\n    h3: '*',\n    h4: '*',\n    h5: '*',\n    h6: '*',\n    head: '*',\n    header: '*',\n    hgroup: '*',\n    hr: '*',\n    html: '*',\n    i: '*',\n    img: '*',\n    input: '*',\n    ins: '*',\n    kbd: '*',\n    label: '*',\n    legend: '*',\n    li: '*',\n    main: '*',\n    map: '*',\n    mark: '*',\n    menu: '*',\n    menuitem: '*',\n    meter: '*',\n    nav: '*',\n    ol: '*',\n    optgroup: '*',\n    option: '*',\n    output: '*',\n    p: '*',\n    picture: '*',\n    pre: '*',\n    progress: '*',\n    q: '*',\n    rp: '*',\n    rt: '*',\n    ruby: '*',\n    s: '*',\n    samp: '*',\n    section: '*',\n    select: '*',\n    small: '*',\n    span: '*',\n    strike: '*',\n    strong: '*',\n    sub: '*',\n    summary: '*',\n    sup: '*',\n    table: '*',\n    tbody: '*',\n    td: '*',\n    template: '*',\n    textarea: '*',\n    tfoot: '*',\n    th: '*',\n    thead: '*',\n    time: '*',\n    tr: '*',\n    tt: '*',\n    u: '*',\n    ul: '*',\n    var: '*',\n    wbr: '*',\n    xmp: '*',\n\n    // Replaced tags:\n    form: 'SPAN',\n\n    // Disallowed tags\n    applet: null,\n    audio: null,\n    base: null,\n    basefont: null,\n    embed: null,\n    frame: null,\n    frameset: null,\n    iframe: null,\n    link: null,\n    meta: null,\n    noscript: null,\n    object: null,\n    param: null,\n    script: null,\n    slot: null,\n    source: null,\n    style: null,\n    title: null,\n    track: null,\n    video: null,\n};\n\nconst ALLOWED_HTML_ATTRIBUTES = (\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +\n    'width,wrap'\n).split(',');\n\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\n    'background-color': 'transparent',\n    'border-bottom-color': 'rgb(0, 0, 0)',\n    'border-bottom-style': 'none',\n    'border-bottom-width': '0px',\n    'border-image-outset': '0',\n    'border-image-repeat': 'stretch',\n    'border-image-slice': '100%',\n    'border-image-source': 'none',\n    'border-image-width': '1',\n    'border-left-color': 'rgb(0, 0, 0)',\n    'border-left-style': 'none',\n    'border-left-width': '0px',\n    'border-right-color': 'rgb(0, 0, 0)',\n    'border-right-style': 'none',\n    'border-right-width': '0px',\n    'border-top-color': 'rgb(0, 0, 0)',\n    'border-top-style': 'none',\n    'border-top-width': '0px',\n    'outline-color': 'transparent',\n    'outline-style': 'none',\n    'outline-width': '0px',\n    overflow: 'visible',\n    'text-decoration': 'none',\n    '-webkit-text-stroke-width': '0px',\n    'word-wrap': 'break-word',\n    'margin-left': '0px',\n    'margin-right': '0px',\n    padding: '0px',\n    'padding-top': '0px',\n    'padding-left': '0px',\n    'padding-right': '0px',\n    'padding-bottom': '0px',\n    border: '0px',\n    'border-top': '0px',\n    'border-left': '0px',\n    'border-right': '0px',\n    'border-bottom': '0px',\n    'vertical-align': 'baseline',\n    float: 'none',\n};\n\n// This is to preserve entity related CSS classes when paste.\nconst ALLOWED_CSS_CLASSES: string[] = [];\n\n/**\n * @internal\n */\nexport function getTagReplacement(\n    additionalReplacements: Record<string, string>\n): Record<string, string> {\n    const result = { ...HTML_TAG_REPLACEMENT };\n    const replacements = additionalReplacements || {};\n    Object.keys(replacements).forEach(key => {\n        if (key) {\n            result[key.toLowerCase()] = replacements[key];\n        }\n    });\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\n        attr.toLocaleLowerCase()\n    );\n}\n\n/**\n * @internal\n */\nexport function getAllowedCssClassesRegex(additionalCssClasses: string[]): RegExp {\n    const patterns = ALLOWED_CSS_CLASSES.concat(additionalCssClasses || []);\n    return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;\n}\n\n/**\n * @internal\n */\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\n    if (additionalDefaultStyles) {\n        Object.keys(additionalDefaultStyles).forEach(name => {\n            let value = additionalDefaultStyles[name];\n            if (value !== null && value !== undefined) {\n                result[name] = value;\n            } else {\n                delete result[name];\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getStyleCallbacks(callbacks: CssStyleCallbackMap): CssStyleCallbackMap {\n    let result = cloneObject(callbacks);\n    result.position = result.position || removeValue;\n    result.width = result.width || removeWidthForLiAndDiv;\n    return result;\n}\n\nfunction removeValue(): null {\n    return null;\n}\n\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\n    let tag = element.tagName;\n    return !(tag == 'LI' || tag == 'DIV');\n}\n\nfunction unique<T>(array: T[]): T[] {\n    return array.filter((value, index, self) => self.indexOf(value) == index);\n}\n","import { HtmlSanitizerOptions } from 'roosterjs-editor-types';\n\n/**\n * Create default value of HtmlSanitizerOptions with every property set\n */\nexport default function createDefaultHtmlSanitizerOptions(): Required<HtmlSanitizerOptions> {\n    return {\n        elementCallbacks: {},\n        attributeCallbacks: {},\n        cssStyleCallbacks: {},\n        additionalTagReplacements: {},\n        additionalAllowedAttributes: [],\n        additionalAllowedCssClasses: [],\n        additionalDefaultStyleValues: {},\n        additionalGlobalStyleNodes: [],\n        additionalPredefinedCssForElement: {},\n        unknownTagReplacement: null,\n    };\n}\n","/**\n * Chain all callback for an attribute together\n * @param map The source callback map\n * @param name Name of the property to chain\n * @param newCallback A new callback to process the given name on the given map.\n * If the same property got multiple callbacks, the final return value will be the return\n * value of the latest callback\n */\nexport default function chainSanitizerCallback<T extends any[], R>(\n    map: Record<string, (...args: T) => R>,\n    name: string,\n    newCallback: (...args: T) => R\n) {\n    if (!map[name]) {\n        map[name] = newCallback;\n    } else {\n        const originalCallback = map[name];\n        map[name] = (...args: T) => {\n            originalCallback(...args);\n            return newCallback(...args);\n        };\n    }\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE = 'contenteditable';\n\n/**\n * Commit information of an entity (type, isReadonly, id) into the wrapper node as CSS Classes\n * @param wrapper The entity wrapper element\n * @param type Entity type\n * @param isReadonly Whether this is a readonly entity\n * @param id Optional Id of the entity\n */\nexport default function commitEntity(\n    wrapper: HTMLElement,\n    type: string,\n    isReadonly: boolean,\n    id?: string\n) {\n    if (wrapper) {\n        wrapper.className = `${EntityClasses.ENTITY_INFO_NAME} ${\n            EntityClasses.ENTITY_TYPE_PREFIX\n        }${type} ${id ? `${EntityClasses.ENTITY_ID_PREFIX}${id} ` : ''}${\n            EntityClasses.ENTITY_READONLY_PREFIX\n        }${isReadonly ? '1' : '0'}`;\n\n        if (isReadonly) {\n            wrapper.contentEditable = 'false';\n        } else if (wrapper.getAttribute(CONTENT_EDITABLE)) {\n            wrapper.removeAttribute(CONTENT_EDITABLE);\n        }\n    }\n}\n","import { Entity, EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * Get Entity object from an entity root element\n * @param element The entity root element. If this element is not an entity root element,\n * it will return null\n */\nexport default function getEntityFromElement(element: HTMLElement): Entity {\n    let isEntity = false;\n    let type: string;\n    let id = '';\n    let isReadonly = false;\n\n    element?.className?.split(' ').forEach(name => {\n        if (name == EntityClasses.ENTITY_INFO_NAME) {\n            isEntity = true;\n        } else if (name.indexOf(EntityClasses.ENTITY_TYPE_PREFIX) == 0) {\n            type = name.substr(EntityClasses.ENTITY_TYPE_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_ID_PREFIX) == 0) {\n            id = name.substr(EntityClasses.ENTITY_ID_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_READONLY_PREFIX) == 0) {\n            isReadonly = name.substr(EntityClasses.ENTITY_READONLY_PREFIX.length) == '1';\n        }\n    });\n\n    return isEntity\n        ? {\n              wrapper: element,\n              id,\n              type,\n              isReadonly,\n          }\n        : null;\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * @internal Get a selector string for specified entity type and id\n * @param type (Optional) Type of entity\n * @param id (Optional) Id of entity\n */\nexport default function getEntitySelector(type?: string, id?: string): string {\n    const typeSelector = type ? `.${EntityClasses.ENTITY_TYPE_PREFIX}${type}` : '';\n    const idSelector = id ? `.${EntityClasses.ENTITY_ID_PREFIX}${id}` : '';\n    return '.' + EntityClasses.ENTITY_INFO_NAME + typeSelector + idSelector;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Gets the cached event data by cache key from event object if there is already one.\n * Otherwise, call getter function to create one, and cache it.\n * @param event The event object\n * @param key Cache key string, need to be unique\n * @param getter Getter function to get the object when it is not in cache yet\n */\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\n    let result =\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\n            ? <T>event.eventDataCache[key]\n            : getter();\n    if (event) {\n        event.eventDataCache = event.eventDataCache || {};\n        event.eventDataCache[key] = result;\n    }\n\n    return result;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Clear a cached object by its key from an event object\n * @param event The event object\n * @param key The cache key\n */\nexport default function clearEventDataCache(event: PluginEvent, key?: string): void {\n    if (event && event.eventDataCache) {\n        if (key && event.eventDataCache.hasOwnProperty(key)) {\n            delete event.eventDataCache[key];\n        } else if (!key) {\n            event.eventDataCache = {};\n        }\n    }\n}\n","import isModifierKey from './isModifierKey';\n\n/**\n * Returns true when the event was fired from a key that produces a character value, otherwise false\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\n * So if we missed some case here it is still acceptable.\n * @param event The keyboard event object\n */\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\n    return !isModifierKey(event) && event.key && event.key.length == 1;\n}\n","import { Browser } from '../utils/Browser';\n\n/**\n * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event\n * @param event A Keyboard event or Mouse event object\n * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac\n */\nconst isCtrlOrMetaPressed: (event: KeyboardEvent | MouseEvent) => boolean = Browser.isMac\n    ? event => event.metaKey\n    : event => event.ctrlKey;\nexport default isCtrlOrMetaPressed;\n","import blockFormat from '../utils/blockFormat';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    getSelectedBlockElementsInRegion,\r\n    getStyles,\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    isNodeInRegion,\r\n    isVoidHtmlElement,\r\n    safeInstanceOf,\r\n    setStyles,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nconst ATTRIBUTES_TO_PRESERVE = ['href', 'src'];\r\nconst TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n */\r\nexport default function clearBlockFormat(editor: IEditor) {\r\n    blockFormat(editor, region => {\r\n        const blocks = getSelectedBlockElementsInRegion(region);\r\n        let nodes = collapseNodesInRegion(region, blocks);\r\n\r\n        if (editor.contains(region.rootNode)) {\r\n            // If there are styles on table cell, wrap all its children and move down all non-border styles.\r\n            // So that we can preserve styles for unselected blocks as well as border styles for table\r\n            const nonborderStyles = removeNonBorderStyles(region.rootNode);\r\n            if (Object.keys(nonborderStyles).length > 0) {\r\n                const wrapper = wrap(toArray(region.rootNode.childNodes));\r\n                setStyles(wrapper, nonborderStyles);\r\n            }\r\n        }\r\n\r\n        while (nodes.length > 0 && isNodeInRegion(region, nodes[0].parentNode)) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n\r\n        nodes.forEach(clearNodeFormat);\r\n    });\r\n}\r\n\r\nfunction clearNodeFormat(node: Node): boolean {\r\n    // 1. Recursively clear format of all its child nodes\r\n    const areBlockElements = toArray(node.childNodes).map(clearNodeFormat);\r\n    let areAllChildrenBlock = areBlockElements.every(b => b);\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. Unwrap the tag if necessary\r\n    const tag = getTagOfNode(node);\r\n    if (tag) {\r\n        if (\r\n            TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||\r\n            (areAllChildrenBlock &&\r\n                !isVoidHtmlElement(node) &&\r\n                TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)\r\n        ) {\r\n            if (returnBlockElement && !areAllChildrenBlock) {\r\n                wrap(node);\r\n            }\r\n            unwrap(node);\r\n        } else {\r\n            // 3. Otherwise, remove all attributes\r\n            clearAttribute(node as HTMLElement);\r\n        }\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement) {\r\n    const isTableCell = safeInstanceOf(element, 'HTMLTableCellElement');\r\n\r\n    for (let attr of toArray(element.attributes)) {\r\n        if (isTableCell && attr.name == 'style') {\r\n            removeNonBorderStyles(element);\r\n        } else if (\r\n            ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNonBorderStyles(element: HTMLElement): Record<string, string> {\r\n    const styles = getStyles(element);\r\n    const result: Record<string, string> = {};\r\n\r\n    Object.keys(styles).forEach(name => {\r\n        if (name.indexOf('border') < 0) {\r\n            result[name] = styles[name];\r\n            delete styles[name];\r\n        }\r\n    });\r\n\r\n    setStyles(element, styles);\r\n\r\n    return result;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer, matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: IEditor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = (checkXss(link) || '').trim();\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: IEditor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n\r\nfunction checkXss(link: string): string {\r\n    const santizer = new HtmlSanitizer();\r\n    const doc = new DOMParser().parseFromString('<a></a>', 'text/html');\r\n    const a = doc.body.firstChild as HTMLAnchorElement;\r\n\r\n    a.href = link || '';\r\n    santizer.sanitize(doc.body);\r\n    // We use getAttribute because some browsers will try to make the href property a valid link.\r\n    // This has unintended side effects when the link lacks a protocol.\r\n    return a.getAttribute('href');\r\n}\r\n","import { getPendableFormatState, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    IEditor,\r\n    PluginEvent,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: IEditor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(editor.getElementAtCursor('OL,UL', null /*startFrom*/, event));\r\n    let headerTag = getTagOfNode(\r\n        editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', null /*startFrom*/, event)\r\n    );\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: IEditor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        ...editor.getUndoState(),\r\n    };\r\n}\r\n","import {\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    IEditor,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * Insert an entity into editor.\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n * @param position (Optional) The position to insert into. If not specified, current position will be used.\n * If isBlock is true, entity will be insert below this position\n */\nexport default function insertEntity(\n    editor: IEditor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean,\n    position?: NodePosition | ContentPosition.Begin | ContentPosition.End | ContentPosition.DomEnd\n): Entity {\n    const wrapper = wrap(contentNode, isBlock ? 'DIV' : 'SPAN');\n\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\n    // there will be some weird behavior when move cursor around the entity node.\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\n    // in IE that there will be a resize border around the inline-block element. We made some\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\n    // will just work fine.\n    if (!isBlock && isReadonly) {\n        wrapper.style.display = 'inline-block';\n    }\n\n    commitEntity(wrapper, type, isReadonly);\n\n    if (!editor.contains(wrapper)) {\n        let currentRange: Range;\n        let contentPosition:\n            | ContentPosition.Begin\n            | ContentPosition.End\n            | ContentPosition.DomEnd\n            | ContentPosition.SelectionStart;\n\n        if (typeof position == 'number') {\n            contentPosition = position;\n        } else if (position) {\n            currentRange = editor.getSelectionRange();\n            const node = position.normalize().node;\n            const existingEntity = node && editor.getElementAtCursor(getEntitySelector(), node);\n\n            // Do not insert entity into another entity\n            if (existingEntity) {\n                position = new Position(existingEntity, PositionType.After);\n            }\n\n            editor.select(position);\n            contentPosition = ContentPosition.SelectionStart;\n        } else {\n            editor.focus();\n            contentPosition = ContentPosition.SelectionStart;\n        }\n\n        editor.insertNode(wrapper, {\n            updateCursor: false,\n            insertOnNewLine: isBlock,\n            replaceSelection: true,\n            position: contentPosition,\n        });\n\n        if (contentPosition == ContentPosition.SelectionStart) {\n            if (currentRange) {\n                editor.select(currentRange);\n            } else if (!isBlock) {\n                editor.select(wrapper, PositionType.After);\n            }\n        }\n    }\n\n    if (isBlock) {\n        // Insert an extra empty line for block entity to make sure\n        // user can still put cursor below the entity.\n        const br = editor.getDocument().createElement('BR');\n        wrapper.parentNode.insertBefore(br, wrapper.nextSibling);\n    }\n\n    const entity = getEntityFromElement(wrapper);\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\n\n    return entity;\n}\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\r\nimport { readFile } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: IEditor, imageFile: File): void;\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image link.\r\n */\r\nexport default function insertImage(editor: IEditor, url: string): void;\r\n\r\nexport default function insertImage(editor: IEditor, imageFile: File | string): void {\r\n    if (typeof imageFile == 'string') {\r\n        insertImageWithSrc(editor, imageFile);\r\n    } else {\r\n        readFile(imageFile, dataUrl => {\r\n            if (dataUrl && !editor.isDisposed()) {\r\n                insertImageWithSrc(editor, dataUrl);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction insertImageWithSrc(editor: IEditor, src: string) {\r\n    editor.addUndoSnapshot(() => {\r\n        const image = editor.getDocument().createElement('img');\r\n        image.src = src;\r\n        image.style.maxWidth = '100%';\r\n        editor.insertNode(image);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: IEditor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(editor =>\r\n            editor.select(new Position(table, PositionType.Begin).normalize())\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableOperation } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: IEditor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            let cellToSelect = calculateCellToSelect(operation, vtable.row, vtable.col);\r\n            editor.select(\r\n                vtable.getCell(cellToSelect.newRow, cellToSelect.newCol).td,\r\n                PositionType.Begin\r\n            );\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction calculateCellToSelect(operation: TableOperation, currentRow: number, currentCol: number) {\r\n    let newRow = currentRow;\r\n    let newCol = currentCol;\r\n    switch (operation) {\r\n        case TableOperation.InsertAbove:\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertBelow:\r\n            newRow += 1;\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertLeft:\r\n            newRow = 0;\r\n            break;\r\n        case TableOperation.InsertRight:\r\n            newRow = 0;\r\n            newCol += 1;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        newRow,\r\n        newCol,\r\n    };\r\n}\r\n","import { ChangeSource, IEditor, TableFormat } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: IEditor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition, IEditor, IPositionContentSearcher } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\n\n/**\n * Rotate an element visually\n * @param editor The editor instance\n * @param element The element that should be rotated\n * @param angle The degree at which to rotate the element from it's center\n */\nexport default function rotateElement(editor: IEditor, element: HTMLElement, angle: number): void {\n    if (element) {\n        editor.addUndoSnapshot(() => {\n            element.style.transform = `rotate(${angle}deg)`;\n        }, ChangeSource.Format);\n    }\n}\n","import execCommand from '../utils/execCommand';\r\nimport {\r\n    Alignment,\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: IEditor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: IEditor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { BlockElement, IEditor, NodeType } from 'roosterjs-editor-types';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocks(\r\n    editor: IEditor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: IEditor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import blockFormat from '../utils/blockFormat';\r\nimport { BlockElement, IEditor, Indentation, RegionBase } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    createVListFromRegion,\r\n    findClosestElementAncestor,\r\n    getSelectedBlockElementsInRegion,\r\n    getTagOfNode,\r\n    isNodeInRegion,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst BlockWrapper = '<blockquote style=\"margin-top:0;margin-bottom:0\"></blockquote>';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: IEditor, indentation: Indentation) {\r\n    const handler = indentation == Indentation.Increase ? indent : outdent;\r\n\r\n    blockFormat(editor, (region, start, end) => {\r\n        const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\r\n        const blockGroups: BlockElement[][] = [[]];\r\n\r\n        for (let i = 0; i < blocks.length; i++) {\r\n            const startNode = blocks[i].getStartNode();\r\n            const vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);\r\n\r\n            if (vList) {\r\n                blockGroups.push([]);\r\n                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {\r\n                    i++;\r\n                }\r\n                vList.setIndentation(start, end, indentation);\r\n                vList.writeBack();\r\n            } else {\r\n                blockGroups[blockGroups.length - 1].push(blocks[i]);\r\n            }\r\n        }\r\n\r\n        blockGroups.forEach(group => handler(region, group));\r\n    });\r\n}\r\n\r\nfunction indent(region: RegionBase, blocks: BlockElement[]) {\r\n    const nodes = collapseNodesInRegion(region, blocks);\r\n    wrap(nodes, BlockWrapper);\r\n}\r\n\r\nfunction outdent(region: RegionBase, blocks: BlockElement[]) {\r\n    blocks.forEach(blockElement => {\r\n        let node = blockElement.collapseToSingleElement();\r\n        const quote = findClosestElementAncestor(node, region.rootNode, 'blockquote');\r\n        if (quote) {\r\n            if (node == quote) {\r\n                node = wrap(toArray(node.childNodes));\r\n            }\r\n\r\n            while (isNodeInRegion(region, node) && getTagOfNode(node) != 'BLOCKQUOTE') {\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (isNodeInRegion(region, node)) {\r\n                unwrap(node);\r\n            }\r\n        }\r\n    });\r\n}\r\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Capitalization, NodeType } from 'roosterjs-editor-types';\nimport applyInlineStyle from '../utils/applyInlineStyle';\nimport { getFirstLeafNode, getNextLeafSibling } from 'roosterjs-editor-dom';\n\n/**\n * Change the capitalization of text in the selection\n * @param editor The editor instance\n * @param capitalization The case option\n * @param language Optional parameter for language string that should comply to \"IETF BCP 47 Tags for\n * Identifying Languages\". For example: 'en' or 'en-US' for English, 'tr' for Turkish.\n * Default is the host environments current locale.\n */\nexport default function changeCapitalization(\n    editor: IEditor,\n    capitalization: Capitalization,\n    language?: string\n) {\n    applyInlineStyle(editor, element => {\n        for (let node = getFirstLeafNode(element); node; node = getNextLeafSibling(element, node)) {\n            if (node.nodeType == NodeType.Text) {\n                try {\n                    node.textContent = getCapitalizedText(node.textContent, language);\n                } catch {\n                    node.textContent = getCapitalizedText(node.textContent, undefined);\n                }\n            }\n        }\n    });\n\n    function getCapitalizedText(originalText: string, language: string): string {\n        switch (capitalization) {\n            case Capitalization.Lowercase:\n                return originalText.toLocaleLowerCase(language);\n            case Capitalization.Uppercase:\n                return originalText.toLocaleUpperCase(language);\n            case Capitalization.CapitalizeEachWord:\n                const wordArray = originalText.toLocaleLowerCase(language).split(' ');\n                for (let i = 0; i < wordArray.length; i++) {\n                    wordArray[i] =\n                        wordArray[i].charAt(0).toLocaleUpperCase(language) + wordArray[i].slice(1);\n                }\n                return wordArray.join(' ');\n            case Capitalization.Sentence:\n                // TODO: Add rules on punctuation for internationalization - TASK 104769\n                const punctuationMarks = '[\\\\.\\\\!\\\\?]';\n                // Find a match of a word character either:\n                // - At the beginning of a string with or without preceding whitespace, for\n                // example: '  hello world' and 'hello world' strings would both match 'h'.\n                // - Or preceded by a punctuation mark and at least one whitespace, for\n                // example 'yes. hello world' would match 'y' and 'h'.\n                const regex = new RegExp('^\\\\s*\\\\w|' + punctuationMarks + '\\\\s+\\\\w', 'g');\n                return originalText.toLocaleLowerCase(language).replace(regex, match => {\n                    return match.toLocaleUpperCase(language);\n                });\n        }\n    }\n}\n","import toggleListType from '../utils/toggleListType';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: IEditor) {\r\n    toggleListType(editor, ListType.Unordered);\r\n}\r\n","import toggleListType from '../utils/toggleListType';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n * @param startNumber (Optional) Start number of the list\r\n */\r\nexport default function toggleNumbering(editor: IEditor, startNumber?: number) {\r\n    toggleListType(editor, ListType.Ordered, startNumber);\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: IEditor, styler?: (element: HTMLElement) => void) {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const wrapper = wrap(nodes, BLOCKQUOTE_TAG);\r\n            (styler || DEFAULT_STYLER)(wrapper);\r\n        },\r\n        () => editor.queryElements('blockquote', QueryScope.OnSelection, unwrap).length == 0\r\n    );\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst SELECTOR = `${PRE_TAG}>${CODE_TAG}`;\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: IEditor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const code = wrap(nodes, CODE_TAG);\r\n            const pre = wrap(code, PRE_TAG);\r\n            styler?.(pre);\r\n        },\r\n        () =>\r\n            editor.queryElements(SELECTOR, QueryScope.OnSelection, code => {\r\n                if (!code.previousSibling && !code.nextSibling) {\r\n                    const parent = code.parentNode;\r\n                    unwrap(code);\r\n                    unwrap(parent);\r\n                }\r\n            }).length == 0\r\n    );\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: IEditor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let blockElement = traverser ? traverser.currentBlockElement : null;\r\n            let sanitizer = new HtmlSanitizer({\r\n                cssStyleCallbacks: {\r\n                    'font-size': () => false,\r\n                },\r\n            });\r\n            while (blockElement) {\r\n                let element = blockElement.collapseToSingleElement();\r\n                sanitizer.sanitize(element);\r\n                blockElement = traverser.getNextBlockElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser, getComputedStyle, Position } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    CursorFeatureSettings,\n    Keys,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\n\nconst NoCycleCursorMove: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.LEFT, Keys.RIGHT],\n    allowFunctionKeys: true,\n    shouldHandleEvent: (event, editor, ctrlOrMeta) => {\n        let range: Range;\n        let position: Position;\n\n        if (\n            !ctrlOrMeta ||\n            !(range = editor.getSelectionRange()) ||\n            !range.collapsed ||\n            !(position = Position.getStart(range)) ||\n            !editor.isPositionAtBeginning(position)\n        ) {\n            return false;\n        }\n\n        let rtl = getComputedStyle(position.element, 'direction') == 'rtl';\n        let rawEvent = event.rawEvent;\n\n        return (!rtl && rawEvent.which == Keys.LEFT) || (rtl && rawEvent.which == Keys.RIGHT);\n    },\n    handleEvent: event => {\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: !Browser.isChrome,\n};\n\n/**\n * @internal\n */\nexport const CursorFeatures: Record<\n    keyof CursorFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    noCycleCursorMove: NoCycleCursorMove,\n};\n","import {\n    cacheGetEventData,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    EntityFeatureSettings,\n    EntityOperation,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Click\" when user\n * clicks on a readonly entity.\n */\nconst ClickOnEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Click);\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Escape\" when user\n * presses ESC on a readonly entity.\n */\nconst EscapeFromEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ESCAPE],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Escape);\n    },\n};\n\nfunction cacheGetReadonlyEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    operation?: EntityOperation\n) {\n    const element = cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', () => {\n        const node = event.rawEvent.target as Node;\n        const entityElement = node && editor.getElementAtCursor(getEntitySelector(), node);\n        return entityElement && !entityElement.isContentEditable ? entityElement : null;\n    });\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * A content edit feature to split current line into two lines at the cursor when user presses\n * ENTER right before a readonly entity.\n * Browser's default behavior will insert an extra BR tag before the entity which causes an extra\n * empty line. So we override the default behavior here.\n */\nconst EnterBeforeReadonlyEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n\n        const range = editor.getSelectionRange();\n        const node = Position.getEnd(range).normalize().node;\n        const br = editor.getDocument().createElement('BR');\n        node.parentNode.insertBefore(br, node.nextSibling);\n\n        const block = editor.getBlockElementAtNode(node);\n        let newContainer: HTMLElement;\n\n        if (block) {\n            newContainer = block.collapseToSingleElement();\n            br.parentNode?.removeChild(br);\n        }\n\n        editor.getSelectionRange().deleteContents();\n\n        if (newContainer.nextSibling) {\n            editor.select(newContainer.nextSibling, PositionType.Begin);\n        }\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromEnd\" when user\n * press BACKSPACE right after an entity\n */\nconst BackspaceAfterEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            false /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromEnd\n        );\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromStart\" when user\n * press DELETE right after an entity\n */\nconst DeleteBeforeEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.DELETE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            true /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromStart\n        );\n    },\n};\n\nfunction cacheGetNeighborEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    isNext: boolean,\n    collapseOnly: boolean,\n    operation?: EntityOperation\n): HTMLElement {\n    const element = cacheGetEventData(\n        event,\n        'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly,\n        () => {\n            const range = editor.getSelectionRange();\n\n            if (collapseOnly && !range.collapsed) {\n                return null;\n            }\n\n            const pos = Position.getEnd(range).normalize();\n            const isAtBeginOrEnd = pos.offset == 0 || pos.isAtEnd;\n            let entityNode: HTMLElement = null;\n\n            if (isAtBeginOrEnd) {\n                const traverser = editor.getBodyTraverser(pos.node);\n                const sibling = isNext\n                    ? pos.offset == 0\n                        ? traverser.currentInlineElement\n                        : traverser.getNextInlineElement()\n                    : pos.isAtEnd\n                    ? traverser.currentInlineElement\n                    : traverser.getPreviousInlineElement();\n                let node = sibling && sibling.getContainerNode();\n\n                if (!collapseOnly) {\n                    const block = editor.getBlockElementAtNode(pos.node);\n                    if (!block || !block.contains(node)) {\n                        node = null;\n                    }\n                }\n\n                entityNode = node && editor.getElementAtCursor(getEntitySelector(), node);\n            }\n\n            return entityNode;\n        }\n    );\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * @internal\n */\nexport const EntityFeatures: Record<\n    keyof EntityFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    clickOnEntity: ClickOnEntityFeature,\n    escapeFromEntity: EscapeFromEntityFeature,\n    enterBeforeReadonlyEntity: EnterBeforeReadonlyEntityFeature,\n    backspaceAfterEntity: BackspaceAfterEntityFeature,\n    deleteBeforeEntity: DeleteBeforeEntityFeature,\n};\n","import {\n    experimentCommitListChains,\n    setIndentation,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\nimport {\n    Browser,\n    getTagOfNode,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    Position,\n    VListChain,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Indentation,\n    ListFeatureSettings,\n    Keys,\n    NodeType,\n    PluginKeyboardEvent,\n    PositionType,\n    QueryScope,\n    RegionBase,\n} from 'roosterjs-editor-types';\n\n/**\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\n */\nconst IndentWhenTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Increase);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\n */\nconst OutdentWhenShiftTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Decrease);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\n * BACKSPACE at beginning of a list item\n */\nconst MergeInNewLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        let range = editor.getSelectionRange();\n        return li && range?.collapsed && isPositionAtBeginningOf(Position.getStart(range), li);\n    },\n    handleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        if (li.previousSibling) {\n            const chains = getListChains(editor);\n            editor.runAsync(editor => {\n                let br = editor.getDocument().createElement('BR');\n                editor.insertNode(br);\n                editor.select(br, PositionType.After);\n                experimentCommitListChains(editor, chains);\n            });\n        } else {\n            toggleListAndPreventDefault(event, editor);\n        }\n    },\n    defaultDisabled: true,\n};\n\n/**\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\n * BACKSPACE at the first and empty line of a list\n */\nconst OutdentWhenBackOn1stEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return li && isNodeEmpty(li) && !li.previousSibling;\n    },\n    handleEvent: toggleListAndPreventDefault,\n};\n\n/**\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\n * ENTER at the beginning of an empty line of a list\n */\nconst OutdentWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\n    },\n    handleEvent: (event, editor) => {\n        editor.addUndoSnapshot(\n            () => toggleListAndPreventDefault(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    },\n    defaultDisabled: !Browser.isIE && !Browser.isChrome,\n};\n\n/**\n * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.\n * When user input \"1. \", convert into a numbering list\n * When user input \"- \" or \"* \", convert into a bullet list\n */\nconst AutoBullet: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.SPACE],\n    shouldHandleEvent: (event, editor) => {\n        if (!cacheGetListElement(event, editor)) {\n            let searcher = editor.getContentSearcherOfCursor(event);\n            let textBeforeCursor = searcher.getSubStringBefore(4);\n\n            // Auto list is triggered if:\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\n            // 2. There's no non-text inline entities before cursor\n            return (\n                /^(\\*|-|[0-9]{1,2}\\.)$/.test(textBeforeCursor) &&\n                !searcher.getNearestNonTextInlineElement()\n            );\n        }\n        return false;\n    },\n    handleEvent: (event, editor) => {\n        editor.runAsync(editor => {\n            editor.addUndoSnapshot(\n                () => {\n                    let regions: RegionBase[];\n                    let searcher = editor.getContentSearcherOfCursor();\n                    let textBeforeCursor = searcher.getSubStringBefore(4);\n                    let rangeToDelete = searcher.getRangeFromText(\n                        textBeforeCursor,\n                        true /*exactMatch*/\n                    );\n\n                    if (!rangeToDelete) {\n                        // no op if the range can't be found\n                    } else if (\n                        textBeforeCursor.indexOf('*') == 0 ||\n                        textBeforeCursor.indexOf('-') == 0\n                    ) {\n                        prepareAutoBullet(editor, rangeToDelete);\n                        toggleBullet(editor);\n                    } else if (textBeforeCursor.indexOf('1.') == 0) {\n                        prepareAutoBullet(editor, rangeToDelete);\n                        toggleNumbering(editor);\n                    } else if ((regions = editor.getSelectedRegions()) && regions.length == 1) {\n                        const num = parseInt(textBeforeCursor);\n                        prepareAutoBullet(editor, rangeToDelete);\n                        toggleNumbering(editor, num);\n                    }\n                },\n                null /*changeSource*/,\n                true /*canUndoByBackspace*/\n            );\n        });\n    },\n};\n\n/**\n * Maintain the list numbers in list chain\n * e.g. we have two lists:\n * 1, 2, 3 and 4, 5, 6\n * Now we delete list item 2, so the first one becomes \"1, 2\".\n * This edit feature can maintain the list number of the second list to become \"3, 4, 5\"\n */\nconst MaintainListChain: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.TAB, Keys.DELETE, Keys.BACKSPACE, Keys.RANGE],\n    shouldHandleEvent: (event, editor) =>\n        editor.queryElements('li', QueryScope.OnSelection).length > 0,\n    handleEvent: (event, editor) => {\n        const chains = getListChains(editor);\n        editor.runAsync(editor => experimentCommitListChains(editor, chains));\n    },\n};\n\nfunction getListChains(editor: IEditor) {\n    return VListChain.createListChains(editor.getSelectedRegions());\n}\n\nfunction prepareAutoBullet(editor: IEditor, range: Range) {\n    range.deleteContents();\n    const node = range.startContainer;\n    if (node?.nodeType == NodeType.Text && node.nodeValue == '' && !node.nextSibling) {\n        const br = editor.getDocument().createElement('BR');\n        editor.insertNode(br);\n        editor.select(br, PositionType.Before);\n    }\n}\n\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: IEditor) {\n    let listInfo = cacheGetListElement(event, editor);\n    if (listInfo) {\n        let listElement = listInfo[0];\n        let tag = getTagOfNode(listElement);\n        if (tag == 'UL') {\n            toggleBullet(editor);\n        } else if (tag == 'OL') {\n            toggleNumbering(editor);\n        }\n        editor.focus();\n        event.rawEvent.preventDefault();\n    }\n}\n\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: IEditor) {\n    let li = editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event);\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\n    return listElement ? [listElement, li] : null;\n}\n\n/**\n * @internal\n */\nexport const ListFeatures: Record<\n    keyof ListFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoBullet: AutoBullet,\n    indentWhenTab: IndentWhenTab,\n    outdentWhenShiftTab: OutdentWhenShiftTab,\n    outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\n    outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\n    mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\n    maintainListChain: MaintainListChain,\n};\n","import { cacheGetEventData, createRange } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    ChangeSource,\n    IEditor,\n    Keys,\n    MarkdownFeatureSettings,\n    NodePosition,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nfunction generateBasicMarkdownFeature(\n    key: Keys,\n    triggerCharacter: string,\n    elementTag: string,\n    useShiftKey: boolean\n): BuildInEditFeature<PluginKeyboardEvent> {\n    return {\n        keys: [key],\n        shouldHandleEvent: (event, editor) =>\n            event.rawEvent.shiftKey === useShiftKey &&\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\n        handleEvent: (event, editor) => {\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\n            editor.runAsync(editor => {\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\n            });\n        },\n    };\n}\n\nfunction cacheGetRangeForMarkdownOperation(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string\n): Range {\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', () => {\n        const searcher = editor.getContentSearcherOfCursor(event);\n\n        let startPosition: NodePosition;\n        let endPosition: NodePosition;\n        searcher.forEachTextInlineElement(textInlineElement => {\n            if (endPosition && startPosition) {\n                return true;\n            }\n            const inlineTextContent = textInlineElement.getTextContent();\n\n            // special case for immediately preceeding character being whitespace\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\n                return false;\n            }\n\n            // special case for consecutive trigger characters\n            if (inlineTextContent[inlineTextContent.length - 1] === triggerCharacter) {\n                return false;\n            }\n\n            if (!endPosition) {\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\n            }\n            if (inlineTextContent[0] == triggerCharacter) {\n                startPosition = textInlineElement.getStartPosition();\n            } else {\n                let contentIndex = inlineTextContent.length - 1;\n                for (; contentIndex > 0; contentIndex--) {\n                    if (startPosition) {\n                        return true;\n                    }\n                    if (\n                        inlineTextContent[contentIndex] == triggerCharacter &&\n                        inlineTextContent[contentIndex - 1].trim().length == 0\n                    ) {\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\n                        return true;\n                    }\n                }\n            }\n        });\n        return !!startPosition && !!endPosition && createRange(startPosition, endPosition);\n    });\n}\n\nfunction handleMarkdownEvent(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string,\n    elementTag: string\n) {\n    editor.addUndoSnapshot(\n        () => {\n            const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\n            if (!!range) {\n                // get the text content range\n                const textContentRange = range.cloneRange();\n                textContentRange.setStart(\n                    textContentRange.startContainer,\n                    textContentRange.startOffset + 1\n                );\n\n                // set the removal range to include the typed last character.\n                range.setEnd(range.endContainer, range.endOffset + 1);\n\n                // extract content and put it into a new element.\n                const elementToWrap = editor.getDocument().createElement(elementTag);\n                elementToWrap.appendChild(textContentRange.extractContents());\n                range.deleteContents();\n\n                // ZWS here ensures we don't end up inside the newly created node.\n                const nonPrintedSpaceTextNode = editor\n                    .getDocument()\n                    .createTextNode(ZERO_WIDTH_SPACE);\n                range.insertNode(nonPrintedSpaceTextNode);\n                range.insertNode(elementToWrap);\n                editor.select(nonPrintedSpaceTextNode, PositionType.End);\n            }\n        },\n        ChangeSource.Format,\n        true /*canUndoByBackspace*/\n    );\n}\n\n/**\n * Markdown bold feature. Bolds text with markdown shortcuts.\n */\nconst MarkdownBold: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.EIGHT_ASTIRISK,\n    '*',\n    'b',\n    true\n);\n\n/**\n * Markdown italics feature. Italicises text with markdown shortcuts.\n */\nconst MarkdownItalic: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.DASH_UNDERSCORE,\n    '_',\n    'i',\n    true\n);\n\n/**\n * Markdown strikethru feature. Strikethrus text with markdown shortcuts.\n */\nconst MarkdownStrikethru: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '~',\n    's',\n    true\n);\n\n/**\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\n */\nconst MarkdownInlineCode: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '`',\n    'code',\n    false\n);\n\n/**\n * @internal\n */\nexport const MarkdownFeatures: Record<\n    keyof MarkdownFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    markdownBold: MarkdownBold,\n    markdownItalic: MarkdownItalic,\n    markdownStrikethru: MarkdownStrikethru,\n    markdownInlineCode: MarkdownInlineCode,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    QuoteFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    getTagOfNode,\n    isNodeEmpty,\n    splitBalancedNodeRange,\n    toArray,\n    unwrap,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst QUOTE_TAG = 'BLOCKQUOTE';\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\n\n/**\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenBackOnEmpty1stLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\n    },\n    handleEvent: splitQuote,\n};\n\n/**\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\n * user press ENTER on an empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let shift = event.rawEvent.shiftKey;\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\n    },\n    handleEvent: (event, editor) =>\n        editor.addUndoSnapshot(\n            () => splitQuote(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        ),\n};\n\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: IEditor): Node {\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\n            let pos = editor.getFocusedPosition();\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\n            if (block) {\n                let node =\n                    block.getStartNode() == quote\n                        ? block.getStartNode()\n                        : block.collapseToSingleElement();\n                return isNodeEmpty(node) ? node : null;\n            }\n        }\n\n        return null;\n    });\n}\n\nfunction splitQuote(event: PluginKeyboardEvent, editor: IEditor) {\n    editor.addUndoSnapshot(() => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let parent: Node;\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\n            childOfQuote = wrap(toArray(childOfQuote.childNodes));\n        }\n        parent = splitBalancedNodeRange(childOfQuote);\n        unwrap(parent);\n        editor.select(childOfQuote, PositionType.Begin);\n    });\n    event.rawEvent.preventDefault();\n}\n\n/**\n * @internal\n */\nexport const QuoteFeatures: Record<\n    keyof QuoteFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\n    unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\n};\n","import { Browser, cacheGetEventData } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    FontSizeChange,\n    IEditor,\n    Keys,\n    PluginEventType,\n    PluginKeyboardEvent,\n    ShortcutFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    changeFontSize,\n    toggleBold,\n    toggleItalic,\n    toggleUnderline,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\n\ninterface ShortcutCommand {\n    winKey: number;\n    macKey: number;\n    action: (editor: IEditor) => any;\n}\n\nfunction createCommand(winKey: number, macKey: number, action: (editor: IEditor) => any) {\n    return {\n        winKey,\n        macKey,\n        action,\n    };\n}\n\nconst commands: ShortcutCommand[] = [\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\n        editor => changeFontSize(editor, FontSizeChange.Increase)\n    ),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\n        Keys.Meta | Keys.Shift | Keys.COMMA,\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\n    ),\n];\n\n/**\n * DefaultShortcut edit feature, provides shortcuts for the following features:\n * Ctrl/Meta+B: toggle bold style\n * Ctrl/Meta+I: toggle italic style\n * Ctrl/Meta+U: toggle underline style\n * Ctrl/Meta+Z: undo\n * Ctrl+Y/Meta+Shift+Z: redo\n * Ctrl/Meta+PERIOD: toggle bullet list\n * Ctrl/Meta+/: toggle numbering list\n * Ctrl/Meta+Shift+>: increase font size\n * Ctrl/Meta+Shift+<: decrease font size\n */\nconst DefaultShortcut: BuildInEditFeature<PluginKeyboardEvent> = {\n    allowFunctionKeys: true,\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\n    shouldHandleEvent: cacheGetCommand,\n    handleEvent: (event, editor) => {\n        let command = cacheGetCommand(event);\n        if (command) {\n            command.action(editor);\n            event.rawEvent.preventDefault();\n            event.rawEvent.stopPropagation();\n        }\n    },\n};\n\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\n        let e = event.rawEvent;\n        let key =\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\n            event.eventType == PluginEventType.KeyDown && !e.altKey\n                ? e.which |\n                  (e.metaKey && Keys.Meta) |\n                  (e.shiftKey && Keys.Shift) |\n                  (e.ctrlKey && Keys.Ctrl)\n                : 0;\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\n    });\n}\n\n/**\n * @internal\n */\nexport const ShortcutFeatures: Record<\n    keyof ShortcutFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    defaultShortcut: DefaultShortcut,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    StructuredNodeFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    fromHtml,\n    isPositionAtBeginningOf,\n    Position,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n// Edge can sometimes lose current format when Enter to new line.\n// So here we add an extra SPAN for Edge to workaround this bug\nconst NEWLINE_HTML = Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\n    TD: 'TABLE',\n    TH: 'TABLE',\n    LI: 'OL,UL',\n};\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\n\n/**\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\n * document\n */\nconst InsertLineBeforeStructuredNodeFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: cacheGetStructuredElement,\n    handleEvent: (event, editor) => {\n        let element = cacheGetStructuredElement(event, editor);\n        let div = fromHtml(NEWLINE_HTML, editor.getDocument())[0] as HTMLElement;\n        editor.addUndoSnapshot(() => {\n            element.parentNode.insertBefore(div, element);\n            // Select the new line when we are in table. This is the same behavior with Word\n            if (getTagOfNode(element) == 'TABLE') {\n                editor.select(new Position(div, PositionType.Begin).normalize());\n            }\n        });\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: IEditor) {\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\n        // Provide a chance to keep browser default behavior by pressing SHIFT\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\n\n        if (element) {\n            let range = editor.getSelectionRange();\n            if (\n                range &&\n                range.collapsed &&\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\n            ) {\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\n            }\n        }\n\n        return null;\n    });\n}\n\n/**\n * @internal\n */\nexport const StructuredNodeFeatures: Record<\n    keyof StructuredNodeFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\n};\n","import { editTable } from 'roosterjs-editor-api';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    NodeType,\n    PluginEvent,\n    PositionType,\n    TableFeatureSettings,\n    TableOperation,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    contains,\n    getTagOfNode,\n    isVoidHtmlElement,\n    Position,\n    VTable,\n} from 'roosterjs-editor-dom';\n\n/**\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\n */\nconst TabInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        let shift = event.rawEvent.shiftKey;\n        let td = cacheGetTableCell(event, editor);\n        for (\n            let vtable = new VTable(td),\n                step = shift ? -1 : 1,\n                row = vtable.row,\n                col = vtable.col + step;\n            ;\n            col += step\n        ) {\n            if (col < 0 || col >= vtable.cells[row].length) {\n                row += step;\n                if (row < 0) {\n                    editor.select(vtable.table, PositionType.Before);\n                    break;\n                } else if (row >= vtable.cells.length) {\n                    editTable(editor, TableOperation.InsertBelow);\n                    break;\n                }\n                col = shift ? vtable.cells[row].length - 1 : 0;\n            }\n            let cell = vtable.getCell(row, col);\n            if (cell.td) {\n                editor.select(cell.td, PositionType.Begin);\n                break;\n            }\n        }\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\n * in table\n */\nconst UpDownInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.UP, Keys.DOWN],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        const td = cacheGetTableCell(event, editor);\n        const vtable = new VTable(td);\n        const isUp = event.rawEvent.which == Keys.UP;\n        const step = isUp ? -1 : 1;\n        const hasShiftKey = event.rawEvent.shiftKey;\n        const selection = editor.getDocument().defaultView?.getSelection();\n        let targetTd: HTMLTableCellElement = null;\n\n        if (selection) {\n            let { anchorNode, anchorOffset } = selection;\n\n            for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\n                let cell = vtable.getCell(row, vtable.col);\n                if (cell.td && cell.td != td) {\n                    targetTd = cell.td;\n                    break;\n                }\n            }\n\n            editor.runAsync(editor => {\n                let newContainer = editor.getElementAtCursor();\n                if (\n                    contains(vtable.table, newContainer) &&\n                    !contains(td, newContainer, true /*treatSameNodeAsContain*/)\n                ) {\n                    let newPos = targetTd\n                        ? new Position(targetTd, PositionType.Begin)\n                        : new Position(\n                              vtable.table,\n                              isUp ? PositionType.Before : PositionType.After\n                          );\n                    if (hasShiftKey) {\n                        newPos =\n                            newPos.node.nodeType == NodeType.Element &&\n                            isVoidHtmlElement(newPos.node)\n                                ? new Position(\n                                      newPos.node,\n                                      newPos.isAtEnd ? PositionType.After : PositionType.Before\n                                  )\n                                : newPos;\n                        const selection = editor.getDocument().defaultView?.getSelection();\n                        selection?.setBaseAndExtent(\n                            anchorNode,\n                            anchorOffset,\n                            newPos.node,\n                            newPos.offset\n                        );\n                    } else {\n                        editor.select(newPos);\n                    }\n                }\n            });\n        }\n    },\n    defaultDisabled: !Browser.isChrome && !Browser.isSafari,\n};\n\nfunction cacheGetTableCell(event: PluginEvent, editor: IEditor): HTMLTableCellElement {\n    return cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', () => {\n        let pos = editor.getFocusedPosition();\n        let firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);\n        return (\n            firstTd && (getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement))\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const TableFeatures: Record<\n    keyof TableFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    tabInTable: TabInTable,\n    upDownInTable: UpDownInTable,\n};\n","import { coreApiMap } from '../coreApi/coreApiMap';\r\nimport createCorePlugins, {\r\n    getPluginState,\r\n    PLACEHOLDER_PLUGIN_NAME,\r\n} from '../corePlugins/createCorePlugins';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    ColorTransformDirection,\r\n    ContentPosition,\r\n    CorePlugins,\r\n    DefaultFormat,\r\n    DOMEventHandler,\r\n    EditorCore,\r\n    EditorOptions,\r\n    EditorPlugin,\r\n    EditorUndoState,\r\n    ExperimentalFeatures,\r\n    GenericContentEditFeature,\r\n    GetContentMode,\r\n    IContentTraverser,\r\n    IEditor,\r\n    InsertOption,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    Region,\r\n    RegionType,\r\n    SelectionPath,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetEventData,\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    deleteSelectedContent,\r\n    getRegionsFromRange,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    getSelectionPath,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    safeInstanceOf,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    wrap,\r\n    isPositionAtBeginningOf,\r\n    arrayPush,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor implements IEditor {\r\n    private core: EditorCore;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        const corePlugins = createCorePlugins(contentDiv, options);\r\n        const plugins: EditorPlugin[] = [];\r\n        Object.keys(corePlugins).forEach(\r\n            (name: typeof PLACEHOLDER_PLUGIN_NAME | keyof CorePlugins) => {\r\n                if (name == PLACEHOLDER_PLUGIN_NAME) {\r\n                    arrayPush(plugins, options.plugins);\r\n                } else {\r\n                    plugins.push(corePlugins[name]);\r\n                }\r\n            }\r\n        );\r\n        this.core = {\r\n            contentDiv,\r\n            api: {\r\n                ...coreApiMap,\r\n                ...(options.coreApiOverride || {}),\r\n            },\r\n            plugins: plugins.filter(x => !!x),\r\n            ...getPluginState(corePlugins),\r\n        };\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure user will type in a container node, not the editor content DIV\r\n        this.ensureTypeInContainer(\r\n            new Position(this.core.contentDiv, PositionType.Begin).normalize()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.core.plugins.reverse().forEach(plugin => plugin.dispose());\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        return node ? this.core.api.insertNode(this.core, node, option) : false;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param toNode node to replace to\r\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(\r\n        existingNode: Node,\r\n        toNode: Node,\r\n        transformColorForDarkMode?: boolean\r\n    ): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (this.contains(existingNode) && toNode) {\r\n            this.core.api.transformColor(\r\n                this.core,\r\n                transformColorForDarkMode ? toNode : null,\r\n                true /*includeSelf*/,\r\n                () => existingNode.parentNode.replaceChild(toNode, existingNode),\r\n                ColorTransformDirection.LightToDark\r\n            );\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param mode specify what kind of HTML content to retrieve\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(mode: GetContentMode = GetContentMode.CleanHTML): string {\r\n        return this.core.api.getContent(this.core, mode);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        this.core.api.setContent(this.core, content, triggerContentChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            const doc = this.getDocument();\r\n            let allNodes = fromHtml(content, doc);\r\n\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n\r\n            let fragment = doc.createDocumentFragment();\r\n            allNodes.forEach(node => fragment.appendChild(node));\r\n\r\n            this.insertNode(fragment, option);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete selected content\r\n     */\r\n    public deleteSelectedContent(): NodePosition {\r\n        const range = this.getSelectionRange();\r\n        return range && !range.collapsed && deleteSelectedContent(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using a clipboardData object\r\n     * @param clipboardData Clipboard data retrieved from clipboard\r\n     * @param pasteAsText Force pasting as plain text. Default value is false\r\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\r\n     * false to keep original foramt.  Default value is false. When pasteAsText is true, this parameter is ignored\r\n     */\r\n    public paste(\r\n        clipboardData: ClipboardData,\r\n        pasteAsText?: boolean,\r\n        applyCurrentFormat?: boolean\r\n    ) {\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n\r\n        if (clipboardData.snapshotBeforePaste) {\r\n            // Restore original content before paste a new one\r\n            this.setContent(clipboardData.snapshotBeforePaste);\r\n        } else {\r\n            clipboardData.snapshotBeforePaste = this.getContent(\r\n                GetContentMode.RawHTMLWithSelection\r\n            );\r\n        }\r\n\r\n        const range = this.getSelectionRange();\r\n        const pos = range && Position.getStart(range);\r\n        const fragment = this.core.api.createPasteFragment(\r\n            this.core,\r\n            clipboardData,\r\n            pos,\r\n            pasteAsText,\r\n            applyCurrentFormat\r\n        );\r\n\r\n        this.addUndoSnapshot(() => {\r\n            this.insertNode(fragment);\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\r\n     * Default value is true\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(tryGetFromCache: boolean = true): Range {\r\n        return this.core.api.getSelectionRange(this.core, tryGetFromCache);\r\n    }\r\n\r\n    /**\r\n     * Get current selection in a serializable format\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection path, or null if editor never got focus before\r\n     */\r\n    public getSelectionPath(): SelectionPath {\r\n        const range = this.getSelectionRange();\r\n        return range && getSelectionPath(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = !arg1\r\n            ? null\r\n            : safeInstanceOf(arg1, 'Range')\r\n            ? arg1\r\n            : Array.isArray(arg1.start) && Array.isArray(arg1.end)\r\n            ? createRange(\r\n                  this.core.contentDiv,\r\n                  (<SelectionPath>arg1).start,\r\n                  (<SelectionPath>arg1).end\r\n              )\r\n            : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getDocument().defaultView?.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getElementAtCursor(\r\n        selector?: string,\r\n        startFrom?: Node,\r\n        event?: PluginEvent\r\n    ): HTMLElement {\r\n        event = startFrom ? null : event; // Only use cache when startFrom is not specified, for different start position can have different result\r\n\r\n        return cacheGetEventData(event, 'GET_ELEMENT_AT_CURSOR_' + selector, () => {\r\n            if (!startFrom) {\r\n                let position = this.getFocusedPosition();\r\n                startFrom = position && position.node;\r\n            }\r\n            return (\r\n                startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector)\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if this position is at beginning of the editor.\r\n     * This will return true if all nodes between the beginning of target node and the position are empty.\r\n     * @param position The position to check\r\n     * @returns True if position is at beginning of the editor, otherwise false\r\n     */\r\n    public isPositionAtBeginning(position: NodePosition): boolean {\r\n        return isPositionAtBeginningOf(position, this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Get impacted regions from selection\r\n     */\r\n    public getSelectedRegions(type: RegionType = RegionType.Table): Region[] {\r\n        const range = this.getSelectionRange();\r\n        return range ? getRegionsFromRange(this.core.contentDiv, range, type) : [];\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap: string | Record<string, DOMEventHandler>,\r\n        handler?: DOMEventHandler\r\n    ): () => void {\r\n        const eventsToMap = typeof nameOrMap == 'string' ? { [nameOrMap]: handler } : nameOrMap;\r\n        return this.core.api.attachDomEvent(this.core, eventsToMap);\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, -1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, 1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition) => any,\r\n        changeSource?: ChangeSource | string,\r\n        canUndoByBackspace?: boolean\r\n    ) {\r\n        this.core.api.addUndoSnapshot(this.core, callback, changeSource, canUndoByBackspace);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo/redo snapshot\r\n     */\r\n    getUndoState(): EditorUndoState {\r\n        const { hasNewContent, snapshotsService } = this.core.undo;\r\n        return {\r\n            canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),\r\n            canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),\r\n        };\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.contentDiv.ownerDocument;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.domEvent.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return (this.core.lifecycle.customData[key] = this.core.lifecycle.customData[key] || {\r\n            value: getter ? getter() : undefined,\r\n            disposer,\r\n        }).value as T;\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.domEvent.isInIME;\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.lifecycle.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): IContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getContentSearcherOfCursor(event?: PluginEvent): IPositionContentSearcher {\r\n        return cacheGetEventData(event, 'CONTENTSEARCHER', () => {\r\n            let range = this.getSelectionRange();\r\n            return (\r\n                range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range))\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: (editor: IEditor) => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback(this);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     */\r\n    public getEditorDomAttribute(name: string): string {\r\n        return this.core.contentDiv.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature.\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature?.keys.forEach(key => {\r\n            let array = this.core.edit.features[key] || [];\r\n            array.push(feature);\r\n            this.core.edit.features[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get style based format state from current selection, including font name/size and colors\r\n     */\r\n    public getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\r\n        if (!node) {\r\n            const range = this.getSelectionRange();\r\n            node = range && Position.getStart(range).normalize().node;\r\n        }\r\n        return this.core.api.getStyleBasedFormatState(this.core, node);\r\n    }\r\n\r\n    /**\r\n     * Ensure user will type into a container element rather than into the editor content DIV directly\r\n     * @param position The position that user is about to type to\r\n     * @param keyboardEvent Optional keyboard event object\r\n     */\r\n    public ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent) {\r\n        this.core.api.ensureTypeInContainer(this.core, position, keyboardEvent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(GetContentMode.CleanHTML);\r\n\r\n        this.triggerContentChangedEvent(\r\n            nextDarkMode ? ChangeSource.SwitchToDarkMode : ChangeSource.SwitchToLightMode\r\n        );\r\n        this.setContent(currentContent);\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.lifecycle.isDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Make the editor in \"Shadow Edit\" mode.\r\n     * In Shadow Edit mode, all format change will finally be ignored.\r\n     * This can be used for building a live preview feature for format button, to allow user\r\n     * see format result without really apply it.\r\n     * This function can be called repeatly. If editor is already in shadow edit mode, we can still\r\n     * use this function to do more shadow edit operation.\r\n     */\r\n    public startShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, true /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\r\n     */\r\n    public stopShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, false /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in Shadow Edit mode\r\n     */\r\n    public isInShadowEdit() {\r\n        return !!this.core.lifecycle.shadowEditFragment;\r\n    }\r\n\r\n    /**\r\n     * Check if the given experimental feature is enabled\r\n     * @param feature The feature to check\r\n     */\r\n    public isFeatureEnabled(feature: ExperimentalFeatures): boolean {\r\n        return this.core.lifecycle.experimentalFeatures.indexOf(feature) >= 0;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { addUndoSnapshot } from './addUndoSnapshot';\nimport { attachDomEvent } from './attachDomEvent';\nimport { CoreApiMap } from 'roosterjs-editor-types';\nimport { createPasteFragment } from './createPasteFragment';\nimport { ensureTypeInContainer } from './ensureTypeInContainer';\nimport { focus } from './focus';\nimport { getContent } from './getContent';\nimport { getSelectionRange } from './getSelectionRange';\nimport { getStyleBasedFormatState } from './getStyleBasedFormatState';\nimport { hasFocus } from './hasFocus';\nimport { insertNode } from './insertNode';\nimport { restoreUndoSnapshot } from './restoreUndoSnapshot';\nimport { selectRange } from './selectRange';\nimport { setContent } from './setContent';\nimport { switchShadowEdit } from './switchShadowEdit';\nimport { transformColor } from './transformColor';\nimport { triggerEvent } from './triggerEvent';\n\n/**\n * @internal\n */\nexport const coreApiMap: CoreApiMap = {\n    attachDomEvent,\n    addUndoSnapshot,\n    createPasteFragment,\n    ensureTypeInContainer,\n    focus,\n    getContent,\n    getSelectionRange,\n    getStyleBasedFormatState,\n    hasFocus,\n    insertNode,\n    restoreUndoSnapshot,\n    selectRange,\n    setContent,\n    switchShadowEdit,\n    transformColor,\n    triggerEvent,\n};\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    AddUndoSnapshot,\n    ChangeSource,\n    ContentChangedEvent,\n    EditorCore,\n    NodePosition,\n    PluginEventType,\n    GetContentMode,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\n * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.\n * @param core The EditorCore object\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\n * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\n */\nexport const addUndoSnapshot: AddUndoSnapshot = (\n    core: EditorCore,\n    callback: (start: NodePosition, end: NodePosition) => any,\n    changeSource: ChangeSource | string,\n    canUndoByBackspace: boolean\n) => {\n    const undoState = core.undo;\n    const isNested = undoState.isNested;\n    const isShadowEdit = !!core.lifecycle.shadowEditFragment;\n    let data: any;\n\n    if (!isNested) {\n        undoState.isNested = true;\n\n        if (!isShadowEdit) {\n            undoState.snapshotsService.addSnapshot(\n                core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                canUndoByBackspace\n            );\n            undoState.hasNewContent = false;\n        }\n    }\n\n    try {\n        if (callback) {\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            data = callback(\n                range && Position.getStart(range).normalize(),\n                range && Position.getEnd(range).normalize()\n            );\n\n            if (!isNested && !isShadowEdit) {\n                undoState.snapshotsService.addSnapshot(\n                    core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                    false /*isAutoCompleteSnapshot*/\n                );\n                undoState.hasNewContent = false;\n            }\n        }\n    } finally {\n        if (!isNested) {\n            undoState.isNested = false;\n        }\n    }\n\n    if (callback && changeSource) {\n        let event: ContentChangedEvent = {\n            eventType: PluginEventType.ContentChanged,\n            source: changeSource,\n            data: data,\n        };\n        core.api.triggerEvent(core, event, true /*broadcast*/);\n    }\n\n    if (canUndoByBackspace) {\n        const range = core.api.getSelectionRange(core, false /*tryGetFromCache*/);\n\n        if (range) {\n            core.undo.hasNewContent = false;\n            core.undo.autoCompletePosition = Position.getStart(range);\n        }\n    }\n};\n","import {\n    AttachDomEvent,\n    DOMEventHandler,\n    DOMEventHandlerObject,\n    EditorCore,\n    PluginDomEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Attach a DOM event to the editor content DIV\n * @param core The EditorCore object\n * @param eventName The DOM event name\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\n */\nexport const attachDomEvent: AttachDomEvent = (\n    core: EditorCore,\n    eventMap: Record<string, DOMEventHandler>\n) => {\n    const disposers = Object.keys(eventMap || {}).map(eventName => {\n        const { pluginEventType, beforeDispatch } = extractHandler(eventMap[eventName]);\n        let onEvent = (event: UIEvent) => {\n            if (beforeDispatch) {\n                beforeDispatch(event);\n            }\n            if (pluginEventType != null) {\n                core.api.triggerEvent(\n                    core,\n                    <PluginDomEvent>{\n                        eventType: pluginEventType,\n                        rawEvent: event,\n                    },\n                    false /*broadcast*/\n                );\n            }\n        };\n        core.contentDiv.addEventListener(eventName, onEvent);\n        return () => {\n            core.contentDiv.removeEventListener(eventName, onEvent);\n        };\n    });\n    return () => disposers.forEach(disposers => disposers());\n};\n\nfunction extractHandler(handlerObj: DOMEventHandler): DOMEventHandlerObject {\n    let result: DOMEventHandlerObject = {\n        pluginEventType: null,\n        beforeDispatch: null,\n    };\n\n    if (typeof handlerObj === 'number') {\n        result.pluginEventType = handlerObj;\n    } else if (typeof handlerObj === 'function') {\n        result.beforeDispatch = handlerObj;\n    } else if (typeof handlerObj === 'object') {\n        result = handlerObj;\n    }\n    return result;\n}\n","import {\n    applyFormat,\n    applyTextStyle,\n    createDefaultHtmlSanitizerOptions,\n    getInheritableStyles,\n    getPendableFormatState,\n    HtmlSanitizer,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    BeforePasteEvent,\n    ClipboardData,\n    CreatePasteFragment,\n    EditorCore,\n    PluginEventType,\n    DefaultFormat,\n    NodePosition,\n} from 'roosterjs-editor-types';\n\nconst START_FRAGMENT = '<!--StartFragment-->';\nconst END_FRAGMENT = '<!--EndFragment-->';\nconst NBSP_HTML = '\\u00A0';\n\n/**\n * @internal\n * Create a DocumentFragment for paste from a ClipboardData\n * @param core The EditorCore object.\n * @param clipboardData Clipboard data retrieved from clipboard\n * @param position The position to paste to\n * @param pasteAsText True to force use plain text as the content to paste, false to choose HTML or Image if any\n * @param applyCurrentStyle True if apply format of current selection to the pasted content,\n * false to keep original foramt\n */\nexport const createPasteFragment: CreatePasteFragment = (\n    core: EditorCore,\n    clipboardData: ClipboardData,\n    position: NodePosition,\n    pasteAsText: boolean,\n    applyCurrentStyle: boolean\n) => {\n    if (!clipboardData) {\n        return null;\n    }\n\n    // Step 1: Prepare BeforePasteEvent object\n    const event = createBeforePasteEvent(core, clipboardData);\n    const { fragment, sanitizingOption } = event;\n    const { rawHtml, text, imageDataUri } = clipboardData;\n    const document = core.contentDiv.ownerDocument;\n    let doc: HTMLDocument;\n\n    // Step 2: Fill the BeforePasteEvent object, especially the fragment for paste\n    if (!pasteAsText && !text && imageDataUri) {\n        // Paste image\n        const img = document.createElement('img');\n        img.style.maxWidth = '100%';\n        img.src = imageDataUri;\n        fragment.appendChild(img);\n    } else if (\n        !pasteAsText &&\n        rawHtml &&\n        (doc = new DOMParser().parseFromString(rawHtml, 'text/html'))?.body\n    ) {\n        // Paste HTML\n        const attributes = doc.querySelector('html')?.attributes;\n        (attributes ? toArray(attributes) : []).reduce((attrs, attr) => {\n            attrs[attr.name] = attr.value;\n            return attrs;\n        }, event.htmlAttributes);\n        toArray(doc.querySelectorAll('meta')).reduce((attrs, meta) => {\n            attrs[meta.name] = meta.content;\n            return attrs;\n        }, event.htmlAttributes);\n\n        // Move all STYLE nodes into header, and save them into sanitizing options.\n        // Because if we directly move them into a fragment, all sheets under STYLE will be lost.\n        processStyles(doc, style => {\n            doc.head.appendChild(style);\n            sanitizingOption.additionalGlobalStyleNodes.push(style);\n        });\n\n        const startIndex = rawHtml.indexOf(START_FRAGMENT);\n        const endIndex = rawHtml.lastIndexOf(END_FRAGMENT);\n\n        if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\n            event.htmlBefore = rawHtml.substr(0, startIndex);\n            event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);\n            doc.body.innerHTML = clipboardData.html = rawHtml.substring(\n                startIndex + START_FRAGMENT.length,\n                endIndex\n            );\n\n            // Remove style nodes just added by setting innerHTML of body since we already have all\n            // style nodes in header.\n            // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY\n            // and the nodes under HEAD are still used when convert global CSS to inline\n            processStyles(doc.body, style => style.parentNode?.removeChild(style));\n        }\n\n        while (doc.body.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n\n        if (applyCurrentStyle && position) {\n            const format = getCurrentFormat(core, position.node);\n            applyTextStyle(fragment, node => applyFormat(node, format));\n        }\n    } else if (text) {\n        // Paste text\n        text.split('\\n').forEach((line, index, lines) => {\n            line = line\n                .replace(/^ /g, NBSP_HTML)\n                .replace(/\\r/g, '')\n                .replace(/ {2}/g, ' ' + NBSP_HTML);\n            const textNode = document.createTextNode(line);\n\n            // There are 3 scenarios:\n            // 1. Single line: Paste as it is\n            // 2. Two lines: Add <br> between the lines\n            // 3. 3 or More lines, For first and last line, paste as it is. For middle lines, wrap with DIV, and add BR if it is empty line\n            if (lines.length == 2 && index == 0) {\n                // 1 of 2 lines scenario, add BR\n                fragment.appendChild(textNode);\n                fragment.appendChild(document.createElement('br'));\n            } else if (index > 0 && index < lines.length - 1) {\n                // Middle line of >=3 lines scenario, wrap with DIV\n                fragment.appendChild(wrap(line == '' ? document.createElement('br') : textNode));\n            } else {\n                // All others, paste as it is\n                fragment.appendChild(textNode);\n            }\n        });\n    }\n\n    // Step 3: Trigger BeforePasteEvent so that plugins can do proper change before paste\n    core.api.triggerEvent(core, event, true /*broadcast*/);\n\n    // Step 4. Sanitize the fragment before paste to make sure the content is safe\n    const sanitizer = new HtmlSanitizer(event.sanitizingOption);\n\n    sanitizer.convertGlobalCssToInlineCss(fragment);\n    sanitizer.sanitize(fragment, position && getInheritableStyles(position.element));\n\n    return fragment;\n};\n\nfunction getCurrentFormat(core: EditorCore, node: Node): DefaultFormat {\n    const pendableFormat = getPendableFormatState(core.contentDiv.ownerDocument);\n    const styleBasedForamt = core.api.getStyleBasedFormatState(core, node);\n    return {\n        fontFamily: styleBasedForamt.fontName,\n        fontSize: styleBasedForamt.fontSize,\n        textColor: styleBasedForamt.textColor,\n        backgroundColor: styleBasedForamt.backgroundColor,\n        textColors: styleBasedForamt.textColors,\n        backgroundColors: styleBasedForamt.backgroundColors,\n        bold: pendableFormat.isBold,\n        italic: pendableFormat.isItalic,\n        underline: pendableFormat.isUnderline,\n    };\n}\n\nfunction createBeforePasteEvent(core: EditorCore, clipboardData: ClipboardData): BeforePasteEvent {\n    return {\n        eventType: PluginEventType.BeforePaste,\n        clipboardData,\n        fragment: core.contentDiv.ownerDocument.createDocumentFragment(),\n        sanitizingOption: createDefaultHtmlSanitizerOptions(),\n        htmlBefore: '',\n        htmlAfter: '',\n        htmlAttributes: {},\n    };\n}\n\nfunction processStyles(node: ParentNode, callback: (style: HTMLStyleElement) => void) {\n    toArray(node.querySelectorAll('style')).forEach(callback);\n}\n","import {\n    ContentPosition,\n    EditorCore,\n    EnsureTypeInContainer,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport {\n    applyFormat,\n    Browser,\n    createRange,\n    fromHtml,\n    getBlockElementAtNode,\n    isNodeEmpty,\n    Position,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * When typing goes directly under content div, many things can go wrong\n * We fix it by wrapping it with a div and reposition cursor within the div\n */\nexport const ensureTypeInContainer: EnsureTypeInContainer = (\n    core: EditorCore,\n    position: NodePosition,\n    keyboardEvent?: KeyboardEvent\n) => {\n    position = position.normalize();\n    const block = getBlockElementAtNode(core.contentDiv, position.node);\n    let formatNode: HTMLElement;\n\n    if (block) {\n        formatNode = block.collapseToSingleElement();\n\n        // if the block is empty, apply default format\n        // Otherwise, leave it as it is as we don't want to change the style for existing data\n        // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\n        const shouldSetNodeStyles =\n            isNodeEmpty(formatNode) ||\n            (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));\n        formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\n    } else {\n        // Only reason we don't get the selection block is that we have an empty content div\n        // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\n        // The fix is to add a DIV wrapping, apply default format and move cursor over\n        formatNode = fromHtml(\n            Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\n            core.contentDiv.ownerDocument\n        )[0] as HTMLElement;\n        core.api.insertNode(core, formatNode, {\n            position: ContentPosition.End,\n            updateCursor: false,\n            replaceSelection: false,\n            insertOnNewLine: false,\n        });\n\n        // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\n        position = new Position(formatNode.firstChild, PositionType.Begin);\n    }\n\n    if (formatNode) {\n        applyFormat(formatNode, core.lifecycle.defaultFormat, core.lifecycle.isDarkMode);\n    }\n\n    // If this is triggered by a keyboard event, let's select the new position\n    if (keyboardEvent) {\n        core.api.selectRange(core, createRange(position));\n    }\n};\n\nfunction wasNodeJustCreatedByKeyboardEvent(event: KeyboardEvent, formatNode: HTMLElement) {\n    return (\n        safeInstanceOf(event.target, 'Node') &&\n        event.target.contains(formatNode) &&\n        event.key === formatNode.innerText\n    );\n}\n","import { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\nimport { EditorCore, Focus, PositionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Focus to editor. If there is a cached selection range, use it as current selection\n * @param core The EditorCore object\n */\nexport const focus: Focus = (core: EditorCore) => {\n    if (!core.lifecycle.shadowEditFragment) {\n        if (\n            !core.api.hasFocus(core) ||\n            !core.api.getSelectionRange(core, false /*tryGetFromCache*/)\n        ) {\n            // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\n            // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\n            // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\n            // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\n            // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\n            // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\n            // It should be better than the case you cannot type\n            if (\n                !core.domEvent.selectionRange ||\n                !core.api.selectRange(core, core.domEvent.selectionRange, true /*skipSameRange*/)\n            ) {\n                let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\n                core.api.selectRange(\n                    core,\n                    createRange(node, PositionType.Begin),\n                    true /*skipSameRange*/\n                );\n            }\n        }\n\n        // remember to clear cached selection range\n        core.domEvent.selectionRange = null;\n\n        // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\n        if (!core.api.hasFocus(core)) {\n            core.contentDiv.focus();\n        }\n    }\n};\n","import {\n    ColorTransformDirection,\n    EditorCore,\n    GetContent,\n    GetContentMode,\n    PluginEventType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getHtmlWithSelectionPath,\n    getSelectionPath,\n    getTextContent,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Get current editor content as HTML string\n * @param core The EditorCore object\n * @param mode specify what kind of HTML content to retrieve\n * @returns HTML string representing current editor content\n */\nexport const getContent: GetContent = (core: EditorCore, mode: GetContentMode): string => {\n    let content = '';\n    const triggerExtractContentEvent = mode == GetContentMode.CleanHTML;\n    const includeSelectionMarker = mode == GetContentMode.RawHTMLWithSelection;\n\n    // When there is fragment for shadow edit, always use the cached fragment as document since HTML node in editor\n    // has been changed by uncommited shadow edit which should be ignored.\n    const root = core.lifecycle.shadowEditFragment || core.contentDiv;\n\n    if (mode == GetContentMode.PlainText) {\n        content = getTextContent(root);\n    } else if (triggerExtractContentEvent || core.lifecycle.isDarkMode) {\n        const clonedRoot = cloneNode(root);\n        const originalRange = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n        const path = !includeSelectionMarker\n            ? null\n            : core.lifecycle.shadowEditFragment\n            ? core.lifecycle.shadowEditSelectionPath\n            : originalRange\n            ? getSelectionPath(core.contentDiv, originalRange)\n            : null;\n        const range = path && createRange(clonedRoot, path.start, path.end);\n\n        if (core.lifecycle.isDarkMode) {\n            core.api.transformColor(\n                core,\n                clonedRoot,\n                false /*includeSelf*/,\n                null /*callback*/,\n                ColorTransformDirection.DarkToLight\n            );\n        }\n\n        if (triggerExtractContentEvent) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.ExtractContentWithDom,\n                    clonedRoot,\n                },\n                true /*broadcast*/\n            );\n\n            content = clonedRoot.innerHTML;\n        } else if (range) {\n            // range is not null, which means we want to include a selection path in the content\n            content = getHtmlWithSelectionPath(clonedRoot, range);\n        } else {\n            content = clonedRoot.innerHTML;\n        }\n    } else {\n        content = getHtmlWithSelectionPath(\n            root,\n            includeSelectionMarker && core.api.getSelectionRange(core, true /*tryGetFromCache*/)\n        );\n    }\n\n    return content;\n};\n\nfunction cloneNode(node: HTMLElement | DocumentFragment): HTMLElement {\n    let clonedNode: HTMLElement;\n    if (safeInstanceOf(node, 'DocumentFragment')) {\n        clonedNode = node.ownerDocument.createElement('div');\n        clonedNode.appendChild(node.cloneNode(true /*deep*/));\n    } else {\n        clonedNode = node.cloneNode(true /*deep*/) as HTMLElement;\n    }\n\n    return clonedNode;\n}\n","import { contains, createRange } from 'roosterjs-editor-dom';\nimport { EditorCore, GetSelectionRange } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get current or cached selection range\n * @param core The EditorCore object\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\n * @returns A Range object of the selection range\n */\nexport const getSelectionRange: GetSelectionRange = (\n    core: EditorCore,\n    tryGetFromCache: boolean\n) => {\n    let result: Range = null;\n\n    if (core.lifecycle.shadowEditFragment) {\n        result =\n            core.lifecycle.shadowEditSelectionPath &&\n            createRange(\n                core.contentDiv,\n                core.lifecycle.shadowEditSelectionPath.start,\n                core.lifecycle.shadowEditSelectionPath.end\n            );\n\n        return result;\n    } else {\n        if (!tryGetFromCache || core.api.hasFocus(core)) {\n            let selection = core.contentDiv.ownerDocument.defaultView?.getSelection();\n            if (selection && selection.rangeCount > 0) {\n                let range = selection.getRangeAt(0);\n                if (contains(core.contentDiv, range)) {\n                    result = range;\n                }\n            }\n        }\n\n        if (!result && tryGetFromCache) {\n            result = core.domEvent.selectionRange;\n        }\n\n        return result;\n    }\n};\n","import { DarkModeDatasetNames, EditorCore, GetStyleBasedFormatState } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, getComputedStyles } from 'roosterjs-editor-dom';\n\nconst ORIGINAL_STYLE_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleColor}],[data-${DarkModeDatasetNames.OriginalAttributeColor}]`;\nconst ORIGINAL_STYLE_BACK_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleBackgroundColor}],[data-${DarkModeDatasetNames.OriginalAttributeBackgroundColor}]`;\n\n/**\n * @internal\n * Get style based format state from current selection, including font name/size and colors\n * @param core The EditorCore objects\n * @param node The node to get style from\n */\nexport const getStyleBasedFormatState: GetStyleBasedFormatState = (\n    core: EditorCore,\n    node: Node\n) => {\n    if (!node) {\n        return {};\n    }\n    const styles = node ? getComputedStyles(node) : [];\n    const isDarkMode = core.lifecycle.isDarkMode;\n    const root = core.contentDiv;\n    const ogTextColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_COLOR_SELECTOR);\n    const ogBackgroundColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_BACK_COLOR_SELECTOR);\n\n    return {\n        fontName: styles[0],\n        fontSize: styles[1],\n        textColor: styles[2],\n        backgroundColor: styles[3],\n        textColors: ogTextColorNode\n            ? {\n                  darkModeColor: styles[2],\n                  lightModeColor:\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalStyleColor] ||\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalAttributeColor],\n              }\n            : undefined,\n        backgroundColors: ogBackgroundColorNode\n            ? {\n                  darkModeColor: styles[3],\n                  lightModeColor:\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalStyleBackgroundColor\n                      ] ||\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalAttributeBackgroundColor\n                      ],\n              }\n            : undefined,\n    };\n};\n","import {\n    BlockElement,\n    ContentPosition,\n    ColorTransformDirection,\n    EditorCore,\n    InsertNode,\n    InsertOption,\n    NodeType,\n    NodePosition,\n    PositionType,\n    QueryScope,\n} from 'roosterjs-editor-types';\nimport {\n    changeElementTag,\n    contains,\n    createRange,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    getFirstLastBlockElement,\n    getTagOfNode,\n    isBlockElement,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    isVoidHtmlElement,\n    Position,\n    queryElements,\n    safeInstanceOf,\n    splitBalancedNodeRange,\n    splitTextNode,\n    toArray,\n    unwrap,\n    VTable,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst adjustSteps: ((\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n) => NodePosition)[] = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];\n\nfunction getInitialRange(\n    core: EditorCore,\n    option: InsertOption\n): { range: Range; rangeToRestore: Range } {\n    // Selection start replaces based on the current selection.\n    // Range inserts based on a provided range.\n    // Both have the potential to use the current selection to restore cursor position\n    // So in both cases we need to store the selection state.\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n    let rangeToRestore = null;\n    if (option.position == ContentPosition.Range) {\n        rangeToRestore = range;\n        range = option.range;\n    } else if (range) {\n        rangeToRestore = range.cloneRange();\n    }\n\n    return { range, rangeToRestore };\n}\n\n/**\n * @internal\n * Insert a DOM node into editor content\n * @param core The EditorCore object. No op if null.\n * @param option An insert option object to specify how to insert the node\n */\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\n    option = option || {\n        position: ContentPosition.SelectionStart,\n        insertOnNewLine: false,\n        updateCursor: true,\n        replaceSelection: true,\n    };\n    let contentDiv = core.contentDiv;\n\n    if (option.updateCursor) {\n        core.api.focus(core);\n    }\n\n    if (option.position == ContentPosition.Outside) {\n        contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\n        return true;\n    }\n\n    core.api.transformColor(\n        core,\n        node,\n        true /*includeSelf*/,\n        () => {\n            switch (option.position) {\n                case ContentPosition.Begin:\n                case ContentPosition.End: {\n                    let isBegin = option.position == ContentPosition.Begin;\n                    let block = getFirstLastBlockElement(contentDiv, isBegin);\n                    let insertedNode: Node | Node[];\n                    if (block) {\n                        let refNode = isBegin ? block.getStartNode() : block.getEndNode();\n                        if (\n                            option.insertOnNewLine ||\n                            refNode.nodeType == NodeType.Text ||\n                            isVoidHtmlElement(refNode)\n                        ) {\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\n                                // because insertBefore() returns an empty DocumentFragment\n                                insertedNode = toArray(node.childNodes);\n                                refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            } else {\n                                insertedNode = refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            }\n                        } else {\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\n                            insertedNode = refNode.insertBefore(\n                                node,\n                                isBegin ? refNode.firstChild : null\n                            );\n                        }\n                    } else {\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\n                        insertedNode = contentDiv.appendChild(node);\n                    }\n\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine) {\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\n                            wrap(nodes);\n                        }\n                    }\n\n                    break;\n                }\n                case ContentPosition.DomEnd:\n                    // Use appendChild to insert the node at the end of the content div.\n                    let insertedNode = contentDiv.appendChild(node);\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\n                        wrap(insertedNode);\n                    }\n                    break;\n                case ContentPosition.Range:\n                case ContentPosition.SelectionStart:\n                    let { range, rangeToRestore } = getInitialRange(core, option);\n\n                    if (!range) {\n                        return;\n                    }\n\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\n                    if (option.replaceSelection && !range.collapsed) {\n                        range.deleteContents();\n                    }\n\n                    let pos = Position.getStart(range);\n                    let blockElement: BlockElement;\n\n                    if (\n                        option.insertOnNewLine &&\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\n                    ) {\n                        pos = new Position(blockElement.getEndNode(), PositionType.After);\n                    } else {\n                        adjustSteps.forEach(handler => {\n                            pos = handler(contentDiv, node, pos);\n                        });\n                    }\n\n                    let nodeForCursor =\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\n                    range = createRange(pos);\n                    range.insertNode(node);\n                    if (option.updateCursor && nodeForCursor) {\n                        rangeToRestore = createRange(\n                            new Position(nodeForCursor, PositionType.After).normalize()\n                        );\n                    }\n                    core.api.selectRange(core, rangeToRestore);\n\n                    break;\n            }\n        },\n        ColorTransformDirection.LightToDark\n    );\n\n    return true;\n};\n\nfunction handleHyperLink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    let blockElement = getBlockElementAtNode(root, position.node);\n\n    if (blockElement) {\n        // Find the first <A> tag within current block which covers current selection\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\n        let anchor = queryElements(\n            root,\n            'a[href]',\n            null /*forEachCallback*/,\n            QueryScope.OnSelection,\n            createRange(position)\n        ).filter(a => blockElement.contains(a))[0];\n\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\n        if (anchor && isNodeEmpty(anchor)) {\n            position = new Position(anchor, PositionType.Before);\n            safeRemove(anchor);\n            anchor = null;\n        }\n\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\n        // otherwise we will have nested A tags which is a wrong HTML structure\n        if (\n            anchor &&\n            (<ParentNode>(<any>nodeToInsert)).querySelector &&\n            (<ParentNode>(<any>nodeToInsert)).querySelector('a[href]')\n        ) {\n            let normalizedPosition = position.normalize();\n            let parentNode = normalizedPosition.node.parentNode;\n            let nextNode =\n                normalizedPosition.node.nodeType == NodeType.Text\n                    ? splitTextNode(\n                          <Text>normalizedPosition.node,\n                          normalizedPosition.offset,\n                          false /*returnFirstPart*/\n                      )\n                    : normalizedPosition.isAtEnd\n                    ? normalizedPosition.node.nextSibling\n                    : normalizedPosition.node;\n            let splitter: Node = root.ownerDocument.createTextNode('');\n            parentNode.insertBefore(splitter, nextNode);\n\n            while (contains(anchor, splitter)) {\n                splitter = splitBalancedNodeRange(splitter);\n            }\n\n            position = new Position(splitter, PositionType.Before);\n            safeRemove(splitter);\n        }\n    }\n\n    return position;\n}\n\nfunction handleStructuredNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    let rootNodeToInsert = nodeToInsert;\n\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\n        let rootNodes = toArray(rootNodeToInsert.childNodes).filter(n => getTagOfNode(n) != 'BR');\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\n    }\n\n    let tag = getTagOfNode(rootNodeToInsert);\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\n\n    if (tag == 'LI') {\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\n    }\n\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\n\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\n            safeRemove(rootNodeToInsert.nextSibling);\n        }\n\n        if (shouldInsertListAsText) {\n            unwrap(rootNodeToInsert.firstChild);\n            unwrap(rootNodeToInsert);\n        } else if (getTagOfNode(listNode) == tag) {\n            unwrap(rootNodeToInsert);\n            position = new Position(\n                listItem,\n                isPositionAtBeginningOf(position, listItem)\n                    ? PositionType.Before\n                    : PositionType.After\n            );\n        }\n    } else if (tag == 'TABLE' && trNode) {\n        // When inserting a table into a table, if these tables have the same column count, and\n        // current position is at beginning of a row, then merge these two tables\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\n        if (\n            currentTable.col == 0 &&\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\n            newTable.cells[0] &&\n            newTable.cells[0].length == currentTable.cells[0].length &&\n            isPositionAtBeginningOf(position, tdNode)\n        ) {\n            if (\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\n                !rootNodeToInsert.firstChild.nextSibling\n            ) {\n                unwrap(rootNodeToInsert.firstChild);\n            }\n            unwrap(rootNodeToInsert);\n            position = new Position(trNode, PositionType.After);\n        }\n    }\n\n    return position;\n}\n\nfunction handleParagraph(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    if (getTagOfNode(position.node) == 'P') {\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\n        // Change P tag to DIV to make sure it works well\n        let pos = position.normalize();\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\n        if (pos.node != div) {\n            position = pos;\n        }\n    }\n\n    return position;\n}\n\nfunction handleVoidElement(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    if (isVoidHtmlElement(position.node)) {\n        position = new Position(\n            position.node,\n            position.isAtEnd ? PositionType.After : PositionType.Before\n        );\n    }\n\n    return position;\n}\n\nfunction safeRemove(node: Node) {\n    node?.parentNode?.removeChild(node);\n}\n","import { EditorCore, RestoreUndoSnapshot } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Restore an undo snapshot into editor\n * @param core The editor core object\n * @param step Steps to move, can be 0, positive or negative\n */\nexport const restoreUndoSnapshot: RestoreUndoSnapshot = (core: EditorCore, step: number) => {\n    if (core.undo.hasNewContent && step < 0) {\n        core.api.addUndoSnapshot(\n            core,\n            null /*callback*/,\n            null /*changeSource*/,\n            false /*canUndoByBackspace*/\n        );\n    }\n\n    const snapshot = core.undo.snapshotsService.move(step);\n\n    if (snapshot != null) {\n        try {\n            core.undo.isRestoring = true;\n            core.api.setContent(core, snapshot, true /*triggerContentChangedEvent*/);\n        } finally {\n            core.undo.isRestoring = false;\n        }\n    }\n};\n","import { EditorCore, SelectRange } from 'roosterjs-editor-types';\nimport { hasFocus } from './hasFocus';\nimport {\n    contains,\n    getPendableFormatState,\n    Position,\n    PendableFormatNames,\n    PendableFormatCommandMap,\n    addRangeToSelection,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Change the editor selection to the given range\n * @param core The EditorCore object\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\n * in editor, otherwise it will always remove current selection ranage and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport const selectRange: SelectRange = (\n    core: EditorCore,\n    range: Range,\n    skipSameRange?: boolean\n) => {\n    if (!core.lifecycle.shadowEditSelectionPath && contains(core.contentDiv, range)) {\n        addRangeToSelection(range, skipSameRange);\n\n        if (!hasFocus(core)) {\n            core.domEvent.selectionRange = range;\n        }\n\n        if (range.collapsed) {\n            // If selected, and current selection is collapsed,\n            // need to restore pending format state if exists.\n            restorePendingFormatState(core);\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n};\n\n/**\n * Restore cached pending format state (if exist) to current selection\n */\nfunction restorePendingFormatState(core: EditorCore) {\n    const {\n        contentDiv,\n        pendingFormatState,\n        api: { getSelectionRange },\n    } = core;\n\n    if (pendingFormatState.pendableFormatState) {\n        const document = contentDiv.ownerDocument;\n        let formatState = getPendableFormatState(document);\n        (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\n            if (!!pendingFormatState.pendableFormatState[key] != formatState[key]) {\n                document.execCommand(PendableFormatCommandMap[key], false, null);\n            }\n        });\n\n        const range = getSelectionRange(core, true /*tryGetFromCache*/);\n        pendingFormatState.pendableFormatPosition = range && Position.getStart(range);\n    }\n}\n","import { setHtmlWithSelectionPath } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ColorTransformDirection,\n    EditorCore,\n    PluginEventType,\n    SetContent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n * if triggerContentChangedEvent is set to true\n * @param core The EditorCore object\n * @param content HTML content to set in\n * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n */\nexport const setContent: SetContent = (\n    core: EditorCore,\n    content: string,\n    triggerContentChangedEvent: boolean\n) => {\n    let contentChanged = false;\n    if (core.contentDiv.innerHTML != content) {\n        const range = setHtmlWithSelectionPath(core.contentDiv, content);\n        core.api.selectRange(core, range);\n        contentChanged = true;\n    }\n\n    // Convert content even if it hasn't changed.\n    core.api.transformColor(\n        core,\n        core.contentDiv,\n        false /*includeSelf*/,\n        null /*callback*/,\n        ColorTransformDirection.LightToDark\n    );\n\n    if (triggerContentChangedEvent && (contentChanged || core.lifecycle.isDarkMode)) {\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: PluginEventType.ContentChanged,\n                source: ChangeSource.SetContent,\n            },\n            false /*broadcast*/\n        );\n    }\n};\n","import { createRange, getSelectionPath } from 'roosterjs-editor-dom';\nimport { EditorCore, PluginEventType, SwitchShadowEdit } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const switchShadowEdit: SwitchShadowEdit = (core: EditorCore, isOn: boolean): void => {\n    const { lifecycle, contentDiv } = core;\n    let { shadowEditFragment, shadowEditSelectionPath } = lifecycle;\n    const wasInShadowEdit = !!shadowEditFragment;\n\n    if (isOn) {\n        if (!wasInShadowEdit) {\n            const range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            shadowEditSelectionPath = range && getSelectionPath(contentDiv, range);\n            shadowEditFragment = core.contentDiv.ownerDocument.createDocumentFragment();\n            while (contentDiv.firstChild) {\n                shadowEditFragment.appendChild(contentDiv.firstChild);\n            }\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.EnteredShadowEdit,\n                    fragment: shadowEditFragment,\n                    selectionPath: shadowEditSelectionPath,\n                },\n                false /*broadcast*/\n            );\n\n            lifecycle.shadowEditFragment = shadowEditFragment;\n            lifecycle.shadowEditSelectionPath = shadowEditSelectionPath;\n        }\n\n        contentDiv.innerHTML = '';\n        contentDiv.appendChild(lifecycle.shadowEditFragment.cloneNode(true /*deep*/));\n    } else {\n        lifecycle.shadowEditFragment = null;\n        lifecycle.shadowEditSelectionPath = null;\n\n        if (wasInShadowEdit) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.LeavingShadowEdit,\n                },\n                false /*broadcast*/\n            );\n\n            contentDiv.innerHTML = '';\n            contentDiv.appendChild(shadowEditFragment);\n            core.api.focus(core);\n\n            if (shadowEditSelectionPath) {\n                core.api.selectRange(\n                    core,\n                    createRange(\n                        contentDiv,\n                        shadowEditSelectionPath.start,\n                        shadowEditSelectionPath.end\n                    )\n                );\n            }\n        }\n    }\n};\n","import { arrayPush, safeInstanceOf, toArray } from 'roosterjs-editor-dom';\nimport {\n    ColorTransformDirection,\n    DarkModeDatasetNames,\n    EditorCore,\n    TransformColor,\n} from 'roosterjs-editor-types';\n\nconst STYLE_DATASET_MAP = {\n    /**\n     * Original style color\n     */\n    [DarkModeDatasetNames.OriginalStyleColor]: (element: HTMLElement, value: string) =>\n        (element.style.color = value),\n\n    /**\n     * Original style background color\n     */\n    [DarkModeDatasetNames.OriginalStyleBackgroundColor]: (element: HTMLElement, value: string) =>\n        (element.style.backgroundColor = value),\n};\nconst ATTR_DATASET_MAP = {\n    /**\n     * Original attribute color\n     */\n    [DarkModeDatasetNames.OriginalAttributeColor]: 'color',\n\n    /**\n     * Original attribute background color\n     */\n    [DarkModeDatasetNames.OriginalAttributeBackgroundColor]: 'bgcolor',\n};\n\n/**\n * @internal\n * Edit and transform color of elements between light mode and dark mode\n * @param core The EditorCore object\n * @param rootNode The root HTML elements to transform\n * @param includeSelf True to transform the root node as well, otherwise false\n * @param callback The callback function to invoke before do color transformation\n * @param direction To specify the transform direction, light to dark, or dark to light\n */\nexport const transformColor: TransformColor = (\n    core: EditorCore,\n    rootNode: Node,\n    includeSelf: boolean,\n    callback: () => void,\n    direction: ColorTransformDirection\n) => {\n    let elementsToTransform = core.lifecycle.isDarkMode ? getAll(rootNode, includeSelf) : [];\n\n    callback?.();\n\n    elementsToTransform.forEach(element => {\n        if (direction == ColorTransformDirection.DarkToLight && element?.dataset) {\n            // Reset color styles based on the content of the ogsc/ogsb data element.\n            // If those data properties are empty or do not exist, set them anyway to clear the content.\n            Object.keys(STYLE_DATASET_MAP).forEach((name: keyof typeof STYLE_DATASET_MAP) => {\n                STYLE_DATASET_MAP[name](element, getValueOrDefault(element.dataset[name], ''));\n                delete element.dataset[name];\n            });\n\n            // Some elements might have set attribute colors. We need to reset these as well.\n            Object.keys(ATTR_DATASET_MAP).forEach((name: keyof typeof ATTR_DATASET_MAP) => {\n                const value = element.dataset[name];\n                if (getValueOrDefault(value, null)) {\n                    element.setAttribute(ATTR_DATASET_MAP[name], value);\n                } else {\n                    element.removeAttribute(ATTR_DATASET_MAP[name]);\n                }\n                delete element.dataset[name];\n            });\n        } else if (direction == ColorTransformDirection.LightToDark && element) {\n            if (core.lifecycle.onExternalContentTransform) {\n                core.lifecycle.onExternalContentTransform(element);\n            } else {\n                element.style.color = null;\n                element.style.backgroundColor = null;\n            }\n        }\n    });\n};\n\nfunction getValueOrDefault(value: string, defualtValue: string | null) {\n    return value && value != 'undefined' && value != 'null' ? value : defualtValue;\n}\n\nfunction getAll(rootNode: Node, includeSelf: boolean): HTMLElement[] {\n    const result: HTMLElement[] = [];\n\n    if (safeInstanceOf(rootNode, 'HTMLElement')) {\n        if (includeSelf) {\n            result.push(rootNode);\n        }\n        const allChildren = rootNode.getElementsByTagName('*');\n        arrayPush(result, toArray(allChildren));\n    } else if (safeInstanceOf(rootNode, 'DocumentFragment')) {\n        const allChildren = rootNode.querySelectorAll('*');\n        arrayPush(result, toArray(allChildren));\n    }\n\n    return result;\n}\n","import { EditorCore, EditorPlugin, PluginEvent, TriggerEvent } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Trigger a plugin event\n * @param core The EditorCore object\n * @param pluginEvent The event object to trigger\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\n */\nexport const triggerEvent: TriggerEvent = (\n    core: EditorCore,\n    pluginEvent: PluginEvent,\n    broadcast: boolean\n) => {\n    if (\n        !core.lifecycle.shadowEditFragment &&\n        (broadcast || !core.plugins.some(plugin => handledExclusively(pluginEvent, plugin)))\n    ) {\n        core.plugins.forEach(plugin => {\n            if (plugin.onPluginEvent) {\n                plugin.onPluginEvent(pluginEvent);\n            }\n        });\n    }\n};\n\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\n    if (plugin.onPluginEvent && plugin.willHandleEventExclusively?.(event)) {\n        plugin.onPluginEvent(event);\n        return true;\n    }\n\n    return false;\n}\n","import CopyPastePlugin from './CopyPastePlugin';\nimport DOMEventPlugin from './DOMEventPlugin';\nimport EditPlugin from './EditPlugin';\nimport EntityPlugin from './EntityPlugin';\nimport LifecyclePlugin from './LifecyclePlugin';\nimport MouseUpPlugin from './MouseUpPlugin';\nimport PendingFormatStatePlugin from './PendingFormatStatePlugin';\nimport TypeAfterLinkPlugin from './TypeAfterLinkPlugin';\nimport TypeInContainerPlugin from './TypeInContainerPlugin';\nimport UndoPlugin from './UndoPlugin';\nimport { CorePlugins, EditorOptions, PluginState } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const PLACEHOLDER_PLUGIN_NAME = '_placeholder';\n\n/**\n * @internal\n * Create Core Plugins\n * @param contentDiv Content DIV of editor\n * @param options Editor options\n */\nexport default function createCorePlugins(\n    contentDiv: HTMLDivElement,\n    options: EditorOptions\n): CorePlugins & { [PLACEHOLDER_PLUGIN_NAME]: null } {\n    const map = options.corePluginOverride || {};\n    // The order matters, some plugin needs to be put before/after others to make sure event\n    // can be handled in right order\n    return {\n        typeInContainer: map.typeInContainer || new TypeInContainerPlugin(),\n        edit: map.edit || new EditPlugin(),\n        _placeholder: null,\n        typeAfterLink: map.typeAfterLink || new TypeAfterLinkPlugin(),\n        undo: map.undo || new UndoPlugin(options),\n        domEvent: map.domEvent || new DOMEventPlugin(options, contentDiv),\n        pendingFormatState: map.pendingFormatState || new PendingFormatStatePlugin(),\n        mouseUp: map.mouseUp || new MouseUpPlugin(),\n        copyPaste: map.copyPaste || new CopyPastePlugin(options),\n        entity: map.entity || new EntityPlugin(),\n        lifecycle: map.lifecycle || new LifecyclePlugin(options, contentDiv),\n    };\n}\n\n/**\n * @internal\n * Get plugin state of core plugins\n * @param corePlugins CorePlugins object\n */\nexport function getPluginState(corePlugins: CorePlugins): PluginState {\n    return {\n        domEvent: corePlugins.domEvent.getState(),\n        pendingFormatState: corePlugins.pendingFormatState.getState(),\n        edit: corePlugins.edit.getState(),\n        lifecycle: corePlugins.lifecycle.getState(),\n        undo: corePlugins.undo.getState(),\n        entity: corePlugins.entity.getState(),\n        copyPaste: corePlugins.copyPaste.getState(),\n    };\n}\n","import {\n    addRangeToSelection,\n    extractClipboardEvent,\n    fromHtml,\n    readFile,\n    setHtmlWithSelectionPath,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ClipboardData,\n    ContentPosition,\n    CopyPastePluginState,\n    EditorOptions,\n    GetContentMode,\n    IEditor,\n    PluginEventType,\n    ExperimentalFeatures,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\nconst CONTAINER_HTML =\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\n\n/**\n * @internal\n * Copy and paste plugin for handling onCopy and onPaste event\n */\nexport default class CopyPastePlugin implements PluginWithState<CopyPastePluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: CopyPastePluginState;\n\n    /**\n     * Construct a new instance of CopyPastePlugin\n     * @param options The editor options\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            allowedCustomPasteType: options.allowedCustomPasteType || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'CopyPaste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            paste: this.onPaste,\n            copy: e => this.onCutCopy(e, false /*isCut*/),\n            cut: e => this.onCutCopy(e, true /*isCut*/),\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onCutCopy(event: Event, isCut: boolean) {\n        const originalRange = this.editor.getSelectionRange();\n        if (originalRange && !originalRange.collapsed) {\n            const html = this.editor.getContent(GetContentMode.RawHTMLWithSelection);\n            const tempDiv = this.getTempDiv(true /*forceInLightMode*/);\n            const newRange = setHtmlWithSelectionPath(tempDiv, html);\n\n            if (newRange) {\n                addRangeToSelection(newRange);\n            }\n\n            this.editor.triggerPluginEvent(PluginEventType.BeforeCutCopy, {\n                clonedRoot: tempDiv,\n                range: newRange,\n                rawEvent: event as ClipboardEvent,\n                isCut,\n            });\n\n            this.editor.runAsync(editor => {\n                this.cleanUpAndRestoreSelection(tempDiv, originalRange);\n\n                if (isCut) {\n                    editor.addUndoSnapshot(() => {\n                        const position = this.editor.deleteSelectedContent();\n                        editor.focus();\n                        editor.select(position);\n                    }, ChangeSource.Cut);\n                }\n            });\n        }\n    }\n\n    private onPaste = (event: Event) => {\n        extractClipboardEvent(\n            event as ClipboardEvent,\n            items => {\n                if (items.rawHtml === undefined) {\n                    // Can't get pasted HTML directly, need to use a temp DIV to retrieve pasted content.\n                    // This is mostly for IE\n                    const originalSelectionRange = this.editor.getSelectionRange();\n                    const tempDiv = this.getTempDiv();\n\n                    this.editor.runAsync(() => {\n                        items.rawHtml = tempDiv.innerHTML;\n                        this.cleanUpAndRestoreSelection(tempDiv, originalSelectionRange);\n                        this.paste(items);\n                    });\n                } else {\n                    this.paste(items);\n                }\n            },\n            {\n                allowLinkPreview: this.editor.isFeatureEnabled(\n                    ExperimentalFeatures.PasteWithLinkPreview\n                ),\n                allowedCustomPasteType: this.state.allowedCustomPasteType,\n            }\n        );\n    };\n\n    private paste(clipboardData: ClipboardData) {\n        if (clipboardData.image) {\n            readFile(clipboardData.image, dataUrl => {\n                clipboardData.imageDataUri = dataUrl;\n                this.editor.paste(clipboardData);\n            });\n        } else {\n            this.editor.paste(clipboardData);\n        }\n    }\n\n    private getTempDiv(forceInLightMode?: boolean) {\n        const div = this.editor.getCustomData(\n            'CopyPasteTempDiv',\n            () => {\n                const tempDiv = fromHtml(\n                    CONTAINER_HTML,\n                    this.editor.getDocument()\n                )[0] as HTMLDivElement;\n                this.editor.insertNode(tempDiv, {\n                    position: ContentPosition.Outside,\n                });\n\n                return tempDiv;\n            },\n            tempDiv => tempDiv.parentNode?.removeChild(tempDiv)\n        );\n\n        if (forceInLightMode) {\n            div.style.backgroundColor = 'white';\n            div.style.color = 'black';\n        }\n\n        div.style.display = '';\n        div.focus();\n\n        return div;\n    }\n\n    private cleanUpAndRestoreSelection(tempDiv: HTMLDivElement, range: Range) {\n        this.editor.select(range);\n        tempDiv.style.backgroundColor = '';\n        tempDiv.style.color = '';\n        tempDiv.style.display = 'none';\n        tempDiv.innerHTML = '';\n    }\n}\n","import { arrayPush, Browser, isCharacterValue } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContextMenuProvider,\n    DOMEventHandler,\n    DOMEventPluginState,\n    EditorOptions,\n    IEditor,\n    PluginEventType,\n    PluginWithState,\n    EditorPlugin,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * DOMEventPlugin handles customized DOM events, including:\n * 1. Keyboard event\n * 2. Mouse event\n * 3. IME state\n * 4. Drop event\n * 5. Focus and blur event\n * 6. Input event\n * 7. Scroll event\n */\nexport default class DOMEventPlugin implements PluginWithState<DOMEventPluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: DOMEventPluginState;\n\n    /**\n     * Construct a new instance of DOMEventPlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.state = {\n            isInIME: false,\n            scrollContainer: options.scrollContainer || contentDiv,\n            selectionRange: null,\n            stopPrintableKeyboardEventPropagation: !options.allowKeyboardEventPropagation,\n            contextMenuProviders:\n                options.plugins?.filter<ContextMenuProvider<any>>(isContextMenuProvider) || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'DOMEvent';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        this.disposer = editor.addDomEventHandler({\n            // 1. Keyboard event\n            keypress: this.getEventHandler(PluginEventType.KeyPress),\n            keydown: this.getEventHandler(PluginEventType.KeyDown),\n            keyup: this.getEventHandler(PluginEventType.KeyUp),\n\n            // 2. Mouse event\n            mousedown: PluginEventType.MouseDown,\n            contextmenu: this.onContextMenuEvent,\n\n            // 3. IME state management\n            compositionstart: () => (this.state.isInIME = true),\n            compositionend: (rawEvent: CompositionEvent) => {\n                this.state.isInIME = false;\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\n                    rawEvent,\n                });\n            },\n\n            // 4. Drop event\n            drop: this.onDrop,\n\n            // 5. Focus mangement\n            focus: this.onFocus,\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: this.onBlur,\n\n            // 6. Input event\n            [Browser.isIE ? 'textinput' : 'input']: this.getEventHandler(PluginEventType.Input),\n        });\n\n        // 7. Scroll event\n        this.state.scrollContainer.addEventListener('scroll', this.onScroll);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onDrop = (e: UIEvent) => {\n        this.editor.runAsync(editor => {\n            editor.addUndoSnapshot(() => {}, ChangeSource.Drop);\n        });\n    };\n\n    private onFocus = () => {\n        this.editor.select(this.state.selectionRange);\n        this.state.selectionRange = null;\n    };\n\n    private onBlur = () => {\n        this.state.selectionRange = this.editor.getSelectionRange(false /*tryGetFromCache*/);\n    };\n\n    private onScroll = (e: UIEvent) => {\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\n            rawEvent: e,\n            scrollContainer: this.state.scrollContainer,\n        });\n    };\n\n    private getEventHandler(eventType: PluginEventType): DOMEventHandler {\n        return this.state.stopPrintableKeyboardEventPropagation\n            ? {\n                  pluginEventType: eventType,\n                  beforeDispatch:\n                      eventType == PluginEventType.Input ? this.onInputEvent : this.onKeybaordEvent,\n              }\n            : eventType;\n    }\n\n    private onKeybaordEvent = (event: KeyboardEvent) => {\n        if (isCharacterValue(event)) {\n            event.stopPropagation();\n        }\n    };\n\n    private onInputEvent = (event: InputEvent) => {\n        event.stopPropagation();\n    };\n\n    private onContextMenuEvent = (event: MouseEvent) => {\n        const allItems: any[] = [];\n        const searcher = this.editor.getContentSearcherOfCursor();\n        const elementBeforeCursor = searcher?.getInlineElementBefore();\n\n        let eventTargetNode = event.target as Node;\n        if (event.button != 2) {\n            eventTargetNode = elementBeforeCursor?.getContainerNode();\n        }\n        this.state.contextMenuProviders.forEach(provider => {\n            const items = provider.getContextMenuItems(eventTargetNode);\n            if (items?.length > 0) {\n                if (allItems.length > 0) {\n                    allItems.push(null);\n                }\n                arrayPush(allItems, items);\n            }\n        });\n        this.editor.triggerPluginEvent(PluginEventType.ContextMenu, {\n            rawEvent: event,\n            items: allItems,\n        });\n    };\n}\n\nfunction isContextMenuProvider(source: EditorPlugin): source is ContextMenuProvider<any> {\n    return !!(<ContextMenuProvider<any>>source)?.getContextMenuItems;\n}\n","import { isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\nimport {\n    EditPluginState,\n    GenericContentEditFeature,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Edit Component helps handle Content edit features\n */\nexport default class EditPlugin implements PluginWithState<EditPluginState> {\n    private editor: IEditor;\n    private state: EditPluginState;\n\n    /**\n     * Construct a new instance of EditPlugin\n     * @param options The editor options\n     */\n    constructor() {\n        this.state = {\n            features: {},\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Edit';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        let hasFunctionKey = false;\n        let features: GenericContentEditFeature<PluginEvent>[];\n        let ctrlOrMeta = false;\n\n        if (event.eventType == PluginEventType.KeyDown) {\n            const rawEvent = event.rawEvent;\n            const range = this.editor.getSelectionRange();\n\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\n            features =\n                this.state.features[rawEvent.which] ||\n                (range && !range.collapsed && this.state.features[Keys.RANGE]);\n        } else if (event.eventType == PluginEventType.ContentChanged) {\n            features = this.state.features[Keys.CONTENTCHANGED];\n        }\n\n        for (let i = 0; i < features?.length; i++) {\n            const feature = features[i];\n            if (\n                (feature.allowFunctionKeys || !hasFunctionKey) &&\n                feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\n            ) {\n                feature.handleEvent(event, this.editor);\n                break;\n            }\n        }\n    }\n}\n","import {\n    Browser,\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    isCharacterValue,\n    toArray,\n    arrayPush,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    EntityClasses,\n    EntityOperation,\n    EntityPluginState,\n    HtmlSanitizerOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    QueryScope,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_ID_REGEX = /_\\d{1,8}$/;\n\nconst ENTITY_CSS_REGEX = '^' + EntityClasses.ENTITY_INFO_NAME + '$';\nconst ENTITY_ID_CSS_REGEX = '^' + EntityClasses.ENTITY_ID_PREFIX;\nconst ENTITY_TYPE_CSS_REGEX = '^' + EntityClasses.ENTITY_TYPE_PREFIX;\nconst ENTITY_READONLY_CSS_REGEX = '^' + EntityClasses.ENTITY_READONLY_PREFIX;\nconst ALLOWED_CSS_CLASSES = [\n    ENTITY_CSS_REGEX,\n    ENTITY_ID_CSS_REGEX,\n    ENTITY_TYPE_CSS_REGEX,\n    ENTITY_READONLY_CSS_REGEX,\n];\n\n/**\n * @internal\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\n */\nexport default class EntityPlugin implements PluginWithState<EntityPluginState> {\n    private editor: IEditor;\n    private state: EntityPluginState;\n\n    /**\n     * Construct a new instance of EntityPlugin\n     */\n    constructor() {\n        this.state = {\n            clickingPoint: null,\n            knownEntityElements: [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Entity';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.state.knownEntityElements = [];\n        this.state.clickingPoint = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.MouseDown:\n                this.handleMouseDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.MouseUp:\n                this.handleMouseUpEvent(event.rawEvent);\n                break;\n            case PluginEventType.KeyDown:\n                this.handleKeyDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.handleCutEvent(event.rawEvent);\n                }\n                break;\n            case PluginEventType.BeforePaste:\n                this.handleBeforePasteEvent(event.fragment, event.sanitizingOption);\n                break;\n            case PluginEventType.ContentChanged:\n                this.handleContentChangedEvent(event.source == ChangeSource.SetContent);\n                break;\n            case PluginEventType.EditorReady:\n                this.handleContentChangedEvent(true /*resetAll*/);\n                break;\n            case PluginEventType.ExtractContentWithDom:\n                this.handleExtractContentWithDomEvent(event.clonedRoot);\n                break;\n            case PluginEventType.ContextMenu:\n                this.handleContextMenuEvent(event.rawEvent);\n                break;\n        }\n    }\n\n    private handleContextMenuEvent(event: UIEvent) {\n        const node = event.target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n\n        if (entityElement) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.ContextMenu, event);\n        }\n    }\n\n    private handleCutEvent = (event: ClipboardEvent) => {\n        const range = this.editor.getSelectionRange();\n        if (range && !range.collapsed) {\n            this.checkRemoveEntityForRange(event);\n        }\n    };\n\n    private handleMouseDownEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n        if (entityElement && !entityElement.isContentEditable) {\n            event.preventDefault();\n            this.state.clickingPoint = { pageX, pageY };\n        }\n    }\n\n    private handleMouseUpEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        let entityElement: HTMLElement;\n\n        if (\n            this.state.clickingPoint &&\n            this.state.clickingPoint.pageX == pageX &&\n            this.state.clickingPoint.pageY == pageY &&\n            node &&\n            !!(entityElement = this.editor.getElementAtCursor(getEntitySelector(), node))\n        ) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.Click, event);\n\n            workaroundSelectionIssueForIE(this.editor);\n        }\n\n        this.state.clickingPoint = null;\n    }\n\n    private handleKeyDownEvent(event: KeyboardEvent) {\n        if (\n            isCharacterValue(event) ||\n            event.which == Keys.BACKSPACE ||\n            event.which == Keys.DELETE\n        ) {\n            const range = this.editor.getSelectionRange();\n            if (!range.collapsed) {\n                this.checkRemoveEntityForRange(event);\n            }\n        }\n    }\n\n    private handleBeforePasteEvent(\n        fragment: DocumentFragment,\n        sanitizingOption: HtmlSanitizerOptions\n    ) {\n        const range = this.editor.getSelectionRange();\n\n        if (!range.collapsed) {\n            this.checkRemoveEntityForRange(null /*rawEvent*/);\n        }\n\n        arrayPush(sanitizingOption.additionalAllowedCssClasses, ALLOWED_CSS_CLASSES);\n    }\n\n    private handleContentChangedEvent(resetAll: boolean) {\n        this.state.knownEntityElements = resetAll\n            ? []\n            : this.state.knownEntityElements.filter(node => this.editor.contains(node));\n        const allId = this.state.knownEntityElements\n            .map(e => getEntityFromElement(e)?.id)\n            .filter(x => !!x);\n\n        this.editor.queryElements(getEntitySelector(), element => {\n            if (this.state.knownEntityElements.indexOf(element) < 0) {\n                this.state.knownEntityElements.push(element);\n\n                const entity = getEntityFromElement(element);\n\n                this.hydrateEntity(entity, allId);\n            }\n        });\n    }\n\n    private handleExtractContentWithDomEvent(root: HTMLElement) {\n        toArray(root.querySelectorAll(getEntitySelector())).forEach(element => {\n            element.removeAttribute('contentEditable');\n\n            this.triggerEvent(element as HTMLElement, EntityOperation.ReplaceTemporaryContent);\n        });\n    }\n\n    private checkRemoveEntityForRange(event: Event) {\n        const editableEntityElements: HTMLElement[] = [];\n        const selector = getEntitySelector();\n        this.editor.queryElements(selector, QueryScope.OnSelection, element => {\n            if (element.isContentEditable) {\n                editableEntityElements.push(element);\n            } else {\n                this.triggerEvent(element, EntityOperation.Overwrite, event);\n            }\n        });\n\n        // For editable entities, we need to check if it is fully or partially covered by current selection,\n        // and trigger different events;\n        if (editableEntityElements.length > 0) {\n            const inSelectionEntityElements = this.editor.queryElements(\n                selector,\n                QueryScope.InSelection\n            );\n            editableEntityElements.forEach(element => {\n                const isFullyCovered = inSelectionEntityElements.indexOf(element) >= 0;\n                this.triggerEvent(\n                    element,\n                    isFullyCovered ? EntityOperation.Overwrite : EntityOperation.PartialOverwrite,\n                    event\n                );\n            });\n        }\n    }\n\n    private hydrateEntity(entity: Entity, knownIds: string[]) {\n        const { id, type, wrapper, isReadonly } = entity;\n        const match = ENTITY_ID_REGEX.exec(id);\n        const baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;\n\n        // Make sure entity id is unique\n        let newId = '';\n\n        for (let num = (match && parseInt(match[1])) || 0; ; num++) {\n            newId = num > 0 ? `${baseId}_${num}` : baseId;\n\n            if (knownIds.indexOf(newId) < 0) {\n                knownIds.push(newId);\n                break;\n            }\n        }\n\n        commitEntity(wrapper, type, isReadonly, newId);\n\n        this.triggerEvent(wrapper, EntityOperation.NewEntity);\n    }\n\n    private triggerEvent(element: HTMLElement, operation: EntityOperation, rawEvent?: Event) {\n        const entity = element && getEntityFromElement(element);\n\n        if (entity) {\n            this.editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n                operation,\n                rawEvent,\n                entity,\n            });\n        }\n    }\n}\n\n/**\n * IE will show a resize border around the readonly content within content editable DIV\n * This is a workaround to remove it by temporarily move focus out of editor\n */\nconst workaroundSelectionIssueForIE = Browser.isIE\n    ? (editor: IEditor) => {\n          editor.runAsync(editor => {\n              const workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', () => {\n                  const button = editor.getDocument().createElement('button');\n                  button.style.overflow = 'hidden';\n                  button.style.position = 'fixed';\n                  button.style.width = '0';\n                  button.style.height = '0';\n                  button.style.left = '0';\n                  button.style.top = '-1000px';\n                  button.onblur = () => {\n                      button.style.display = 'none';\n                  };\n\n                  editor.insertNode(button, {\n                      position: ContentPosition.Outside,\n                  });\n\n                  return button;\n              });\n\n              workaroundButton.style.display = '';\n              const range = editor.getDocument().createRange();\n              range.setStart(workaroundButton, 0);\n              try {\n                  window.getSelection().removeAllRanges();\n                  window.getSelection().addRange(range);\n              } catch {}\n          });\n      }\n    : () => {};\n","import { Browser, getComputedStyles } from 'roosterjs-editor-dom';\nimport {\n    DefaultFormat,\n    DocumentCommand,\n    EditorOptions,\n    IEditor,\n    LifecyclePluginState,\n    PluginEventType,\n    PluginWithState,\n    PluginEvent,\n    ChangeSource,\n} from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE_ATTRIBUTE_NAME = 'contenteditable';\nconst COMMANDS: {\n    [command: string]: any;\n} = Browser.isFirefox\n    ? {\n          /**\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\n           */\n          [DocumentCommand.EnableObjectResizing]: false,\n          [DocumentCommand.EnableInlineTableEditing]: false,\n      }\n    : Browser.isIE\n    ? {\n          /**\n           * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P\n           */\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\n\n          /**\n           * Disable auto link feature in IE since we have our own implementation\n           */\n          [DocumentCommand.AutoUrlDetect]: false,\n      }\n    : {};\n\nconst DARK_MODE_DEFAULT_FORMAT = {\n    backgroundColors: {\n        darkModeColor: 'rgb(51,51,51)',\n        lightModeColor: 'rgb(255,255,255)',\n    },\n    textColors: {\n        darkModeColor: 'rgb(255,255,255)',\n        lightModeColor: 'rgb(0,0,0)',\n    },\n};\n\n/**\n * @internal\n * Lifecycle plugin handles editor initialization and disposing\n */\nexport default class LifecyclePlugin implements PluginWithState<LifecyclePluginState> {\n    private editor: IEditor;\n    private state: LifecyclePluginState;\n    private initialContent: string;\n    private contentDivFormat: string[];\n    private initializer: () => void;\n    private disposer: () => void;\n\n    /**\n     * Construct a new instance of LifecyclePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.initialContent = options.initialContent || contentDiv.innerHTML || '';\n        this.contentDivFormat = getComputedStyles(contentDiv);\n\n        // Make the container editable and set its selection styles\n        if (contentDiv.getAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME) === null) {\n            this.initializer = () => {\n                contentDiv.contentEditable = 'true';\n                this.setSelectStyle(contentDiv, 'text');\n            };\n            this.disposer = () => {\n                this.setSelectStyle(contentDiv, '');\n                contentDiv.removeAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME);\n            };\n        }\n\n        this.state = {\n            customData: {},\n            defaultFormat: options.defaultFormat || null,\n            isDarkMode: !!options.inDarkMode,\n            onExternalContentTransform: options.onExternalContentTransform,\n            experimentalFeatures: options.experimentalFeatures || [],\n            shadowEditFragment: null,\n            shadowEditSelectionPath: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Lifecycle';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        // Calculate default format\n        this.recalculateDefaultFormat();\n\n        // Ensure initial content and its format\n        this.editor.setContent(this.initialContent, false /*triggerContentChangedEvent*/);\n\n        // Set content DIV to be editable\n        this.initializer?.();\n\n        // Do proper change for browsers to disable some browser-specified behaviors.\n        this.adjustBrowserBehavior();\n\n        // Let other plugins know that we are ready\n        this.editor.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\n\n        Object.keys(this.state.customData).forEach(key => {\n            const data = this.state.customData[key];\n\n            if (data && data.disposer) {\n                data.disposer(data.value);\n            }\n\n            delete this.state.customData[key];\n        });\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n            this.initializer = null;\n        }\n\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.ContentChanged &&\n            (event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode)\n        ) {\n            this.state.isDarkMode = event.source == ChangeSource.SwitchToDarkMode;\n            this.recalculateDefaultFormat();\n        }\n    }\n\n    private adjustBrowserBehavior() {\n        Object.keys(COMMANDS).forEach(command => {\n            // Catch any possible exception since this should not block the initialization of editor\n            try {\n                this.editor.getDocument().execCommand(command, false, COMMANDS[command]);\n            } catch {}\n        });\n    }\n\n    private setSelectStyle(node: HTMLElement, value: string) {\n        node.style.userSelect = value;\n        node.style.msUserSelect = value;\n        node.style.webkitUserSelect = value;\n    }\n\n    private recalculateDefaultFormat() {\n        const { defaultFormat: baseFormat, isDarkMode } = this.state;\n\n        if (isDarkMode && baseFormat) {\n            if (!baseFormat.backgroundColors) {\n                baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\n            }\n            if (!baseFormat.textColors) {\n                baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\n            }\n        }\n\n        if (baseFormat && Object.keys(baseFormat).length === 0) {\n            return;\n        }\n\n        const {\n            fontFamily,\n            fontSize,\n            textColor,\n            textColors,\n            backgroundColor,\n            backgroundColors,\n            bold,\n            italic,\n            underline,\n        } = baseFormat || <DefaultFormat>{};\n        const defaultFormat = this.contentDivFormat;\n\n        this.state.defaultFormat = {\n            fontFamily: fontFamily || defaultFormat[0],\n            fontSize: fontSize || defaultFormat[1],\n            get textColor() {\n                return textColors\n                    ? isDarkMode\n                        ? textColors.darkModeColor\n                        : textColors.lightModeColor\n                    : textColor || defaultFormat[2];\n            },\n            textColors: textColors,\n            get backgroundColor() {\n                return backgroundColors\n                    ? isDarkMode\n                        ? backgroundColors.darkModeColor\n                        : backgroundColors.lightModeColor\n                    : backgroundColor || '';\n            },\n            backgroundColors: backgroundColors,\n            bold: bold,\n            italic: italic,\n            underline: underline,\n        };\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * MouseUpPlugin help trigger MouseUp event even when mouse up happens outside editor\n * as long as the mouse was pressed within Editor before\n */\nexport default class MouseUpPlugin implements EditorPlugin {\n    private editor: IEditor;\n    private mouseUpEventListerAdded: boolean;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'MouseUp';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.removeMouseUpEventListener();\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\n            this.editor\n                .getDocument()\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\n            this.mouseUpEventListerAdded = true;\n        }\n    }\n    private removeMouseUpEventListener() {\n        if (this.mouseUpEventListerAdded) {\n            this.mouseUpEventListerAdded = false;\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private onMouseUp = (rawEvent: MouseEvent) => {\n        if (this.editor) {\n            this.removeMouseUpEventListener();\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\n                rawEvent,\n            });\n        }\n    };\n}\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    IEditor,\n    PendingFormatStatePluginState,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * PendingFormatStatePlugin handles pending format state management\n */\nexport default class PendingFormatStatePlugin\n    implements PluginWithState<PendingFormatStatePluginState> {\n    private editor: IEditor;\n    private state: PendingFormatStatePluginState;\n\n    /**\n     * Construct a new instance of PendingFormatStatePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor() {\n        this.state = {\n            pendableFormatPosition: null,\n            pendableFormatState: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'PendingFormatState';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.clear();\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.PendingFormatStateChanged:\n                // Got PendingFormatStateChagned event, cache current position and pending format\n                this.state.pendableFormatPosition = this.getCurrentPosition();\n                this.state.pendableFormatState = event.formatState;\n                break;\n            case PluginEventType.KeyDown:\n            case PluginEventType.MouseDown:\n            case PluginEventType.ContentChanged:\n                // If content or position is changed (by keyboard, mouse, or code),\n                // check if current position is still the same with the cached one (if exist),\n                // and clear cached format if position is changed since it is out-of-date now\n                if (\n                    this.state.pendableFormatPosition &&\n                    !this.state.pendableFormatPosition.equalTo(this.getCurrentPosition())\n                ) {\n                    this.clear();\n                }\n                break;\n        }\n    }\n\n    private clear() {\n        this.state.pendableFormatPosition = null;\n        this.state.pendableFormatState = null;\n    }\n\n    private getCurrentPosition() {\n        let range = this.editor.getSelectionRange();\n        return range && Position.getStart(range).normalize();\n    }\n}\n","import { Browser, LinkInlineElement } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * TypeAfterLinkPlugin Component helps handle typing event when cursor is right after a link.\n * When typing/pasting after a link, browser may put the new charactor inside link.\n * This plugin overrides this behavior to always insert outside of link.\n */\nexport default class TypeAfterLinkPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeAfterLink';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            (Browser.isFirefox && event.eventType == PluginEventType.KeyPress) ||\n            event.eventType == PluginEventType.BeforePaste\n        ) {\n            let range = this.editor.getSelectionRange();\n            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {\n                const searcher = this.editor.getContentSearcherOfCursor(event);\n                const inlineElementBefore = searcher.getInlineElementBefore();\n                const inlineElementAfter = searcher.getInlineElementAfter();\n                if (inlineElementBefore instanceof LinkInlineElement) {\n                    this.editor.select(inlineElementBefore.getContainerNode(), PositionType.After);\n                } else if (inlineElementAfter instanceof LinkInlineElement) {\n                    this.editor.select(inlineElementAfter.getContainerNode(), PositionType.Before);\n                }\n            }\n        }\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, Position } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Typing Component helps to ensure typing is always happening under a DOM container\n */\nexport default class TypeInContainerPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeInContainer';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.KeyPress) {\n            // If normalization was not possible before the keypress,\n            // check again after the keyboard event has been processed by browser native behaviour.\n            //\n            // This handles the case where the keyboard event that first inserts content happens when\n            // there is already content under the selection (e.g. Ctrl+a -> type new content).\n            //\n            // Only scheudle when the range is not collapsed to catch this edge case.\n            let range = this.editor.getSelectionRange();\n\n            if (!range || this.editor.contains(findClosestElementAncestor(range.startContainer))) {\n                return;\n            }\n\n            if (range.collapsed) {\n                this.editor.ensureTypeInContainer(Position.getStart(range), event.rawEvent);\n            } else {\n                this.editor.runAsync(editor => {\n                    editor.ensureTypeInContainer(editor.getFocusedPosition(), event.rawEvent);\n                });\n            }\n        }\n    }\n}\n","import {\n    EditorOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    UndoPluginState,\n    UndoSnapshotsService,\n} from 'roosterjs-editor-types';\nimport {\n    addSnapshot,\n    canMoveCurrentSnapshot,\n    clearProceedingSnapshots,\n    createSnapshots,\n    isCtrlOrMetaPressed,\n    moveCurrentSnapsnot,\n    canUndoAutoComplete,\n} from 'roosterjs-editor-dom';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAXSIZELIMIT = 1e7;\n\n/**\n * @internal\n * Provides snapshot based undo service for Editor\n */\nexport default class UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: IEditor;\n    private lastKeyPress: number;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            snapshotsService: options.undoSnapshotService || createUndoSnapshots(),\n            isRestoring: false,\n            hasNewContent: false,\n            isNested: false,\n            autoCompletePosition: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            event.eventType == PluginEventType.KeyDown &&\n            event.rawEvent.which == Keys.BACKSPACE &&\n            this.canUndoAutoComplete()\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        // if editor is in IME, don't do anything\n        if (!this.editor || this.editor.isInIME()) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n                const undoState = this.editor.getUndoState();\n                if (!undoState.canUndo && !undoState.canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case PluginEventType.KeyDown:\n                this.onKeyDown(event.rawEvent);\n                break;\n            case PluginEventType.KeyPress:\n                this.onKeyPress(event.rawEvent);\n                break;\n            case PluginEventType.CompositionEnd:\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case PluginEventType.ContentChanged:\n                if (!this.state.isRestoring) {\n                    this.clearRedoForInput();\n                }\n                break;\n        }\n    }\n\n    private onKeyDown(evt: KeyboardEvent): void {\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        if (evt.which == Keys.BACKSPACE || evt.which == Keys.DELETE) {\n            if (evt.which == Keys.BACKSPACE && this.canUndoAutoComplete()) {\n                evt.preventDefault();\n                this.editor.undo();\n                this.state.autoCompletePosition = null;\n                this.lastKeyPress = evt.which;\n            } else {\n                let selectionRange = this.editor.getSelectionRange();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selectionRange &&\n                    (!selectionRange.collapsed ||\n                        this.lastKeyPress != evt.which ||\n                        isCtrlOrMetaPressed(evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                this.state.hasNewContent = true;\n                this.lastKeyPress = evt.which;\n            }\n        } else if (evt.which >= Keys.PAGEUP && evt.which <= Keys.DOWN) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.lastKeyPress = 0;\n        }\n    }\n\n    private onKeyPress(evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        let range = this.editor.getSelectionRange();\n        if (\n            (range && !range.collapsed) ||\n            (evt.which == Keys.SPACE && this.lastKeyPress != Keys.SPACE) ||\n            evt.which == Keys.ENTER\n        ) {\n            this.addUndoSnapshot();\n            if (evt.which == Keys.ENTER) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.lastKeyPress = evt.which;\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsService.clearRedo();\n        this.lastKeyPress = 0;\n        this.state.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete() {\n        return (\n            this.state.snapshotsService.canUndoAutoComplete() &&\n            this.state.autoCompletePosition?.equalTo(this.editor.getFocusedPosition())\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor.addUndoSnapshot();\n        this.state.autoCompletePosition = null;\n    }\n}\n\nfunction createUndoSnapshots(): UndoSnapshotsService {\n    const snapshots = createSnapshots(MAXSIZELIMIT);\n\n    return {\n        canMove: (delta: number): boolean => canMoveCurrentSnapshot(snapshots, delta),\n        move: (delta: number): string => moveCurrentSnapsnot(snapshots, delta),\n        addSnapshot: (snapshot: string, isAutoCompleteSnapshot: boolean) =>\n            addSnapshot(snapshots, snapshot, isAutoCompleteSnapshot),\n        clearRedo: () => clearProceedingSnapshots(snapshots),\n        canUndoAutoComplete: () => canUndoAutoComplete(snapshots),\n    };\n}\n","export { default as HyperLink } from './HyperLink';\n","import { Browser, isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';\nimport { EditorPlugin, IEditor, Keys, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * An editor plugin that show a tooltip for existing link\n */\nexport default class HyperLink implements EditorPlugin {\n    private originalHref: string;\n    private trackedLink: HTMLAnchorElement = null;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n        this.disposer =\n            this.getTooltipCallback &&\n            editor.addDomEventHandler({\n                mouseover: this.onMouse,\n                mouseout: this.onMouse,\n                blur: this.onBlur,\n            });\n    }\n\n    protected onMouse = (e: MouseEvent) => {\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\n        const href = this.tryGetHref(a);\n\n        if (href) {\n            this.editor.setEditorDomAttribute(\n                'title',\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\n            );\n        }\n    };\n\n    protected onBlur = (e: FocusEvent) => {\n        if (this.trackedLink) {\n            this.updateLinkHrefIfShouldUpdate();\n        }\n\n        this.resetLinkTracking();\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        if (\n            event.eventType == PluginEventType.MouseUp ||\n            (event.eventType == PluginEventType.KeyUp &&\n                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == Keys.SPACE)) ||\n            event.eventType == PluginEventType.ContentChanged\n        ) {\n            const anchor = this.editor.getElementAtCursor(\n                'A[href]',\n                null /*startFrom*/,\n                event\n            ) as HTMLAnchorElement;\n\n            const shouldCheckUpdateLink =\n                anchor !== this.trackedLink ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.ContentChanged;\n\n            if (\n                this.trackedLink &&\n                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)\n            ) {\n                // If cursor has moved out of previously tracked link\n                // update link href if display text doesn't match href anymore.\n                if (shouldCheckUpdateLink) {\n                    this.updateLinkHrefIfShouldUpdate();\n                }\n\n                // If the link's href value was edited, or the cursor has moved out of the\n                // previously tracked link, stop tracking the link.\n                this.resetLinkTracking();\n            }\n\n            // Cache link and href value if its href attribute currently matches its display text\n            if (!this.trackedLink && this.doesLinkDisplayMatchHref(anchor)) {\n                this.trackedLink = anchor;\n                this.originalHref = this.tryGetHref(anchor);\n            }\n        }\n\n        if (event.eventType == PluginEventType.MouseUp) {\n            const anchor = this.editor.getElementAtCursor(\n                'A',\n                <Node>event.rawEvent.srcElement\n            ) as HTMLAnchorElement;\n\n            if (anchor) {\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\n                    return;\n                }\n\n                let href: string;\n                if (\n                    !Browser.isFirefox &&\n                    (href = this.tryGetHref(anchor)) &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    try {\n                        const target = this.target || '_blank';\n                        const window = this.editor.getDocument().defaultView;\n                        window.open(href, target);\n                    } catch {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Try get href from an anchor element\n     * The reason this is put in a try-catch is that\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\n     */\n    private tryGetHref(anchor: HTMLAnchorElement): string {\n        try {\n            return anchor ? anchor.href : null;\n        } catch {}\n    }\n\n    /**\n     * Determines if KeyboardEvent is meant to edit content\n     */\n    private isContentEditValue(event: KeyboardEvent): boolean {\n        return (\n            isCharacterValue(event) || event.which == Keys.BACKSPACE || event.which == Keys.DELETE\n        );\n    }\n\n    /**\n     * Updates the href of the tracked link if the display text doesn't match href anymore\n     */\n    private updateLinkHrefIfShouldUpdate() {\n        if (!this.doesLinkDisplayMatchHref(this.trackedLink)) {\n            this.updateLinkHref();\n        }\n    }\n\n    /**\n     * Clears the tracked link and its original href value so that it's back to default state\n     */\n    private resetLinkTracking() {\n        this.trackedLink = null;\n        this.originalHref = '';\n    }\n\n    /**\n     * Compares the normalized URL of inner text of element to its href to see if they match.\n     */\n    private doesLinkDisplayMatchHref(element: HTMLAnchorElement): boolean {\n        if (element) {\n            let display = element.innerText.trim();\n\n            // We first escape the display text so that any text passed into the regex is not\n            // treated as a special character.\n            let escapedDisplay = display.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n            let rule = new RegExp(`^(?:https?:\\\\/\\\\/)?${escapedDisplay}\\\\/?`, 'i');\n            let href = this.tryGetHref(element);\n            if (href !== null) {\n                return rule.test(href);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update href of an element in place to new display text if it's a valid URL\n     */\n    private updateLinkHref() {\n        if (this.trackedLink) {\n            let linkData = matchLink(this.trackedLink.innerText.trim());\n            if (linkData !== null) {\n                this.editor.addUndoSnapshot(() => {\n                    this.trackedLink.href = linkData.normalizedUrl;\n                });\n            }\n        }\n    }\n}\n","export { default as Paste } from './Paste';\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\nimport convertPastedContentFromTeams from './teamsConverter/convertPastedContentFromTeams';\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\nimport handleLineMerge from './lineMerge/handleLineMerge';\nimport { EditorPlugin, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\nimport { toArray } from 'roosterjs-editor-dom';\nimport { WAC_IDENTIFING_SELECTOR } from './officeOnlineConverter/constants';\nimport convertPastedContentFromWordOnline, {\n    isWordOnlineWithList,\n} from './officeOnlineConverter/convertPastedContentFromWordOnline';\n\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\nconst EXCEL_ONLINE_ATTRIBUTE_NAME = 'ProgId';\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\nconst GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';\n\n/**\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\n * 1. Content copied from Word\n * 2. Content copied from Excel\n * 3. Content copied from Word Online or Onenote Online\n */\nexport default class Paste implements EditorPlugin {\n    /**\n     * Construct a new instance of Paste class\n     * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN\n     */\n    constructor(private unknownTagReplacement: string = 'SPAN') {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Paste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize() {}\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {}\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.BeforePaste) {\n            const { htmlAttributes, fragment, sanitizingOption } = event;\n            let wacListElements: Node[];\n\n            if (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE) {\n                // Handle HTML copied from Word\n                convertPastedContentFromWord(event);\n            } else if (\n                htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||\n                htmlAttributes[EXCEL_ONLINE_ATTRIBUTE_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE\n            ) {\n                // Handle HTML copied from Excel\n                convertPastedContentFromExcel(event);\n            } else if (\n                (wacListElements = toArray(fragment.querySelectorAll(WAC_IDENTIFING_SELECTOR))) &&\n                wacListElements.length > 0\n            ) {\n                // Once it is known that the document is from WAC\n                // We need to remove the display property and margin from all the list item\n                wacListElements.forEach((el: HTMLElement) => {\n                    el.style.display = null;\n                    el.style.margin = null;\n                });\n                // call conversion function if the pasted content is from word online and\n                // has list element in the pasted content.\n                if (isWordOnlineWithList(fragment)) {\n                    convertPastedContentFromWordOnline(fragment);\n                }\n            } else if (fragment.querySelector(GOOGLE_SHEET_NODE_NAME)) {\n                sanitizingOption.additionalTagReplacements[GOOGLE_SHEET_NODE_NAME] = '*';\n            } else {\n                convertPastedContentFromTeams(fragment);\n                handleLineMerge(fragment);\n            }\n\n            // Replace unknown tags with SPAN\n            sanitizingOption.unknownTagReplacement = this.unknownTagReplacement;\n        }\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\n\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\n\n/**\n * @internal\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\n * @param doc HTML Document which contains the content from Excel\n */\nexport default function convertPastedContentFromExcel(event: BeforePasteEvent) {\n    const { fragment, sanitizingOption, htmlBefore, clipboardData } = event;\n    const html = excelHandler(clipboardData.html, htmlBefore);\n\n    if (clipboardData.html != html) {\n        const doc = new DOMParser().parseFromString(html, 'text/html');\n        while (fragment.firstChild) {\n            fragment.removeChild(fragment.firstChild);\n        }\n        while (doc?.body?.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n    }\n\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'TD', element => {\n        if (element.style.borderStyle == 'none') {\n            element.style.border = DEFAULT_BORDER_STYLE;\n        }\n        return true;\n    });\n}\n\n/**\n * @internal Export for test only\n * @param html Source html\n */\nexport function excelHandler(html: string, htmlBefore: string): string {\n    if (html.match(LAST_TD_END_REGEX)) {\n        const trMatch = htmlBefore.match(LAST_TR_REGEX);\n        const tr = trMatch ? trMatch[0] : '<TR>';\n        html = tr + html + '</TR>';\n    }\n    if (html.match(LAST_TR_END_REGEX)) {\n        let tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\n        let table = tableMatch ? tableMatch[0] : '<TABLE>';\n        html = table + html + '</TABLE>';\n    }\n\n    return html;\n}\n","import { changeElementTag, getTagOfNode, toArray } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Convert content copied from Teams to be well-formed\n */\nexport default function convertPastedContentFromTeams(fragment: DocumentFragment) {\n    const firstChild = fragment.firstChild;\n\n    // When copy from Teams, it is possible that we get LI nodes directly under DIV.\n    // In that case we need to convert DIV to UL. It is also possible to be OL, but we don't know it.\n    // So always assume it is UL here, and later user can change it.\n    if (\n        firstChild &&\n        !firstChild.nextSibling &&\n        getTagOfNode(firstChild) == 'DIV' &&\n        !toArray(firstChild.childNodes).some(node => getTagOfNode(node) != 'LI')\n    ) {\n        changeElementTag(firstChild as HTMLElement, 'UL');\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\nimport { createWordConverter } from './wordConverter';\nimport { createWordConverterArguments } from './WordConverterArguments';\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\n\n/**\n * @internal\n * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags\n */\nexport default function convertPastedContentFromWord(event: BeforePasteEvent) {\n    const { sanitizingOption, fragment } = event;\n\n    // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'O:P', element => {\n        element.innerHTML = '&nbsp;';\n        return true;\n    });\n\n    let wordConverter = createWordConverter();\n\n    // First find all the nodes that we need to check for list item information\n    // This call will return all the p and header elements under the root node.. These are the elements that\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\n    let elements = fragment.querySelectorAll('p');\n    if (elements.length > 0) {\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\n        if (processNodesDiscovery(wordConverter)) {\n            processNodeConvert(wordConverter);\n        }\n    }\n}\n","import WordConverterArguments from './WordConverterArguments';\nimport WordCustomData, { createCustomData } from './WordCustomData';\n\n/**\n * @internal\n * Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags\n */\nexport default interface WordConverter {\n    /** Next unique id to be assigned to a list */\n    nextUniqueId: number;\n\n    /** Number of bullets converted */\n    numBulletsConverted: number;\n\n    /** Number of numbering converted */\n    numNumberedConverted: number;\n\n    /** The structure that records the status of the conversion */\n    wordConverterArgs: WordConverterArguments;\n\n    /** Custom data storage for list items */\n    wordCustomData: WordCustomData;\n}\n\n/**\n * @internal\n * create an empty WordConverter\n */\nexport function createWordConverter(): WordConverter {\n    return {\n        nextUniqueId: 1,\n        numBulletsConverted: 0,\n        numNumberedConverted: 0,\n        wordConverterArgs: null,\n        wordCustomData: createCustomData(),\n    };\n}\n","import LevelLists, { createLevelLists } from './LevelLists';\nimport ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Contains the state of the WordConverter when called back after yielding\n */\nexport default interface WordConverterArguments {\n    /** The list of element nodes being processed */\n    nodes: NodeListOf<HTMLElement>;\n\n    /** The index of the element currently being processed */\n    currentIndex: number;\n\n    /**\n     * Holds the metadata for all the lists we have found\n     * key: unique list id, value: list metadata\n     */\n    lists: { [key: string]: ListMetadata };\n\n    /**\n     * Stores the list item metatada of the items we\n     * have found that need to be converted\n     */\n    listItems: ListItemMetadata[];\n\n    /**\n     * This array holds the list id of the lists we are processing\n     * that are next to each other.. This list will be used to determine\n     * if list items are next to each other or if they are separated...\n     * Separated items are ignored from the conversion\n     */\n\n    currentListIdsByLevels: LevelLists[];\n\n    /** Remembers the item that was last processed  */\n    lastProcessedItem: HTMLElement;\n}\n\n/**\n * @internal\n * create an empty WordConverterArguments\n */\nexport function createWordConverterArguments(\n    nodes: NodeListOf<HTMLElement>\n): WordConverterArguments {\n    return {\n        nodes: nodes,\n        currentIndex: 0,\n        lists: {},\n        listItems: [],\n        currentListIdsByLevels: [createLevelLists()],\n        lastProcessedItem: null,\n    };\n}\n","import ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\nimport WordConverter from './wordConverter';\nimport WordConverterArguments from './WordConverterArguments';\nimport { createLevelLists } from './LevelLists';\nimport { getObject, setObject } from './WordCustomData';\nimport { getStyles, getTagOfNode } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\n\n/** Word list metadata style name */\nconst LOOKUP_DEPTH = 5;\n\n/** Name for the word list id property in the custom data */\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\n\n/** Word list metadata style name */\nconst MSO_LIST_STYLE_NAME = 'mso-list';\n\n/** Regular expression to match line breaks */\nconst LINE_BREAKS = /[\\n|\\r]/gi;\n\n/**\n * @internal\n * Handles the pass 1: Discovery\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\n */\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    while (args.currentIndex < args.nodes.length) {\n        let node = args.nodes.item(args.currentIndex);\n\n        // Try to get the list metadata for the specified node\n        let itemMetadata = getListItemMetadata(node);\n        if (itemMetadata) {\n            let levelInfo =\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\n\n            // We need to drop some list information if this is not an item next to another\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\n                // This list item is not next to the previous one. This means that there is some content in between them\n                // so we need to reset our list of list ids per level\n                resetCurrentLists(args);\n            }\n\n            // Get the list metadata for the list that will hold this item\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\n            if (!listMetadata) {\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n\n                // This is a the first item of a list.. We'll create the list metadata using the information\n                // we already have from this first item\n                listMetadata = {\n                    numberOfItems: 0,\n                    uniqueListId: wordConverter.nextUniqueId++,\n                    firstFakeBullet: firstFakeBullet,\n\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\n                    // that this is not an item we need to convert of that the format doesn't match what\n                    // we are expecting\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\n\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\n                    tagName: getFakeBulletTagName(firstFakeBullet),\n                };\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\n                // items we have an decide if we create ordered or unordered lists based on this.\n                // This is the best way we can do this since we cannot read the metadata that Word\n                // puts in the head of the HTML...\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n                listMetadata.tagName =\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\n            }\n\n            // Set the unique id to the list\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\n\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\n            // it, or we'll know it because the previous list items are not next to this one\n            if (\n                listMetadata.ignore ||\n                (listMetadata.tagName == 'OL' &&\n                    listMetadata.numberOfItems > 0 &&\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\n            ) {\n                // We need to ignore this item... and we also need to forget about the lists that\n                // are not at the root level\n                listMetadata.ignore = true;\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\n            } else {\n                // This is an item we don't need to ignore... If added lists deep under this one before\n                // we'll drop their ids from the list of ids per level.. this is because this list item\n                // breaks the deeper lists.\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\n                        0,\n                        itemMetadata.level\n                    );\n                }\n\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\n\n                // Add the list item into the list of items to be processed\n                args.listItems.push(itemMetadata);\n                listMetadata.numberOfItems++;\n            }\n\n            args.lastProcessedItem = node;\n        } else {\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\n            // the list conversion thinking that the list items are not together...\n            let last = args.lastProcessedItem;\n            if (\n                last &&\n                getRealPreviousSibling(node) == last &&\n                node.tagName == last.tagName &&\n                node.className == last.className\n            ) {\n                // Add 2 line breaks and move all the nodes to the last item\n                last.appendChild(last.ownerDocument.createElement('br'));\n                last.appendChild(last.ownerDocument.createElement('br'));\n                while (node.firstChild != null) {\n                    last.appendChild(node.firstChild);\n                }\n\n                // Remove the item that we don't need anymore\n                node.parentNode.removeChild(node);\n            }\n        }\n\n        // Move to the next element are return true if more elements need to be processed\n        args.currentIndex++;\n    }\n\n    return args.listItems.length > 0;\n}\n\n/**\n * @internal\n * Handles the pass 2: Conversion\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\n * conversion needed\n */\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    args.currentIndex = 0;\n\n    while (args.currentIndex < args.listItems.length) {\n        let metadata = args.listItems[args.currentIndex];\n        let node = metadata.originalNode;\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\n        if (!listMetadata.ignore) {\n            // We have a list item that we need to convert, get or create the list\n            // that hold this item out\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\n            if (list) {\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\n                cleanupListIgnore(node, LOOKUP_DEPTH);\n\n                // Create a new list item and transfer the children\n                let li = node.ownerDocument.createElement('LI');\n                while (node.firstChild) {\n                    li.appendChild(node.firstChild);\n                }\n\n                // Append the list item into the list\n                list.appendChild(li);\n\n                // Remove the node we just converted\n                node.parentNode.removeChild(node);\n\n                if (listMetadata.tagName == 'UL') {\n                    wordConverter.numBulletsConverted++;\n                } else {\n                    wordConverter.numNumberedConverted++;\n                }\n            }\n        }\n\n        args.currentIndex++;\n    }\n\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\n}\n\n/**\n * Gets or creates the list (UL or OL) that holds this item out based on the\n * items content and the specified metadata\n */\nfunction getOrCreateListForNode(\n    wordConverter: WordConverter,\n    node: HTMLElement,\n    metadata: ListItemMetadata,\n    listMetadata: ListMetadata\n): Node {\n    // First get the last list next to this node under the specified level. This code\n    // path will return the list or will create lists if needed\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\n\n    // Here use the unique list ID to detect if we have the right list...\n    // it is possible to have 2 different lists next to each other with different formats, so\n    // we want to detect this an create separate lists for those cases\n    let listId = getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\n\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\n    // is a completely new list, so we'll append a new list for that\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\n        list.parentNode.insertBefore(newList, list.nextSibling);\n        list = newList;\n    }\n\n    // Set the list id into the custom data\n    setObject(\n        wordConverter.wordCustomData,\n        list,\n        UNIQUE_LIST_ID_CUSTOM_DATA,\n        metadata.uniqueListId\n    );\n\n    // This call will convert the list if needed to the right type of list required. This can happen\n    // on the cases where the first list item for this list is located after a deeper list. for that\n    // case, we will have created a UL for it, and we may need to convert it\n    return convertListIfNeeded(wordConverter, list, listMetadata);\n}\n\n/**\n * Converts the list between UL and OL if needed, by using the fake bullet and\n * information already stored in the list itself\n */\nfunction convertListIfNeeded(\n    wordConverter: WordConverter,\n    list: Node,\n    listMetadata: ListMetadata\n): Node {\n    // Check if we need to convert the list out\n    if (listMetadata.tagName != getTagOfNode(list)) {\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\n        setObject(\n            wordConverter.wordCustomData,\n            newList,\n            UNIQUE_LIST_ID_CUSTOM_DATA,\n            getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\n        );\n        while (list.firstChild) {\n            newList.appendChild(list.firstChild);\n        }\n        list.parentNode.insertBefore(newList, list);\n        list.parentNode.removeChild(list);\n        list = newList;\n    }\n\n    return list;\n}\n\n/**\n * Gets or creates the specified list\n */\nfunction recurringGetOrCreateListAtNode(\n    node: HTMLElement,\n    level: number,\n    listMetadata: ListMetadata\n): Node {\n    let parent: Node = null;\n    let possibleList: Node;\n    if (level == 1) {\n        // Root case, we'll check if the list is the previous sibling of the node\n        possibleList = getRealPreviousSibling(node);\n    } else {\n        // If we get here, we are looking for level 2 or deeper... get the upper list\n        // and check if the last element is a list\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\n        possibleList = parent.lastChild;\n    }\n\n    // Check the element that we got and verify that it is a list\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\n        let tag = getTagOfNode(possibleList);\n        if (tag == 'UL' || tag == 'OL') {\n            // We have a list.. use it\n            return possibleList;\n        }\n    }\n\n    // If we get here, it means we don't have a list and we need to create one\n    // this code path will always create new lists as UL lists\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\n    if (level == 1) {\n        // For level 1, we'll insert the list beofre the node\n        node.parentNode.insertBefore(newList, node);\n    } else {\n        // Any level 2 or above, we insert the list as the last\n        // child of the upper level list\n        parent.appendChild(newList);\n    }\n\n    return newList;\n}\n\n/**\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\n * This nodes hold the fake bullet information that Word puts in and when\n * conversion is happening, we want to get rid of these elements\n */\nfunction cleanupListIgnore(node: Node, levels: number) {\n    let nodesToRemove: Node[] = [];\n\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\n        // Clean up the item internally first if we need to based on the number of levels\n        if (child.nodeType == NodeType.Element && levels > 1) {\n            cleanupListIgnore(child, levels - 1);\n        }\n\n        // Try to convert word comments into ignore elements if we haven't done so for this element\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if we can remove this item out\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\n            nodesToRemove.push(child);\n        }\n    }\n\n    nodesToRemove.forEach(child => node.removeChild(child));\n}\n\n/**\n * Reads the word list metadada out of the specified node. If the node\n * is not a Word list item, it returns null.\n */\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0) {\n            try {\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\n                // Where:\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\n                // list indentation value\n                // (2) Contains a specific list identifier.\n                // Example value: \"l0 level1 lfo1\"\n                let listprops = listatt.split(' ');\n                if (listprops.length == 3) {\n                    return <ListItemMetadata>{\n                        level: parseInt(listprops[1].substr('level'.length)),\n                        wordListId: listatt,\n                        originalNode: node,\n                        uniqueListId: 0,\n                    };\n                }\n            } catch (e) {}\n        }\n    }\n    return null;\n}\n\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '', '', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): string {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = null;\n    let child: Node = node.firstChild;\n    while (!result && child) {\n        // First, check if we need to convert the Word list comments into real elements\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent.trim();\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * If the specified element is a Word List comments, this code verifies and fixes\n * the markup when needed to ensure that Chrome bullet conversions work as expected\n * -----\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\n * styles of the span, but we'll use these comments to recreate them out\n */\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\n    if (child.nodeType == NodeType.Comment) {\n        let value = (child as Comment).data;\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\n            // We have a list ignore start, find the end.. We know is not more than\n            // 3 nodes away, so we'll optimize our checks\n            let nextElement = child;\n            let endComment: Node = null;\n            for (let j = 0; j < 4; j++) {\n                nextElement = getRealNextSibling(nextElement);\n                if (!nextElement) {\n                    break;\n                }\n                if (nextElement.nodeType == NodeType.Comment) {\n                    value = (nextElement as Comment).data;\n                    if (value && value.trim().toLowerCase() == '[endif]') {\n                        endComment = nextElement;\n                        break;\n                    }\n                }\n            }\n\n            // if we found the end node, wrap everything out\n            if (endComment) {\n                let newSpan = child.ownerDocument.createElement('span');\n                newSpan.setAttribute('style', 'mso-list: ignore');\n                nextElement = getRealNextSibling(child);\n                while (nextElement != endComment) {\n                    nextElement = nextElement.nextSibling as HTMLElement;\n                    newSpan.appendChild(nextElement.previousSibling);\n                }\n\n                // Insert the element out and use that one as the current child\n                endComment.parentNode.insertBefore(newSpan, endComment);\n\n                // Remove the comments out if the call specified it out\n                if (removeComments) {\n                    child.parentNode.removeChild(child);\n                    endComment.parentNode.removeChild(endComment);\n                }\n\n                // Last, make sure we return the new element out instead of the comment\n                child = newSpan;\n            }\n        }\n    }\n\n    return child;\n}\n\n/** Finds the real previous sibling, ignoring emtpy text nodes */\nfunction getRealPreviousSibling(node: Node): Node {\n    let prevSibling = node;\n    do {\n        prevSibling = prevSibling.previousSibling;\n    } while (prevSibling && isEmptyTextNode(prevSibling));\n    return prevSibling;\n}\n\n/** Finds the real next sibling, ignoring empty text nodes */\nfunction getRealNextSibling(node: Node): Node {\n    let nextSibling = node;\n    do {\n        nextSibling = nextSibling.nextSibling;\n    } while (nextSibling && isEmptyTextNode(nextSibling));\n\n    return nextSibling;\n}\n\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Checks if the specified node is an empty span. */\nfunction isEmptySpan(node: Node): boolean {\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\n}\n\n/** Reads the specified style value from the node */\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\n    // Word uses non-standard names for the metadata that puts in the style of the element...\n    // Most browsers will not provide the information for those unstandard values throug the node.style\n    // property, so the only reliable way to read them is to get the attribute directly and do\n    // the required parsing..\n    return getStyles(node)[styleName] || null;\n}\n\n/** Checks if the node is an empty text node that can be ignored */\nfunction isEmptyTextNode(node: Node): boolean {\n    // No node is empty\n    if (!node) {\n        return true;\n    }\n\n    // Empty text node is empty\n    if (node.nodeType == NodeType.Text) {\n        let value = node.nodeValue;\n        value = value.replace(LINE_BREAKS, '');\n        return value.trim().length == 0;\n    }\n\n    // Span or Font with an empty child node is empty\n    let tagName = getTagOfNode(node);\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\n        return isEmptyTextNode(node.firstChild);\n    }\n\n    // If not found, then this is not empty\n    return false;\n}\n\n/** Resets the list */\nfunction resetCurrentLists(args: WordConverterArguments) {\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\n        let ll = args.currentListIdsByLevels[i];\n        if (ll) {\n            ll.currentUniqueListId = -1;\n        }\n    }\n}\n","import {\n    changeElementTag,\n    ContentTraverser,\n    getBlockElementAtNode,\n    getNextLeafSibling,\n    getPreviousLeafSibling,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n/**\n * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,\n * change the tag of first and last node to be SPAN so that it will be merged into current block\n * @param root Root node of content to process\n */\nexport default function handleLineMerge(root: Node) {\n    const traverser = ContentTraverser.createBodyTraverser(root);\n    const blocks: { start: Node; end: Node }[] = [];\n\n    for (\n        let block = traverser?.currentBlockElement;\n        block;\n        block = traverser.getNextBlockElement()\n    ) {\n        blocks.push({\n            start: block.getStartNode(),\n            end: block.getEndNode(),\n        });\n    }\n\n    if (blocks.length > 0) {\n        processBlock(blocks[0]);\n        processBlock(blocks[blocks.length - 1]);\n        checkAndAddBr(root, blocks[0], true /*isFirst*/);\n        checkAndAddBr(root, blocks[blocks.length - 1], false /*isFirst*/);\n    }\n}\n\nfunction processBlock(block: { start: Node; end: Node }) {\n    const { start, end } = block;\n\n    if (start == end && getTagOfNode(start) == 'DIV') {\n        const node = changeElementTag(start as HTMLElement, 'SPAN');\n        block.start = node;\n        block.end = node;\n\n        if (getTagOfNode(node.lastChild) == 'BR') {\n            node.removeChild(node.lastChild);\n        }\n    } else if (getTagOfNode(end) == 'BR') {\n        const node = end.ownerDocument.createTextNode('');\n        end.parentNode?.insertBefore(node, end);\n        block.end = node;\n        end.parentNode?.removeChild(end);\n    }\n}\n\nfunction checkAndAddBr(root: Node, block: { start: Node; end: Node }, isFirst: boolean) {\n    const blockElement = getBlockElementAtNode(root, block.start);\n    const sibling = isFirst\n        ? getNextLeafSibling(root, block.end)\n        : getPreviousLeafSibling(root, block.start);\n\n    if (blockElement?.contains(sibling)) {\n        (isFirst ? block.end : block.start).parentNode?.insertBefore(\n            block.start.ownerDocument.createElement('br'),\n            isFirst ? block.end.nextSibling : block.start\n        );\n    }\n}\n","import ListItemBlock, { createListItemBlock } from './ListItemBlock';\nimport {\n    WORD_ORDERED_LIST_SELECTOR,\n    WORD_UNORDERED_LIST_SELECTOR,\n    WORD_ONLINE_IDENTIFYING_SELECTOR,\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\n    ORDERED_LIST_TAG_NAME,\n    UNORDERED_LIST_TAG_NAME,\n} from './constants';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap,\n    toArray,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n */\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * @internal\n * Convert text copied from word online into text that's workable with rooster editor\n * @param fragment Document fragment that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\n    sanitizeListItemContainer(fragment);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\n\n    listItemBlocks.forEach(itemBlock => {\n        // There are cases where consecutive List Elements are seperated into different divs:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item divs.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(fragment, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;\n\n        let convertedListElement: Element;\n        const doc = fragment.ownerDocument;\n\n        itemBlock.listItemContainers.forEach(listItemContainer => {\n            let listType: 'OL' | 'UL' = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            // Initialize processed element with propery listType if this is the first element\n            if (!convertedListElement) {\n                convertedListElement = doc.createElement(listType);\n            }\n\n            // Get all list items(<li>) in the current iterator element.\n            const currentListItems = toArray(listItemContainer.querySelectorAll('li'));\n            currentListItems.forEach(item => {\n                // If item is in root level and the type of list changes then\n                // insert the current list into body and then reinitialize the convertedListElement\n                // Word Online is using data-aria-level to determine the the depth of the list item.\n                const itemLevel = parseInt(item.getAttribute('data-aria-level'));\n                // In first level list, there are cases where a consecutive list item divs may have different list type\n                // When that happens we need to insert the processed elements into the document, then change the list type\n                // and keep the processing going.\n                if (getTagOfNode(convertedListElement) != listType && itemLevel == 1) {\n                    insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n                    convertedListElement = doc.createElement(listType);\n                }\n                insertListItem(convertedListElement, item, listType, doc);\n            });\n        });\n\n        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach(listItemContainer => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be melformed, this function is to split all the other elements out of ListContainerWrapper\n * @param fragment pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\n    const listItemContainerListEl = toArray(\n        fragment.querySelectorAll(`${WORD_ORDERED_LIST_SELECTOR}, ${WORD_UNORDERED_LIST_SELECTOR}`)\n    );\n    listItemContainerListEl.forEach(el => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param fragment pasted document that contains all the list element.\n */\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock;\n    for (let i = 0; i < listElements.length; i++) {\n        let curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem);\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (\n                curItem == lastItemInCurBlock.nextSibling ||\n                getFirstLeafNode(curItem) ==\n                    getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock)\n            ) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem;\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock?.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param fragment Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\n    const collapsedListItemSections = collapseNodes(\n        fragment,\n        listItemBlock.startElement,\n        listItemBlock.endElement,\n        true\n    );\n    collapsedListItemSections.forEach(section => {\n        if (getTagOfNode(section.firstChild) == 'DIV') {\n            unwrap(section);\n        }\n    });\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == UNORDERED_LIST_TAG_NAME || tag == ORDERED_LIST_TAG_NAME ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(\n    listRootElement: Element,\n    itemToInsert: HTMLElement,\n    listType: string,\n    doc: HTMLDocument\n): void {\n    if (!listType) {\n        return;\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.appendChild(doc.createElement(listType));\n            curListLevel = curListLevel.firstElementChild;\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            let lastChild = curListLevel.lastElementChild;\n            let lastChildTag = getTagOfNode(lastChild);\n            if (lastChildTag == UNORDERED_LIST_TAG_NAME || lastChildTag == ORDERED_LIST_TAG_NAME) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.appendChild(doc.createElement(listType));\n                curListLevel = curListLevel.lastElementChild;\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param fragment Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(\n    convertedListElement: Element,\n    fragment: DocumentFragment,\n    listItemBlock: ListItemBlock\n) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const parentNode = insertPositionNode.parentNode;\n        if (parentNode) {\n            parentNode.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const parentNode = listItemBlock.startElement.parentNode;\n        if (parentNode) {\n            parentNode.appendChild(convertedListElement);\n        } else {\n            fragment.appendChild(convertedListElement);\n        }\n    }\n}\n","/**\n * @internal\n * Type that holds all the info of a consecutive list item block.\n */\nexport default interface ListItemBlock {\n    /**\n     * The first element in block of list item from pasted word online document.\n     */\n    startElement: Element;\n\n    /**\n     * The last element in block of list item from pasted word online document.\n     */\n    endElement: Element;\n\n    /**\n     * The position where the processed bulleted list should be inserted.\n     */\n    insertPositionNode: Node;\n\n    /**\n     * The list of containers that wraps each list item.\n     */\n    listItemContainers: Element[];\n}\n\n/**\n * @internal\n * Initialize an empty ListItemBlock\n */\nexport function createListItemBlock(listItem: Element = null): ListItemBlock {\n    return {\n        startElement: listItem,\n        endElement: listItem,\n        insertPositionNode: null,\n        listItemContainers: listItem ? [listItem] : [],\n    };\n}\n","export * from './ContentEdit';\r\nexport * from './ContextMenu';\r\nexport * from './CustomReplace';\r\nexport * from './CutPasteListChain';\r\nexport * from './HyperLink';\r\nexport * from './ImageResize';\r\nexport * from './Paste';\r\nexport * from './Picker';\r\nexport * from './TableResize';\r\nexport * from './Watermark';\r\n","export * from './plugins/ContextMenu/index';\n","export { default as ContextMenu, ContextMenuOptions } from './ContextMenu';\n","import { fromHtml } from 'roosterjs-editor-dom';\nimport {\n    ContentPosition,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\nconst CONTAINER_HTML = '<div style=\"position: fixed; width: 0; height: 0\"></div>';\n\nexport interface ContextMenuOptions<T> {\n    render: (container: HTMLElement, items: (T | null)[], onDismiss: () => void) => void;\n\n    dismiss?: (container: HTMLElement) => void;\n\n    allowDefaultMenu?: boolean;\n}\n\n/**\n * An editor plugin that support showing a context menu using render() function from options parameter\n */\nexport default class ContextMenu<T> implements EditorPlugin {\n    private container: HTMLElement;\n    private editor: IEditor;\n    private isMenuShowing: boolean;\n\n    /**\n     * Create a new instance of ContextMenu class\n     * @param options An options object to determine how to show/hide the context menu\n     */\n    constructor(private options: ContextMenuOptions<T>) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContextMenu';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onDismiss();\n\n        if (this.container) {\n            this.container.parentNode.removeChild(this.container);\n            this.container = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.ContextMenu && event.items.length > 0) {\n            const { rawEvent, items } = event;\n\n            this.onDismiss();\n\n            if (!this.options.allowDefaultMenu) {\n                rawEvent.preventDefault();\n            }\n\n            this.initContainer(rawEvent.pageX, rawEvent.pageY);\n            this.options.render(this.container, items as T[], this.onDismiss);\n            this.isMenuShowing = true;\n        }\n    }\n\n    private initContainer(x: number, y: number) {\n        if (!this.container) {\n            this.container = fromHtml(CONTAINER_HTML, this.editor.getDocument())[0] as HTMLElement;\n            this.editor.insertNode(this.container, {\n                position: ContentPosition.Outside,\n            });\n        }\n        this.container.style.left = x + 'px';\n        this.container.style.top = y + 'px';\n    }\n\n    private onDismiss = () => {\n        if (this.container && this.isMenuShowing) {\n            this.options.dismiss?.(this.container);\n            this.isMenuShowing = false;\n        }\n    };\n}\n","export * from './plugins/CustomReplace/index';\n","export { default as CustomReplace } from './CustomReplace';\n","import {\n    CustomReplacement,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst makeReplacement = (\n    sourceString: string,\n    replacementHTML: string,\n    matchSourceCaseSensitive: boolean\n): CustomReplacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\n\nconst defaultReplacements: CustomReplacement[] = [\n    makeReplacement(':)', '', true),\n    makeReplacement(';)', '', true),\n    makeReplacement(':O', '', true),\n    makeReplacement(':o', '', true),\n    makeReplacement('<3', '', true),\n];\n\n/**\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\n * content edit feature\n */\nexport default class CustomReplacePlugin implements EditorPlugin {\n    private longestReplacementLength: number;\n    private editor: IEditor;\n    private replacements: CustomReplacement[];\n    private replacementEndCharacters: Set<string>;\n\n    /**\n     * Create instance of CustomReplace plugin\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\n     */\n    constructor(replacements: CustomReplacement[] = defaultReplacements) {\n        this.updateReplacements(replacements);\n    }\n\n    /**\n     * Set the replacements that this plugin is looking for.\n     * @param newReplacements new set of replacements for this plugin\n     */\n    updateReplacements(newReplacements: CustomReplacement[]) {\n        this.replacements = newReplacements;\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\n    }\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CustomReplace';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\n            return;\n        }\n\n        // Exit early on input events that do not insert a replacement's final character.\n        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {\n            return;\n        }\n\n        // Get the matching replacement\n        const range = this.editor.getSelectionRange();\n        if (range == null) {\n            return;\n        }\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\n\n        const replacement = this.getMatchingReplacement(stringToSearch);\n        if (replacement == null) {\n            return;\n        }\n\n        // Reconstruct a selection of the text on the document that matches the\n        // replacement we selected.\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\n\n        // parse the html string off the dom and inline the resulting element.\n        const document = this.editor.getDocument();\n        const parsingSpan = document.createElement('span');\n        parsingSpan.innerHTML = replacement.replacementHTML;\n        const nodeToInsert =\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\n\n        // Switch the node for the selection range\n        this.editor.addUndoSnapshot(\n            () => {\n                matchingRange.deleteContents();\n                matchingRange.insertNode(nodeToInsert);\n                this.editor.select(nodeToInsert, PositionType.End);\n            },\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    }\n\n    private getMatchingReplacement(stringToSearch: string): CustomReplacement | null {\n        if (stringToSearch.length == 0) {\n            return null;\n        }\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\n        for (const replacement of this.replacements) {\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\n                ? [stringToSearch, replacement.sourceString]\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\n\n            if (\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\n                replacementMatch\n            ) {\n                return replacement;\n            }\n        }\n        return null;\n    }\n}\n\nfunction getLongestReplacementSourceLength(replacements: CustomReplacement[]): number {\n    return Math.max.apply(\n        null,\n        replacements.map(replacement => replacement.sourceString.length)\n    );\n}\n\nfunction getReplacementEndCharacters(replacements: CustomReplacement[]): Set<string> {\n    const endChars = new Set<string>();\n    for (let replacement of replacements) {\n        const sourceString = replacement.sourceString;\n        if (sourceString.length == 0) {\n            continue;\n        }\n        const lastChar = sourceString[sourceString.length - 1];\n        if (!replacement.matchSourceCaseSensitive) {\n            endChars.add(lastChar.toLocaleLowerCase());\n            endChars.add(lastChar.toLocaleUpperCase());\n        } else {\n            endChars.add(lastChar);\n        }\n    }\n    return endChars;\n}\n","export * from './plugins/CutPasteListChain/index';\n","export { default as CutPasteListChain } from './CutPasteListChain';\n","import { experimentCommitListChains } from 'roosterjs-editor-api';\nimport { VListChain } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * Maintain list numbers of list chain when content is modified by cut/paste/drag&drop\n */\nexport default class CutPasteListChain implements EditorPlugin {\n    private chains: VListChain[];\n    private expectedChangeSource: ChangeSource;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CutPasteListChain';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler('drop', this.onDrop);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer?.();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.cacheListChains(ChangeSource.Cut);\n                }\n                break;\n\n            case PluginEventType.BeforePaste:\n                this.cacheListChains(ChangeSource.Paste);\n                break;\n\n            case PluginEventType.ContentChanged:\n                if (this.chains?.length > 0 && this.expectedChangeSource == event.source) {\n                    experimentCommitListChains(this.editor, this.chains);\n                    this.chains = null;\n                    this.expectedChangeSource = null;\n                }\n                break;\n        }\n    }\n\n    private onDrop = () => {\n        this.cacheListChains(ChangeSource.Drop);\n    };\n\n    private cacheListChains(source: ChangeSource) {\n        this.chains = VListChain.createListChains(this.editor.getSelectedRegions());\n        this.expectedChangeSource = source;\n    }\n}\n","export * from './plugins/ImageResize/index';\n","export { default as ImageResize } from './ImageResize';\n","import { Browser, fromHtml, getEntitySelector, getTagOfNode, toArray } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n    EntityOperation,\n    Entity,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\n\nconst DELETE_KEYCODE = 46;\nconst BACKSPACE_KEYCODE = 8;\nconst SHIFT_KEYCODE = 16;\nconst CTRL_KEYCODE = 17;\nconst ALT_KEYCODE = 18;\n\nconst ENTITY_TYPE = 'IMAGE_RESIZE_WRAPPER';\n\nconst HANDLE_SIZE = 7;\nconst HANDLE_MARGIN = 3;\nconst CORNER_HANDLE_POSITIONS = ['nw', 'ne', 'se', 'sw'];\nconst SIDE_HANDLE_POSITIONS = ['n', 'e', 's', 'w'];\nconst ALL_HANDLE_POSITIONS = CORNER_HANDLE_POSITIONS.concat(SIDE_HANDLE_POSITIONS);\n\n/**\n * ImageResize plugin provides the ability to resize an inline image in editor\n */\nexport default class ImageResize implements EditorPlugin {\n    private editor: IEditor;\n    private startPageX: number;\n    private startPageY: number;\n    private startWidth: number;\n    private startHeight: number;\n    private resizeDiv: HTMLElement;\n    private direction: string;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of ImageResize\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\n     * that the tag must be IMG regardless what the selector is\n     */\n    constructor(\n        private minWidth: number = 10,\n        private minHeight: number = 10,\n        private selectionBorderColor: string = '#DB626C',\n        private forcePreserveRatio: boolean = false,\n        private resizableImageSelector: string = 'img'\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ImageResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = editor.addDomEventHandler({\n            dragstart: this.onDragStart,\n            blur: this.onBlur,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.hideResizeHandle();\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        if (e.eventType == PluginEventType.MouseDown) {\n            if (this.resizeDiv) {\n                this.hideResizeHandle();\n            }\n        } else if (e.eventType == PluginEventType.MouseUp) {\n            const event = e.rawEvent;\n            const target = <HTMLElement>(event.srcElement || event.target);\n\n            if (getTagOfNode(target) == 'IMG' && target.isContentEditable) {\n                const parent = target.parentNode as HTMLElement;\n                const elements = parent\n                    ? toArray(parent.querySelectorAll(this.resizableImageSelector))\n                    : [];\n                if (elements.indexOf(target) < 0) {\n                    return;\n                }\n\n                const currentImg = this.getSelectedImage();\n                if (currentImg && currentImg != target) {\n                    this.hideResizeHandle();\n                }\n\n                if (!this.resizeDiv) {\n                    this.showResizeHandle(<HTMLImageElement>target);\n                }\n            }\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\n            const event = e.rawEvent;\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\n                this.editor.addUndoSnapshot(() => {\n                    this.editor.deleteNode(this.resizeDiv);\n                });\n                this.resizeDiv = null;\n                event.preventDefault();\n            } else if (\n                event.which != SHIFT_KEYCODE &&\n                event.which != CTRL_KEYCODE &&\n                event.which != ALT_KEYCODE\n            ) {\n                this.hideResizeHandle(true /*selectImage*/);\n            }\n        } else if (\n            e.eventType == PluginEventType.ContentChanged &&\n            e.source != ChangeSource.ImageResize &&\n            (e.source != ChangeSource.InsertEntity || (<Entity>e.data)?.type != ENTITY_TYPE)\n        ) {\n            this.editor.queryElements(getEntitySelector(ENTITY_TYPE), this.removeResizeDiv);\n            this.resizeDiv = null;\n        } else if (e.eventType == PluginEventType.EntityOperation && e.entity.type == ENTITY_TYPE) {\n            if (e.operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeResizeDiv(e.entity.wrapper);\n            } else if (e.operation == EntityOperation.Click) {\n                this.stopEvent(e.rawEvent);\n            }\n        }\n    }\n\n    /**\n     * Select a given IMG element, show the resize handle\n     * @param img The IMG element to select\n     */\n    showResizeHandle(img: HTMLImageElement) {\n        this.resizeDiv = this.createResizeDiv(img);\n        this.editor.select(this.resizeDiv, PositionType.After);\n    }\n\n    /**\n     * Hide resize handle of current selected image\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\n     */\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\n        if (this.resizeDiv) {\n            const transform = this.resizeDiv.style.transform;\n            const img = this.removeResizeDiv(this.resizeDiv);\n\n            if (img) {\n                img.style.transform = transform;\n\n                if (selectImageAfterUnSelect) {\n                    this.editor.select(img);\n                }\n            }\n\n            this.resizeDiv = null;\n        }\n    }\n\n    private startResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            this.startPageX = e.pageX;\n            this.startPageY = e.pageY;\n            this.startWidth = img.clientWidth;\n            this.startHeight = img.clientHeight;\n            this.editor.addUndoSnapshot();\n\n            let document = this.editor.getDocument();\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).dataset.direction;\n        }\n\n        this.stopEvent(e);\n    };\n\n    private doResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            let widthChange = e.pageX - this.startPageX;\n            let heightChange = e.pageY - this.startPageY;\n            let newWidth = this.calculateNewWidth(widthChange);\n            let newHeight = this.calculateNewHeight(heightChange);\n            const isSingleDirection =\n                this.isSingleDirectionNS(this.direction) ||\n                this.isSingleDirectionWE(this.direction);\n            const shouldPreserveRatio =\n                !isSingleDirection && (this.forcePreserveRatio || e.shiftKey);\n\n            if (shouldPreserveRatio) {\n                newHeight = Math.min(newHeight, (newWidth * this.startHeight) / this.startWidth);\n                newWidth = Math.min(newWidth, (newHeight * this.startWidth) / this.startHeight);\n\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n                if (ratio > 0) {\n                    if (newWidth < newHeight * ratio) {\n                        newWidth = newHeight * ratio;\n                    } else {\n                        newHeight = newWidth / ratio;\n                    }\n                }\n            }\n\n            img.style.width = newWidth + 'px';\n            img.style.height = newHeight + 'px';\n\n            // double check\n            if (shouldPreserveRatio) {\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n\n                const clientWidth = Math.floor(img.clientWidth);\n                const clientHeight = Math.floor(img.clientHeight);\n                newWidth = Math.floor(newWidth);\n                newHeight = Math.floor(newHeight);\n                if (clientHeight !== newHeight || clientWidth !== newWidth) {\n                    if (clientHeight < newHeight) {\n                        newWidth = clientHeight * ratio;\n                    } else {\n                        newHeight = clientWidth / ratio;\n                    }\n                    img.style.width = newWidth + 'px';\n                    img.style.height = newHeight + 'px';\n                }\n            }\n        }\n        this.stopEvent(e);\n    };\n\n    private calculateNewWidth(widthChange: number): number {\n        let newWidth = this.startWidth;\n        if (!this.isSingleDirectionNS(this.direction)) {\n            newWidth = Math.max(\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\n                this.minWidth\n            );\n        }\n        return newWidth;\n    }\n\n    private calculateNewHeight(heightChange: number): number {\n        let newHeight = this.startHeight;\n        if (!this.isSingleDirectionWE(this.direction)) {\n            newHeight = Math.max(\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\n                this.minHeight\n            );\n        }\n        return newHeight;\n    }\n\n    private finishResize = (e: MouseEvent) => {\n        var img = this.getSelectedImage() as HTMLImageElement;\n        if (this.editor && img) {\n            let document = this.editor.getDocument();\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            let width = img.clientWidth;\n            let height = img.clientHeight;\n            img.style.width = width + 'px';\n            img.style.height = height + 'px';\n            img.width = width;\n            img.height = height;\n            this.resizeDiv.style.width = '';\n            this.resizeDiv.style.height = '';\n        }\n        this.direction = null;\n        this.editor.addUndoSnapshot();\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize, img);\n        this.stopEvent(e);\n    };\n\n    private createResizeDiv(target: HTMLElement) {\n        const { wrapper } = insertEntity(\n            this.editor,\n            ENTITY_TYPE,\n            target,\n            false /*isBlock*/,\n            true /*isReadonly*/\n        );\n\n        wrapper.style.position = 'relative';\n        wrapper.style.display = Browser.isSafari ? 'inline-block' : 'inline-flex';\n\n        const html =\n            (this.editor.isFeatureEnabled(ExperimentalFeatures.SingleDirectionResize)\n                ? ALL_HANDLE_POSITIONS\n                : CORNER_HANDLE_POSITIONS\n            )\n                .map(\n                    pos =>\n                        `<div style=\"position:absolute;${this.isWest(pos) ? 'left' : 'right'}:${\n                            this.isSingleDirectionNS(pos) ? '50%' : '0px'\n                        };${this.isNorth(pos) ? 'top' : 'bottom'}:${\n                            this.isSingleDirectionWE(pos) ? '50%' : '0px'\n                        }\">\n                            <div id=${pos}-handle data-direction=\"${pos}\" style=\"position:relative;width:${HANDLE_SIZE}px;height:${HANDLE_SIZE}px;background-color: ${\n                            this.selectionBorderColor\n                        };cursor: ${pos}-resize;${\n                            this.isNorth(pos) ? 'top' : 'bottom'\n                        }:-${HANDLE_MARGIN}px;${\n                            this.isWest(pos) ? 'left' : 'right'\n                        }:-${HANDLE_MARGIN}px\"></div></div>`\n                )\n                .join('') +\n            `<div style=\"position:absolute;left:0;right:0;top:0;bottom:0;border:solid 1px ${this.selectionBorderColor};pointer-events:none;\">`;\n\n        fromHtml(html, this.editor.getDocument()).forEach(div => {\n            wrapper.appendChild(div);\n            div.addEventListener('mousedown', this.startResize);\n        });\n\n        // If the resizeDiv's image has a transform, apply it to the container\n        const selectedImage = this.getSelectedImage(wrapper);\n        if (selectedImage && selectedImage.style && selectedImage.style.transform) {\n            wrapper.style.transform = selectedImage.style.transform;\n            selectedImage.style.transform = '';\n        }\n\n        return wrapper;\n    }\n\n    private stopEvent = (e: Event) => {\n        e.stopPropagation();\n        e.preventDefault();\n    };\n\n    private removeResizeDiv = (resizeDiv: HTMLElement): HTMLImageElement => {\n        if (resizeDiv?.parentNode) {\n            const img = resizeDiv.querySelector('img');\n            if (img) {\n                resizeDiv.parentNode.insertBefore(img, resizeDiv);\n            }\n            resizeDiv.parentNode.removeChild(resizeDiv);\n            return img;\n        } else {\n            return null;\n        }\n    };\n\n    private onBlur = (e: FocusEvent) => {\n        this.hideResizeHandle();\n    };\n\n    private getSelectedImage(div?: HTMLElement): HTMLElement {\n        const divWithImage = div || this.resizeDiv;\n        return divWithImage ? <HTMLElement>divWithImage.getElementsByTagName('IMG')[0] : null;\n    }\n\n    private isNorth(direction: string): boolean {\n        return direction && direction.substr(0, 1) == 'n';\n    }\n\n    private isWest(direction: string): boolean {\n        return direction && (direction.substr(1, 1) == 'w' || direction == 'w');\n    }\n\n    private isSingleDirectionNS(direction: string): boolean {\n        return direction && (direction == 'n' || direction == 's');\n    }\n\n    private isSingleDirectionWE(direction: string): boolean {\n        return direction && (direction == 'w' || direction == 'e');\n    }\n\n    private onDragStart = (e: DragEvent) => {\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\n            this.hideResizeHandle(true);\n        }\n    };\n}\n","export * from './plugins/Picker/index';\n","export { default as PickerPlugin } from './PickerPlugin';\n","import { replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    Browser,\n    createRange,\n    isCharacterValue,\n    isModifierKey,\n    PartialInlineElement,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    NodePosition,\n    PickerDataProvider,\n    PickerPluginOptions,\n    PluginDomEvent,\n    PluginEvent,\n    PluginEventType,\n    PluginInputEvent,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n// Character codes.\n// IE11 uses different character codes. which are noted below.\n// If adding a new key, test in IE to figure out what the code is.\nconst BACKSPACE_CHARCODE = 'Backspace';\nconst TAB_CHARCODE = 'Tab';\nconst ENTER_CHARCODE = 'Enter';\nconst ESC_CHARCODE = !Browser.isIE ? 'Escape' : 'Esc';\nconst LEFT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\nconst UP_ARROW_CHARCODE = !Browser.isIE ? 'ArrowUp' : 'Up';\nconst RIGHT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowRight' : 'Right';\nconst DOWN_ARROW_CHARCODE = !Browser.isIE ? 'ArrowDown' : 'Down';\nconst DELETE_CHARCODE = !Browser.isIE ? 'Delete' : 'Del';\n\n// Input event input types.\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\n\n// Unidentified key, the code for Android keyboard events.\nconst UNIDENTIFIED_KEY = 'Unidentified';\n// the char code for Android keyboard events on Webview below 51.\nconst UNIDENTIFIED_CODE = [0, 229];\n\n/**\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\n * - Show picker when special trigger key is pressed\n * - Hide picker\n * - Change selection in picker by Up/Down/Left/Right\n * - Apply selected item in picker\n *\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\n * To show a picker UI, you need to build your own UI component. Please reference to\n * https://github.com/microsoft/roosterjs/tree/master/demo/scripts/controls/samplepicker\n */\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\n    implements EditorPlugin {\n    private editor: IEditor;\n    private eventHandledOnKeyDown: boolean;\n    private blockSuggestions: boolean;\n    private isSuggesting: boolean;\n    private lastKnownRange: Range;\n\n    // For detecting backspace in Android\n    private isPendingInputEventHandling: boolean = false;\n    private currentInputLength: number;\n    private newInputLength: number;\n\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) {}\n\n    /**\n     * Get a friendly name\n     */\n    getName() {\n        return 'Picker';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    public initialize(editor: IEditor) {\n        this.editor = editor;\n        this.dataProvider.onInitalize(\n            (htmlNode: Node) => {\n                this.editor.focus();\n\n                let wordToReplace = this.getWord(null);\n\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\n                // We fall back to using the lastKnownRange to try to get around this.\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\n                    this.editor.select(this.lastKnownRange);\n                    wordToReplace = this.getWord(null);\n                }\n\n                let insertNode = () => {\n                    if (wordToReplace) {\n                        replaceWithNode(\n                            this.editor,\n                            wordToReplace,\n                            htmlNode,\n                            true /* exactMatch */\n                        );\n                    } else {\n                        this.editor.insertNode(htmlNode);\n                    }\n                    this.setIsSuggesting(false);\n                };\n\n                this.editor.addUndoSnapshot(\n                    insertNode,\n                    this.pickerOptions.changeSource,\n                    this.pickerOptions.handleAutoComplete\n                );\n            },\n            (isSuggesting: boolean) => {\n                this.setIsSuggesting(isSuggesting);\n            },\n            editor\n        );\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose() {\n        this.editor = null;\n        this.dataProvider.onDispose();\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check\n     */\n    public willHandleEventExclusively(event: PluginEvent) {\n        return (\n            this.isSuggesting &&\n            (event.eventType == PluginEventType.KeyDown ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.Input)\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.ContentChanged:\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\n                    // Stop suggesting since content is fully changed\n                    if (this.isSuggesting) {\n                        this.setIsSuggesting(false);\n                    }\n\n                    // Undos and other major changes to document content fire this type of event.\n                    // Inform the data provider of the current picker placed elements in the body.\n                    let elementIds: string[] = [];\n                    this.editor.queryElements(\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\n                        element => {\n                            if (element.id) {\n                                elementIds.push(element.id);\n                            }\n                        }\n                    );\n                    this.dataProvider.onContentChanged(elementIds);\n                }\n                break;\n\n            case PluginEventType.KeyDown:\n                this.eventHandledOnKeyDown = false;\n                if (this.isAndroidKeyboardEvent(event)) {\n                    // On Android, the key for KeyboardEvent is \"Unidentified\" or undefined,\n                    // so handling should be done using the input rather than key down event\n                    // Since the key down event happens right before the input event, calculate the input\n                    // length here in preparation for onAndroidInputEvent\n                    this.currentInputLength = this.calcInputLength(event);\n                    this.isPendingInputEventHandling = true;\n                } else {\n                    this.onKeyDownEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.Input:\n                if (this.isPendingInputEventHandling) {\n                    this.onAndroidInputEvent(event);\n                }\n                break;\n\n            case PluginEventType.KeyUp:\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\n                    this.onKeyUpDomEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.MouseUp:\n                if (this.isSuggesting) {\n                    this.setIsSuggesting(false);\n                }\n                break;\n\n            case PluginEventType.Scroll:\n                if (this.dataProvider.onScroll) {\n                    // Dispatch scroll event to data provider\n                    this.dataProvider.onScroll(event.scrollContainer);\n                }\n                break;\n        }\n    }\n\n    private setLastKnownRange(range: Range) {\n        this.lastKnownRange = range;\n    }\n\n    private setIsSuggesting(isSuggesting: boolean) {\n        this.isSuggesting = isSuggesting;\n\n        if (!isSuggesting) {\n            this.setLastKnownRange(null);\n        }\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\n\n        this.setAriaOwns(isSuggesting);\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\n    }\n\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\n        this.eventHandledOnKeyDown = true;\n        event.rawEvent.preventDefault();\n        event.rawEvent.stopImmediatePropagation();\n    }\n\n    private getIdValue(node: Node): string {\n        let element = node as Element;\n        return element.attributes && element.attributes.getNamedItem('id')\n            ? (element.attributes.getNamedItem('id').value as string)\n            : null;\n    }\n\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\n        let searcher = this.editor.getContentSearcherOfCursor(event);\n        return searcher ? searcher.getWordBefore() : null;\n    }\n\n    private replaceNode(currentNode: Node, replacementNode: Node) {\n        if (currentNode) {\n            this.editor.deleteNode(currentNode);\n        }\n        if (replacementNode) {\n            this.editor.insertNode(replacementNode);\n        }\n    }\n\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\n        let positionContentSearcher = this.editor.getContentSearcherOfCursor(event);\n        let startPos: NodePosition;\n        let endPos: NodePosition;\n        positionContentSearcher.forEachTextInlineElement(textInline => {\n            let hasMatched = false;\n            let nodeContent = textInline.getTextContent();\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\n            while (nodeIndex >= 0) {\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\n                    startPos = textInline.getStartPosition().move(nodeIndex);\n                    hasMatched = true;\n                    break;\n                }\n                nodeIndex--;\n            }\n\n            if (hasMatched) {\n                endPos = textInline.getEndPosition();\n            }\n\n            return hasMatched;\n        });\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\n    }\n\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\" or undefined\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\n        return (\n            this.isAndroidKeyboardEvent(event) ||\n            isCharacterValue(event.rawEvent) ||\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\n        );\n    }\n\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\n        if (this.isSuggesting) {\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\n            const wordBeforeCursor = this.getWord(event);\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n\n            // If we hit a case where wordBeforeCursor is just the trigger character,\n            // that means we've gotten a onKeyUp event right after it's been typed.\n            // Otherwise, update the query string when:\n            // 1. There's an actual value\n            // 2. That actual value isn't just pure whitespace\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\n            // Otherwise, we want to dismiss the picker plugin's UX.\n            if (\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\n                (trimmedWordBeforeCursor &&\n                    trimmedWordBeforeCursor.length > 0 &&\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\n            ) {\n                this.dataProvider.queryStringUpdated(\n                    trimmedWordBeforeCursor,\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                );\n                this.setLastKnownRange(this.editor.getSelectionRange());\n            } else {\n                this.setIsSuggesting(false);\n            }\n        } else {\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\n            if (!this.blockSuggestions) {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor.split(' ').length <= 4 &&\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\n                ) {\n                    this.setIsSuggesting(true);\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n                    this.dataProvider.queryStringUpdated(\n                        trimmedWordBeforeCursor,\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                    );\n                    this.setLastKnownRange(this.editor.getSelectionRange());\n                    if (this.dataProvider.setCursorPoint) {\n                        // Determine the bounding rectangle for the @mention\n                        let searcher = this.editor.getContentSearcherOfCursor(event);\n                        let rangeNode = this.editor.getDocument().createRange();\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\n                        let rangeStartSuccessfullySet = this.setRangeStart(\n                            rangeNode,\n                            nodeBeforeCursor,\n                            wordBeforeCursor\n                        );\n                        if (!rangeStartSuccessfullySet) {\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\n                            // is not including the trigger character. In this case, the node before\n                            // the node before cursor is the trigger character, and this is where the range should start.\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\n                            this.setRangeStart(\n                                rangeNode,\n                                nodeBeforeNodeBeforeCursor,\n                                this.pickerOptions.triggerCharacter\n                            );\n                        }\n                        let rect = rangeNode.getBoundingClientRect();\n\n                        // Safari's support for range.getBoundingClientRect is incomplete.\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\n                            rect = rangeNode.getClientRects()[0];\n                        }\n\n                        if (rect) {\n                            rangeNode.detach();\n\n                            // Display the @mention popup in the correct place\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\n                            let bufferZone = (rect.bottom - rect.top) / 2;\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\n                        }\n                    }\n                }\n            } else {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\n                ) {\n                    this.blockSuggestions = false;\n                }\n            }\n        }\n    }\n\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\n        let keyboardEvent = event.rawEvent;\n        if (this.isSuggesting) {\n            if (keyboardEvent.key == ESC_CHARCODE) {\n                this.setIsSuggesting(false);\n                this.blockSuggestions = true;\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                // #483: If we are backspacing over the trigger character that triggered this Picker\n                // then we need to hide the Picker\n                const wordBeforeCursor = this.getWord(event);\n                if (wordBeforeCursor == this.pickerOptions.triggerCharacter) {\n                    this.setIsSuggesting(false);\n                }\n            } else if (\n                this.dataProvider.shiftHighlight &&\n                (this.pickerOptions.isHorizontal\n                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||\n                      keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                    : keyboardEvent.key == UP_ARROW_CHARCODE ||\n                      keyboardEvent.key == DOWN_ARROW_CHARCODE)\n            ) {\n                this.dataProvider.shiftHighlight(\n                    this.pickerOptions.isHorizontal\n                        ? keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                        : keyboardEvent.key == DOWN_ARROW_CHARCODE\n                );\n\n                if (this.dataProvider.getSelectedIndex) {\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\n                }\n\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (\n                this.dataProvider.selectOption &&\n                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)\n            ) {\n                this.dataProvider.selectOption();\n                this.cancelDefaultKeyDownEvent(event);\n            } else {\n                // Currently no op.\n            }\n        } else {\n            if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                const nodeRemoved = this.tryRemoveNode(event);\n                if (nodeRemoved) {\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            } else if (keyboardEvent.key == DELETE_CHARCODE) {\n                let searcher = this.editor.getContentSearcherOfCursor(event);\n                let nodeAfterCursor = searcher.getInlineElementAfter()\n                    ? searcher.getInlineElementAfter().getContainerNode()\n                    : null;\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\n                    this.replaceNode(nodeAfterCursor, replacementNode);\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            }\n        }\n    }\n\n    private onAndroidInputEvent(event: PluginInputEvent) {\n        this.newInputLength = this.calcInputLength(event);\n\n        if (\n            this.newInputLength < this.currentInputLength ||\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\n        ) {\n            const nodeRemoved = this.tryRemoveNode(event);\n            if (nodeRemoved) {\n                this.eventHandledOnKeyDown = true;\n            }\n        }\n    }\n\n    private calcInputLength(event: PluginEvent) {\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\n        return wordBeforCursor ? wordBeforCursor.length : 0;\n    }\n\n    private tryRemoveNode(event: PluginDomEvent): boolean {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const nodeBeforeCursor = inlineElementBefore\n            ? inlineElementBefore.getContainerNode()\n            : null;\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\n        const inlineElementAfter = searcher.getInlineElementAfter();\n\n        if (\n            nodeId &&\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\n        ) {\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\n            if (replacementNode) {\n                this.replaceNode(nodeBeforeCursor, replacementNode);\n                if (this.isPendingInputEventHandling) {\n                    this.editor.runAsync(editor => {\n                        editor.select(replacementNode, PositionType.After);\n                    });\n                } else {\n                    this.editor.select(replacementNode, PositionType.After);\n                }\n            } else {\n                this.editor.deleteNode(nodeBeforeCursor);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private getWord(event: PluginKeyboardEvent) {\n        let wordFromRange = this.getRangeUntilAt(event).toString();\n        let wordFromCache = this.getWordBeforeCursor(event);\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\n        // so wordFromCache is what we want to return.\n        if (\n            wordFromRange == this.pickerOptions.triggerCharacter &&\n            wordFromRange != wordFromCache\n        ) {\n            return wordFromCache;\n        }\n        return wordFromRange;\n    }\n\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\n        if (nodeOffset > -1) {\n            rangeNode.setStart(node, nodeOffset);\n            return true;\n        }\n        return false;\n    }\n\n    private setAriaOwns(isSuggesting: boolean) {\n        this.editor.setEditorDomAttribute(\n            'aria-owns',\n            isSuggesting && this.pickerOptions.suggestionsLabel\n                ? this.pickerOptions.suggestionsLabel\n                : null\n        );\n    }\n\n    private setAriaActiveDescendant(selectedIndex: number) {\n        this.editor.setEditorDomAttribute(\n            'aria-activedescendant',\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\n                : null\n        );\n    }\n\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const element = searcher ? searcher.getInlineElementBefore() : null;\n        return element ? element.getTextContent() : null;\n    }\n\n    private isAndroidKeyboardEvent(event: PluginKeyboardEvent): boolean {\n        // Check keyboard events on Android for further handling.\n        // On Android Webview later 51, the KeyboardEvent's key is \"Unidentified\".\n        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,\n        // so using the charCode property, which is 0 or 229.\n        return (\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\n            (event.rawEvent.key == undefined &&\n                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1)\n        );\n    }\n}\n","export * from './plugins/TableResize/index';\n","export { default as TableResize } from './TableResize';\n","import { fromHtml, getComputedStyle, normalizeRect, VTable } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    Rect,\n    ChangeSource,\n    TableOperation,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst INSERTER_COLOR = '#4A4A4A';\nconst INSERTER_COLOR_DARK_MODE = 'white';\nconst INSERTER_SIDE_LENGTH = 12;\nconst INSERTER_BORDER_SIZE = 1;\nconst INSERTER_HOVER_OFFSET = 5;\nconst MIN_CELL_WIDTH = 30;\nconst CELL_RESIZER_WIDTH = 4;\nconst HORIZONTAL_RESIZER_HTML =\n    '<div style=\"position: fixed; cursor: row-resize; user-select: none\"></div>';\nconst VERTICAL_RESIZER_HTML =\n    '<div style=\"position: fixed; cursor: col-resize; user-select: none\"></div>';\n\nconst enum ResizeState {\n    None,\n    Horizontal,\n    Vertical,\n}\n\n/**\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\n */\nexport default class TableResize implements EditorPlugin {\n    private editor: IEditor;\n    private onMouseMoveDisposer: () => void;\n    private tableRectMap: { table: HTMLTableElement; rect: Rect }[] = null;\n    private resizerContainer: HTMLDivElement;\n    private currentTable: HTMLTableElement;\n    private currentTd: HTMLTableCellElement;\n    private currentCellsToResize: HTMLTableCellElement[] = [];\n    private nextCellsToResize: HTMLTableCellElement[] = [];\n    private horizontalResizer: HTMLDivElement;\n    private verticalResizer: HTMLDivElement;\n    private resizingState: ResizeState = ResizeState.None;\n\n    private currentInsertTd: HTMLTableCellElement;\n    private insertingState: ResizeState = ResizeState.None;\n    private inserter: HTMLDivElement;\n    private isRTL: boolean;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TableResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.setupResizerContainer();\n        this.onMouseMoveDisposer = this.editor.addDomEventHandler('mousemove', this.onMouseMove);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onMouseMoveDisposer();\n        this.destoryRectMap();\n        this.removeResizerContainer();\n\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        switch (e.eventType) {\n            case PluginEventType.Input:\n            case PluginEventType.ContentChanged:\n            case PluginEventType.Scroll:\n                this.destoryRectMap();\n                break;\n        }\n    }\n\n    private setupResizerContainer() {\n        this.resizerContainer = this.editor.getDocument().createElement('div');\n        this.editor.insertNode(this.resizerContainer, {\n            updateCursor: false,\n            insertOnNewLine: false,\n            replaceSelection: false,\n            position: ContentPosition.Outside,\n        });\n    }\n\n    private removeResizerContainer() {\n        this.resizerContainer.parentNode.removeChild(this.resizerContainer);\n        this.resizerContainer = null;\n    }\n\n    private onMouseMove = (e: MouseEvent) => {\n        if (this.resizingState != ResizeState.None) {\n            return;\n        }\n\n        if (!this.tableRectMap) {\n            this.cacheRects();\n        }\n\n        if (this.tableRectMap) {\n            let i = this.tableRectMap.length - 1;\n            for (; i >= 0; i--) {\n                const { table, rect } = this.tableRectMap[i];\n\n                if (\n                    e.pageX <= rect.right + (this.isRTL ? INSERTER_SIDE_LENGTH : 0) &&\n                    e.pageX >= rect.left - (this.isRTL ? 0 : INSERTER_SIDE_LENGTH) &&\n                    e.pageY >= rect.top - INSERTER_SIDE_LENGTH &&\n                    e.pageY <= rect.bottom\n                ) {\n                    this.setCurrentTable(table, rect);\n                    break;\n                }\n            }\n\n            if (i < 0) {\n                this.setCurrentTable(null);\n            }\n\n            if (this.currentTable) {\n                const map = this.tableRectMap.filter(map => map.table == this.currentTable)[0];\n\n                for (let i = 0; i < this.currentTable.rows.length; i++) {\n                    const tr = this.currentTable.rows[i];\n\n                    let j = 0;\n                    for (; j < tr.cells.length; j++) {\n                        const td = tr.cells[j];\n                        const tdRect = normalizeRect(td.getBoundingClientRect());\n\n                        if (\n                            tdRect &&\n                            (this.isRTL ? e.pageX >= tdRect.left : e.pageX <= tdRect.right) &&\n                            e.pageY <= tdRect.bottom\n                        ) {\n                            // check vertical isnerter\n                            if (i == 0 && e.pageY <= tdRect.top + INSERTER_HOVER_OFFSET) {\n                                let verticalInserterTd: HTMLTableCellElement = null;\n                                // set inserter at current td\n                                if (\n                                    this.isRTL\n                                        ? e.pageX <=\n                                          tdRect.left + (tdRect.right - tdRect.left) / 2.0\n                                        : e.pageX >=\n                                          tdRect.left + (tdRect.right - tdRect.left) / 2.0\n                                ) {\n                                    verticalInserterTd = td;\n                                } else if (\n                                    this.isRTL ? e.pageX <= tdRect.right : e.pageX >= tdRect.left\n                                ) {\n                                    // set inserter at previous td if it exists\n                                    const preTd = td.previousElementSibling as HTMLTableCellElement;\n                                    if (preTd) {\n                                        verticalInserterTd = preTd;\n                                    }\n                                }\n                                if (verticalInserterTd) {\n                                    this.setCurrentTd(null);\n                                    this.setCurrentInsertTd(\n                                        ResizeState.Vertical,\n                                        verticalInserterTd,\n                                        map.rect\n                                    );\n                                    break;\n                                }\n                                // check horizontal inserter\n                            } else if (\n                                j == 0 &&\n                                (this.isRTL\n                                    ? e.pageX >= tdRect.right - INSERTER_HOVER_OFFSET\n                                    : e.pageX <= tdRect.left + INSERTER_HOVER_OFFSET)\n                            ) {\n                                let horizontalInserterTd: HTMLTableCellElement = null;\n                                // set inserter at current td\n                                if (e.pageY >= tdRect.top + (tdRect.bottom - tdRect.top) / 2.0) {\n                                    horizontalInserterTd = td;\n                                } else if (e.pageY >= tdRect.top) {\n                                    // set insert at previous td if it exists\n                                    const preTd = this.currentTable.rows[i - 1]?.cells[0];\n                                    if (preTd) {\n                                        horizontalInserterTd = preTd;\n                                    }\n                                }\n\n                                if (horizontalInserterTd) {\n                                    this.setCurrentTd(null);\n                                    this.setCurrentInsertTd(\n                                        ResizeState.Horizontal,\n                                        horizontalInserterTd,\n                                        map.rect\n                                    );\n                                    break;\n                                }\n                            } else {\n                                this.setCurrentTd(\n                                    td,\n                                    map.rect,\n                                    this.isRTL ? tdRect.left : tdRect.right,\n                                    tdRect.bottom\n                                );\n                                this.setCurrentInsertTd(ResizeState.None);\n                                break;\n                            }\n                        }\n                    }\n                    if (j < tr.cells.length) {\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n    private setCurrentInsertTd(insertingState: ResizeState.None): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td: HTMLTableCellElement,\n        tableRect: Rect\n    ): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td?: HTMLTableCellElement,\n        tableRect?: Rect\n    ) {\n        if (td != this.currentInsertTd || insertingState != this.insertingState) {\n            if (this.currentInsertTd) {\n                this.resizerContainer.removeChild(this.inserter);\n                this.inserter = null;\n            }\n            this.insertingState = insertingState;\n            this.currentInsertTd = td;\n            if (this.currentInsertTd) {\n                this.inserter = this.createInserter(tableRect);\n                this.resizerContainer.appendChild(this.inserter);\n            }\n        }\n    }\n\n    private createInserter(tableRect: Rect) {\n        if (this.insertingState == ResizeState.None) {\n            return;\n        }\n\n        const rect = normalizeRect(this.currentInsertTd.getBoundingClientRect());\n        const editorBackgroundColor = this.editor.getDefaultFormat().backgroundColor;\n        const inserterBackgroundColor = editorBackgroundColor || 'white';\n        const inserterColor = this.editor.isDarkMode() ? INSERTER_COLOR_DARK_MODE : INSERTER_COLOR;\n        const leftOrRight = this.isRTL ? 'right' : 'left';\n\n        const HORIZONTAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${inserterColor}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${inserterColor}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; ${leftOrRight}: 12px; top: 5px; height: 3px; border-top: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-left: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\n        const VERTICAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${inserterColor}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${inserterColor}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; left: 5px; top: 12px; width: 3px; border-left: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-top: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\n\n        const inserter = fromHtml(\n            this.insertingState == ResizeState.Horizontal\n                ? HORIZONTAL_INSERTER_HTML\n                : VERTICAL_INSERTER_HTML,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n\n        if (rect) {\n            if (this.insertingState == ResizeState.Horizontal) {\n                if (this.isRTL) {\n                    inserter.style.left = `${rect.right}px`;\n                } else {\n                    inserter.style.left = `${\n                        rect.left - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                    }px`;\n                }\n                inserter.style.top = `${rect.bottom - 8}px`;\n                (inserter.firstChild as HTMLElement).style.width = `${\n                    tableRect.right - tableRect.left\n                }px`;\n            } else {\n                if (this.isRTL) {\n                    inserter.style.left = `${rect.left - 8}px`;\n                } else {\n                    inserter.style.left = `${rect.right - 8}px`;\n                }\n                inserter.style.top = `${\n                    rect.top - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                }px`;\n                (inserter.firstChild as HTMLElement).style.height = `${\n                    tableRect.bottom - tableRect.top\n                }px`;\n            }\n        }\n\n        inserter.addEventListener('click', this.insertTd);\n\n        return inserter;\n    }\n\n    private insertTd = () => {\n        this.editor.addUndoSnapshot((start, end) => {\n            const vtable = new VTable(this.currentInsertTd);\n            vtable.edit(\n                this.insertingState == ResizeState.Horizontal\n                    ? TableOperation.InsertBelow\n                    : TableOperation.InsertRight\n            );\n            vtable.writeBack();\n            this.editor.select(start, end);\n            this.setCurrentInsertTd(ResizeState.None);\n        }, ChangeSource.Format);\n    };\n\n    private setCurrentTable(table: HTMLTableElement, rect: Rect): void;\n    private setCurrentTable(table: null): void;\n    private setCurrentTable(table: HTMLTableElement, rect?: Rect) {\n        if (this.currentTable != table) {\n            this.setCurrentTd(null);\n            this.setCurrentInsertTd(ResizeState.None);\n            this.currentTable = table;\n        }\n    }\n\n    private setCurrentTd(td: null): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect: Rect,\n        resizerPosX: number,\n        bottom: number\n    ): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect?: Rect,\n        resizerPosX?: number,\n        bottom?: number\n    ) {\n        if (this.currentTd != td) {\n            if (this.currentTd) {\n                this.resizerContainer.removeChild(this.horizontalResizer);\n                this.resizerContainer.removeChild(this.verticalResizer);\n                this.horizontalResizer = null;\n                this.verticalResizer = null;\n            }\n\n            this.currentTd = td;\n\n            if (this.currentTd) {\n                this.horizontalResizer = this.createResizer(\n                    true /*horizontal*/,\n                    tableRect.left,\n                    bottom - CELL_RESIZER_WIDTH + 1,\n                    tableRect.right - tableRect.left,\n                    CELL_RESIZER_WIDTH\n                );\n                this.verticalResizer = this.createResizer(\n                    false /*horizontal*/,\n                    resizerPosX - CELL_RESIZER_WIDTH + 1,\n                    tableRect.top,\n                    CELL_RESIZER_WIDTH,\n                    tableRect.bottom - tableRect.top\n                );\n\n                this.resizerContainer.appendChild(this.horizontalResizer);\n                this.resizerContainer.appendChild(this.verticalResizer);\n            }\n        }\n    }\n\n    private createResizer(\n        horizontal: boolean,\n        left: number,\n        top: number,\n        width: number,\n        height: number\n    ) {\n        const div = fromHtml(\n            horizontal ? HORIZONTAL_RESIZER_HTML : VERTICAL_RESIZER_HTML,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n        div.style.top = `${top}px`;\n        div.style.left = `${left}px`;\n        div.style.width = `${width}px`;\n        div.style.height = `${height}px`;\n\n        div.addEventListener(\n            'mousedown',\n            horizontal ? this.startHorizontalResizeTable : this.startVerticalResizeTable\n        );\n\n        return div;\n    }\n\n    private startHorizontalResizeTable = (e: MouseEvent) => {\n        this.resizingState = ResizeState.Horizontal;\n        this.startResizeTable(e);\n    };\n\n    private startVerticalResizeTable = (e: MouseEvent) => {\n        this.resizingState = ResizeState.Vertical;\n\n        const vtable = new VTable(this.currentTd);\n        if (vtable) {\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\n\n            // calculate and retrieve the cells of the two columns shared by the current vertical resizer\n            this.currentCellsToResize = vtable.getCellsWithBorder(\n                this.isRTL ? rect.left : rect.right,\n                !this.isRTL\n            );\n            this.nextCellsToResize = vtable.getCellsWithBorder(\n                this.isRTL ? rect.left : rect.right,\n                this.isRTL\n            );\n        }\n\n        this.startResizeTable(e);\n    };\n\n    private startResizeTable(e: MouseEvent) {\n        const doc = this.editor.getDocument();\n        doc.addEventListener('mousemove', this.frameAnimateResizeTable, true);\n        doc.addEventListener('mouseup', this.endResizeTable, true);\n    }\n\n    private frameAnimateResizeTable = (e: MouseEvent) => {\n        this.editor.runAsync(() => this.resizeTable(e));\n    };\n\n    private resizeTable = (e: MouseEvent) => {\n        if (this.currentTd && this.resizingState !== ResizeState.None) {\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\n\n            if (rect) {\n                const newPos = this.resizingState == ResizeState.Horizontal ? e.pageY : e.pageX;\n\n                let vtable = new VTable(this.currentTd);\n\n                if (this.resizingState == ResizeState.Horizontal) {\n                    vtable.table.style.height = null;\n                    vtable.forEachCellOfCurrentRow(cell => {\n                        if (cell.td) {\n                            cell.td.style.height =\n                                cell.td == this.currentTd ? `${newPos - rect.top}px` : null;\n                        }\n                    });\n                } else {\n                    let leftBoundary: number;\n                    let rightBoundary: number;\n\n                    if (this.isRTL) {\n                        leftBoundary =\n                            this.nextCellsToResize.length > 0\n                                ? parseInt(\n                                      this.nextCellsToResize[0].getAttribute('originalLeftBorder')\n                                  )\n                                : 0;\n                        rightBoundary = parseInt(\n                            this.currentCellsToResize[0].getAttribute('originalRightBorder')\n                        );\n                    } else {\n                        leftBoundary = parseInt(\n                            this.currentCellsToResize[0].getAttribute('originalLeftBorder')\n                        );\n                        rightBoundary =\n                            this.nextCellsToResize.length > 0\n                                ? parseInt(\n                                      this.nextCellsToResize[0].getAttribute('originalRightBorder')\n                                  )\n                                : Number.MAX_SAFE_INTEGER;\n                    }\n\n                    if (\n                        newPos <= leftBoundary + MIN_CELL_WIDTH ||\n                        newPos >= rightBoundary - MIN_CELL_WIDTH\n                    ) {\n                        return;\n                    }\n\n                    this.currentCellsToResize.forEach(td => {\n                        const rect = normalizeRect(td.getBoundingClientRect());\n                        td.style.wordBreak = 'break-word';\n                        td.style.boxSizing = 'border-box';\n                        td.style.width = this.isRTL\n                            ? `${rect.right - newPos}px`\n                            : `${newPos - rect.left}px`;\n                    });\n\n                    this.nextCellsToResize.forEach(td => {\n                        td.style.wordBreak = 'break-word';\n                        const tdWidth = this.isRTL\n                            ? newPos - parseInt(td.getAttribute('originalLeftBorder'))\n                            : parseInt(td.getAttribute('originalRightBorder')) - newPos;\n                        td.style.boxSizing = 'border-box';\n                        td.style.width = `${tdWidth}px`;\n                    });\n                }\n                vtable.writeBack();\n            }\n        }\n    };\n\n    private endResizeTable = (e: MouseEvent) => {\n        const doc = this.editor.getDocument();\n        doc.removeEventListener('mousemove', this.frameAnimateResizeTable, true);\n        doc.removeEventListener('mouseup', this.endResizeTable, true);\n        this.currentCellsToResize = [];\n        this.nextCellsToResize = [];\n\n        this.editor.addUndoSnapshot((start, end) => {\n            this.frameAnimateResizeTable(e);\n            this.editor.select(start, end);\n        }, ChangeSource.Format);\n\n        this.setCurrentTd(null);\n        this.resizingState = ResizeState.None;\n    };\n\n    private destoryRectMap() {\n        this.setCurrentTable(null);\n        this.tableRectMap = null;\n    }\n\n    private cacheRects() {\n        this.destoryRectMap();\n        this.tableRectMap = [];\n        this.editor.queryElements('table', table => {\n            if (table.isContentEditable) {\n                const rect = normalizeRect(table.getBoundingClientRect());\n                if (rect) {\n                    this.tableRectMap.push({\n                        table,\n                        rect,\n                    });\n                }\n            }\n        });\n        this.isRTL = getComputedStyle(this.editor.getDocument().body, 'direction') == 'rtl';\n    }\n}\n","export * from './plugins/Watermark/index';\n","export { default as Watermark } from './Watermark';\n","import { applyFormat, getEntitySelector, getTagOfNode } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    DefaultFormat,\n    EditorPlugin,\n    Entity,\n    EntityOperation,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_TYPE = 'WATERMARK_WRAPPER';\n\n/**\n * A watermark plugin to manage watermark string for roosterjs\n */\nexport default class Watermark implements EditorPlugin {\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create an instance of Watermark plugin\n     * @param watermark The watermark string\n     */\n    constructor(private watermark: string, private format?: DefaultFormat) {\n        this.format = this.format || {\n            fontSize: '14px',\n            textColor: '#aaa',\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Watermark';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            focus: this.showHideWatermark,\n            blur: this.showHideWatermark,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.EditorReady ||\n            (event.eventType == PluginEventType.ContentChanged &&\n                (<Entity>event.data)?.type != ENTITY_TYPE)\n        ) {\n            this.showHideWatermark();\n        } else if (\n            event.eventType == PluginEventType.EntityOperation &&\n            event.entity.type == ENTITY_TYPE\n        ) {\n            const {\n                operation,\n                entity: { wrapper },\n            } = event;\n            if (operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeWatermark(wrapper);\n            } else if (event.operation == EntityOperation.NewEntity) {\n                applyFormat(wrapper, this.format, this.editor.isDarkMode());\n                wrapper.spellcheck = false;\n            }\n        }\n    }\n\n    private showHideWatermark = () => {\n        const hasFocus = this.editor.hasFocus();\n        const watermarks = this.editor.queryElements(getEntitySelector(ENTITY_TYPE));\n        const isShowing = watermarks.length > 0;\n\n        if (hasFocus && isShowing) {\n            watermarks.forEach(this.removeWatermark);\n            this.editor.focus();\n        } else if (!hasFocus && !isShowing && this.editor.isEmpty()) {\n            insertEntity(\n                this.editor,\n                ENTITY_TYPE,\n                this.editor.getDocument().createTextNode(this.watermark),\n                false /*isBlock*/,\n                false /*isReadonly*/,\n                ContentPosition.Begin\n            );\n        }\n    };\n\n    private removeWatermark = (wrapper: HTMLElement) => {\n        const parentNode = wrapper.parentNode;\n        parentNode?.removeChild(wrapper);\n\n        // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\n        if (\n            this.editor.contains(parentNode) &&\n            getTagOfNode(parentNode) == 'DIV' &&\n            !parentNode.firstChild\n        ) {\n            parentNode.appendChild(this.editor.getDocument().createElement('BR'));\n        }\n    };\n}\n"],"sourceRoot":""}