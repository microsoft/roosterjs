{"version":3,"file":"rooster-min.js","mappings":"2CACA,IAAIA,EAAc,EAAQ,MAMtBC,EAAkB,CAAC,EACvB,IAAK,IAAIC,KAAOF,EACXA,EAAYG,eAAeD,KAC9BD,EAAgBD,EAAYE,IAAQA,GAItC,IAAIE,EAAUC,EAAOC,QAAU,CAC9BC,IAAK,CAACC,SAAU,EAAGC,OAAQ,OAC3BC,IAAK,CAACF,SAAU,EAAGC,OAAQ,OAC3BE,IAAK,CAACH,SAAU,EAAGC,OAAQ,OAC3BG,IAAK,CAACJ,SAAU,EAAGC,OAAQ,OAC3BI,KAAM,CAACL,SAAU,EAAGC,OAAQ,QAC5BK,IAAK,CAACN,SAAU,EAAGC,OAAQ,OAC3BM,IAAK,CAACP,SAAU,EAAGC,OAAQ,OAC3BO,IAAK,CAACR,SAAU,EAAGC,OAAQ,OAC3BQ,IAAK,CAACT,SAAU,EAAGC,OAAQ,CAAC,QAC5BS,QAAS,CAACV,SAAU,EAAGC,OAAQ,CAAC,YAChCU,OAAQ,CAACX,SAAU,EAAGC,OAAQ,CAAC,WAC/BW,QAAS,CAACZ,SAAU,EAAGC,OAAQ,CAAC,YAChCY,IAAK,CAACb,SAAU,EAAGC,OAAQ,CAAC,IAAK,IAAK,MACtCa,MAAO,CAACd,SAAU,EAAGC,OAAQ,CAAC,MAAO,MAAO,QAC5Cc,KAAM,CAACf,SAAU,EAAGC,OAAQ,CAAC,UAI9B,IAAK,IAAIe,KAASpB,EACjB,GAAIA,EAAQD,eAAeqB,GAAQ,CAClC,KAAM,aAAcpB,EAAQoB,IAC3B,MAAM,IAAIC,MAAM,8BAAgCD,GAGjD,KAAM,WAAYpB,EAAQoB,IACzB,MAAM,IAAIC,MAAM,oCAAsCD,GAGvD,GAAIpB,EAAQoB,GAAOf,OAAOiB,SAAWtB,EAAQoB,GAAOhB,SACnD,MAAM,IAAIiB,MAAM,sCAAwCD,GAGzD,IAAIhB,EAAWJ,EAAQoB,GAAOhB,SAC1BC,EAASL,EAAQoB,GAAOf,cACrBL,EAAQoB,GAAOhB,gBACfJ,EAAQoB,GAAOf,OACtBkB,OAAOC,eAAexB,EAAQoB,GAAQ,WAAY,CAACK,MAAOrB,IAC1DmB,OAAOC,eAAexB,EAAQoB,GAAQ,SAAU,CAACK,MAAOpB,GACzD,CAGDL,EAAQG,IAAIG,IAAM,SAAUH,GAC3B,IAMIuB,EAEAC,EARAC,EAAIzB,EAAI,GAAK,IACb0B,EAAI1B,EAAI,GAAK,IACb2B,EAAI3B,EAAI,GAAK,IACb4B,EAAMC,KAAKD,IAAIH,EAAGC,EAAGC,GACrBG,EAAMD,KAAKC,IAAIL,EAAGC,EAAGC,GACrBI,EAAQD,EAAMF,EA+BlB,OA1BIE,IAAQF,EACXL,EAAI,EACME,IAAMK,EAChBP,GAAKG,EAAIC,GAAKI,EACJL,IAAMI,EAChBP,EAAI,GAAKI,EAAIF,GAAKM,EACRJ,IAAMG,IAChBP,EAAI,GAAKE,EAAIC,GAAKK,IAGnBR,EAAIM,KAAKD,IAAQ,GAAJL,EAAQ,MAEb,IACPA,GAAK,KAGNC,GAAKI,EAAME,GAAO,EAUX,CAACP,EAAO,KARXO,IAAQF,EACP,EACMJ,GAAK,GACXO,GAASD,EAAMF,GAEfG,GAAS,EAAID,EAAMF,IAGA,IAAJJ,EACrB,EAEA3B,EAAQG,IAAII,IAAM,SAAUJ,GAC3B,IAAIgC,EACAC,EACAC,EACAX,EACAY,EAEAV,EAAIzB,EAAI,GAAK,IACb0B,EAAI1B,EAAI,GAAK,IACb2B,EAAI3B,EAAI,GAAK,IACboC,EAAIP,KAAKC,IAAIL,EAAGC,EAAGC,GACnBU,EAAOD,EAAIP,KAAKD,IAAIH,EAAGC,EAAGC,GAC1BW,EAAQ,SAAUC,GACrB,OAAQH,EAAIG,GAAK,EAAIF,EAAO,EAC7B,EAwBA,OAtBa,IAATA,EACHd,EAAIY,EAAI,GAERA,EAAIE,EAAOD,EACXJ,EAAOM,EAAMb,GACbQ,EAAOK,EAAMZ,GACbQ,EAAOI,EAAMX,GAETF,IAAMW,EACTb,EAAIW,EAAOD,EACDP,IAAMU,EAChBb,EAAK,EAAI,EAAKS,EAAOE,EACXP,IAAMS,IAChBb,EAAK,EAAI,EAAKU,EAAOD,GAElBT,EAAI,EACPA,GAAK,EACKA,EAAI,IACdA,GAAK,IAIA,CACF,IAAJA,EACI,IAAJY,EACI,IAAJC,EAEF,EAEAvC,EAAQG,IAAIK,IAAM,SAAUL,GAC3B,IAAIyB,EAAIzB,EAAI,GACR0B,EAAI1B,EAAI,GACR2B,EAAI3B,EAAI,GAMZ,MAAO,CALCH,EAAQG,IAAIG,IAAIH,GAAK,GACrB,EAAI,IAAM6B,KAAKD,IAAIH,EAAGI,KAAKD,IAAIF,EAAGC,IAI3B,IAAS,KAFxBA,EAAI,EAAI,EAAI,IAAME,KAAKC,IAAIL,EAAGI,KAAKC,IAAIJ,EAAGC,KAG3C,EAEA9B,EAAQG,IAAIM,KAAO,SAAUN,GAC5B,IAMIwC,EANAf,EAAIzB,EAAI,GAAK,IACb0B,EAAI1B,EAAI,GAAK,IACb2B,EAAI3B,EAAI,GAAK,IAWjB,MAAO,CAAK,MAJP,EAAIyB,GADTe,EAAIX,KAAKD,IAAI,EAAIH,EAAG,EAAIC,EAAG,EAAIC,MACZ,EAAIa,IAAM,GAIR,MAHhB,EAAId,EAAIc,IAAM,EAAIA,IAAM,GAGC,MAFzB,EAAIb,EAAIa,IAAM,EAAIA,IAAM,GAEU,IAAJA,EACpC,EAaA3C,EAAQG,IAAIW,QAAU,SAAUX,GAC/B,IAAIyC,EAAW/C,EAAgBM,GAC/B,GAAIyC,EACH,OAAOA,EAGR,IACIC,EAfwBC,EAAGC,EAc3BC,EAAyBC,IAG7B,IAAK,IAAInC,KAAWlB,EACnB,GAAIA,EAAYG,eAAee,GAAU,CACxC,IAGIoC,GAtBsBJ,EAsBS3C,EAtBN4C,EAmBjBnD,EAAYkB,GAjBzBkB,KAAKmB,IAAIL,EAAE,GAAKC,EAAE,GAAI,GACtBf,KAAKmB,IAAIL,EAAE,GAAKC,EAAE,GAAI,GACtBf,KAAKmB,IAAIL,EAAE,GAAKC,EAAE,GAAI,IAqBjBG,EAAWF,IACdA,EAAyBE,EACzBL,EAAwB/B,EAE1B,CAGD,OAAO+B,CACR,EAEA7C,EAAQc,QAAQX,IAAM,SAAUW,GAC/B,OAAOlB,EAAYkB,EACpB,EAEAd,EAAQG,IAAIO,IAAM,SAAUP,GAC3B,IAAIyB,EAAIzB,EAAI,GAAK,IACb0B,EAAI1B,EAAI,GAAK,IACb2B,EAAI3B,EAAI,GAAK,IAWjB,MAAO,CAAK,KAJC,OAJbyB,EAAIA,EAAI,OAAUI,KAAKmB,KAAMvB,EAAI,MAAS,MAAQ,KAAQA,EAAI,OAIlC,OAH5BC,EAAIA,EAAI,OAAUG,KAAKmB,KAAMtB,EAAI,MAAS,MAAQ,KAAQA,EAAI,OAGnB,OAF3CC,EAAIA,EAAI,OAAUE,KAAKmB,KAAMrB,EAAI,MAAS,MAAQ,KAAQA,EAAI,QAMzC,KAHR,MAAJF,EAAmB,MAAJC,EAAmB,MAAJC,GAGT,KAFjB,MAAJF,EAAmB,MAAJC,EAAmB,MAAJC,GAGxC,EAEA9B,EAAQG,IAAIQ,IAAM,SAAUR,GAC3B,IAAIO,EAAMV,EAAQG,IAAIO,IAAIP,GACtB2C,EAAIpC,EAAI,GACRqC,EAAIrC,EAAI,GACR0C,EAAI1C,EAAI,GAiBZ,OAXAqC,GAAK,IACLK,GAAK,QAELN,GAJAA,GAAK,QAIG,QAAWd,KAAKmB,IAAIL,EAAG,EAAI,GAAM,MAAQA,EAAM,GAAK,IAQrD,CAJF,KAHLC,EAAIA,EAAI,QAAWf,KAAKmB,IAAIJ,EAAG,EAAI,GAAM,MAAQA,EAAM,GAAK,KAG5C,GACZ,KAAOD,EAAIC,GACX,KAAOA,GAJXK,EAAIA,EAAI,QAAWpB,KAAKmB,IAAIC,EAAG,EAAI,GAAM,MAAQA,EAAM,GAAK,MAO7D,EAEApD,EAAQM,IAAIH,IAAM,SAAUG,GAC3B,IAGI+C,EACAC,EACAC,EACApD,EACAqD,EAPA9B,EAAIpB,EAAI,GAAK,IACbgC,EAAIhC,EAAI,GAAK,IACbqB,EAAIrB,EAAI,GAAK,IAOjB,GAAU,IAANgC,EAEH,MAAO,CADPkB,EAAU,IAAJ7B,EACO6B,EAAKA,GASnBH,EAAK,EAAI1B,GALR2B,EADG3B,EAAI,GACFA,GAAK,EAAIW,GAETX,EAAIW,EAAIX,EAAIW,GAKlBnC,EAAM,CAAC,EAAG,EAAG,GACb,IAAK,IAAIsD,EAAI,EAAGA,EAAI,EAAGA,KACtBF,EAAK7B,EAAI,EAAI,IAAM+B,EAAI,IACd,GACRF,IAEGA,EAAK,GACRA,IAIAC,EADG,EAAID,EAAK,EACNF,EAAiB,GAAXC,EAAKD,GAAUE,EACjB,EAAIA,EAAK,EACbD,EACI,EAAIC,EAAK,EACbF,GAAMC,EAAKD,IAAO,EAAI,EAAIE,GAAM,EAEhCF,EAGPlD,EAAIsD,GAAW,IAAND,EAGV,OAAOrD,CACR,EAEAH,EAAQM,IAAIC,IAAM,SAAUD,GAC3B,IAAIoB,EAAIpB,EAAI,GACRgC,EAAIhC,EAAI,GAAK,IACbqB,EAAIrB,EAAI,GAAK,IACboD,EAAOpB,EACPqB,EAAO3B,KAAKC,IAAIN,EAAG,KAUvB,OALAW,IADAX,GAAK,IACM,EAAKA,EAAI,EAAIA,EACxB+B,GAAQC,GAAQ,EAAIA,EAAO,EAAIA,EAIxB,CAACjC,EAAQ,KAFL,IAANC,EAAW,EAAI+B,GAASC,EAAOD,GAAS,EAAIpB,GAAMX,EAAIW,KADtDX,EAAIW,GAAK,EAGW,IAC1B,EAEAtC,EAAQO,IAAIJ,IAAM,SAAUI,GAC3B,IAAImB,EAAInB,EAAI,GAAK,GACb+B,EAAI/B,EAAI,GAAK,IACbgC,EAAIhC,EAAI,GAAK,IACbqD,EAAK5B,KAAK6B,MAAMnC,GAAK,EAErBoC,EAAIpC,EAAIM,KAAK6B,MAAMnC,GACnBqC,EAAI,IAAMxB,GAAK,EAAID,GACnB0B,EAAI,IAAMzB,GAAK,EAAKD,EAAIwB,GACxBG,EAAI,IAAM1B,GAAK,EAAKD,GAAK,EAAIwB,IAGjC,OAFAvB,GAAK,IAEGqB,GACP,KAAK,EACJ,MAAO,CAACrB,EAAG0B,EAAGF,GACf,KAAK,EACJ,MAAO,CAACC,EAAGzB,EAAGwB,GACf,KAAK,EACJ,MAAO,CAACA,EAAGxB,EAAG0B,GACf,KAAK,EACJ,MAAO,CAACF,EAAGC,EAAGzB,GACf,KAAK,EACJ,MAAO,CAAC0B,EAAGF,EAAGxB,GACf,KAAK,EACJ,MAAO,CAACA,EAAGwB,EAAGC,GAEjB,EAEAhE,EAAQO,IAAID,IAAM,SAAUC,GAC3B,IAIIoD,EACAO,EACAvC,EANAD,EAAInB,EAAI,GACR+B,EAAI/B,EAAI,GAAK,IACbgC,EAAIhC,EAAI,GAAK,IACb4D,EAAOnC,KAAKC,IAAIM,EAAG,KAYvB,OAPAZ,GAAK,EAAIW,GAAKC,EAEd2B,EAAK5B,EAAI6B,EAKF,CAACzC,EAAQ,KAHhBwC,GADAA,IAFAP,GAAQ,EAAIrB,GAAK6B,IAEF,EAAKR,EAAO,EAAIA,IACpB,GAGc,KAFzBhC,GAAK,GAGN,EAGA3B,EAAQQ,IAAIL,IAAM,SAAUK,GAC3B,IAIIiD,EACAlB,EACAuB,EACAM,EAkBAxC,EACAC,EACAC,EA3BAJ,EAAIlB,EAAI,GAAK,IACb6D,EAAK7D,EAAI,GAAK,IACd8D,EAAK9D,EAAI,GAAK,IACd+D,EAAQF,EAAKC,EAyBjB,OAlBIC,EAAQ,IACXF,GAAME,EACND,GAAMC,GAKPT,EAAI,EAAIpC,GAFR+B,EAAIzB,KAAK6B,MAAM,EAAInC,IAIV,EAAJ+B,IACJK,EAAI,EAAIA,GAGTM,EAAIC,EAAKP,IAPTvB,EAAI,EAAI+B,GAOUD,GAKVZ,GACP,QACA,KAAK,EACL,KAAK,EAAG7B,EAAIW,EAAGV,EAAIuC,EAAGtC,EAAIuC,EAAI,MAC9B,KAAK,EAAGzC,EAAIwC,EAAGvC,EAAIU,EAAGT,EAAIuC,EAAI,MAC9B,KAAK,EAAGzC,EAAIyC,EAAIxC,EAAIU,EAAGT,EAAIsC,EAAG,MAC9B,KAAK,EAAGxC,EAAIyC,EAAIxC,EAAIuC,EAAGtC,EAAIS,EAAG,MAC9B,KAAK,EAAGX,EAAIwC,EAAGvC,EAAIwC,EAAIvC,EAAIS,EAAG,MAC9B,KAAK,EAAGX,EAAIW,EAAGV,EAAIwC,EAAIvC,EAAIsC,EAG5B,MAAO,CAAK,IAAJxC,EAAa,IAAJC,EAAa,IAAJC,EAC3B,EAEA9B,EAAQS,KAAKN,IAAM,SAAUM,GAC5B,IAAIiC,EAAIjC,EAAK,GAAK,IACd+D,EAAI/D,EAAK,GAAK,IACdsC,EAAItC,EAAK,GAAK,IACdkC,EAAIlC,EAAK,GAAK,IASlB,MAAO,CAAK,KAJR,EAAIuB,KAAKD,IAAI,EAAGW,GAAK,EAAIC,GAAKA,IAIb,KAHjB,EAAIX,KAAKD,IAAI,EAAGyC,GAAK,EAAI7B,GAAKA,IAGJ,KAF1B,EAAIX,KAAKD,IAAI,EAAGgB,GAAK,EAAIJ,GAAKA,IAGnC,EAEA3C,EAAQU,IAAIP,IAAM,SAAUO,GAC3B,IAGIkB,EACAC,EACAC,EALAgB,EAAIpC,EAAI,GAAK,IACbqC,EAAIrC,EAAI,GAAK,IACb0C,EAAI1C,EAAI,GAAK,IA0BjB,OApBAmB,GAAU,MAALiB,EAAoB,OAAJC,EAAmB,MAAJK,EACpCtB,EAAS,MAAJgB,GAAoB,KAALC,EAAoB,MAAJK,EAGpCxB,GALAA,EAAS,OAAJkB,GAAoB,OAALC,GAAqB,MAALK,GAK5B,SACH,MAAQpB,KAAKmB,IAAIvB,EAAG,EAAM,KAAQ,KAChC,MAAJA,EAEHC,EAAIA,EAAI,SACH,MAAQG,KAAKmB,IAAItB,EAAG,EAAM,KAAQ,KAChC,MAAJA,EAEHC,EAAIA,EAAI,SACH,MAAQE,KAAKmB,IAAIrB,EAAG,EAAM,KAAQ,KAChC,MAAJA,EAMI,CAAK,KAJZF,EAAII,KAAKD,IAAIC,KAAKC,IAAI,EAAGL,GAAI,IAIR,KAHrBC,EAAIG,KAAKD,IAAIC,KAAKC,IAAI,EAAGJ,GAAI,IAGC,KAF9BC,EAAIE,KAAKD,IAAIC,KAAKC,IAAI,EAAGH,GAAI,IAG9B,EAEA9B,EAAQU,IAAIC,IAAM,SAAUD,GAC3B,IAAIoC,EAAIpC,EAAI,GACRqC,EAAIrC,EAAI,GACR0C,EAAI1C,EAAI,GAiBZ,OAXAqC,GAAK,IACLK,GAAK,QAELN,GAJAA,GAAK,QAIG,QAAWd,KAAKmB,IAAIL,EAAG,EAAI,GAAM,MAAQA,EAAM,GAAK,IAQrD,CAJF,KAHLC,EAAIA,EAAI,QAAWf,KAAKmB,IAAIJ,EAAG,EAAI,GAAM,MAAQA,EAAM,GAAK,KAG5C,GACZ,KAAOD,EAAIC,GACX,KAAOA,GAJXK,EAAIA,EAAI,QAAWpB,KAAKmB,IAAIC,EAAG,EAAI,GAAM,MAAQA,EAAM,GAAK,MAO7D,EAEApD,EAAQW,IAAID,IAAM,SAAUC,GAC3B,IAGImC,EACAC,EACAK,EALAzB,EAAIhB,EAAI,GAQZmC,EAPQnC,EAAI,GAOJ,KADRoC,GAAKpB,EAAI,IAAM,KAEfyB,EAAIL,EAPIpC,EAAI,GAOA,IAEZ,IAAI8D,EAAKzC,KAAKmB,IAAIJ,EAAG,GACjB2B,EAAK1C,KAAKmB,IAAIL,EAAG,GACjB6B,EAAK3C,KAAKmB,IAAIC,EAAG,GASrB,OARAL,EAAI0B,EAAK,QAAWA,GAAM1B,EAAI,GAAK,KAAO,MAC1CD,EAAI4B,EAAK,QAAWA,GAAM5B,EAAI,GAAK,KAAO,MAC1CM,EAAIuB,EAAK,QAAWA,GAAMvB,EAAI,GAAK,KAAO,MAMnC,CAJPN,GAAK,OACLC,GAAK,IACLK,GAAK,QAGN,EAEApD,EAAQW,IAAIC,IAAM,SAAUD,GAC3B,IAIIe,EAJAC,EAAIhB,EAAI,GACRiE,EAAIjE,EAAI,GACRmB,EAAInB,EAAI,GAcZ,OARAe,EAAS,IADJM,KAAK6C,MAAM/C,EAAG8C,GACJ,EAAI5C,KAAK8C,IAEhB,IACPpD,GAAK,KAKC,CAACC,EAFJK,KAAK+C,KAAKH,EAAIA,EAAI9C,EAAIA,GAEZJ,EACf,EAEA1B,EAAQY,IAAID,IAAM,SAAUC,GAC3B,IAKIoE,EALArD,EAAIf,EAAI,GACR8B,EAAI9B,EAAI,GAUZ,OAJAoE,EALQpE,EAAI,GAKH,IAAM,EAAIoB,KAAK8C,GAIjB,CAACnD,EAHJe,EAAIV,KAAKiD,IAAID,GACbtC,EAAIV,KAAKkD,IAAIF,GAGlB,EAEAhF,EAAQG,IAAIY,OAAS,SAAUoE,GAC9B,IAAIvD,EAAIuD,EAAK,GACTtD,EAAIsD,EAAK,GACTrD,EAAIqD,EAAK,GACT1D,EAAQ,KAAK2D,UAAYA,UAAU,GAAKpF,EAAQG,IAAII,IAAI4E,GAAM,GAIlE,GAAc,KAFd1D,EAAQO,KAAKqD,MAAM5D,EAAQ,KAG1B,OAAO,GAGR,IAAI6D,EAAO,IACNtD,KAAKqD,MAAMvD,EAAI,MAAQ,EACxBE,KAAKqD,MAAMxD,EAAI,MAAQ,EACxBG,KAAKqD,MAAMzD,EAAI,MAMlB,OAJc,IAAVH,IACH6D,GAAQ,IAGFA,CACR,EAEAtF,EAAQO,IAAIQ,OAAS,SAAUoE,GAG9B,OAAOnF,EAAQG,IAAIY,OAAOf,EAAQO,IAAIJ,IAAIgF,GAAOA,EAAK,GACvD,EAEAnF,EAAQG,IAAIa,QAAU,SAAUmE,GAC/B,IAAIvD,EAAIuD,EAAK,GACTtD,EAAIsD,EAAK,GACTrD,EAAIqD,EAAK,GAIb,OAAIvD,IAAMC,GAAKA,IAAMC,EAChBF,EAAI,EACA,GAGJA,EAAI,IACA,IAGDI,KAAKqD,OAAQzD,EAAI,GAAK,IAAO,IAAM,IAGhC,GACP,GAAKI,KAAKqD,MAAMzD,EAAI,IAAM,GAC1B,EAAII,KAAKqD,MAAMxD,EAAI,IAAM,GAC1BG,KAAKqD,MAAMvD,EAAI,IAAM,EAGzB,EAEA9B,EAAQe,OAAOZ,IAAM,SAAUgF,GAC9B,IAAII,EAAQJ,EAAO,GAGnB,GAAc,IAAVI,GAAyB,IAAVA,EAOlB,OANIJ,EAAO,KACVI,GAAS,KAKH,CAFPA,EAAQA,EAAQ,KAAO,IAERA,EAAOA,GAGvB,IAAIC,EAA6B,IAAL,KAAbL,EAAO,KAKtB,MAAO,EAJW,EAARI,GAAaC,EAAQ,KACpBD,GAAS,EAAK,GAAKC,EAAQ,KAC3BD,GAAS,EAAK,GAAKC,EAAQ,IAGvC,EAEAxF,EAAQgB,QAAQb,IAAM,SAAUgF,GAE/B,GAAIA,GAAQ,IAAK,CAChB,IAAIzC,EAAmB,IAAdyC,EAAO,KAAY,EAC5B,MAAO,CAACzC,EAAGA,EAAGA,EACf,CAIA,IAAI+C,EAKJ,OAPAN,GAAQ,GAOD,CAJCnD,KAAK6B,MAAMsB,EAAO,IAAM,EAAI,IAC5BnD,KAAK6B,OAAO4B,EAAMN,EAAO,IAAM,GAAK,EAAI,IACvCM,EAAM,EAAK,EAAI,IAGzB,EAEAzF,EAAQG,IAAIU,IAAM,SAAUsE,GAC3B,IAIIO,KAJkC,IAAtB1D,KAAKqD,MAAMF,EAAK,MAAe,MACpB,IAAtBnD,KAAKqD,MAAMF,EAAK,MAAe,IACV,IAAtBnD,KAAKqD,MAAMF,EAAK,MAECQ,SAAS,IAAIC,cAClC,MAAO,SAASC,UAAUH,EAAOpE,QAAUoE,CAC5C,EAEA1F,EAAQa,IAAIV,IAAM,SAAUgF,GAC3B,IAAIW,EAAQX,EAAKQ,SAAS,IAAIG,MAAM,4BACpC,IAAKA,EACJ,MAAO,CAAC,EAAG,EAAG,GAGf,IAAIC,EAAcD,EAAM,GAEA,IAApBA,EAAM,GAAGxE,SACZyE,EAAcA,EAAYC,MAAM,IAAIC,KAAI,SAAUC,GACjD,OAAOA,EAAOA,CACf,IAAGC,KAAK,KAGT,IAAIC,EAAUC,SAASN,EAAa,IAKpC,MAAO,CAJEK,GAAW,GAAM,IACjBA,GAAW,EAAK,IACP,IAAVA,EAGT,EAEApG,EAAQG,IAAIc,IAAM,SAAUd,GAC3B,IAOImG,EAPA1E,EAAIzB,EAAI,GAAK,IACb0B,EAAI1B,EAAI,GAAK,IACb2B,EAAI3B,EAAI,GAAK,IACb8B,EAAMD,KAAKC,IAAID,KAAKC,IAAIL,EAAGC,GAAIC,GAC/BC,EAAMC,KAAKD,IAAIC,KAAKD,IAAIH,EAAGC,GAAIC,GAC/ByE,EAAUtE,EAAMF,EAyBpB,OAdCuE,EADGC,GAAU,EACP,EAEHtE,IAAQL,GACHC,EAAIC,GAAKyE,EAAU,EAExBtE,IAAQJ,EACL,GAAKC,EAAIF,GAAK2E,EAEd,GAAK3E,EAAIC,GAAK0E,EAAS,EAG9BD,GAAO,EAGA,CAAO,KAFdA,GAAO,GAEqB,IAATC,EAA0B,KArBzCA,EAAS,EACAxE,GAAO,EAAIwE,GAEX,GAmBd,EAEAvG,EAAQM,IAAIW,IAAM,SAAUX,GAC3B,IAEIoC,EAFAJ,EAAIhC,EAAI,GAAK,IACbqB,EAAIrB,EAAI,GAAK,IAEbwD,EAAI,EAYR,OATCpB,EADGf,EAAI,GACH,EAAMW,EAAIX,EAEV,EAAMW,GAAK,EAAMX,IAGd,IACPmC,GAAKnC,EAAI,GAAMe,IAAM,EAAMA,IAGrB,CAACpC,EAAI,GAAQ,IAAJoC,EAAa,IAAJoB,EAC1B,EAEA9D,EAAQO,IAAIU,IAAM,SAAUV,GAC3B,IAAI+B,EAAI/B,EAAI,GAAK,IACbgC,EAAIhC,EAAI,GAAK,IAEbmC,EAAIJ,EAAIC,EACRuB,EAAI,EAMR,OAJIpB,EAAI,IACPoB,GAAKvB,EAAIG,IAAM,EAAIA,IAGb,CAACnC,EAAI,GAAQ,IAAJmC,EAAa,IAAJoB,EAC1B,EAEA9D,EAAQiB,IAAId,IAAM,SAAUc,GAC3B,IAAIS,EAAIT,EAAI,GAAK,IACbyB,EAAIzB,EAAI,GAAK,IACbY,EAAIZ,EAAI,GAAK,IAEjB,GAAU,IAANyB,EACH,MAAO,CAAK,IAAJb,EAAa,IAAJA,EAAa,IAAJA,GAG3B,IAII2E,EAJAC,EAAO,CAAC,EAAG,EAAG,GACd7C,EAAMlC,EAAI,EAAK,EACfa,EAAIqB,EAAK,EACT8C,EAAI,EAAInE,EAGZ,OAAQP,KAAK6B,MAAMD,IAClB,KAAK,EACJ6C,EAAK,GAAK,EAAGA,EAAK,GAAKlE,EAAGkE,EAAK,GAAK,EAAG,MACxC,KAAK,EACJA,EAAK,GAAKC,EAAGD,EAAK,GAAK,EAAGA,EAAK,GAAK,EAAG,MACxC,KAAK,EACJA,EAAK,GAAK,EAAGA,EAAK,GAAK,EAAGA,EAAK,GAAKlE,EAAG,MACxC,KAAK,EACJkE,EAAK,GAAK,EAAGA,EAAK,GAAKC,EAAGD,EAAK,GAAK,EAAG,MACxC,KAAK,EACJA,EAAK,GAAKlE,EAAGkE,EAAK,GAAK,EAAGA,EAAK,GAAK,EAAG,MACxC,QACCA,EAAK,GAAK,EAAGA,EAAK,GAAK,EAAGA,EAAK,GAAKC,EAKtC,OAFAF,GAAM,EAAM9D,GAAKb,EAEV,CACe,KAApBa,EAAI+D,EAAK,GAAKD,GACM,KAApB9D,EAAI+D,EAAK,GAAKD,GACM,KAApB9D,EAAI+D,EAAK,GAAKD,GAEjB,EAEAxG,EAAQiB,IAAIV,IAAM,SAAUU,GAC3B,IAAIyB,EAAIzB,EAAI,GAAK,IAGbsB,EAAIG,EAFAzB,EAAI,GAAK,KAEA,EAAMyB,GACnBoB,EAAI,EAMR,OAJIvB,EAAI,IACPuB,EAAIpB,EAAIH,GAGF,CAACtB,EAAI,GAAQ,IAAJ6C,EAAa,IAAJvB,EAC1B,EAEAvC,EAAQiB,IAAIX,IAAM,SAAUW,GAC3B,IAAIyB,EAAIzB,EAAI,GAAK,IAGbU,EAFIV,EAAI,GAAK,KAEJ,EAAMyB,GAAK,GAAMA,EAC1BJ,EAAI,EASR,OAPIX,EAAI,GAAOA,EAAI,GAClBW,EAAII,GAAK,EAAIf,GAEVA,GAAK,IAAOA,EAAI,IACnBW,EAAII,GAAK,GAAK,EAAIf,KAGZ,CAACV,EAAI,GAAQ,IAAJqB,EAAa,IAAJX,EAC1B,EAEA3B,EAAQiB,IAAIT,IAAM,SAAUS,GAC3B,IAAIyB,EAAIzB,EAAI,GAAK,IAEbsB,EAAIG,EADAzB,EAAI,GAAK,KACA,EAAMyB,GACvB,MAAO,CAACzB,EAAI,GAAc,KAATsB,EAAIG,GAAoB,KAAT,EAAIH,GACrC,EAEAvC,EAAQQ,IAAIS,IAAM,SAAUT,GAC3B,IAAIkG,EAAIlG,EAAI,GAAK,IAEb+B,EAAI,EADA/B,EAAI,GAAK,IAEbkC,EAAIH,EAAImE,EACR7E,EAAI,EAMR,OAJIa,EAAI,IACPb,GAAKU,EAAIG,IAAM,EAAIA,IAGb,CAAClC,EAAI,GAAQ,IAAJkC,EAAa,IAAJb,EAC1B,EAEA7B,EAAQkB,MAAMf,IAAM,SAAUe,GAC7B,MAAO,CAAEA,EAAM,GAAK,MAAS,IAAMA,EAAM,GAAK,MAAS,IAAMA,EAAM,GAAK,MAAS,IAClF,EAEAlB,EAAQG,IAAIe,MAAQ,SAAUf,GAC7B,MAAO,CAAEA,EAAI,GAAK,IAAO,MAAQA,EAAI,GAAK,IAAO,MAAQA,EAAI,GAAK,IAAO,MAC1E,EAEAH,EAAQmB,KAAKhB,IAAM,SAAUgF,GAC5B,MAAO,CAACA,EAAK,GAAK,IAAM,IAAKA,EAAK,GAAK,IAAM,IAAKA,EAAK,GAAK,IAAM,IACnE,EAEAnF,EAAQmB,KAAKb,IAAMN,EAAQmB,KAAKZ,IAAM,SAAU4E,GAC/C,MAAO,CAAC,EAAG,EAAGA,EAAK,GACpB,EAEAnF,EAAQmB,KAAKX,IAAM,SAAUW,GAC5B,MAAO,CAAC,EAAG,IAAKA,EAAK,GACtB,EAEAnB,EAAQmB,KAAKV,KAAO,SAAUU,GAC7B,MAAO,CAAC,EAAG,EAAG,EAAGA,EAAK,GACvB,EAEAnB,EAAQmB,KAAKR,IAAM,SAAUQ,GAC5B,MAAO,CAACA,EAAK,GAAI,EAAG,EACrB,EAEAnB,EAAQmB,KAAKN,IAAM,SAAUM,GAC5B,IAAIqC,EAAwC,IAAlCxB,KAAKqD,MAAMlE,EAAK,GAAK,IAAM,KAGjCuE,IAFWlC,GAAO,KAAOA,GAAO,GAAKA,GAEpBmC,SAAS,IAAIC,cAClC,MAAO,SAASC,UAAUH,EAAOpE,QAAUoE,CAC5C,EAEA1F,EAAQG,IAAIgB,KAAO,SAAUhB,GAE5B,MAAO,EADIA,EAAI,GAAKA,EAAI,GAAKA,EAAI,IAAM,EACzB,IAAM,IACrB,C,kBCn2BA,IAAIwG,EAAc,EAAQ,OACtBC,EAAQ,EAAQ,MAEhB5G,EAAU,CAAC,EAEFuB,OAAOsF,KAAKF,GAuDlBG,SAAQ,SAAUC,GACxB/G,EAAQ+G,GAAa,CAAC,EAEtBxF,OAAOC,eAAexB,EAAQ+G,GAAY,WAAY,CAACtF,MAAOkF,EAAYI,GAAW3G,WACrFmB,OAAOC,eAAexB,EAAQ+G,GAAY,SAAU,CAACtF,MAAOkF,EAAYI,GAAW1G,SAEnF,IAAI2G,EAASJ,EAAMG,GACDxF,OAAOsF,KAAKG,GAElBF,SAAQ,SAAUG,GAC7B,IAAIC,EAAKF,EAAOC,GAEhBjH,EAAQ+G,GAAWE,GA5CrB,SAAqBC,GACpB,IAAIC,EAAY,SAAUhC,GACzB,GAAIA,QACH,OAAOA,EAGJC,UAAU9D,OAAS,IACtB6D,EAAOiC,MAAMC,UAAUC,MAAMC,KAAKnC,YAGnC,IAAIoC,EAASN,EAAG/B,GAKhB,GAAsB,iBAAXqC,EACV,IAAK,IAAIC,EAAMD,EAAOlG,OAAQmC,EAAI,EAAGA,EAAIgE,EAAKhE,IAC7C+D,EAAO/D,GAAKzB,KAAKqD,MAAMmC,EAAO/D,IAIhC,OAAO+D,CACR,EAOA,MAJI,eAAgBN,IACnBC,EAAUO,WAAaR,EAAGQ,YAGpBP,CACR,CAcgCQ,CAAYT,GAC1ClH,EAAQ+G,GAAWE,GAASW,IAlE9B,SAAiBV,GAChB,IAAIC,EAAY,SAAUhC,GACzB,OAAIA,QACIA,GAGJC,UAAU9D,OAAS,IACtB6D,EAAOiC,MAAMC,UAAUC,MAAMC,KAAKnC,YAG5B8B,EAAG/B,GACX,EAOA,MAJI,eAAgB+B,IACnBC,EAAUO,WAAaR,EAAGQ,YAGpBP,CACR,CA+CoCU,CAAQX,EAC3C,GACD,IAEAjH,EAAOC,QAAUF,C,iBC7EjB,IAAI2G,EAAc,EAAQ,OAwD1B,SAASmB,EAAKC,EAAMC,GACnB,OAAO,SAAU7C,GAChB,OAAO6C,EAAGD,EAAK5C,GAChB,CACD,CAEA,SAAS8C,EAAehB,EAASiB,GAKhC,IAJA,IAAIC,EAAO,CAACD,EAAMjB,GAASmB,OAAQnB,GAC/BC,EAAKP,EAAYuB,EAAMjB,GAASmB,QAAQnB,GAExCoB,EAAMH,EAAMjB,GAASmB,OAClBF,EAAMG,GAAKD,QACjBD,EAAKG,QAAQJ,EAAMG,GAAKD,QACxBlB,EAAKY,EAAKnB,EAAYuB,EAAMG,GAAKD,QAAQC,GAAMnB,GAC/CmB,EAAMH,EAAMG,GAAKD,OAIlB,OADAlB,EAAGQ,WAAaS,EACTjB,CACR,CAEAjH,EAAOC,QAAU,SAAU6G,GAK1B,IAJA,IAAImB,EA/CL,SAAmBnB,GAClB,IAAImB,EAnBL,WAKC,IAJA,IAAIA,EAAQ,CAAC,EAETK,EAAShH,OAAOsF,KAAKF,GAEhBc,EAAMc,EAAOjH,OAAQmC,EAAI,EAAGA,EAAIgE,EAAKhE,IAC7CyE,EAAMK,EAAO9E,IAAM,CAGlBP,UAAW,EACXkF,OAAQ,MAIV,OAAOF,CACR,CAIaM,GACRC,EAAQ,CAAC1B,GAIb,IAFAmB,EAAMnB,GAAW7D,SAAW,EAErBuF,EAAMnH,QAIZ,IAHA,IAAIoH,EAAUD,EAAME,MAChBC,EAAYrH,OAAOsF,KAAKF,EAAY+B,IAE/BjB,EAAMmB,EAAUtH,OAAQmC,EAAI,EAAGA,EAAIgE,EAAKhE,IAAK,CACrD,IAAIoF,EAAWD,EAAUnF,GACrBqF,EAAOZ,EAAMW,IAEM,IAAnBC,EAAK5F,WACR4F,EAAK5F,SAAWgF,EAAMQ,GAASxF,SAAW,EAC1C4F,EAAKV,OAASM,EACdD,EAAMH,QAAQO,GAEhB,CAGD,OAAOX,CACR,CAwBaa,CAAUhC,GAClBW,EAAa,CAAC,EAEda,EAAShH,OAAOsF,KAAKqB,GAChBT,EAAMc,EAAOjH,OAAQmC,EAAI,EAAGA,EAAIgE,EAAKhE,IAAK,CAClD,IAAIwD,EAAUsB,EAAO9E,GAGD,OAFTyE,EAAMjB,GAERmB,SAKTV,EAAWT,GAAWgB,EAAehB,EAASiB,GAC/C,CAEA,OAAOR,CACR,C,wBC7FAzH,EAAOC,QAAU,CAChB,UAAa,CAAC,IAAK,IAAK,KACxB,aAAgB,CAAC,IAAK,IAAK,KAC3B,KAAQ,CAAC,EAAG,IAAK,KACjB,WAAc,CAAC,IAAK,IAAK,KACzB,MAAS,CAAC,IAAK,IAAK,KACpB,MAAS,CAAC,IAAK,IAAK,KACpB,OAAU,CAAC,IAAK,IAAK,KACrB,MAAS,CAAC,EAAG,EAAG,GAChB,eAAkB,CAAC,IAAK,IAAK,KAC7B,KAAQ,CAAC,EAAG,EAAG,KACf,WAAc,CAAC,IAAK,GAAI,KACxB,MAAS,CAAC,IAAK,GAAI,IACnB,UAAa,CAAC,IAAK,IAAK,KACxB,UAAa,CAAC,GAAI,IAAK,KACvB,WAAc,CAAC,IAAK,IAAK,GACzB,UAAa,CAAC,IAAK,IAAK,IACxB,MAAS,CAAC,IAAK,IAAK,IACpB,eAAkB,CAAC,IAAK,IAAK,KAC7B,SAAY,CAAC,IAAK,IAAK,KACvB,QAAW,CAAC,IAAK,GAAI,IACrB,KAAQ,CAAC,EAAG,IAAK,KACjB,SAAY,CAAC,EAAG,EAAG,KACnB,SAAY,CAAC,EAAG,IAAK,KACrB,cAAiB,CAAC,IAAK,IAAK,IAC5B,SAAY,CAAC,IAAK,IAAK,KACvB,UAAa,CAAC,EAAG,IAAK,GACtB,SAAY,CAAC,IAAK,IAAK,KACvB,UAAa,CAAC,IAAK,IAAK,KACxB,YAAe,CAAC,IAAK,EAAG,KACxB,eAAkB,CAAC,GAAI,IAAK,IAC5B,WAAc,CAAC,IAAK,IAAK,GACzB,WAAc,CAAC,IAAK,GAAI,KACxB,QAAW,CAAC,IAAK,EAAG,GACpB,WAAc,CAAC,IAAK,IAAK,KACzB,aAAgB,CAAC,IAAK,IAAK,KAC3B,cAAiB,CAAC,GAAI,GAAI,KAC1B,cAAiB,CAAC,GAAI,GAAI,IAC1B,cAAiB,CAAC,GAAI,GAAI,IAC1B,cAAiB,CAAC,EAAG,IAAK,KAC1B,WAAc,CAAC,IAAK,EAAG,KACvB,SAAY,CAAC,IAAK,GAAI,KACtB,YAAe,CAAC,EAAG,IAAK,KACxB,QAAW,CAAC,IAAK,IAAK,KACtB,QAAW,CAAC,IAAK,IAAK,KACtB,WAAc,CAAC,GAAI,IAAK,KACxB,UAAa,CAAC,IAAK,GAAI,IACvB,YAAe,CAAC,IAAK,IAAK,KAC1B,YAAe,CAAC,GAAI,IAAK,IACzB,QAAW,CAAC,IAAK,EAAG,KACpB,UAAa,CAAC,IAAK,IAAK,KACxB,WAAc,CAAC,IAAK,IAAK,KACzB,KAAQ,CAAC,IAAK,IAAK,GACnB,UAAa,CAAC,IAAK,IAAK,IACxB,KAAQ,CAAC,IAAK,IAAK,KACnB,MAAS,CAAC,EAAG,IAAK,GAClB,YAAe,CAAC,IAAK,IAAK,IAC1B,KAAQ,CAAC,IAAK,IAAK,KACnB,SAAY,CAAC,IAAK,IAAK,KACvB,QAAW,CAAC,IAAK,IAAK,KACtB,UAAa,CAAC,IAAK,GAAI,IACvB,OAAU,CAAC,GAAI,EAAG,KAClB,MAAS,CAAC,IAAK,IAAK,KACpB,MAAS,CAAC,IAAK,IAAK,KACpB,SAAY,CAAC,IAAK,IAAK,KACvB,cAAiB,CAAC,IAAK,IAAK,KAC5B,UAAa,CAAC,IAAK,IAAK,GACxB,aAAgB,CAAC,IAAK,IAAK,KAC3B,UAAa,CAAC,IAAK,IAAK,KACxB,WAAc,CAAC,IAAK,IAAK,KACzB,UAAa,CAAC,IAAK,IAAK,KACxB,qBAAwB,CAAC,IAAK,IAAK,KACnC,UAAa,CAAC,IAAK,IAAK,KACxB,WAAc,CAAC,IAAK,IAAK,KACzB,UAAa,CAAC,IAAK,IAAK,KACxB,UAAa,CAAC,IAAK,IAAK,KACxB,YAAe,CAAC,IAAK,IAAK,KAC1B,cAAiB,CAAC,GAAI,IAAK,KAC3B,aAAgB,CAAC,IAAK,IAAK,KAC3B,eAAkB,CAAC,IAAK,IAAK,KAC7B,eAAkB,CAAC,IAAK,IAAK,KAC7B,eAAkB,CAAC,IAAK,IAAK,KAC7B,YAAe,CAAC,IAAK,IAAK,KAC1B,KAAQ,CAAC,EAAG,IAAK,GACjB,UAAa,CAAC,GAAI,IAAK,IACvB,MAAS,CAAC,IAAK,IAAK,KACpB,QAAW,CAAC,IAAK,EAAG,KACpB,OAAU,CAAC,IAAK,EAAG,GACnB,iBAAoB,CAAC,IAAK,IAAK,KAC/B,WAAc,CAAC,EAAG,EAAG,KACrB,aAAgB,CAAC,IAAK,GAAI,KAC1B,aAAgB,CAAC,IAAK,IAAK,KAC3B,eAAkB,CAAC,GAAI,IAAK,KAC5B,gBAAmB,CAAC,IAAK,IAAK,KAC9B,kBAAqB,CAAC,EAAG,IAAK,KAC9B,gBAAmB,CAAC,GAAI,IAAK,KAC7B,gBAAmB,CAAC,IAAK,GAAI,KAC7B,aAAgB,CAAC,GAAI,GAAI,KACzB,UAAa,CAAC,IAAK,IAAK,KACxB,UAAa,CAAC,IAAK,IAAK,KACxB,SAAY,CAAC,IAAK,IAAK,KACvB,YAAe,CAAC,IAAK,IAAK,KAC1B,KAAQ,CAAC,EAAG,EAAG,KACf,QAAW,CAAC,IAAK,IAAK,KACtB,MAAS,CAAC,IAAK,IAAK,GACpB,UAAa,CAAC,IAAK,IAAK,IACxB,OAAU,CAAC,IAAK,IAAK,GACrB,UAAa,CAAC,IAAK,GAAI,GACvB,OAAU,CAAC,IAAK,IAAK,KACrB,cAAiB,CAAC,IAAK,IAAK,KAC5B,UAAa,CAAC,IAAK,IAAK,KACxB,cAAiB,CAAC,IAAK,IAAK,KAC5B,cAAiB,CAAC,IAAK,IAAK,KAC5B,WAAc,CAAC,IAAK,IAAK,KACzB,UAAa,CAAC,IAAK,IAAK,KACxB,KAAQ,CAAC,IAAK,IAAK,IACnB,KAAQ,CAAC,IAAK,IAAK,KACnB,KAAQ,CAAC,IAAK,IAAK,KACnB,WAAc,CAAC,IAAK,IAAK,KACzB,OAAU,CAAC,IAAK,EAAG,KACnB,cAAiB,CAAC,IAAK,GAAI,KAC3B,IAAO,CAAC,IAAK,EAAG,GAChB,UAAa,CAAC,IAAK,IAAK,KACxB,UAAa,CAAC,GAAI,IAAK,KACvB,YAAe,CAAC,IAAK,GAAI,IACzB,OAAU,CAAC,IAAK,IAAK,KACrB,WAAc,CAAC,IAAK,IAAK,IACzB,SAAY,CAAC,GAAI,IAAK,IACtB,SAAY,CAAC,IAAK,IAAK,KACvB,OAAU,CAAC,IAAK,GAAI,IACpB,OAAU,CAAC,IAAK,IAAK,KACrB,QAAW,CAAC,IAAK,IAAK,KACtB,UAAa,CAAC,IAAK,GAAI,KACvB,UAAa,CAAC,IAAK,IAAK,KACxB,UAAa,CAAC,IAAK,IAAK,KACxB,KAAQ,CAAC,IAAK,IAAK,KACnB,YAAe,CAAC,EAAG,IAAK,KACxB,UAAa,CAAC,GAAI,IAAK,KACvB,IAAO,CAAC,IAAK,IAAK,KAClB,KAAQ,CAAC,EAAG,IAAK,KACjB,QAAW,CAAC,IAAK,IAAK,KACtB,OAAU,CAAC,IAAK,GAAI,IACpB,UAAa,CAAC,GAAI,IAAK,KACvB,OAAU,CAAC,IAAK,IAAK,KACrB,MAAS,CAAC,IAAK,IAAK,KACpB,MAAS,CAAC,IAAK,IAAK,KACpB,WAAc,CAAC,IAAK,IAAK,KACzB,OAAU,CAAC,IAAK,IAAK,GACrB,YAAe,CAAC,IAAK,IAAK,I,kBCrJ3B,IAAI8I,EAAa,EAAQ,MACrBC,EAAU,EAAQ,OAElBC,EAAe,CAAC,EAGpB,IAAK,IAAIC,KAAQH,EACZA,EAAWjJ,eAAeoJ,KAC7BD,EAAaF,EAAWG,IAASA,GAInC,IAAIC,EAAKnJ,EAAOC,QAAU,CACzB8H,GAAI,CAAC,EACLqB,IAAK,CAAC,GAmNP,SAASC,EAAMC,EAAKxH,EAAKE,GACxB,OAAOD,KAAKD,IAAIC,KAAKC,IAAIF,EAAKwH,GAAMtH,EACrC,CAEA,SAASuH,EAAUD,GAClB,IAAIE,EAAMF,EAAI5D,SAAS,IAAIC,cAC3B,OAAQ6D,EAAInI,OAAS,EAAK,IAAMmI,EAAMA,CACvC,CAvNAL,EAAGC,IAAM,SAAU3D,GAClB,IACIlC,EACApC,EACJ,OAHasE,EAAOG,UAAU,EAAG,GAAG6D,eAInC,IAAK,MACJlG,EAAM4F,EAAGC,IAAI/I,IAAIoF,GACjBtE,EAAQ,MACR,MACD,IAAK,MACJoC,EAAM4F,EAAGC,IAAI7I,IAAIkF,GACjBtE,EAAQ,MACR,MACD,QACCoC,EAAM4F,EAAGC,IAAIlJ,IAAIuF,GACjBtE,EAAQ,MAIV,OAAKoC,EAIE,CAACpC,MAAOA,EAAOK,MAAO+B,GAHrB,IAIT,EAEA4F,EAAGC,IAAIlJ,IAAM,SAAUuF,GACtB,IAAKA,EACJ,OAAO,KAGR,IAOII,EACArC,EACAkG,EAHAxJ,EAAM,CAAC,EAAG,EAAG,EAAG,GAKpB,GAAI2F,EAAQJ,EAAOI,MAVT,mCAUqB,CAI9B,IAHA6D,EAAW7D,EAAM,GACjBA,EAAQA,EAAM,GAETrC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAEvB,IAAImG,EAAS,EAAJnG,EACTtD,EAAIsD,GAAK4C,SAASP,EAAMwB,MAAMsC,EAAIA,EAAK,GAAI,GAC5C,CAEID,IACHxJ,EAAI,GAAKkG,SAASsD,EAAU,IAAM,IAEpC,MAAO,GAAI7D,EAAQJ,EAAOI,MAxBf,uBAwB4B,CAItC,IAFA6D,GADA7D,EAAQA,EAAM,IACG,GAEZrC,EAAI,EAAGA,EAAI,EAAGA,IAClBtD,EAAIsD,GAAK4C,SAASP,EAAMrC,GAAKqC,EAAMrC,GAAI,IAGpCkG,IACHxJ,EAAI,GAAKkG,SAASsD,EAAWA,EAAU,IAAM,IAE/C,MAAO,GAAI7D,EAAQJ,EAAOI,MAjCf,2FAiC4B,CACtC,IAAKrC,EAAI,EAAGA,EAAI,EAAGA,IAClBtD,EAAIsD,GAAK4C,SAASP,EAAMrC,EAAI,GAAI,GAG7BqC,EAAM,KACT3F,EAAI,GAAK0J,WAAW/D,EAAM,IAE5B,KAAO,MAAIA,EAAQJ,EAAOI,MAxChB,8GAgDH,OAAIA,EAAQJ,EAAOI,MA/CZ,UAgDI,gBAAbA,EAAM,GACF,CAAC,EAAG,EAAG,EAAG,IAGlB3F,EAAM6I,EAAWlD,EAAM,MAMvB3F,EAAI,GAAK,EAEFA,GALC,KAOD,KAtBP,IAAKsD,EAAI,EAAGA,EAAI,EAAGA,IAClBtD,EAAIsD,GAAKzB,KAAKqD,MAAiC,KAA3BwE,WAAW/D,EAAMrC,EAAI,KAGtCqC,EAAM,KACT3F,EAAI,GAAK0J,WAAW/D,EAAM,IAkB5B,CAEA,IAAKrC,EAAI,EAAGA,EAAI,EAAGA,IAClBtD,EAAIsD,GAAK6F,EAAMnJ,EAAIsD,GAAI,EAAG,KAI3B,OAFAtD,EAAI,GAAKmJ,EAAMnJ,EAAI,GAAI,EAAG,GAEnBA,CACR,EAEAiJ,EAAGC,IAAI/I,IAAM,SAAUoF,GACtB,IAAKA,EACJ,OAAO,KAGR,IACII,EAAQJ,EAAOI,MADT,2HAGV,GAAIA,EAAO,CACV,IAAIgE,EAAQD,WAAW/D,EAAM,IAM7B,MAAO,EALE+D,WAAW/D,EAAM,IAAM,KAAO,IAC/BwD,EAAMO,WAAW/D,EAAM,IAAK,EAAG,KAC/BwD,EAAMO,WAAW/D,EAAM,IAAK,EAAG,KAC/BwD,EAAMS,MAAMD,GAAS,EAAIA,EAAO,EAAG,GAG5C,CAEA,OAAO,IACR,EAEAV,EAAGC,IAAI7I,IAAM,SAAUkF,GACtB,IAAKA,EACJ,OAAO,KAGR,IACII,EAAQJ,EAAOI,MADT,yHAGV,GAAIA,EAAO,CACV,IAAIgE,EAAQD,WAAW/D,EAAM,IAK7B,MAAO,EAJG+D,WAAW/D,EAAM,IAAM,IAAO,KAAO,IACvCwD,EAAMO,WAAW/D,EAAM,IAAK,EAAG,KAC/BwD,EAAMO,WAAW/D,EAAM,IAAK,EAAG,KAC/BwD,EAAMS,MAAMD,GAAS,EAAIA,EAAO,EAAG,GAE5C,CAEA,OAAO,IACR,EAEAV,EAAGpB,GAAGnH,IAAM,WACX,IAAImJ,EAAOf,EAAQ7D,WAEnB,MACC,IACAoE,EAAUQ,EAAK,IACfR,EAAUQ,EAAK,IACfR,EAAUQ,EAAK,KACdA,EAAK,GAAK,EACPR,EAAUxH,KAAKqD,MAAgB,IAAV2E,EAAK,KAC3B,GAEL,EAEAZ,EAAGpB,GAAG7H,IAAM,WACX,IAAI6J,EAAOf,EAAQ7D,WAEnB,OAAO4E,EAAK1I,OAAS,GAAiB,IAAZ0I,EAAK,GAC5B,OAAShI,KAAKqD,MAAM2E,EAAK,IAAM,KAAOhI,KAAKqD,MAAM2E,EAAK,IAAM,KAAOhI,KAAKqD,MAAM2E,EAAK,IAAM,IACzF,QAAUhI,KAAKqD,MAAM2E,EAAK,IAAM,KAAOhI,KAAKqD,MAAM2E,EAAK,IAAM,KAAOhI,KAAKqD,MAAM2E,EAAK,IAAM,KAAOA,EAAK,GAAK,GAC/G,EAEAZ,EAAGpB,GAAG7H,IAAI8J,QAAU,WACnB,IAAID,EAAOf,EAAQ7D,WAEfxD,EAAII,KAAKqD,MAAM2E,EAAK,GAAK,IAAM,KAC/BnI,EAAIG,KAAKqD,MAAM2E,EAAK,GAAK,IAAM,KAC/BlI,EAAIE,KAAKqD,MAAM2E,EAAK,GAAK,IAAM,KAEnC,OAAOA,EAAK1I,OAAS,GAAiB,IAAZ0I,EAAK,GAC5B,OAASpI,EAAI,MAAQC,EAAI,MAAQC,EAAI,KACrC,QAAUF,EAAI,MAAQC,EAAI,MAAQC,EAAI,MAAQkI,EAAK,GAAK,GAC5D,EAEAZ,EAAGpB,GAAG1H,IAAM,WACX,IAAI4J,EAAOjB,EAAQ7D,WACnB,OAAO8E,EAAK5I,OAAS,GAAiB,IAAZ4I,EAAK,GAC5B,OAASA,EAAK,GAAK,KAAOA,EAAK,GAAK,MAAQA,EAAK,GAAK,KACtD,QAAUA,EAAK,GAAK,KAAOA,EAAK,GAAK,MAAQA,EAAK,GAAK,MAAQA,EAAK,GAAK,GAC7E,EAIAd,EAAGpB,GAAGxH,IAAM,WACX,IAAI2J,EAAOlB,EAAQ7D,WAEfR,EAAI,GAKR,OAJIuF,EAAK7I,QAAU,GAAiB,IAAZ6I,EAAK,KAC5BvF,EAAI,KAAOuF,EAAK,IAGV,OAASA,EAAK,GAAK,KAAOA,EAAK,GAAK,MAAQA,EAAK,GAAK,IAAMvF,EAAI,GACxE,EAEAwE,EAAGpB,GAAGlH,QAAU,SAAUX,GACzB,OAAO+I,EAAa/I,EAAImH,MAAM,EAAG,GAClC,C,8BC7NA,IAAIvB,EAAc,EAAQ,OACtB/F,EAAU,EAAQ,OAElBoK,EAAS,GAAG9C,MAEZ+C,EAAgB,CAEnB,UAGA,OAGA,OAGGC,EAAkB,CAAC,EACvB/I,OAAOsF,KAAK7G,GAAS8G,SAAQ,SAAU1F,GACtCkJ,EAAgBF,EAAO7C,KAAKvH,EAAQoB,GAAOf,QAAQkK,OAAOpE,KAAK,KAAO/E,CACvE,IAEA,IAAIoJ,EAAW,CAAC,EAEhB,SAASC,EAAMC,EAAKtJ,GACnB,KAAMuJ,gBAAgBF,GACrB,OAAO,IAAIA,EAAMC,EAAKtJ,GAOvB,GAJIA,GAASA,KAASiJ,IACrBjJ,EAAQ,MAGLA,KAAWA,KAASpB,GACvB,MAAM,IAAIqB,MAAM,kBAAoBD,GAGrC,IAAIqC,EACArD,EAEJ,GAAW,MAAPsK,EACHC,KAAKvJ,MAAQ,MACbuJ,KAAKpF,MAAQ,CAAC,EAAG,EAAG,GACpBoF,KAAKC,OAAS,OACR,GAAIF,aAAeD,EACzBE,KAAKvJ,MAAQsJ,EAAItJ,MACjBuJ,KAAKpF,MAAQmF,EAAInF,MAAM+B,QACvBqD,KAAKC,OAASF,EAAIE,YACZ,GAAmB,iBAARF,EAAkB,CACnC,IAAIlD,EAASzB,EAAYsD,IAAIqB,GAC7B,GAAe,OAAXlD,EACH,MAAM,IAAInG,MAAM,sCAAwCqJ,GAGzDC,KAAKvJ,MAAQoG,EAAOpG,MACpBhB,EAAWJ,EAAQ2K,KAAKvJ,OAAOhB,SAC/BuK,KAAKpF,MAAQiC,EAAO/F,MAAM6F,MAAM,EAAGlH,GACnCuK,KAAKC,OAA2C,iBAA3BpD,EAAO/F,MAAMrB,GAAyBoH,EAAO/F,MAAMrB,GAAY,CACrF,MAAO,GAAIsK,EAAIpJ,OAAQ,CACtBqJ,KAAKvJ,MAAQA,GAAS,MACtBhB,EAAWJ,EAAQ2K,KAAKvJ,OAAOhB,SAC/B,IAAIyK,EAAST,EAAO7C,KAAKmD,EAAK,EAAGtK,GACjCuK,KAAKpF,MAAQuF,EAAUD,EAAQzK,GAC/BuK,KAAKC,OAAkC,iBAAlBF,EAAItK,GAAyBsK,EAAItK,GAAY,CACnE,MAAO,GAAmB,iBAARsK,EAEjBA,GAAO,SACPC,KAAKvJ,MAAQ,MACbuJ,KAAKpF,MAAQ,CACXmF,GAAO,GAAM,IACbA,GAAO,EAAK,IACP,IAANA,GAEDC,KAAKC,OAAS,MACR,CACND,KAAKC,OAAS,EAEd,IAAI/D,EAAOtF,OAAOsF,KAAK6D,GACnB,UAAWA,IACd7D,EAAKkE,OAAOlE,EAAKmE,QAAQ,SAAU,GACnCL,KAAKC,OAA8B,iBAAdF,EAAIZ,MAAqBY,EAAIZ,MAAQ,GAG3D,IAAImB,EAAapE,EAAK0D,OAAOpE,KAAK,IAClC,KAAM8E,KAAcX,GACnB,MAAM,IAAIjJ,MAAM,sCAAwC6J,KAAKC,UAAUT,IAGxEC,KAAKvJ,MAAQkJ,EAAgBW,GAE7B,IAAI5K,EAASL,EAAQ2K,KAAKvJ,OAAOf,OAC7BkF,EAAQ,GACZ,IAAK9B,EAAI,EAAGA,EAAIpD,EAAOiB,OAAQmC,IAC9B8B,EAAM6F,KAAKV,EAAIrK,EAAOoD,KAGvBkH,KAAKpF,MAAQuF,EAAUvF,EACxB,CAGA,GAAIiF,EAASG,KAAKvJ,OAEjB,IADAhB,EAAWJ,EAAQ2K,KAAKvJ,OAAOhB,SAC1BqD,EAAI,EAAGA,EAAIrD,EAAUqD,IAAK,CAC9B,IAAI4H,EAAQb,EAASG,KAAKvJ,OAAOqC,GAC7B4H,IACHV,KAAKpF,MAAM9B,GAAK4H,EAAMV,KAAKpF,MAAM9B,IAEnC,CAGDkH,KAAKC,OAAS5I,KAAKC,IAAI,EAAGD,KAAKD,IAAI,EAAG4I,KAAKC,SAEvCrJ,OAAO+J,QACV/J,OAAO+J,OAAOX,KAEhB,CA0TA,SAASY,EAAOnK,EAAOoK,EAASC,GAS/B,OARArK,EAAQgG,MAAMsE,QAAQtK,GAASA,EAAQ,CAACA,IAElC0F,SAAQ,SAAUtC,IACtBgG,EAAShG,KAAOgG,EAAShG,GAAK,KAAKgH,GAAWC,CAChD,IAEArK,EAAQA,EAAM,GAEP,SAAUoC,GAChB,IAAIgE,EAEJ,OAAIpC,UAAU9D,QACTmK,IACHjI,EAAMiI,EAASjI,KAGhBgE,EAASmD,KAAKvJ,MACPmE,MAAMiG,GAAWhI,EACjBgE,IAGRA,EAASmD,KAAKvJ,KAASmE,MAAMiG,GACzBC,IACHjE,EAASiE,EAASjE,IAGZA,EACR,CACD,CAEA,SAASmE,EAAM1J,GACd,OAAO,SAAUM,GAChB,OAAOP,KAAKC,IAAI,EAAGD,KAAKD,IAAIE,EAAKM,GAClC,CACD,CAMA,SAASuI,EAAUc,EAAKtK,GACvB,IAAK,IAAImC,EAAI,EAAGA,EAAInC,EAAQmC,IACL,iBAAXmI,EAAInI,KACdmI,EAAInI,GAAK,GAIX,OAAOmI,CACR,CAzWAnB,EAAMpD,UAAY,CACjB1B,SAAU,WACT,OAAOgF,KAAKjF,QACb,EAEAmG,OAAQ,WACP,OAAOlB,KAAKA,KAAKvJ,QAClB,EAEAsE,OAAQ,SAAUoG,GACjB,IAAIC,EAAOpB,KAAKvJ,SAAS2E,EAAYiC,GAAK2C,KAAOA,KAAKxK,MAElDgF,EAAuB,KAD3B4G,EAAOA,EAAK1G,MAAwB,iBAAXyG,EAAsBA,EAAS,IACxClB,OAAemB,EAAKxG,MAAQwG,EAAKxG,MAAMyG,OAAOrB,KAAKC,QACnE,OAAO7E,EAAYiC,GAAG+D,EAAK3K,OAAO+D,EACnC,EAEA8G,cAAe,SAAUH,GACxB,IAAIC,EAAOpB,KAAKxK,MAAMkF,MAAwB,iBAAXyG,EAAsBA,EAAS,GAC9D3G,EAAuB,IAAhB4G,EAAKnB,OAAemB,EAAKxG,MAAQwG,EAAKxG,MAAMyG,OAAOrB,KAAKC,QACnE,OAAO7E,EAAYiC,GAAG7H,IAAI8J,QAAQ9E,EACnC,EAEA+G,MAAO,WACN,OAAuB,IAAhBvB,KAAKC,OAAeD,KAAKpF,MAAM+B,QAAUqD,KAAKpF,MAAMyG,OAAOrB,KAAKC,OACxE,EAEAuB,OAAQ,WAKP,IAJA,IAAI3E,EAAS,CAAC,EACVpH,EAAWJ,EAAQ2K,KAAKvJ,OAAOhB,SAC/BC,EAASL,EAAQ2K,KAAKvJ,OAAOf,OAExBoD,EAAI,EAAGA,EAAIrD,EAAUqD,IAC7B+D,EAAOnH,EAAOoD,IAAMkH,KAAKpF,MAAM9B,GAOhC,OAJoB,IAAhBkH,KAAKC,SACRpD,EAAOsC,MAAQa,KAAKC,QAGdpD,CACR,EAEA4E,UAAW,WACV,IAAIjM,EAAMwK,KAAKxK,MAAMoF,MASrB,OARApF,EAAI,IAAM,IACVA,EAAI,IAAM,IACVA,EAAI,IAAM,IAEU,IAAhBwK,KAAKC,QACRzK,EAAIiL,KAAKT,KAAKC,QAGRzK,CACR,EAEAkM,WAAY,WACX,IAAIlM,EAAMwK,KAAKxK,MAAMgM,SASrB,OARAhM,EAAIyB,GAAK,IACTzB,EAAI0B,GAAK,IACT1B,EAAI2B,GAAK,IAEW,IAAhB6I,KAAKC,SACRzK,EAAI2J,MAAQa,KAAKC,QAGXzK,CACR,EAEAkF,MAAO,SAAUyG,GAEhB,OADAA,EAAS9J,KAAKC,IAAI6J,GAAU,EAAG,GACxB,IAAIrB,EAAME,KAAKpF,MAAMU,IA4O9B,SAAsB6F,GACrB,OAAO,SAAUvC,GAChB,OANF,SAAiBA,EAAKuC,GACrB,OAAOQ,OAAO/C,EAAIgD,QAAQT,GAC3B,CAISU,CAAQjD,EAAKuC,EACrB,CACD,CAhPkCW,CAAaX,IAASE,OAAOrB,KAAKC,QAASD,KAAKvJ,MACjF,EAEA0I,MAAO,SAAUtG,GAChB,OAAI4B,UAAU9D,OACN,IAAImJ,EAAME,KAAKpF,MAAMyG,OAAOhK,KAAKC,IAAI,EAAGD,KAAKD,IAAI,EAAGyB,KAAQmH,KAAKvJ,OAGlEuJ,KAAKC,MACb,EAGA8B,IAAKnB,EAAO,MAAO,EAAGI,EAAM,MAC5BgB,MAAOpB,EAAO,MAAO,EAAGI,EAAM,MAC9BiB,KAAMrB,EAAO,MAAO,EAAGI,EAAM,MAE7BrF,IAAKiF,EAAO,CAAC,MAAO,MAAO,MAAO,MAAO,OAAQ,GAAG,SAAU/H,GAAO,OAASA,EAAM,IAAO,KAAO,GAAK,IAEvGqJ,YAAatB,EAAO,MAAO,EAAGI,EAAM,MACpCmB,UAAWvB,EAAO,MAAO,EAAGI,EAAM,MAElCoB,YAAaxB,EAAO,MAAO,EAAGI,EAAM,MACpClK,MAAO8J,EAAO,MAAO,EAAGI,EAAM,MAE9BpF,OAAQgF,EAAO,MAAO,EAAGI,EAAM,MAC/BxK,KAAMoK,EAAO,MAAO,EAAGI,EAAM,MAE7BqB,MAAOzB,EAAO,MAAO,EAAGI,EAAM,MAC9BsB,OAAQ1B,EAAO,MAAO,EAAGI,EAAM,MAE/BuB,KAAM3B,EAAO,OAAQ,EAAGI,EAAM,MAC9BwB,QAAS5B,EAAO,OAAQ,EAAGI,EAAM,MACjCyB,OAAQ7B,EAAO,OAAQ,EAAGI,EAAM,MAChC0B,MAAO9B,EAAO,OAAQ,EAAGI,EAAM,MAE/B7I,EAAGyI,EAAO,MAAO,EAAGI,EAAM,MAC1B5I,EAAGwI,EAAO,MAAO,EAAGI,EAAM,MAC1BvI,EAAGmI,EAAO,MAAO,EAAGI,EAAM,MAE1BhK,EAAG4J,EAAO,MAAO,EAAGI,EAAM,MAC1B/G,EAAG2G,EAAO,MAAO,GACjBzJ,EAAGyJ,EAAO,MAAO,GAEjBzK,QAAS,SAAU0C,GAClB,OAAI4B,UAAU9D,OACN,IAAImJ,EAAMjH,GAGXxD,EAAQ2K,KAAKvJ,OAAON,QAAQ6J,KAAKpF,MACzC,EAEA1E,IAAK,SAAU2C,GACd,OAAI4B,UAAU9D,OACN,IAAImJ,EAAMjH,GAGXuC,EAAYiC,GAAGnH,IAAI8J,KAAKxK,MAAMkF,QAAQE,MAC9C,EAEA+H,UAAW,WACV,IAAInN,EAAMwK,KAAKxK,MAAMoF,MACrB,OAAkB,IAATpF,EAAI,KAAc,IAAiB,IAATA,EAAI,KAAc,EAAe,IAATA,EAAI,EAChE,EAEAoN,WAAY,WAKX,IAHA,IAAIpN,EAAMwK,KAAKxK,MAAMoF,MAEjBiI,EAAM,GACD/J,EAAI,EAAGA,EAAItD,EAAImB,OAAQmC,IAAK,CACpC,IAAIgK,EAAOtN,EAAIsD,GAAK,IACpB+J,EAAI/J,GAAMgK,GAAQ,OAAWA,EAAO,MAAQzL,KAAKmB,KAAMsK,EAAO,MAAS,MAAQ,IAChF,CAEA,MAAO,MAASD,EAAI,GAAK,MAASA,EAAI,GAAK,MAASA,EAAI,EACzD,EAEAE,SAAU,SAAUC,GAEnB,IAAIC,EAAOjD,KAAK4C,aACZM,EAAOF,EAAOJ,aAElB,OAAIK,EAAOC,GACFD,EAAO,MAASC,EAAO,MAGxBA,EAAO,MAASD,EAAO,IAChC,EAEAE,MAAO,SAAUH,GAChB,IAAII,EAAgBpD,KAAK+C,SAASC,GAClC,OAAII,GAAiB,IACb,MAGAA,GAAiB,IAAO,KAAO,EACxC,EAEAC,OAAQ,WAEP,IAAI7N,EAAMwK,KAAKxK,MAAMoF,MAErB,OADoB,IAATpF,EAAI,GAAoB,IAATA,EAAI,GAAoB,IAATA,EAAI,IAAY,IAC5C,GACd,EAEA8N,QAAS,WACR,OAAQtD,KAAKqD,QACd,EAEAE,OAAQ,WAEP,IADA,IAAI/N,EAAMwK,KAAKxK,MACNsD,EAAI,EAAGA,EAAI,EAAGA,IACtBtD,EAAIoF,MAAM9B,GAAK,IAAMtD,EAAIoF,MAAM9B,GAEhC,OAAOtD,CACR,EAEAgO,QAAS,SAAU5J,GAClB,IAAIjE,EAAMqK,KAAKrK,MAEf,OADAA,EAAIiF,MAAM,IAAMjF,EAAIiF,MAAM,GAAKhB,EACxBjE,CACR,EAEA8N,OAAQ,SAAU7J,GACjB,IAAIjE,EAAMqK,KAAKrK,MAEf,OADAA,EAAIiF,MAAM,IAAMjF,EAAIiF,MAAM,GAAKhB,EACxBjE,CACR,EAEA+N,SAAU,SAAU9J,GACnB,IAAIjE,EAAMqK,KAAKrK,MAEf,OADAA,EAAIiF,MAAM,IAAMjF,EAAIiF,MAAM,GAAKhB,EACxBjE,CACR,EAEAgO,WAAY,SAAU/J,GACrB,IAAIjE,EAAMqK,KAAKrK,MAEf,OADAA,EAAIiF,MAAM,IAAMjF,EAAIiF,MAAM,GAAKhB,EACxBjE,CACR,EAEAiO,OAAQ,SAAUhK,GACjB,IAAI/D,EAAMmK,KAAKnK,MAEf,OADAA,EAAI+E,MAAM,IAAM/E,EAAI+E,MAAM,GAAKhB,EACxB/D,CACR,EAEAgO,QAAS,SAAUjK,GAClB,IAAI/D,EAAMmK,KAAKnK,MAEf,OADAA,EAAI+E,MAAM,IAAM/E,EAAI+E,MAAM,GAAKhB,EACxB/D,CACR,EAEAiO,UAAW,WAEV,IAAItO,EAAMwK,KAAKxK,MAAMoF,MACjB/B,EAAe,GAATrD,EAAI,GAAoB,IAATA,EAAI,GAAqB,IAATA,EAAI,GAC7C,OAAOsK,EAAMtK,IAAIqD,EAAKA,EAAKA,EAC5B,EAEAkL,KAAM,SAAUnK,GACf,OAAOoG,KAAKb,MAAMa,KAAKC,OAAUD,KAAKC,OAASrG,EAChD,EAEAoK,QAAS,SAAUpK,GAClB,OAAOoG,KAAKb,MAAMa,KAAKC,OAAUD,KAAKC,OAASrG,EAChD,EAEAqK,OAAQ,SAAUC,GACjB,IAAIvO,EAAMqK,KAAKrK,MACXgG,EAAMhG,EAAIiF,MAAM,GAIpB,OAFAe,GADAA,GAAOA,EAAMuI,GAAW,KACZ,EAAI,IAAMvI,EAAMA,EAC5BhG,EAAIiF,MAAM,GAAKe,EACRhG,CACR,EAEAwO,IAAK,SAAUC,EAAYC,GAG1B,IAAKD,IAAeA,EAAW5O,IAC9B,MAAM,IAAIkB,MAAM,gFAAkF0N,GAEnG,IAAIE,EAASF,EAAW5O,MACpBwN,EAAShD,KAAKxK,MACd4D,OAAemL,IAAXF,EAAuB,GAAMA,EAEjCtI,EAAI,EAAI3C,EAAI,EACZa,EAAIqK,EAAOnF,QAAU6D,EAAO7D,QAE5BqF,IAAQzI,EAAI9B,IAAO,EAAK8B,GAAKA,EAAI9B,IAAM,EAAI8B,EAAI9B,IAAM,GAAK,EAC1DwK,EAAK,EAAID,EAEb,OAAO1E,EAAMtK,IACXgP,EAAKF,EAAOvC,MAAQ0C,EAAKzB,EAAOjB,MAChCyC,EAAKF,EAAOtC,QAAUyC,EAAKzB,EAAOhB,QAClCwC,EAAKF,EAAOrC,OAASwC,EAAKzB,EAAOf,OACjCqC,EAAOnF,QAAU/F,EAAI4J,EAAO7D,SAAW,EAAI/F,GAC9C,GAIDxC,OAAOsF,KAAK7G,GAAS8G,SAAQ,SAAU1F,GACtC,IAAsC,IAAlCiJ,EAAcW,QAAQ5J,GAA1B,CAIA,IAAIhB,EAAWJ,EAAQoB,GAAOhB,SAG9BqK,EAAMpD,UAAUjG,GAAS,WACxB,GAAIuJ,KAAKvJ,QAAUA,EAClB,OAAO,IAAIqJ,EAAME,MAGlB,GAAIvF,UAAU9D,OACb,OAAO,IAAImJ,EAAMrF,UAAWhE,GAG7B,IA4DmBoC,EA5Df6L,EAA0C,iBAAxBjK,UAAUhF,GAAyBA,EAAWuK,KAAKC,OACzE,OAAO,IAAIH,GA2DQjH,EA3DUxD,EAAQ2K,KAAKvJ,OAAOA,GAAOwG,IAAI+C,KAAKpF,OA4D3D6B,MAAMsE,QAAQlI,GAAOA,EAAM,CAACA,IA5DuCwI,OAAOqD,GAAWjO,EAC5F,EAGAqJ,EAAMrJ,GAAS,SAAUmE,GAIxB,MAHqB,iBAAVA,IACVA,EAAQuF,EAAUV,EAAO7C,KAAKnC,WAAYhF,IAEpC,IAAIqK,EAAMlF,EAAOnE,EACzB,CAxBA,CAyBD,IA+DAnB,EAAOC,QAAUuK,C,YCjejBxK,EAAOC,QAAU,SAAoBwK,GACpC,SAAKA,GAAsB,iBAARA,KAIZA,aAAetD,OAASA,MAAMsE,QAAQhB,IAC3CA,EAAIpJ,QAAU,IAAMoJ,EAAIK,kBAAkBuE,UACzC/N,OAAOgO,yBAAyB7E,EAAMA,EAAIpJ,OAAS,IAAgC,WAAzBoJ,EAAI8E,YAAYrG,MAC9E,C,+BCNA,IAAIsG,EAAa,EAAQ,OAErBzD,EAAS5E,MAAMC,UAAU2E,OACzB1E,EAAQF,MAAMC,UAAUC,MAExB2B,EAAUhJ,EAAOC,QAAU,SAAiBiF,GAG/C,IAFA,IAAIuK,EAAU,GAELjM,EAAI,EAAGgE,EAAMtC,EAAK7D,OAAQmC,EAAIgE,EAAKhE,IAAK,CAChD,IAAIkM,EAAMxK,EAAK1B,GAEXgM,EAAWE,GAEdD,EAAU1D,EAAOzE,KAAKmI,EAASpI,EAAMC,KAAKoI,IAE1CD,EAAQtE,KAAKuE,EAEf,CAEA,OAAOD,CACR,EAEAzG,EAAQ2G,KAAO,SAAU1I,GACxB,OAAO,WACN,OAAOA,EAAG+B,EAAQ7D,WACnB,CACD,C,sGC5BA,eAAS,8EAAAyK,OAAO,G,gFCAhB,cASA,mBACItK,EACAuK,QAAA,IAAAA,IAAAA,EATsB,QAWtB,IACI,IAAMC,EAAgBtF,EAAMlF,QAAS2J,GAC/Bc,EAAWD,EAAcpP,MAAMuL,QAC/B+D,GAAa,IAAMD,EAAS,MAAQ,IAAMF,GAAc,KAAOA,EACrEvK,EAAQkF,EAAM9J,IAAIsP,EAAWD,EAAS,GAAIA,EAAS,IAC9C7P,MACA2J,MAAMiG,EAAcjG,SACpBnE,U,CACP,SAAM,CAER,OAAOJ,CACX,C,g0CCxBA,eAAS,6EAAA2K,WAAW,IACpB,eAAS,6EAAAC,WAAW,IACpB,eAAS,mFAAAC,iBAAiB,IAC1B,eAAS,2EAAAC,SAAS,IAClB,eAAS,wFAAAC,sBAAsB,IAC/B,eAAS,8EAAAC,YAAY,IACrB,eAAS,iFAAAC,eAAe,IACxB,eAAS,4EAAAC,UAAU,IACnB,eAAS,8EAAAC,YAAY,IACrB,eAAS,iFAAAC,eAAe,IACxB,eAAS,qFAAAC,mBAAmB,IAC5B,cAAS,iFAAAC,eAAe,IACxB,eAAS,mFAAAC,iBAAiB,IAC1B,eAAS,oFAAAC,kBAAkB,IAC3B,cAAS,6EAAAC,WAAW,IACpB,eAAS,6EAAAC,WAAW,IACpB,cAAS,8EAAAC,YAAY,IACrB,eAAS,gFAAAC,cAAc,IACvB,eAAS,oFAAAC,kBAAkB,IAC3B,aAAS,sFAAAC,oBAAoB,IAC7B,eAAS,kFAAAC,gBAAgB,IACzB,eAAS,6EAAAC,WAAW,IACpB,eAAS,8EAAAC,YAAY,IACrB,eAAS,oFAAAC,kBAAkB,IAC3B,eAAS,gFAAAC,cAAc,IACvB,eAAS,8EAAAC,YAAY,IACrB,eAAS,8EAAAC,YAAY,IACrB,eAAS,iFAAAC,eAAe,IACxB,eAAS,kFAAAC,gBAAgB,IACzB,cAAS,4EAAAC,UAAU,IACnB,eAAS,gFAAAC,cAAc,IACvB,eAAS,mFAAAC,iBAAiB,IAC1B,eAAS,6EAAAC,WAAW,IACpB,eAAS,wDAAA7I,IAAA,oBAAA8I,cAAc,IACvB,eAAS,6EAAAC,WAAW,IACpB,eAAS,4EAAAC,UAAU,IACnB,cAAS,4EAAAC,UAAU,IACnB,eAAS,qFAAAC,mBAAmB,IAC5B,eAAS,iFAAAC,eAAe,IACxB,eAAS,sFAAAC,oBAAoB,IAC7B,cAAS,oFAAAC,kBAAkB,IAC3B,eAAS,4EAAAC,UAAU,IACnB,eAAS,8EAAAC,YAAY,IACrB,eAAS,gFAAAC,cAAc,IACvB,eAAS,mFAAAC,iBAAiB,IAC1B,eAAS,oFAAAC,kBAAkB,IAE3B,eAAS,8FAAAC,4BAA4B,IACrC,eAAS,6FAAAC,2BAA2B,IACpC,eAAS,6FAAAC,2BAA2B,IACpC,eAAS,iGAAAC,+BAA+B,IACxC,eAAS,+FAAAC,6BAA6B,IACtC,gBAAS,yGAAAC,sCAAsC,IAC/C,gBAAS,oGAAAC,iCAAiC,IAE1C,gBAAS,8EAAAC,WAAW,IACpB,gBAAS,oFAAAC,iBAAiB,IAC1B,gBAAS,0FAAAC,uBAAuB,IAChC,gBAAS,4FAAAC,yBAAyB,IAClC,eAAS,sFAAAC,mBAAmB,IAC5B,gBAAS,4EAAAC,SAAS,IAClB,gBAAS,8EAAAC,WAAW,IAAE,wDAAAxK,IAAA,qBAAAyK,cAAc,IACpC,gBAAS,6DAAAzK,IAAA,qBAAA0K,mBAAmB,IAC5B,gBAAS,0FAAAC,uBAAuB,IAChC,gBAAS,sFAAAC,mBAAmB,G,2GChE5B,eACA,WACA,WAOMC,EAGF,CACAC,KAAM,CACFC,IAAK,QACLC,IAAK,OAETC,OAAQ,CACJF,IAAK,SACLC,IAAK,UAETE,MAAO,CACHH,IAAK,MACLC,IAAK,SAETG,QAAS,CACLJ,IAAK,UACLC,IAAK,YAIPI,EAGF,CACAN,KAAM,CACFC,IAAK,YACLC,IAAK,cAETC,OAAQ,CACJF,IAAK,cACLC,IAAK,eAETE,MAAO,CACHH,IAAK,aACLC,IAAK,cAOb,6BACIjT,EACAsT,IAEA,IAAAC,4BAA2BvT,GAE3B,IAAMwT,GAA6B,IAAAC,sBAC/BzT,EACA,CAAC,YACD,CAAC,cAwBL,OArBAwT,EAA2B9N,SAAQ,SAAC,G,IAASgO,EAAa,QAChDC,GAAQ,IAAAC,aAAYF,GACpBG,EAAef,EAAUQ,GAAqC,OAA1BK,EAAMG,OAAOC,UAAqB,MAAQ,OAE5D,UAApBJ,EAAMK,WAAuC,YAAdV,GAC/B,IAAAW,YACIN,EACAN,EAAcC,GAAqC,OAA1BK,EAAMG,OAAOC,UAAqB,MAAQ,QAEhEJ,IACiB,eAApBA,EAAMK,WAAuD,aAAzBL,EAAMO,gBAC1CP,EAAMQ,OAAOzO,SAAQ,SAAAhF,IACE,IAAAkT,aAAYlT,GAAE,OAC1B0T,UAAYP,CACvB,IAEeF,EAAK,OACjBS,UAAYP,EAE3B,IAEOL,EAA2BtT,OAAS,CAC/C,C,2GCtFA,eACA,WACA,WAmBMmU,EAAiB,0DACjBC,EAAiB,2EACjBC,EAAmB,MAkDzB,SAASC,EAAqBb,EAAkCI,GAI5D,GAHyC,OAA1BJ,EAAMG,OAAOC,YACD,OAAbA,GAEO,CACT,IAAAD,GAAW,IAAAF,aAAYD,GAAM,OACrCG,EAAOC,UAAYA,EAGnB,IAAMU,EAAaX,EAAOW,WACpBC,EAAcZ,EAAOY,YAE3BC,EAAYb,EAAQ,aAAcA,EAAOc,aACzCD,EAAYb,EAAQ,cAAeW,GACnCE,EAAYb,EAAQ,cAAeA,EAAOe,cAC1CF,EAAYb,EAAQ,eAAgBY,GAGhCf,GAA4B,SAAnBA,EAAMK,YACfL,EAAMmB,KAAKpP,SAAQ,SAAAqP,GACfA,EAAIC,MAAMtP,SAAQ,SAAAuP,IAEd,IAAAC,0BAAwB,IAAAtB,aAAYqB,IAAO,SAAAE,GACvC,GAAIA,aAAQ,EAARA,EAAUC,eAAgB,CAC1B,IAAMC,EAAkBJ,EAAKnB,OAAOwB,WACpCX,EAAYM,EAAKnB,OAAQ,aAAcmB,EAAKnB,OAAOyB,aACnDZ,EAAYM,EAAKnB,OAAQ,cAAeuB,E,CAE5C,OAAOF,CACX,GACJ,GACJ,KAGA,IAAAK,kBAAiB7B,OAAO7F,GAA2B,G,CAG/D,CAEA,SAAS6G,EACLb,EACApV,EACA2B,GAEIA,EACAyT,EAAOpV,GAAO2B,SAEPyT,EAAOpV,EAEtB,CA9FA,6BACIsB,EACA+T,IAEA,IAAAR,4BAA2BvT,GAE3B,IAAMwT,GAA6B,IAAAC,sBAC/BzT,EACA,CAAC,YACD,CAAC,cAiCL,OA9BAwT,EAA2B9N,SAAQ,SAAC,G,IAC5B+P,EAD8B9B,EAAK,QAGnC8B,EADc,SAAd1B,EAmFZ,SAAgCJ,GAC5B,GAAwB,cAApBA,EAAMK,UAA2B,CACjC,IAAM0B,EAAgD/B,EAAMgC,SAASC,QACjE,SAACC,GAAyC,MAAoB,SAApBA,EAAIC,WAAJ,IAE1CC,EACAL,EAAkBxV,OAAS,EACrBwV,EAAkBM,QAAO,SAACC,EAAMJ,GAAQ,OAAAI,EAAOJ,EAAIK,IAAX,GAAiB,SACzDpI,EACV,GAAMiI,EAAW,CAOb,IAAMI,GAFNJ,GAHAA,EAAYA,EAAUK,QAAQ9B,EAAgB,KAGxB8B,QAAQ7B,EAAkB,KAEnB7P,MAAM2P,GAC7BgC,EAAWF,EAAaA,EAAWjW,OAAS,EAIlD,OAAOmW,EAFUN,EAAU7V,OAASmW,EAEP,MAAQ,K,CAErC,MAAO,K,CAGX,MAAO,KAEf,CA9G4BC,CAAuB3C,GAEvBI,GAEhB,IAAAwC,oBAAyC5C,EAAO,aAClC,IAAArB,2BAA0BtS,EAAO2T,GAEzCjO,SAAQ,SAAA8Q,GACV,IAAMC,GAAO,IAAA7C,aAAY4C,GAEzBC,EAAKC,OAAOhR,SAAQ,SAAAgH,GAChBA,EAAMoH,OAAOC,UAAY0B,CAC7B,WAGOgB,EAAK3C,OAAOC,iBAGZ0C,EAAK3C,OAAOM,UAEnBqC,EAAKtC,OAAOzO,SAAQ,SAAAiO,GAAS,OAAAa,EAAqBb,EAAO8B,EAA5B,GACjC,IACO9B,GACPa,EAAqBb,EAAO8B,EAEpC,IAEOjC,EAA2BtT,OAAS,CAC/C,C,2HCvEA,WACA,WACA,WACA,WACA,WA8IA,SAASyW,EAAWC,GAChB,OAAOA,EAASzC,OAAO0C,MAAK,SAAAlD,GACxB,GAAuB,aAAnBA,EAAMK,UACN,OAAOL,EAAMgC,SAASkB,MAAK,SAAAC,GAAW,OAAAA,EAAQH,UAAR,GAE9C,GACJ,CA8BA,SAASI,EACLjD,EACAkD,EACA9W,QAAA,IAAAA,IAAAA,EAAiB,EAAA+W,mBAET,IAAAxC,EAAuCX,EAAM,WAAjCc,EAA2Bd,EAAM,YAC/CoD,EAAqB,OADoBpD,EAAM,UAE/CqD,GAAgB,IAAAC,oBAAmBF,EAAQtC,EAAcH,GAC3D4C,GAAYL,EAAWpW,KAAK0W,KAAO1W,KAAK6B,OAAO0U,EAAgBjX,GAAUA,EAM7E,OAJImX,GAAYF,IACZE,EAAWzW,KAAKC,IAAIwW,EAAWnX,GAAU8W,EAAW,GAAK,GAAI,IAG7DK,GAAYF,EAEL,KAEAE,CAEf,CA5KA,+BACIrX,EACAuX,EACArX,EACAsX,QADA,IAAAtX,IAAAA,EAAiB,EAAA+W,oBAGjB,IAAA1D,4BAA2BvT,GAE3B,IAAMyX,GAAsB,IAAAhE,sBACxBzT,EACA,CAAC,YACD,CAAC,cAECgX,EAA0B,UAAfO,EACXG,EAA8C,GA6FpD,OA3FAD,EAAoB/R,SAAQ,SAAC,G,IAAEiO,EAAK,QAAE3M,EAAM,SAAED,EAAI,OAC9C,IAAI,IAAAwP,oBAAyC5C,EAAO,YAAa,CAC7D,IAAMgE,GAAS,IAAArF,2BAA0BtS,EAAO2T,GAC1CiE,EAAYD,EAAO,GAEzB,GAAIhB,EAAWiB,IAAyC,GAA3BA,EAAUlB,OAAOxW,OAAa,CACvD,IAAMwM,EAAQiH,EAAM+C,OAAO,GAEnBjC,GADAX,EAAWpH,EAAK,QACkB,WAAtBkI,EAAgBd,EAAM,YACpCuD,EAAWN,EAAqBjD,EAAQkD,EAAU9W,GAClDgX,EAA4B,OAApBpD,EAAOC,UACfoD,GAAgB,IAAAC,oBAAmBF,EAAQtC,EAAcH,GAE1DuC,GAA6B,GAAjBG,EAEO,OAAbE,IACHH,EACAxK,EAAMoH,OAAOc,YAAcyC,EAAW,KAEtC3K,EAAMoH,OAAOW,WAAa4C,EAAW,MALzC1D,EAAM+C,OAAOnP,K,MASd,GAA2B,GAAvBoM,EAAM+C,OAAOxW,SAyFpC,SACIF,EACA4W,EACA5P,GAGA,IADA,IACS3E,EADS2E,EAAOmN,OAAOvK,QAAQgN,GACf,EAAGvU,GAAK,EAAGA,IAAK,CACrC,IAAMsR,EAAQ3M,EAAOmN,OAAO9R,GAC5B,IACI,IAAAkU,oBAAyC5C,EAAO,aACzB,GAAvBA,EAAM+C,OAAOxW,QACbyW,EAAWhD,GAGX,OAAOgD,GADW,IAAArE,2BAA0BtS,EAAO2T,GAAO,IAI9D,KAAK,IAAA4C,oBAAyC5C,EAAO,YACjD,OAAO,C,CAGf,OAAO,CACX,CA/GoDkE,CAAsB7X,EAAO2T,EAAO3M,GAAS,CACjF,GAAIgQ,EAAU,CACV,IAAMc,EAAYH,EAAO/N,QAAQ+J,GAC3BoE,EAAeJ,EAAOG,EAAY,GAClCE,EAAWL,EAAOG,EAAY,GAC9BG,EAActE,EAAM+C,OAAOxW,OAC3BgY,EAAYvE,EAAM+C,OAAOuB,EAAc,GACvCE,GAAkC,IAAAC,kBACpCF,aAAS,EAATA,EAAWG,WAAY,KACvBH,aAAS,EAATA,EAAWpE,OACXiE,GAAgBA,EAAarB,OAAOxW,OAAS+X,EACvCF,EAAarB,OAAOuB,GAAaK,QACjCN,GAAYA,EAAStB,OAAOxW,OAAS+X,EACrCD,EAAStB,OAAOuB,GAAaK,aAC7BxK,IAGV,IAAAyK,oBAAmBJ,GAAU,SAAAhD,GAGzB,OAFAA,EAAWA,GAAY,CAAC,GACfqD,yBAA0B,EAC5BrD,CACX,WAGOgD,EAASrE,OAAO2E,oBAEvB9E,EAAM+C,OAAO1M,KAAKmO,E,MAElBxE,EAAM+C,OAAOnP,MAGboM,EAAM+C,OAAOxW,OAAS,GAAKsX,IAC3BA,EAAQkB,cAAe,IAAA/F,sBAAmB,oBAAEgB,IAAK,YAAK5M,IAAI,I,OAG/D,GAAI4M,EAIP,IAHA,IAAIgF,EAA0ChF,EAC1CiF,EAAgD5R,EAE7C4R,GAAiBlB,EAAe9N,QAAQ+O,GAAgB,GAAG,CAC9D,IACQ7E,EADF+E,EAAQ9R,EAAK6C,QAAQgP,GAI3B,GAAiB,QAFXvB,EAAWN,EADTjD,GAAW,IAAAF,aAAY+E,GAAa,OACE3B,EAAU9W,IAEjC,EACbgX,EAA4B,OAApBpD,EAAOC,WAGjBD,EAAOc,YAAcyC,EAAW,KAEhCvD,EAAOW,WAAa4C,EAAW,KAGnCK,EAAe1N,KAAK2O,GAEpB,K,CACG,KAAoC,mBAAhCC,EAAc1E,gBAAuC2E,GAAS,GAMrE,OALA,IAAAjF,aAAYgF,GAEZD,EAAeC,EACfA,EAAgB7R,EAAK8R,EAAQ,E,CAM7C,IAEIpB,EAAoBvX,OAAS,KAC7B,IAAA4Y,uBAAsB9Y,IAEf,EAIf,C,mIChJA,WA+DA,SAAS+Y,EACLC,GAEA,OAAO,IAAAC,kBAAgB,EAAsBD,EAAKlF,OAAQkF,EAAKE,cAAeF,EAAKG,UACvF,CAnDA,sCAA2CnZ,G,cACjCoZ,GAAa,IAAAC,kCACfrZ,GACA,GACA,G,IAGJ,IAA8B,qBAAAoZ,GAAU,8BAAE,CAA/B,8BAAIJ,GAAF,KAAM,MAAEjS,EAAI,KACrB,GAAIiS,aAAI,EAAJA,EAAMrD,SAASkB,MAAK,SAAA3V,GAAK,MAAiB,MAAjBA,EAAE4U,WAAF,IAAwB,CACjD,IAAIwD,EAAmBP,EAAsBC,GACzCO,GAAoB,EAClBC,EAAuD,GACvD,GAAS,IAAA5F,aAAY7M,EAAK,IAC1B8R,EAAQ,EAAO1E,OAAOvK,QAAQoP,GAEpC,GAAIH,GAAS,EAAG,C,IACZ,IAAsB,oCAAAjF,aAAYoF,GAAMrD,WAAQ,8BAAE,CAA7C,IAAMmB,EAAO,QACa,MAAvBA,EAAQhB,aACHyD,GACDD,EAAiB3D,SAAS3L,KAAK8M,GAG/BwC,EAAiB3D,SAASzV,OAAS,GACnCsZ,EAAcxP,KAAKsP,GAGvBA,EAAmBP,EAAsBC,GACzCO,GAAoB,IAEpBD,EAAiB3D,SAAS3L,KAAK8M,GAEJ,mBAAvBA,EAAQhB,cACRyD,GAAoB,G,mGAK5BD,EAAiB3D,SAASzV,OAAS,GACnCsZ,EAAcxP,KAAKsP,IAGvB,IAAOnF,QAAOxK,OAAM,6BAACkP,EAAO,IAAC,YAAKW,IAAa,G,qGAI/D,C,+GC7DA,eACA,WACA,WA0EA,SAASC,EAAQ9F,GACb,OACI,IAAA4C,oBAAgD5C,EAAO,oBACtC,cAAjBA,EAAM+F,OAEd,CAvDA,iCACI1Z,EACA2Z,EACAC,IAEA,IAAArG,4BAA2BvT,GAE3B,IAAM6Z,GAAmB,IAAApG,sBAEvBzT,EAAO,CAAC,kBAAmB,YAAa,CAAC,cAAc,GAAoB,SAAA2T,GACzE,MAA+B,mBAAxBA,EAAMO,gBAAuD,cAAjBP,EAAM+F,OAC7D,IAEA,GAAsBG,EAqDCC,OAAM,SAAAC,GAAkB,OAAAN,EAAQM,EAAepG,MAAvB,IAnD3CkG,EAAiBnU,SAAQ,SAAC,G,IAAEiO,EAAK,QAAE3M,EAAM,UACrC,IAAAgT,aAAYhT,EAAQ2M,EACxB,QACG,CACH,IAAM,EAAoE,GACpE,EAAU,SAACuD,GACb,WAAA+C,uBAAsB,aAAc/C,EAAQ0C,EAAYD,EAAxD,EACE,EAAW,SACbzC,EACAgD,EACA5S,GAEA,OAgBZ,SACI4S,EACApG,GAEA,OAAO2F,EAAQS,KAAW,IAAAC,gBAAerG,EAAQoG,EAAOpG,OAC5D,CArBYsG,CAAcF,GAAQ5S,aAAO,EAAPA,EAASwM,UAAWoD,EAAQ0C,EAAYD,GAA9D,EAEJE,EAAiBnU,SAAQ,SAAC,G,IAAEiO,EAAK,QAAE3M,EAAM,SACjCyS,EAAQ9F,KAGR,IAAA0G,gBAAe,EAAcrT,EAAQ2M,EAAO,EAAS,EAE7D,KAEA,IAAA2G,gBAAe,EAAc,E,CAGjC,OAAOT,EAAiB3Z,OAAS,CACrC,C,2KCnEA,WAiBA,SAASqa,EAAgBrE,GACrB,IAAMsE,EAKV,SAA+BnS,G,QACvBoS,EAAQ,E,IACZ,IAAmB,qBAAApS,GAAG,8BAAE,CAAnB,IAAMvD,EAAI,QACX,GAlBS,MAkBLA,GAhBa,MAgBQA,GAjBX,KAiBwCA,EAGlD,MAFA2V,G,mGAKR,OAAOA,CACX,CAfmBC,CAAsBxE,GAErC,OADkBtV,KAAK6B,MAAM+X,EAAS,EAE1C,CANa,EAAAvD,kBAAoB,GAuBjC,iCAAsCL,GAClC,IAAMjD,EAAQiD,EAASzC,OAAO,GAC9B,GACuB,aAAnBR,EAAMK,WACNL,EAAMgC,SAASzV,OAAS,GACS,QAAjCyT,EAAMgC,SAAS,GAAGG,YACpB,CACE,IAAM,EAAYyE,EAAgB5G,EAAMgC,SAAS,GAAGO,MAEhD,EAAY,KACZ,IAAAyE,eAAchH,EAAOA,EAAMgC,SAAS,IAAI,SAAAiF,GACpCA,EAAY1E,KAAO0E,EAAY1E,KAAKzR,UAAsB,EAAZ,EAClD,IACAmS,EAASF,OAAO,GAAG5C,OAAOW,WAAa,EAAY,EAAAwC,kBAAoB,K,CAGnF,EAKA,kCAAuC4D,EAA0BC,GACrD,IAAAC,EAAsBF,EAAW,UAAtBG,EAAWH,EAAW,OACnCI,EAAoBC,EAAoBH,GAE1CE,IACAJ,EAAYE,UAAUpF,SAAW,CAACqF,GACY,OAA1CH,EAAYE,UAAUjH,OAAOC,UAC7B+G,EAAMhH,OAAOc,YAAcqG,EAAoB,EAAAhE,kBAAoB,KAEnE6D,EAAMhH,OAAOW,WAAawG,EAAoB,EAAAhE,kBAAoB,KAG9E,EAEA,IAAMiE,EAAsB,SAACH,G,QACrBI,EAAa,EACXxF,EAAWoF,EAAUpF,SAS3B,GAPoBoF,EAAUpF,SAASmE,OACnC,SAAA5Y,GACI,MAAkB,QAAjBA,EAAE4U,aAAiD,GAAxB5U,EAAEgV,KAAKkF,OAAOlb,QACzB,mBAAjBgB,EAAE4U,aACe,MAAjB5U,EAAE4U,WAFF,IAKR,CAIA,IAAIuF,EAAmB,E,IACvB,IAAkB,qBAAA1F,GAAQ,8BAAE,CAAvB,IAAME,EAAG,QACV,GAAwB,SAApBA,EAAIC,YAIJ,MAHAqF,GAA0BZ,EAAgB1E,EAAIK,MAC9CmF,G,mGAQR,OAAI1F,EAASzV,OAAS,GAAKmb,EAChBF,OADX,C,CAKJ,C,yHCzGA,WACA,WAyJA,SAASG,EACLvU,EACA4M,GAEA,IAAM4H,GAAqB,IAAAC,mCACvBzU,EACA,CAAC,mBACD,CAAC,cAGL,GAAIwU,GAAsB,GAAKA,EAAqBxU,EAAK7G,OAAS,EAAG,CACjE,IAAMub,GAAY,IAAA7H,aACd7M,EAAKwU,IAEHG,EAAiB3U,EAAKwU,EAAqB,GAAGpH,OAAOvK,QAAQ6R,GAC7DE,EAAaF,EAAUtH,OAAOvK,QAAQ+J,GAE5C,GAAIgI,GAAc,GAAKD,GAAkB,EAAG,CACxC,IAAME,GAA0D,IAAA3B,uBAC5DwB,EAAU/B,QACV+B,EAAU3H,QAGd2H,EAAUtH,OAAOxK,OAAOgS,EAAY,GACpCC,EAAazH,OAASsH,EAAUtH,OAAOxK,OAAOgS,IAE9C,IAAA/H,aAAY7M,EAAKwU,EAAqB,IAAIpH,OAAOxK,OAC7C+R,EAAiB,EACjB,EACA/H,EACAiI,E,EAIhB,CAEA,SAASC,EAAgB9U,GACrB,IAAM6P,EAAW7P,GAAK,IAAAyU,mCAAkCzU,EAAM,CAAC,YAAa,CAAC,eAI7E,QAAI6P,KACA,IAAAhD,aAAYgD,GAAUF,OAAS,IAExB,EAIf,CAEA,SAASoF,EACL/U,EACA4M,GAEA,GAAuB,WAAnBA,EAAMK,UAAwB,CAC9B,IAAM6E,EAAQ9R,EAAK,GAAGoN,OAAOvK,QAAQ+J,GAEjCkF,GAAS,IACT,IAAAjF,aAAY7M,EAAK,IAAIoN,OAAOxK,OAAOkP,EAAO,E,KAEpB,aAAnBlF,EAAMK,YACbL,EAAMG,OAAS,CAAC,SACTH,EAAMwF,UAErB,CA5LA,4BACInZ,EACA+b,EACAC,EACAC,GAEA,IAAIC,GAAyB,GAE7B,IAAAC,mBACInc,GACA,SAAC+G,EAAMqV,EAAczI,EAAOgC,GACxB,GAAIA,EACA,GAAwB,cAApBhC,aAAK,EAALA,EAAOK,WAA0B,CAC3B,IAAGqI,GAAH,aAAsB,IAAAC,gBAAe3I,EAAOgC,GAAS,GAAnC,GAExBqG,EAAgBhS,KAAI,MAApBgS,GAAe,mCAASK,IAAe,G,KAEb,YAA1BtV,EAAK,GAAGmN,gBACW,GAAnByB,EAASzV,QACT6G,EAAK,GAAGwV,cAAgB5G,EAAS,IAEjCqG,EAAgBhS,MAAK,IAAA4J,aAAY7M,EAAK,IAAIwV,cAI9C5I,EACAoI,EAAc/R,KAAK,CAACjD,GAAM,IAAA6M,aAAYD,KAC/ByI,GAyEvB,SACIA,EACAH,GAEA,GAAIG,EAAc,CACN,MAAoDA,EAAY,MAAzDI,EAA6CJ,EAAY,SAA/CK,EAAmCL,EAAY,SAArCM,EAAyBN,EAAY,qBAClEnH,EAAO,EAAMH,KAAK2H,GAAUzH,MAAMwH,GAExC,GAAIvH,EAAK0B,WAAY,CACjB,IAAMgG,GAAc,IAAA/I,aAAYqB,IAEhC,IAAAC,yBAAwByH,GAAa,WAAM,eAC3CA,EAAYC,UAAW,EACvBD,EAAY7I,OAAS,CACjB+I,aAAc5H,EAAKnB,OAAO+I,a,CAI7BZ,EAAca,MAAK,SAAApb,GAAK,OAAAA,EAAE,IAAM,CAAR,KACzBua,EAAcjS,KAAK,EAAC,IAAA4J,aAAY,GAAQ8I,G,CAGpD,CA9FgBK,CAAqBX,EAAcH,EAE3C,GACA,CAKIe,wBAAyBhd,EAAM8T,OAAS,QAAU,eAI1D,IAAMkH,EAASgB,EAAgB,GAG/B,GAC4B,GAAxBD,EAAc7b,QAkJtB,SAAuCyT,GACnC,IAAMgC,EAA8B,aAAnBhC,EAAMK,UAA2BL,EAAMgC,SAASC,QAAO,SAAAlU,GAAK,OAAAA,EAAEiV,UAAF,IAAgB,GAE7F,OAA0B,GAAnBhB,EAASzV,QAA0C,mBAA3ByV,EAAS,GAAGG,WAC/C,CArJQmH,CAA8BlB,EAAc,GAAG,KACvB,GAAxBA,EAAc7b,OAEd8b,EAAgBrS,OAAM,MAAtBqS,GAAe,oBAAQ,EAAGA,EAAgB9b,SAAM,aAAK,IAAA2S,qBAAoB7S,EAAOgb,KAAO,IACvFkB,EAAyBL,EAAgBE,EAAc,GAAG,KAAOG,OAC9D,GAAIH,EAAc7b,OAAS,GAAK6b,EAAclF,MAAK,SAAAnV,GAAK,OAkJnE,SAA8BiS,GAC1B,OACKA,EAA6BgD,YACV,aAAnBhD,EAAMK,WAA4BL,EAAMgC,SAASmE,OAAM,SAAApY,GAAK,OAAAA,EAAEiV,UAAF,GAErE,CAvJmEuG,CAAqBxb,EAAE,GAAvB,IAE3D,IAAK,IAAIW,EAAI0Z,EAAc7b,OAAS,EAAGmC,GAAK,EAAGA,IAAK,CAC1C,mBAAgB0Z,EAAc1Z,GAAE,GAA/B0E,EAAI,KAAE4M,EAAK,KAElBmI,EAAiB/U,EAAM4M,GACvBuI,EAAyBL,EAAgB9U,IAASmV,EAClDZ,EAAqBvU,EAAM4M,E,CAUnC,OAkBJ,SACIqI,EACAmB,GAEAnB,EAAgBtW,SAAQ,SAAAhE,GACpBA,EAAEoS,QAAS,EAAH,eAASqJ,GAAwB,CAAC,GAEtCzb,EAAEgF,aACKhF,EAAEgF,KAAKoN,OAAOsJ,iBAGlB1b,EAAE2b,IACb,GACJ,CApCIC,CAAoBtB,EAAiBhc,EAAM8T,QAQ/C,SAA4BmI,GACxBA,EAAcvW,SAAQ,SAAAhE,GACZ,mBAAgCA,EAAC,GAAhCoZ,EAAK,KAAsB,OAE9BA,EAAMhH,OAAS,CACX+I,aAAc/B,EAAMhH,OAAO+I,aAC3BU,eAAgBzC,EAAMhH,OAAOyJ,iBAEjC,IAAAC,qBAAoB1C,GAAO,WAAM,iBAGrC,IAAAtF,kBAAiBsF,OAAOhN,GAAyB,EACrD,GACJ,CAlBI2P,CAAmBxB,GAEZC,CACX,C,gIClGA,WA0FA,SAASwB,EACL/J,EACAgK,EACA/H,GAEA,OAGJ,SACIjC,EACAgK,GAEA,OAAOhK,EAAMK,WAAa2J,CAC9B,CARWC,CAAejK,EAAOgK,MAAW/H,GAAUA,EAAOjC,GAC7D,CA9EA,mCAAgBf,EACZiL,EACAF,EACA/H,EACAkI,EACAC,GAGA,I,YADMC,EAAgB,GACb3b,EAAI,EAAGA,EAAIwb,EAAM1J,OAAOjU,OAAQmC,IAAK,CAC1C,GAAIyb,GAAiBE,EAAS9d,OAAS,EACnC,OAAO8d,EAEX,IAAMrK,EAAQkK,EAAM1J,OAAO9R,GAE3B,OAAQsR,EAAMK,WACV,IAAK,YACL,IAAK,UACL,IAAK,SAID,GAHI0J,EAAoB/J,EAAOgK,EAAM/H,IACjCoI,EAAShU,KAAK2J,GAEK,UAAnBA,EAAMK,WAAyB+J,EAAoB,CACnD,IAAME,EAAgBF,EAAmBpK,GACzC,GAAIsK,EAAe,CACf,IAAMzG,GAAU,IAAA0G,yBAAwBD,GAElC,EAAUrL,GADF,IAAAuL,mBAAkBxK,EAAMyK,QAAS5G,GAG3CmG,EACA/H,EACAkI,EACAC,GAEJC,EAAShU,KAAI,MAAbgU,GAAQ,mCAAS,IAAO,G,EAGhC,MACJ,IAAK,aACGN,EAAoB/J,EAAOgK,EAAM/H,IACjCoI,EAAShU,KAAK2J,GAElB,IAAMrF,EAAUsE,EACZe,EACAgK,EACA/H,EACAkI,EACAC,GAEJC,EAAShU,KAAI,MAAbgU,GAAQ,mCAAS1P,IAAO,IACxB,MACJ,IAAK,QACGoP,EAAoB/J,EAAOgK,EAAM/H,IACjCoI,EAAShU,KAAK2J,G,IAElB,IAAkB,+BAAAA,EAAMmB,OAAI,8BAAE,CAAzB,IAAMC,EAAG,Q,IACV,IAAmB,+BAAAA,EAAIC,QAAK,8BAAE,CAAzB,IACK,EAAUpC,EADL,QAGP+K,EACA/H,EACAkI,EACAC,GAEJC,EAAShU,KAAI,MAAbgU,GAAQ,mCAAS,IAAO,G,wMAM5C,OAAOA,CACX,C,mICxFA,WA2BA,sCACIH,EACA7W,EACAwQ,GAEA,IAAKA,EAAQ6G,UAAW,CACpB,IAAMC,GAAoB,IAAAC,sBAAqB/G,EAAQgH,WACvDhH,EAAQ6G,UAAYC,EA6B5B,SAAyBG,EAAYC,GAIjC,IAHA,IAAMtY,EAAiB,GACnBsB,EAAoBgX,EAEjBhX,GAAQ+W,GAAQ/W,GAAQ+W,EAAKE,SAASjX,KACrC,IAAAkX,cAAalX,EAAM,iBAAmC,SAAhBA,EAAKgS,QAG3CtT,EAAOuD,OAAO,EAAGvD,EAAOlG,OAAQwH,GAEhCtB,EAAO4D,KAAKtC,GAGhBA,EAAOA,EAAKmX,WAGhB,OAAOzY,CACX,CA9CgD0Y,CAAgB9X,EAAQsX,GAAqB,E,CAGzF,IAAMS,EAAavH,EAAQ6G,UAAU9W,MAErC,GAAIwX,EAAY,CACN,oBAAmC,IAAAC,4BAA2BxH,EAASxQ,GAAO,GAA7EiY,EAAe,KAAEC,EAAa,KAG/BrG,EACFoG,GAAmB,GAAKC,GAAiB,EAsCrD,SAAuBlY,EAAoB+X,GAIvC,IAHA,IAAIlG,EAAQ,EACRsG,EAAQnY,EAAOoY,WAEZD,GAASA,GAASJ,GACrBlG,IACAsG,EAAQA,EAAME,YAElB,OAAOxG,CACX,CA/CyDyG,CAActY,EAAQ+X,IAAe,EAElFlG,GAAS,IACT,IAAA0G,wBAAuB1G,EAAOrB,EAASqG,EAAOoB,EAAiBC,IAGnE,IAAAM,kBAAiB3B,EAAOkB,EAAYvH,GAEhCqB,GAAS,IACT,IAAA0G,wBAAuB1G,EAAQ,EAAGrB,EAASqG,EAAOoB,EAAiBC,E,MAMvE1H,EAAQiI,yBAAyBN,MAAMtB,EAAO7W,EAAQwQ,EAE9D,C,wIC7DA,WAoBA,0BACIkI,EACAC,EACAC,EACAC,EACAC,G,MAEM9Y,EAAS2Y,GAAiB,IAAA/L,aAAY+L,GAAkB,KACxDI,GAAc,IAAAnM,aAAYgM,GAC1B/G,EAA2C,QAAnC,EAAA7R,aAAM,EAANA,EAAQmN,OAAOvK,QAAQmW,UAAY,SAAK,EAEtD,GAAI/Y,GAAU6R,GAAS,EAAG,CACtB7R,EAAOmN,OAAOxK,OAAOkP,EAAO,GAE5B,IAAMmH,EAA+ChZ,EAAOmN,OAAO0E,EAAQ,GACrEoH,EAAYD,GAAoB,IAAApM,aAAYoM,GAAqB,KACjE9I,EAAwC,OAAhC6I,EAAYjM,OAAOC,UAC3BqK,EACF6B,GAAaH,EAAS5I,EAAO+I,GACvBA,EAgClB,SACIjZ,EACA6R,EACAgH,EACA3I,GAEA,IAAMvD,EAAQkM,EAAQ3I,GAItB,OAFA,IAAAtD,aAAY5M,GAAQmN,OAAOxK,OAAOkP,EAAO,EAAGlF,GAErCA,CACX,CA1CkBuM,CAAalZ,EAAQ6R,EAAOgH,EAAS3I,IAE/C,IAAAiJ,yBAAwBJ,IACxB,IAAAK,UAAShC,EAAS2B,GAGlBL,EAAYxY,QAAQ,CAAEF,OAAM,EAAEoX,QAAO,G,CAE7C,EAKA,0BACIsB,EACAI,GAEAJ,EAAYha,SAAQ,SAAC,G,MAAEsB,EAAM,SAAEoX,EAAO,UAC5BvF,EAAQ7R,EAAOmN,OAAOvK,QAAQwU,GAC9BiC,EAAoBrZ,EAAOmN,OAAO0E,EAAQ,GAC1CyH,EAAYD,GAAoB,IAAAzM,aAAYyM,GAAqB,KACjEnJ,EAAoC,OAA5BkH,EAAQtK,OAAOC,UAEzB8E,GAAS,GAAKyH,GAAaR,EAAS5I,EAAOoJ,EAAWlC,KACtDA,EAAQjK,OAAOzO,QAAQ,EAAAya,0BACvB,EAAA/B,EAAQjK,QAAOnK,KAAI,4CAAIsW,EAAUnM,SAAM,KACvC,IAAAP,aAAY5M,GAAQmN,OAAOxK,OAAOkP,EAAQ,EAAG,GAErD,GACJ,C,yHCrEA,WAyBA,6BACI7Y,EACAugB,EACAC,EACAC,EACAC,EACAlJ,EACAmJ,G,QAEIC,EAEA/F,EADAc,GAAc,EAGlB,GAAgB,SAAZ6E,GAAmC,OAAZA,EACvBI,EAAc5gB,EACd2b,EAAyB,SAAZ6E,EAAsB,EAAIxgB,EAAMmU,OAAOjU,OAE/CugB,GACDtgB,OAAO0gB,OAAON,EAAYzM,OAAQ9T,EAAM8T,aAEzC,GAAK+G,EAqEhB,SACI7a,EACA2gB,EACAnJ,GAEA,GAAImJ,EAAqB,CACb,IAAA5F,EAA0C4F,EAAmB,UAAlD3F,EAA+B2F,EAAmB,OAA1CvE,EAAuBuE,EAAmB,aAA5B5Z,EAAS4Z,EAAmB,KAC/D9H,EAAQkC,EAAUpF,SAAS/L,QAAQoR,GACnC8F,EAAkBjI,EAAQ,EAAIkC,EAAUpF,SAASkD,EAAQ,GAAK,KASpE,MAAuC,oBAAhCiI,aAAe,EAAfA,EAAiBhL,cAAoCgL,EAAgBnK,WACtE,CACIqE,OAAQ8F,EACR/F,UAAS,EACTqB,aAAY,EACZrV,KAAI,GAER4Z,C,CAEN,IAAMI,GAAe,IAAAC,iBAAgBhhB,EAAO,GAAIwX,GAC1CqD,EAAckG,EAAalG,YAMjC,MAJiC,SAA7BkG,EAAaA,eACb,IAAAjI,uBAAsB9Y,GAGnB6a,CAEf,CAxG8BoG,CAAejhB,EAAO2gB,EAAqBnJ,GAAW,CACpE,IAAAwD,EAA4BH,EAAW,OAA/BE,EAAoBF,EAAW,UAApB9T,EAAS8T,EAAW,KAE/C,GAAK4F,EAQE,CACH,IAAMS,EACU,QAAZV,GACM,IAAAhF,mCAAkCzU,EAAM,CAAC,YAAa,aACtD,EACV6Z,GAAc,IAAAhN,aAAY7M,EAAKma,IAE/B,IAAM/B,EAAQpY,EAAKma,EAAY,GACzBC,EACuB,oBAAzBhC,aAAK,EAALA,EAAOjL,iBACkB,YAAzBiL,aAAK,EAALA,EAAOjL,iBACkB,aAAzBiL,aAAK,EAALA,EAAOjL,gBACDiL,EACApE,EACJqG,EAAaR,EAAYzM,OAAOvK,QAAQuX,GAC9CxF,EAAayF,GAAc,EAAIA,EAAa,GAAK,C,KAvBvC,CACV,IAAMvI,EAAQkC,EAAUpF,SAAS/L,QAAQoR,GAEzC7a,OAAO0gB,OAAON,EAAYzM,OAAQkH,EAAOlH,QAErC+E,GAAS,GACTkC,EAAUpF,SAAShM,OAAO+W,EAAmB7H,EAAQA,EAAQ,EAAG,EAAG0H,E,EAqB/E,GAAI5E,GAAc,GAAKiF,EAAa,CAChC,IAAMS,EAAoD,GACtDC,OAAa,EAEjB,GAAIb,EAAS,CACT,IAAMH,EAAYM,EAAYzM,OAAOwH,GAErC0F,EAAerX,KAAKuW,GAEQ,cAAxBD,aAAS,EAATA,EAAWtM,WACXsN,GAAgB,IAAA1N,aAAY0M,GACpBA,GAAoC,UAAvBA,EAAUtM,YAAyB0M,KACxDY,GAAgB,IAAArI,kBAAgB,EAAsB,CAAC,EAAGjZ,EAAM8T,SAClD6B,SAAS3L,MAAK,IAAAuX,UAASvhB,EAAM8T,SAC3CuN,EAAerX,KAAKsX,G,MAGxBA,GAAgB,IAAArI,kBACZ,OACAnL,EACA9N,EAAM8T,SAGI6B,SAAS3L,KAAKuW,GAC5Bc,EAAerX,KAAKsX,GAKxB,IAFA,OAAA1N,aAAYgN,GAAazM,QAAOxK,OAAM,6BAACgS,EAAY,IAAC,YAAK0F,IAAc,IAEnEX,GAAoBY,EAAe,CAC7BtG,GAAS,IAAAwG,wBAA+C,QAAzB,EAAAF,EAAc3L,SAAS,UAAE,eAAE7B,SAAU9T,EAAM8T,QAAhF,IACM6B,EAAW2L,EAAc3L,SAE/B8K,EAAU9K,EAASzO,QAAQ8T,GAAUrF,EAAS3L,KAAKgR,IACnD,IAAAyG,cAAazhB,EAAOgb,EAAQA,E,EAGxC,C,gHChHA,eAMA,kCACI0G,EACAC,EACAC,GAEA,GAAID,EAAQ,CACR,IAAM7N,EAAS4N,EAAM5N,OACb+N,EAAwBF,EAAM,MAAvBG,EAAiBH,EAAM,MAAhBxd,EAAUwd,EAAM,MAEhCI,GAAkB,IAAAC,qBAAoBlO,EAAgB,WACtDmO,EAAcF,EAAgB5d,MAC9B+d,EAAcH,EAAgBF,MAC9BM,EAAcJ,EAAgBD,MAChCM,EAAe,GAGfA,EADAP,GACe,IAAAzK,oBAAmByK,GAAS,KACpCK,GAGQ,MAGfJ,EACAM,EAAkBA,EAAY,IAAIN,EAC3BK,EACPC,EAAkBA,EAAY,IAAID,EAElCC,GAA8B,SAG9Bje,EACAie,EAAkBA,EAAY,IAAIje,EAC3B8d,IACPG,EAAkBA,EAAY,IAAIH,GAEtCP,EAAM5N,OAAOwB,WAAa8M,EAC1BV,EAAM5N,OAAOuO,UAAYD,EACzBV,EAAM5N,OAAOwO,aAAeF,EAC5BV,EAAM5N,OAAOyB,YAAc6M,C,aAEpBV,EAAM5N,OAAOwB,kBACboM,EAAM5N,OAAOuO,iBACbX,EAAM5N,OAAOwO,oBACbZ,EAAM5N,OAAOyB,YAGpBqM,IACAF,EAAM5N,OAAO8N,aAAeA,EAEpC,C,oGCxDA,eAGMW,EAAe,uBACfC,EAAkB,WAAWD,EAC7BE,EAAe,cAAcF,EAKnC,sBAA2BrM,EAAcwM,G,MAC/B,EAAoCA,QAAAA,EAAmB,CAAC,EAAtDC,EAAQ,WAAEC,EAAU,aAAEC,EAAO,UAC/BC,EAcV,SAAqB5M,GACjB,OAAOA,EAAKxR,MAAM+d,GAAgBvM,EAAK6M,yBAAsBjV,CACjE,CAhBwBkV,CAAY9M,GAChC,IAAI4M,GAAgBF,EAApB,CAGA,IAAMK,EAAYN,EAA0B,QAAf,OAAAnQ,WAAU0D,UAAK,eAAEgN,mBAAgBpV,EACxDqV,EAAWN,EAKrB,SAAkB3M,GACd,OAAOA,EAAKxR,MAAM8d,GAAmBtM,EAAK6M,yBAAsBjV,CACpE,CAP+BsV,CAASlN,QAAQpI,EAE5C,OAAOmV,GAAaE,GAAYL,C,CACpC,C,kHCpBA,WA4BMO,EAAmB,sGAGnBC,EAAa,kCAGbC,EAFkB,MAAMD,EAAU,QAAQA,EAEdE,kCAE5BC,EAAgD,CAClDC,KAAM,CACFhf,MAAO,IAAIif,OACP,mCAAmCJ,EAAsB,UAAUA,EACnE,KAEJK,OAAQP,EACRQ,aAAc,SAAAC,GACV,WAAIH,OAAO,mCAAoC,KAAKI,KAAKD,GAAOA,EAAM,UAAYA,CAAlF,GAERE,MAAO,CACHtf,MAAO,IAAIif,OAAO,oCAAoCJ,EAA0B,KAChFK,OAAQP,GAEZY,OAAQ,CAAEvf,MAAO,IAAIif,OAAO,2BAA4B,MACxDO,MAAO,CAAExf,MAAO,IAAIif,OAAO,oBAAqB,MAChDQ,KAAM,CAAEzf,MAAO,IAAIif,OAAO,uBAAwB,MAClDS,IAAK,CAAE1f,MAAO,IAAIif,OAAO,gBAAiB,MAC1CU,IAAK,CACD3f,MAAO,IAAIif,OACP,cAAcJ,EAAsB,UAAUA,EAC9C,KAEJM,aAAc,SAAAC,GAAO,OAAC,IAAIH,OAAO,cAAe,KAAKI,KAAKD,GAAOA,EAAM,SAAWA,CAA7D,GAEzBQ,KAAM,CAAE5f,MAAO,IAAIif,OAAO,kBAAkBJ,EAA0B,MACtEgB,OAAQ,CAAE7f,MAAO,IAAIif,OAAO,oBAAoBJ,EAA0B,MAC1EiB,OAAQ,CAAE9f,MAAO,IAAIif,OAAO,iBAAiBJ,EAA0B,MACvEkB,KAAM,CAAE/f,MAAO,IAAIif,OAAO,kBAAkBJ,EAA0B,OAa1E,qBAA0BO,G,QACtB,GAAIA,E,IACA,IAAqB,0BAAAY,eAAcjB,IAAe,8BAAE,CAA/C,IAAMkB,EAAM,QACPC,EAAOnB,EAAekB,GACtBE,EAAUf,EAAIpf,MAAMkgB,EAAKlgB,OAC/B,GAAImgB,GAAWA,EAAQ,IAAMf,KAASc,EAAKhB,SAAWgB,EAAKhB,OAAOG,KAAKD,IACnE,MAAO,CACHgB,OAAQH,EACRI,YAAajB,EACbZ,cAAe0B,EAAKf,aAAee,EAAKf,aAAaC,GAAOA,E,mGAM5E,OAAO,IACX,C,sHC7FA,eACA,WAyDA,SAAgBpR,EACZoE,EACA4L,GAEA,IAAMhc,EAAOoQ,EAAQZ,KAAKtR,MAAM,KAAK2C,MAC/Buc,EAAMpd,aAAI,EAAJA,EAAM0U,OACd4J,OAA8BlX,EAClC,GAAIgW,GAAOpd,IAASse,GAAU,IAAAC,YAAWnB,EAAKpB,IAC1C,MAAO,CACHwC,MAAOxe,EACPye,KAAMH,EAIlB,CApDA,uBACIlO,EACAiE,EACA2H,GAEA,GAAI5L,EAAQpQ,KACR,OAAO,KAGX,IAAM0e,EAAe1S,EAAeoE,EAAS4L,GAE7C,GAAI0C,EAAc,CACd,IAAMC,GAAc,IAAAnV,kBAChB4G,EACAiE,EACAjE,EAAQZ,KAAKhW,OAASklB,EAAaF,MAAMI,WAAWplB,OACpD4W,EAAQZ,KAAKqP,YAAYrlB,QAU7B,OARAmlB,EAAY3e,KAAO,CACfoN,OAAQ,CACJqR,KAAMC,EAAaD,KACnBK,WAAW,GAEflN,QAAS,CAAC,GAGP+M,C,CAGX,OAAO,IACX,EAQA,kB,6BCpBA,SAASI,EACL5H,EACAzX,GAEAyX,EAAM1J,OAAOzO,SAAQ,SAAAiO,GACjB,OAAQA,EAAMK,WACV,IAAK,aAC2B,YAAxBL,EAAMO,eACN9N,EAAO4D,KAAK2J,IAEZ+R,EAAoBtf,GACpBqf,EAAc9R,EAAOvN,GACrBsf,EAAoBtf,IAExB,MAEJ,IAAK,YACDsf,EAAoBtf,GAEpBuN,EAAMgC,SAASjQ,SAAQ,SAAAoR,GACQ,WAAvBA,EAAQhB,aACR2P,EAAc3O,EAAS1Q,EAE/B,IAEAsf,EAAoBtf,GACpB,MAEJ,IAAK,QACDsf,EAAoBtf,GAEpBuN,EAAMmB,KAAKpP,SAAQ,SAAAqP,GACf,OAAAA,EAAIC,MAAMtP,SAAQ,SAAAuP,GACdwQ,EAAcxQ,EAAM7O,EACxB,GAFA,IAIJsf,EAAoBtf,GAIhC,GACJ,CAEA,SAASsf,EAAoBtf,GACzB,IAAMuf,EAAOvf,EAAOA,EAAOlG,OAAS,GAE/BylB,GAAiB,OAATA,GACTvf,EAAO4D,KAAK,KAEpB,CAoEA,SAAS4b,EACLC,EACAC,EACAC,GAEA,IAAMC,EAAgBH,EAAUC,GAAepP,OACzCuP,EAAkBJ,EAAUE,GAAiBrP,OAEnD,OACIsP,EAAc9lB,QAAU+lB,EAAgB/lB,QACxC8lB,EAAclM,OACV,SAACoM,EAAc7jB,GAAM,OAAA6jB,EAAa7N,UAAY4N,EAAgB5jB,GAAGgW,QAA5C,GAGjC,CAEA,SAAS8N,EAAuB1P,EAAoCwB,GAChE,OAAOxB,EAAKC,OACPxQ,MAAM,EAAG+R,GACTpB,MAAK,SAAAnK,GAAS,YAAqCoB,IAArCpB,EAAMoH,OAAO2E,mBAAb,GACvB,C,oFApJA,qCACIoF,EACAuI,GAEA,IAAMC,EAAyC,GAI/C,OAFAZ,EAAc5H,EAAOwI,GAwDzB,SACIA,EACAD,G,MAEMhgB,EAAyC,GACzC0f,EAAeO,EAAMzc,QAAQwc,GAC7BnO,EAAcmO,EAAY1P,OAAOxW,OACjComB,EAAiE,OAAd,QAAnC,EAAAF,EAAY1P,OAAOuB,EAAc,UAAE,eAAEI,UAE3D,GAAIyN,GAAgB,EAAG,CACnB,IAAK,IAAIzjB,EAAIyjB,EAAczjB,GAAK,EAAGA,IAAK,CAGpC,KAFMoU,EAAO4P,EAAMhkB,IAER,CACP,GAAIikB,EACA,SAEA,K,CAIR,IAAM7N,EAAsB0N,EAAuB1P,EAAMwB,GAEzD,GAAI2N,EAAuBS,EAAOP,EAAczjB,IAG5C,GAFA+D,EAAOc,QAAQuP,GAEX6P,GAAiB7N,EACjB,WAED,IACF6N,GACD7N,GACAhC,EAAKC,OAAOxW,OAASkmB,EAAY1P,OAAOxW,OAExC,K,CAIR,IAASmC,EAAIyjB,EAAe,EAAGzjB,EAAIgkB,EAAMnmB,OAAQmC,IAAK,CAClD,IAAMoU,EAEN,KAFMA,EAAO4P,EAAMhkB,IAER,CACP,GAAIikB,EACA,SAEA,K,CAMR,GAFM7N,EAAsB0N,EAAuB1P,EAAMwB,GAErD2N,EAAuBS,EAAOP,EAAczjB,KAAOoW,EACnDrS,EAAO4D,KAAKyM,QACT,IACF6P,GACD7N,GACAhC,EAAKC,OAAOxW,OAASkmB,EAAY1P,OAAOxW,OAExC,K,EAKZ,OAAOkG,CACX,CAtHWmgB,CAAgBF,EAAOD,EAClC,C,6GCpCA,eACA,WAkBA,+BAAoCrf,GAChC,IAAM8R,GAAQ,IAAA2C,mCAAkCzU,EAAM,CAAC,YAAa,CAAC,cAErE,GAAI8R,GAAS,EAAG,CACZ,IAAMjC,EAAW7P,EAAK8R,GAChBnM,EAAQkK,EAASF,OAAOE,EAASF,OAAOxW,OAAS,GAEvD,IAAKwM,GAASA,EAAMoH,OAAO0S,oBACvB,OAAO,KACJ,GAAsB,MAAlB9Z,EAAM2L,SAAkB,CAC/B,IAAMoO,EAyBlB,SACI1f,EACA6P,GAKA,I,QAHMyP,GAAQ,IAAA/T,2BAA0BvL,EAAKA,EAAK7G,OAAS,GAAI0W,GAC3D6P,EAAa,EAERpkB,EAAI,EAAGA,EAAIgkB,EAAMnmB,OAAQmC,IAAK,CACnC,IAAMoU,EAAO4P,EAAMhkB,GAMnB,GAJkB,GAAdokB,GAAmBhQ,EAAKC,OAAOxW,QAAU0W,EAASF,OAAOxW,SACzDumB,EAA4E,QAA/D,EAAmC,QAAnC,EAAAhQ,EAAKC,OAAOD,EAAKC,OAAOxW,OAAS,UAAE,eAAE4T,OAAO2E,2BAAmB,QAAI,GAGhFhC,GAAQG,EAER,MACG,GAAIH,EAAKC,OAAOxW,OAAS0W,EAASF,OAAOxW,OAE5CumB,EAAa,MACV,IAAIhQ,EAAKC,OAAOxW,OAAS0W,EAASF,OAAOxW,OAE5C,SACQuW,EAAKC,OAAOD,EAAKC,OAAOxW,OAAS,GAAG4T,OAAO0S,qBAEnDC,G,EAGR,OAAOA,CACX,CAtD+BC,CAAc3f,EAAM6P,GACjCzB,GAAW,IAAAwR,iBAAgBja,GAC3Bka,GAAY,IAAAC,sBACd,KACA1R,QAAAA,EAAY,CAAC,EACbyB,EAASF,OAAOxW,OAAS,EACzBwM,EAAMoH,OAAOgT,eAGjB,YAAqBhZ,IAAd8Y,EACD,KACA,CACIG,eAAgB,4BAChBC,cAAe,EAAC,IAAAC,yBAAwBL,EAAWH,I,CAG7D,MAAO,CACHM,eAAgB,yB,CAIxB,OAAO,IAEf,C,qGCpDA,eACA,WACA,WAgKA,SAASG,EAAkBvT,GACvB,OAAQA,EAAMK,WACV,IAAK,QACD,OAAO,EACX,IAAK,YACD,OAAOL,EAAMgC,SAASmE,OAClB,SAAApY,GAAK,MAAiB,MAAjBA,EAAEoU,aAAwC,mBAAjBpU,EAAEoU,WAA3B,IAEb,QACI,OAAO,EAEnB,CA/IA,uBACI9V,EACAqY,EACA8O,QAAA,IAAAA,IAAAA,GAAA,IAEA,IAAA5T,4BAA2BvT,GAE3B,IAAMonB,GAAuB,IAAA3T,sBACzBzT,EACA,CAAC,YACD,IAEEqnB,EAAwBD,EAAqBtN,OAAM,SAAC,G,MAAEnG,EAAK,QAC7D,WAAA4C,oBAAiD5C,EAAO,aACb,QAArC,EAAAA,EAAM+C,OAAO/C,EAAM+C,OAAOxW,OAAS,UAAE,eAAEmY,WAAYA,EACnD6O,EAAkBvT,E,IAExB2T,EAAoD,GAgHxD,OA9GAF,EAAqB1hB,SAAQ,SAAC,EAAmB6hB,G,QAAjB5T,EAAK,QAAE3M,EAAM,SACzC,IAAI,IAAAuP,oBAAiD5C,EAAO,YAAa,CACrE,IACMjH,GADA8a,GAAe,IAAA5T,aAAYD,IACN+C,OAAOnP,OAE7B8f,GAAyB3a,GAC1BA,EAAM2L,SAAWA,GAEjB,IAAAE,oBAAmB7L,GAAO,SAAAyI,GACtB,OAAAhV,OAAO0gB,OAAO,CAAC,EAAG1L,EAAU,CACxBqD,yBAAyB,GAD7B,IAKJgP,EAAa9Q,OAAO1M,KAAK0C,IACK,GAAvBiH,EAAMQ,OAAOjU,SACpB,IAAAigB,yBAAwBxM,EAAMQ,OAAO,IAGrCkT,GAEA1T,EAAMQ,OAAOzO,SAAQ,SAAAhE,IACjB,IAAA+lB,YAAoC/lB,EAAEoS,OAAQH,EAAMG,OAAQ,EAAA4T,YAChE,G,KAED,CACH,IAAM7O,EAAQ7R,EAAOmN,OAAOvK,QAAQ+J,GAC9BgU,EAA6C,aAAzB3gB,EAAOkN,eAEjC,GAAI2E,GAAS,EACT,GACmC,GAA/BuO,EAAqBlnB,SACpBgnB,EAAkBvT,IACnBgU,EACF,CACE,IAAM1H,EAAYjZ,EAAOmN,OAAO0E,EAAQ,GAClCK,EACkB,aAAnBvF,EAAMK,YAA6C,QAAjB,EAAAL,EAAMgC,SAAS,UAAE,eAAE7B,SAAW,CAAC,EAChE8T,GAAkD,IAAAC,gBACpD,EACI,IAAAzP,iBAAgBC,EAAU,CACtBI,oBACIkP,GACAJ,EAAY,GACa,eAAxBtH,aAAS,EAATA,EAAWjM,YACoB,YAA5BiM,EAAU/L,gBACuB,OAAd,QAAnB,EAAA+L,EAAUvJ,OAAO,UAAE,eAAE2B,eACnBvK,EACA,EACViG,UAAWJ,EAAMG,OAAOC,UACxBK,UAAWT,EAAMG,OAAOM,UACxB0T,aAAcX,EAAgB,WAAQrZ,EACtCia,UAAWZ,EAAgB,WAAQrZ,KAI3C,CACIka,WAAY9O,EAAc8O,WAC1BC,SAAU/O,EAAc+O,SACxB7K,UAAWlE,EAAckE,YAIV,aAAnBzJ,EAAMK,YACN,IAAAmM,yBAAwBxM,GAG5B,IAAM6T,GAAe,IAAA5T,aAAYD,GAEjCiU,EAAYzT,OAAOnK,KAAKwd,IAExB,IAAAU,uBAAsBN,IAEtB,IAAAH,YACIG,EAAY9T,OACZ0T,EAAa1T,OACb,EAAAqU,mBACA,IAEJ,IAAAV,YACIG,EAAY9T,OACZ0T,EAAa1T,OACb,EAAAsU,oBAGJ,IAAAxU,aAAY5M,GAAQmN,OAAOxK,OAAOkP,EAAO,EAAG+O,GAC5CN,EAAkBtd,KAAK4d,GAEvB,IAAMS,EAAaT,EAAYlR,OAAOxW,OAAS,GACzCwM,GAAQ,IAAAkH,aAAYgU,GAAalR,OAAO2R,MAG1C,IAAA9P,oBAAmB7L,GAAO,SAAAyI,GACtB,OAAAhV,OAAO0gB,OAAO,CAAC,EAAG1L,EAAU,CACxBqD,yBAAyB,GAD7B,G,MAMR8O,EAAkB5hB,SACd,SAAAhE,GAAK,OAAC,IAAAkS,aAAYlS,GAAGgV,OAAO,GAAG5C,OAAOgU,aAAe,KAAhD,IAETR,EAAoB,E,CAIpC,KAEA,IAAAxO,uBAAsB9Y,GAEfonB,EAAqBlnB,OAAS,CACzC,C,iHChKA,eAQA,mCAAwCF,EAAqCK,GACzE,IAAMuW,GAAW,IAAA0R,0BAAyBtoB,GACpC0M,EAAQkK,GAAW,IAAAhD,aAAYgD,GAAUF,QAAOE,aAAQ,EAARA,EAAUF,OAAOxW,QAAS,GAAK,KAErF,QAAIwM,IACAA,EAAMoH,OAAO2E,oBAAsBpY,GAE5B,EAIf,C,2GCnBA,eACA,WAeA,6BAAkCL,EAAqC8hB,GACnE,IAAMlL,GAAW,IAAA0R,0BAAyBtoB,GAE1C,GAAI4W,EAAU,CACV,IAAMiP,GAAY,IAAAvT,2BAA0BtS,EAAO4W,GAC7C,EAAaA,EAASF,OAAOxW,OAAS,EAE5C2lB,EAAUngB,SAAQ,SAAAkR,GACd,IAAMlK,GAAQ,IAAAkH,aAAYgD,GAAUF,OAAO,GAEvChK,IACA,IAAA6L,oBAAmB7L,GAAO,SAAAyI,GAAY,OAAAhV,OAAO0gB,OAAO,CAAC,EAAG1L,EAAU2M,EAA5B,GAE9C,G,CAEJ,QAASlL,CACb,C,gHChCA,eAUA,kCACI5W,EACAuoB,EAIAC,GAMA,IACIC,EACA9C,EAFE+C,GAAa,IAAAC,uBAAsB3oB,GAGrC4oB,GAAU,EAqCd,OAnCAF,EAAWhjB,SAAQ,SAAA/C,GACf,IAAMkW,EAAQ4P,EAAQ,EAAI9lB,EAAEgT,SAASkT,WAAU,SAAAnnB,GAAK,OAAA6mB,EAAa7mB,EAAGiB,EAAhB,IAC9CgT,EAAWhT,EAAEgT,SAEnB,IAAK8S,EAAO,CACRA,EAAQ9S,EAASkD,GAEjB,IAAK,IAAIxW,EAAIwW,EAAOxW,EAAI,EAAGA,IAAK,CAC5B,IAAImmB,EAAe7S,EAAStT,EAAI,GAAIomB,EAAO9lB,GAGpC,CACHimB,EAAUA,KAAajT,EAAStT,EAAI,GAAGsU,WACvC,K,CAJA8R,EAAQ9S,EAAStT,EAAI,GACrBumB,EAAUA,IAAYjT,EAAStT,EAAI,GAAGsU,U,EAQlD,GAAI8R,EACA,IAASpmB,EAAIwW,EAAOxW,EAAIM,EAAEgT,SAASzV,OAAQmC,IAAK,CAC5C,GAAIA,GAAKwW,IAAS2P,EAAe7S,EAAStT,GAAIsjB,GAAQhQ,EAASkD,GAAQlW,GAGhE,CACHimB,EAAUA,KAAajT,EAAStT,GAAGsU,WACnC,K,CAJAgP,EAAOhQ,EAAStT,GAChBumB,EAAUA,IAAYjT,EAAStT,GAAGsU,U,CAOlD,IAEI8R,GAAS9C,IACT,IAAAlE,cAAazhB,EAAOyoB,EAAO9C,GAGxBiD,CACX,C,mIC/DA,WAuCA,SAASE,EAAyBhS,GAC9B,OAAOA,EAAQH,aAGOT,EAHwBY,EAAQZ,MAI1CqP,cAAgBrP,IAGhC,SAAyBA,GACrB,OAAkC,GAA3BA,EAAKqP,YAAYrlB,MAC5B,CAToE6oB,CAAgBjS,EAAQZ,MAG5F,IAA0BA,CAF1B,CAUA,SAAShG,EACLwD,EACAsV,IAEA,IAAArO,eAAcjH,EAAesV,GAAqB,SAACpO,EAAajH,G,MACtDuC,EAAO0E,EAAY1E,KAAKqP,YACxB0D,EAAgBrO,EAAY1E,KAAKzR,UAAUyR,EAAKhW,QAChDgpB,GAAU,IAAAC,YAAWjT,EAAM0E,EAAY9G,OAAQ8G,EAAYlU,KAAMkU,EAAYyC,MACnF6L,EAAQvS,YAAa,EACrB,IAAMyS,EAAoBxO,EAAYlU,MAChC,EAAD,8BACQkU,EAAYlU,MAAI,CACnBoN,QAAQ,EAAF,8BACiB,QAAhB,EAAA8G,EAAYlU,YAAI,eAAEoN,QAAM,CAC3B0R,WAAW,WAGnB1X,EACAub,GAAuB,IAAAF,YACzBF,OACAnb,EACAsb,EACAxO,EAAYyC,MAEhBgM,EAAqB1S,YAAa,EAClC,IAAMkC,EAAQlF,EAAMgC,SAAS/L,QAAQgR,GACrCjH,EAAMgC,SAAShM,OAAOkP,EAAO,EAAGqQ,EAASG,EAC7C,GACJ,CApEA,wCAA6CrpB,IACzC,IAAAmc,mBAAkBnc,GAAO,SAACspB,EAAGC,EAAI5V,EAAOgC,GACpC,GAAyB,eAArBhC,aAAK,EAALA,EAAOK,YAA6B2B,GAAYA,EAASzV,OAAS,EAClE,GACwB,IAApByV,EAASzV,QACmB,SAA5ByV,EAAS,GAAGG,aACZgT,EAAyBnT,EAAS,IAElCzF,EAAiByD,EAAOgC,EAAS,QAC9B,CACH,IAAM6T,EAC4C,oBAA9C7T,EAASA,EAASzV,OAAS,GAAG4V,YACxBH,EAASA,EAASzV,OAAS,GAC3ByV,EAASA,EAASzV,OAAS,GAEjCspB,GACgC,SAAhCA,EAAgB1T,aAChBgT,EAAyBU,IAEzBtZ,EAAiByD,EAAO6V,E,CAKpC,OAAO,CACX,GACJ,C,4HCrCA,WAgHA,SAASC,EAAc3S,EAA2B4S,GAC9C,IAAMC,EAAO7S,EAAQZ,KACjB0T,GAAU,EACd,GAAIF,EACA,IAAK,IAAIrnB,EAAI,EAAGA,EAAIsnB,EAAKzpB,OAAQmC,IAAK,CAClC,IAAMyC,EAAO6kB,EAAKtnB,GAElB,IAAI,IAAAwnB,eAAc/kB,KAAS,IAAAglB,SAAQhlB,GAAO,CACtC8kB,EAASvnB,EACT,K,OAIR,IAASA,EAAIsnB,EAAKzpB,OAAS,EAAGmC,GAAK,EAAGA,IAGlC,GAFMyC,EAAO6kB,EAAKtnB,IAEd,IAAAwnB,eAAc/kB,KAAS,IAAAglB,SAAQhlB,GAAO,CACtC8kB,EAASvnB,EAAI,EACb,K,CAIZ,OAAOunB,CACX,CAEA,SAAS1Z,EACLyF,EACAiF,EACA/B,EACAkR,GAEA,IAAM7T,EAAO0E,EAAY1E,KACnB8T,GAAiB,IAAAb,YACnBjT,EAAKzR,UAAU,EAAGslB,GAClBnP,EAAY9G,OACZ8G,EAAYlU,KACZkU,EAAYyC,MAEV4M,GAAkB,IAAAd,YACpBjT,EAAKzR,UAAUslB,EAAO7T,EAAKhW,QAC3B0a,EAAY9G,OACZ8G,EAAYlU,KACZkU,EAAYyC,MAEhB1H,EAAShM,OAAOkP,EAAO,EAAGmR,EAAgBC,EAC9C,CAzIA,+BACIjqB,EACAgb,GAEA,IAAIkP,GAEJ,IAAA/N,mBAAkBnc,GAAO,SAACspB,EAAGC,EAAI5V,EAAOgC,GAKpC,MAHwB,cAApBhC,aAAK,EAALA,EAAOK,YAAgD,IAApB2B,aAAQ,EAARA,EAAUzV,SAAeyV,EAAS,IAAMqF,IAC3EkP,GAAc,IAAAtW,aAAYD,KAEvB,CACX,IAEA,IAAMwW,EAAeD,GAAc,EAAD,iCAAKA,EAAYvU,WAAQ,QAAI7H,EAE/D,GAAIqc,GAAgBD,EAAa,CAG7B,IAFA,IAAMvU,EAAgD,GAClDyU,EAAuBD,EAAavgB,QAAQoR,GACvC3Y,EAAI+nB,EAAuB,EAAG/nB,GAAK,GAEN,SAD5BgoB,EAAiBF,EAAa9nB,IACjByT,YAFwBzT,IAAK,CAI5C,IADM0nB,EAAQN,EAAcY,GAAgB,KAC/B,EAAG,CACZ,GAAIN,GAASM,EAAenU,KAAKhW,OAC7B,MAGJgQ,EAAiBia,EAAcE,EAAgBhoB,EAAG0nB,GAElDpU,EAAS3L,KAAKmgB,EAAa9nB,EAAI,IAE/B,K,CAEAsT,EAAS3L,KAAKmgB,EAAa9nB,G,CAWvC,GAJA+nB,EAAuBD,EAAavgB,QAAQoR,GAC5CrF,EAAS3L,KAAKgR,GAGVrF,EAASzV,QAAU,EACnB,OAAOyV,EAGX,IAAStT,EAAI+nB,EAAuB,EAAG/nB,EAAI8nB,EAAajqB,OAAQmC,IAAK,CACjE,IAAMgoB,EAEIN,EADV,GAAkC,SAD5BM,EAAiBF,EAAa9nB,IACjByT,YAaf,MAXA,IADMiU,EAAQN,EAAcY,GAAgB,KAC/B,EAAG,CACZ,GAAa,GAATN,EACA,MAEJ7Z,EAAiBia,EAAcE,EAAgBhoB,EAAG0nB,GAClDpU,EAAS3L,KAAKmgB,EAAa9nB,IAC3B,K,CAEAsT,EAAS3L,KAAKmgB,EAAa9nB,G,CAQvC,OAAIsT,EAASA,EAASzV,OAAS,IAAM8a,EAC1B,CAACA,IAGZkP,EAAYvU,SAAWwU,EAChBxU,E,CAEP,MAAO,CAACqF,EAEhB,C,gHClGA,eASA,kCACIlG,EACA0J,G,MAEQ8L,EAA0B9L,EAAS,YACrCvJ,EAAqB,QAAd,EAAAH,EADqB0J,EAAS,iBAChB,eAAExJ,MAAMsV,GAC/BrV,IACA,IAAAsV,aAAW,IAAA3W,aAAYqB,IAAO,IAAAuM,yBAEtC,C,kGCVA,sBAA2B1G,EAAwC0P,GAC/D1P,EAAMhH,OAAOW,WAA0B,aAAb+V,EAA2B,GAAK,OAC1D1P,EAAMhH,OAAOc,YAA2B,cAAb4V,EAA4B,GAAK,MAChE,C,+ICXA,eAYMC,EAGF,CACAC,cAAe,CACX1X,IAAK,QACLC,IAAK,OAET0X,gBAAiB,CACb3X,IAAK,SACLC,IAAK,UAET2X,eAAgB,CACZ5X,IAAK,MACLC,IAAK,UAIP4X,EAGD,CACDC,aAAc,MACdC,gBAAiB,SACjBC,gBAAiB,UAkCrB,SAASC,EACLnQ,EACAoQ,G,MAEMC,GAAM,IAAAC,kBAAiBtQ,GAE7B,GAAIqQ,EACA,IAAK,IAAI1O,EAAW0O,EAAIE,SAAU5O,GAAY0O,EAAIG,QAAS7O,IACvD,IAAK,IAAID,EAAW2O,EAAIb,YAAa9N,GAAY2O,EAAII,WAAY/O,IAAY,CACzE,IAAMvH,EAA2B,QAApB,EAAA6F,EAAMhG,KAAK2H,UAAS,eAAEzH,MAAMwH,IAC1BvH,aAAI,EAAJA,EAAMnB,UAGjBoX,GAAS,IAAAtX,aAAYqB,IAErBA,EAAKd,OAAOzO,SAAQ,SAAAiO,GACQ,cAApBA,EAAMK,WAA6BL,EAAMG,OAAOM,kBACzC,IAAAR,aAAYD,GAAOG,OAAOM,SAEzC,I,CAKpB,CApDA,sCACI0G,EACA0P,GAEAS,EAAuBnQ,GAAO,SAAA7F,GAC1BA,EAAKnB,OAAOM,UACRqW,EAAkBD,GAAoC,OAAzBvV,EAAKnB,OAAOC,UAAqB,MAAQ,MAC9E,GACJ,EAKA,oCACI+G,EACA0P,GAEAS,EAAuBnQ,GAAO,SAAA7F,GAC1BA,EAAKnB,OAAO0X,cAAgBX,EAAsBL,IAElD,IAAAtV,yBAAwBD,GAAM,SAAAE,GAG1B,OAFAA,EAAWA,GAAY,CAAC,GACfsW,gBAAiB,EACnBtW,CACX,GACJ,GACJ,C,qGC/DA,yBACIL,EACAuW,EACAK,EACAJ,EACAK,GAEA,IAAMC,EACFF,GAAYC,GACZ7W,EAAKuW,GAAUrW,MAAM8E,OACjB,SAAC7E,EAAMuH,GAAa,OAAAA,EAAWkP,GAAYlP,EAAWmP,IAAY1W,EAAK4W,SAAnD,IAEtBC,EACFT,GAAYC,GACZxW,EAAKgF,OACD,SAAC/E,EAAK0H,GACF,OAAAA,EAAW4O,GAAY5O,EAAW6O,IAAYvW,EAAIC,MAAM0W,GAAUK,QAAlE,IAGNC,EAAuBlX,EAAKwW,GAAStW,MACtCnQ,KAAI,SAACykB,EAAG9M,GACL,OAAAA,GAAYkP,GAAYlP,GAAYmP,EAgBhD,SACI7W,EACA2H,EACAD,GAIA,I,QAFIyP,EAAY,EAEPlX,EAAM0H,EAAW,EAAG1H,EAAMD,EAAK5U,SACN,QAA1B,EAAS,QAAT,EAAA4U,EAAKC,UAAI,eAAEC,MAAMwH,UAAS,eAAEqP,WADY9W,IAExCkX,IAMR,OAAOA,CACX,CA/BkBC,CAAkBpX,EAAMwW,EAAS9O,IAChC,CAFP,IAIH1C,OAAM,SAACpY,EAAG4nB,EAAG9lB,GAAM,OAAA9B,EAAI,GAAKA,GAAK8B,EAAEkoB,EAAhB,IAClBS,EAAuBrX,EACxBjQ,KAAI,SAACykB,EAAG7M,GACL,OAAAA,GAAY4O,GAAY5O,GAAY6O,EA2BhD,SACIxW,EACA2H,EACAD,GAIA,I,UAFIyP,EAAY,EAEPG,EAAM5P,EAAW,EAAG4P,GAAoB,QAAd,EAAAtX,EAAK2H,UAAS,eAAEzH,MAAM9U,UACvB,QAA1B,EAAc,QAAd,EAAA4U,EAAK2H,UAAS,eAAEzH,MAAMoX,UAAI,eAAEL,UAD6BK,IAEzDH,IAMR,OAAOA,CACX,CA1CkBI,CAAkBvX,EAAM2H,EAAUkP,IACjC,CAFP,IAIH7R,OAAM,SAACpY,EAAG4nB,EAAG9lB,GAAM,OAAA9B,EAAI,GAAKA,GAAK8B,EAAE6nB,EAAhB,IAExB,OAAOO,GAAeE,GAAcE,GAAwBG,CAChE,C,4GCxCA,eAWA,8BACIrR,EACAqQ,GAEA,GACIA,EAAIb,aAAe,GACnBa,EAAIE,UAAY,GAChBF,EAAIG,QAAUxQ,EAAMhG,KAAK5U,QACzBirB,EAAII,WAAazQ,EAAMhG,KAAKqW,EAAIG,SAAStW,MAAM9U,OAE/C,IAAK,IAAImC,EAAI8oB,EAAIE,SAAUhpB,GAAK8oB,EAAIG,QAASjpB,IAGzC,IAFA,IAAM0S,EAAM+F,EAAMhG,KAAKzS,GAEdiqB,EAAInB,EAAIb,YAAagC,GAAKnB,EAAII,WAAYe,IAAK,CACpD,IAAMrX,EAAOF,EAAIC,MAAMsX,GAEnBrX,IACIA,EAAK0B,cACL,IAAA/C,aAAYqB,GAAM0B,YAAa,IAGnC,IAAA8K,cAAaxM,G,CAKjC,C,uHCrCA,eAMA,yCACIA,EACAsX,GAEA,IAAM5Y,EAAQsB,EAAKd,OAAO,GAC1B,GAAIR,GAA6B,cAApBA,aAAK,EAALA,EAAOK,WAA0B,CAC1C,IAAMwY,EAAe7Y,EAAMgC,SAAS,GACpC,GACI6W,IAC6B,QAA5BA,EAAa1W,aACkB,MAA5B0W,EAAa1W,aACe,mBAA5B0W,EAAa1W,aACnB,CACE,IAAM2W,GAAmB,IAAAxT,kBACrB,EACAtF,EAAMG,OACNH,EAAMuF,eAEJwT,GAAK,IAAAnL,UAASiL,EAAa1Y,QACjC2Y,EAAiB9W,SAAS3L,KAAK0iB,IAC/B,IAAA9Y,aAAY2Y,GAASpY,OAAOnK,KAAKyiB,E,EAG7C,C,8GC7BA,eAUA,gCACIzlB,EACA2lB,EACA7X,EACA8X,GAEA,IAAM9R,GAAQ,IAAA+R,aAAY/X,GAiB1B,OAfA,IAAAsL,UAASpZ,EAAQ8T,GAEjBA,EAAMhG,KAAKpP,SAAQ,SAAAqP,GACf,IAAK,IAAI1S,EAAI,EAAGA,EAAIsqB,EAAStqB,IAAK,CAC9B,IAAM4S,GAAO,IAAA6X,sBACThf,OACAA,OACAA,EACA8e,GAGJ7X,EAAIC,MAAMhL,KAAKiL,E,CAEvB,IAEO6F,CACX,C,mGC7BA,uBAA4BA,GACxBA,EAAMhG,KAAO,EACjB,C,2GCPA,eACA,WAMA,6BAAkCgG,GAC9B,IAAMqQ,GAAM,IAAAC,kBAAiBtQ,GAE7B,GAAIqQ,EAAK,CACL,IAAK,IAAI1O,EAAW,EAAGA,EAAW3B,EAAMhG,KAAK5U,OAAQuc,IAAY,CAC7D,IAAMsQ,EAAgBjS,EAAMhG,KAAK2H,GAAUzH,MAAMmW,EAAII,WAAa,GAE9DwB,KACA,IAAAnZ,aAAYmZ,GAAehB,SACvBgB,EAAchB,UAAYjR,EAAMhG,KAAK2H,GAAUzH,MAAMmW,EAAIb,aAAayB,UAG9EjR,EAAMhG,KAAK2H,GAAUzH,MAAMrL,OACvBwhB,EAAIb,YACJa,EAAII,WAAaJ,EAAIb,YAAc,E,CAI3CxP,EAAMkS,OAAOrjB,OAAOwhB,EAAIb,YAAaa,EAAII,WAAaJ,EAAIb,YAAc,IACxE,IAAA2C,wBAAuBnS,EAAMhG,KAAMqW,E,CAE3C,C,wGC5BA,eACA,WAMA,0BAA+BrQ,GAC3B,IAAMqQ,GAAM,IAAAC,kBAAiBtQ,GAEzBqQ,IACArQ,EAAMhG,KAAKqW,EAAIE,UAAUrW,MAAMtP,SAAQ,SAACuP,EAAMuH,G,MACpC0Q,EAA4C,QAA3B,EAAApS,EAAMhG,KAAKqW,EAAIG,QAAU,UAAE,eAAEtW,MAAMwH,GAEtD0Q,KACA,IAAAtZ,aAAYsZ,GAAgBrB,UAAYqB,EAAerB,WAAa5W,EAAK4W,UAEjF,IAEA/Q,EAAMhG,KAAKnL,OAAOwhB,EAAIE,SAAUF,EAAIG,QAAUH,EAAIE,SAAW,IAE7D,IAAA4B,wBAAuBnS,EAAMhG,KAAMqW,GAE3C,C,0HCvBA,eAkEA,SAASgC,EAAqBntB,GAC1B,IAAMotB,GAAU,IAAAnU,kBAAgB,OAAsBnL,EAA2B9N,EAAM8T,QACjF4Y,GAAK,IAAAnL,UAASvhB,EAAM8T,QAI1B,OAFAsZ,EAAQzX,SAAS3L,KAAK0iB,GAEfU,CACX,CA1DA,4CACIptB,EACA+G,EACA+T,G,QAEIC,EACEsS,EAA6D,QAAjD,EAAAvS,EAAMhG,KAAKc,QAAO,SAAAb,GAAO,OAAAA,EAAIC,MAAM9U,OAAS,CAAnB,IAAsB,UAAE,eAAE8U,MAAM,GAE3E,GAAIqY,GAEAtS,EAAYsS,EAAUlZ,OAAOyB,QACzB,SAACjC,GAA0C,MAAmB,aAAnBA,EAAMK,SAAN,IAC7C,MAIE+G,EAAYoS,EAAqBntB,IACjC,IAAA4T,aAAYyZ,GAAWlZ,OAAOnK,KAAK+Q,QAEpC,CAEH,IACI,EADApH,EAAmCmH,EAMvC,IAJAC,EAAYoS,EAAqBntB,GAIzB,EAAS+G,EAAKumB,SAAU,CAC5B,IAAMzU,EAAoC,QAA5B,IAAO1E,OAAOvK,QAAQ+J,UAAM,SAAK,EAM/C,GAJI,GAAUkF,GAAS,IACnB,IAAAjF,aAAY,GAAQO,OAAOxK,OAAOkP,EAAO,EAAGkC,GAInB,mBAAzB,EAAO7G,gBACiB,GAAxB,EAAOC,OAAOjU,QACd,EAAOiU,OAAO,IAAM4G,EAMpB,MAHApH,EAAQ,C,EAQpB,OAAOoH,CACX,C,2GChEA,eACA,WACA,WAWA,6BACID,EACA0P,GAEA,IAAMW,GAAM,IAAAC,kBAAiBtQ,GACvByS,EAA0B,cAAb/C,EAEnB,GAAIW,EAAK,EACL,IAAAxZ,oBAAmBmJ,EAAOqQ,GAC1B,IAAK,IAAI9oB,EAAI8oB,aAAG,EAAHA,EAAKb,YAAajoB,GAAK8oB,EAAII,WAAYlpB,IAChDyY,EAAMhG,KAAKpP,SAAQ,SAAAqP,GACf,IAAME,EAAOF,EAAIC,MAAMuY,EAAapC,EAAIb,YAAca,EAAII,YAEpDgB,GAAU,IAAAO,iBACZ7X,EAAK8W,SACL9W,EAAK4W,UACL5W,EAAK2H,SACL3H,EAAKnB,OACLmB,EAAKqD,UAET,IAAAkV,+BAA8BvY,EAAMsX,GACpCA,EAAQ5V,YAAa,EAErB5B,EAAIC,MAAMrL,OAAO4jB,EAAapC,EAAIb,YAAca,EAAII,WAAa,EAAG,EAAGgB,EAC3E,IACAzR,EAAMkS,OAAOrjB,OACT4jB,EAAapC,EAAIb,YAAca,EAAII,WAAa,EAChD,EACAzQ,EAAMkS,OAAOO,EAAapC,EAAIb,YAAca,EAAII,Y,CAIhE,C,uHC7CA,WACA,WACA,WAWA,0BACIzQ,EACA0P,GAEA,IAAMW,GAAM,IAAAC,kBAAiBtQ,GACvB2S,EAA2B,eAAbjD,EAEpB,GAAIW,EAAK,EACL,IAAAxZ,oBAAmBmJ,EAAOqQ,GAE1B,IAAK,IAAI9oB,EAAI8oB,EAAIE,SAAUhpB,GAAK8oB,EAAIG,QAASjpB,IAAK,CAC9C,IAAMqrB,EAAY5S,EAAMhG,KAAK2Y,EAActC,EAAIE,SAAWF,EAAIG,SAE9DxQ,EAAMhG,KAAKnL,OAAO8jB,EAActC,EAAIE,SAAWF,EAAIG,QAAU,EAAG,EAAG,CAC/DxX,QAAQ,EAAF,eAAO4Z,EAAU5Z,QACvBkB,MAAO0Y,EAAU1Y,MAAMnQ,KAAI,SAAAoQ,GACvB,IAAMsX,GAAU,IAAAO,iBACZ7X,EAAK8W,SACL9W,EAAK4W,UACL5W,EAAK2H,SACL3H,EAAKnB,OACLmB,EAAKqD,SAIT,OAFA,IAAAkV,+BAA8BvY,EAAMsX,GACpCA,EAAQ5V,YAAa,EACd4V,CACX,IACAoB,OAAQD,EAAUC,Q,EAIlC,C,wGC5CA,eACA,WAMA,2BAAgC7S,GAC5B,IAAMqQ,GAAM,IAAAC,kBAAiBtQ,GAE7B,GACIqQ,IACA,IAAAyC,eAAc9S,EAAMhG,KAAMqW,EAAIE,SAAUF,EAAIb,YAAaa,EAAIG,QAASH,EAAII,YAE1E,IAAK,IAAI9O,EAAW0O,EAAIE,SAAU5O,GAAY0O,EAAIG,QAAS7O,IACvD,IAAK,IAAID,EAAW2O,EAAIb,YAAa9N,GAAY2O,EAAII,WAAY/O,IAAY,CACzE,IAAMvH,EAAO6F,EAAMhG,KAAK2H,GAAUzH,MAAMwH,GAExC,GAAIvH,EAAM,CACN,IAAM0H,GAAc,IAAA/I,aAAYqB,GAEhC0H,EAAYoP,SAAWvP,EAAW2O,EAAIb,YACtC3N,EAAYkP,UAAYpP,EAAW0O,EAAIE,Q,EAK3D,C,0GC3BA,eACA,WASA,4BACIvQ,EACA0P,G,YAEMW,GAAM,IAAAC,kBAAiBtQ,GAG7B,GAAIqQ,EAAK,CACL,IAAM0C,EAHqB,aAAbrD,EAGsBW,EAAIb,YAAca,EAAII,WAAa,EAEvE,GAAIsC,EAAkB,GAAKA,EAAkB/S,EAAMhG,KAAK,GAAGE,MAAM9U,OAC7D,IAAK,IAAIuc,EAAW0O,EAAIE,SAAU5O,GAAY0O,EAAIG,QAAS7O,IAAY,CACnE,IAAMxH,EAA2B,QAApB,EAAA6F,EAAMhG,KAAK2H,UAAS,eAAEzH,MAAM6Y,GAEzC,GACI5Y,IACA,IAAA2Y,eACI9S,EAAMhG,KACN2H,EACAoR,EAAkB,EAClBpR,EACAoR,GAEN,EACE,IAAAja,aAAYqB,GAAM8W,UAAW,EAI7B,IAFA,IAAI+B,EAAiBD,EAE6B,QAA3C,EAAoB,QAApB,EAAA/S,EAAMhG,KAAK2H,UAAS,eAAEzH,MAAM8Y,UAAe,eAAE/B,WAChD,IAAAnY,aAAYkH,EAAMhG,KAAK2H,GAAUzH,MAAM8Y,IACvCA,IAGJ,IAAMvB,EAA8B,QAApB,EAAAzR,EAAMhG,KAAK2H,UAAS,eAAEzH,MAAM8Y,GACxCvB,KACA,IAAA3Y,aAAY2Y,GAAS5V,YAAa,E,GAM1D,C,uGCnDA,eACA,WASA,yBACImE,EACA0P,G,UAEMW,GAAM,IAAAC,kBAAiBtQ,GAG7B,GAAIqQ,EAAK,CACL,IAAM4C,EAHsB,cAAbvD,EAGsBW,EAAIE,SAAWF,EAAIG,QAAU,EAElE,GAAIyC,EAAkB,GAAKA,EAAkBjT,EAAMhG,KAAK5U,OACpD,IAAK,IAAIsc,EAAW2O,EAAIb,YAAa9N,GAAY2O,EAAII,WAAY/O,IAAY,CACzE,IAAMvH,EAAO6F,EAAMhG,KAAKiZ,GAAiB/Y,MAAMwH,GAE/C,GACIvH,IACA,IAAA2Y,eACI9S,EAAMhG,KACNiZ,EAAkB,EAClBvR,EACAuR,EACAvR,GAEN,EACE,IAAA5I,aAAYqB,GAAM4W,WAAY,EAI9B,IAFA,IAAImC,EAAiBD,EAE6B,QAA3C,EAA0B,QAA1B,EAAAjT,EAAMhG,KAAKkZ,UAAe,eAAEhZ,MAAMwH,UAAS,eAAEqP,YAChD,IAAAjY,aAAYkH,EAAMhG,KAAKkZ,GAAgBhZ,MAAMwH,IAC7CwR,IAGJ,IAAMzB,EAAoC,QAA1B,EAAAzR,EAAMhG,KAAKkZ,UAAe,eAAEhZ,MAAMwH,GAE9C+P,KACA,IAAA3Y,aAAY2Y,GAAS5V,YAAa,E,GAM1D,C,mICpDA,WAQA,sCAA2CmE,GACvC,IAAMqQ,GAAM,IAAAC,kBAAiBtQ,GAE7B,GAAIqQ,EACA,I,eAAS3O,GACL,GACI1B,EAAMhG,KAAKgF,OACP,SAAC/E,EAAK0H,G,MACF,OAAAA,EAAW0O,EAAIE,UACf5O,EAAW0O,EAAIG,UACQ,QAAvB,EAAAvW,EAAIC,MAAMwH,EAAW,UAAE,eAAEuP,S,IAGjCjR,EAAMhG,KAAKpP,SAAQ,SAACqP,EAAK0H,IACrB,IAAA7I,aAAYmB,EAAIC,MAAMwH,IAElBC,GAAY0O,EAAIE,UAAY5O,GAAY0O,EAAIG,WAC5C,IAAA1X,aAAYmB,EAAIC,MAAMwH,EAAW,IAAIuP,UAAW,EAExD,QACG,CACHjR,EAAMhG,KAAKpP,SAAQ,SAACqP,EAAK0H,GACrB,IAAMxH,EAAOF,EAAIC,MAAMwH,GACvB,GAAIvH,EAAM,CACN,IAAM0H,GAAc,IAAA/I,aAAYqB,UAEzB0H,EAAY7I,OAAO+N,MAE1B,IAAM0K,GAAU,IAAAO,iBACZ7X,EAAK8W,SACL9W,EAAK4W,UACL5W,EAAK2H,SACLD,EAAY7I,QAGhByY,EAAQjU,SAAU,EAAH,eAAQrD,EAAKqD,SAExBmE,EAAW0O,EAAIE,UAAY5O,EAAW0O,EAAIG,QAC1CiB,EAAQR,UAAW,EAEnBQ,EAAQ5V,WAAa1B,EAAK0B,WAE9B5B,EAAIC,MAAMrL,OAAO6S,EAAW,EAAG,EAAG+P,IAElC,IAAA3Y,aAAYmB,EAAIC,MAAMwH,G,CAE9B,IAEA,IAAMyR,EAAWrtB,KAAKC,IAAIia,EAAMkS,OAAOxQ,GAAY,EArDjD,IAuDF1B,EAAMkS,OAAOrjB,OAAO6S,EAAU,EAAGyR,EAAUA,E,GA9C1CzR,EAAW2O,EAAII,WAAY/O,GAAY2O,EAAIb,YAAa9N,I,EAAxDA,EAkDjB,C,iIC9DA,WAWA,oCAAyC1B,GACrC,IAAMqQ,GAAM,IAAAC,kBAAiBtQ,GAE7B,GAAIqQ,EACA,IAAK,IAAI1O,EAAW0O,EAAIG,QAAS7O,GAAY0O,EAAIE,SAAU5O,IAAY,CACnE,IAAM1H,EAAM+F,EAAMhG,KAAK2H,GACjByR,EAAWpT,EAAMhG,KAAK2H,EAAW,GAIvC,GAFA1H,EAAIC,MAAMtP,QAAQ,EAAAkO,aAGdsa,aAAQ,EAARA,EAAUlZ,MAAM8E,OACZ,SAACqU,EAAW3R,GACR,OAAAA,EAAW2O,EAAIb,aACf9N,EAAW2O,EAAII,YACf4C,EAAUtC,SAFV,IAKRqC,EAASlZ,MAAMtP,SAAQ,SAACyoB,EAAW3R,GAC3BA,GAAY2O,EAAIb,aAAe9N,GAAY2O,EAAII,cAC/C,IAAA3X,aAAYua,GAAWtC,WAAY,EAE3C,QACG,CACH,IAAMuC,EAAYxtB,KAAKC,IAAKkU,EAAI4Y,QAAU,EA7BvC,IA8BGU,EAA+B,CACjCva,QAAQ,EAAF,eAAOiB,EAAIjB,QACjB6Z,OAAQS,EACRpZ,MAAOD,EAAIC,MAAMnQ,KAAI,SAACoQ,EAAMuH,GACxB,IAAMG,GAAc,IAAA/I,aAAYqB,UAEzB0H,EAAY7I,OAAO6Z,OAE1B,IAAMpB,GAAU,IAAAO,iBACZ7X,EAAK8W,SACL9W,EAAK4W,UACL5W,EAAK2H,SACLD,EAAY7I,QAWhB,OARAyY,EAAQjU,SAAU,EAAH,eAAQrD,EAAKqD,SAExBkE,EAAW2O,EAAIb,aAAe9N,EAAW2O,EAAII,WAC7CgB,EAAQV,WAAY,EAEpBU,EAAQ5V,WAAa1B,EAAK0B,WAGvB4V,CACX,KAGJxX,EAAI4Y,OAASS,EACbtT,EAAMhG,KAAKnL,OAAO8S,EAAW,EAAG,EAAG4R,E,EAInD,C,sGCpEA,eAQA,wBAA6BC,EAAiBhb,GAC1Cgb,EAAOC,QAEPD,EAAOE,oBAAmB,SAAAxuB,GAAS,WAAAyuB,mBAAkBzuB,EAAOsT,EAAzB,GAAqC,CACpEob,QAAS,gBAEjB,C,sGCdA,eAQA,wBAA6BJ,EAAiBva,GAC1Cua,EAAOC,QAEPD,EAAOE,oBAAmB,SAAAxuB,GAAS,WAAA2uB,mBAAkB3uB,EAAO+T,EAAzB,GAAqC,CACpE2a,QAAS,gBAEjB,C,yGCdA,eAKME,EAAoD,CACtDC,GAAI,MACJC,GAAI,QACJC,GAAI,SACJC,GAAI,MACJC,GAAI,SACJC,GAAI,UAQR,2BAAgCZ,EAAiBa,GAC7Cb,EAAOC,SAEP,IAAAxc,iCAAgCuc,EAAQ,mBAAmB,SAAAtV,GACvD,IA4BJG,EAEMiW,EACA1iB,EA/BIgN,EACFyV,EAAe,EACP,IAAMA,GA4BhBC,GAAMjW,OAFZA,EAzBoCH,EAAKG,gBA2BpB,EAATA,EAAWO,UAAW,IAC5BhN,EAAQzH,SAASmqB,EAAI3qB,UAAU,MAErB,GAAKiI,GAAS,EAAK0iB,EAA2B,MA5BtDD,EAAe,GACfnW,EAAKG,UAAY,CACbO,QAASA,EACT5F,OAAQ4F,EACF,CACI2V,WAAY,OACZpH,SAAU2G,EAAgBlV,IAE9B,CAAC,GAIXV,EAAKrD,SAASjQ,SAAQ,SAAAoR,UACXA,EAAQhD,OAAOmU,gBACfnR,EAAQhD,OAAOub,UAC1B,KACO3V,UACAV,EAAKG,SAEpB,GACJ,C,wGChDA,cASA,0BACImV,EACA/W,EACArX,GAEAouB,EAAOC,QAEPD,EAAOE,oBACH,SAACxuB,EAAOwX,GACJ,IAAMpR,GAAS,IAAAmM,qBAAoBvS,EAAOuX,EAAarX,GAIvD,OAFAsX,EAAQ8X,iBAAmB,WAEpBlpB,CACX,GACA,CACIsoB,QAAS,kBAGrB,C,2GC5BA,eACA,WAUA,8BACIJ,EACAvG,EACAD,GAEAwG,EAAOC,SAEP,IAAAxc,iCAAgCuc,EAAQ,sBAAsB,SAAAtV,GACrDA,EAAKG,YACNH,EAAKG,WAAY,IAAAoW,0BAAyB,MAG1CxH,EACA/O,EAAKlF,OAAOiU,UAAYA,EACH,OAAdA,UACA/O,EAAKlF,OAAOiU,UAGnBD,EACA9O,EAAKlF,OAAOgU,aAAeA,EACH,OAAjBA,UACA9O,EAAKlF,OAAOgU,YAE3B,GACJ,C,mGCnCA,eAQA,sBAA2BwG,EAAiBkB,GACxClB,EAAOC,SAEP,IAAAxc,iCAAgCuc,EAAQ,cAAc,SAAAvT,GAClDA,EAAUjH,OAAO2b,WAAaD,EAAQjrB,WACtCwW,EAAUpF,SAASjQ,SAAQ,SAAAoR,GACnBA,EAAQhD,OAAO2b,mBACR3Y,EAAQhD,OAAO2b,UAE9B,GACJ,GACJ,C,yHCnBA,WAGMC,EAA2D,CAC7Dpa,WAAY,+BACZ8H,UAAW,sBAETuS,EAA2D,CAC7Dpa,YAAa,+BACb6H,UAAW,sBAETwS,EAAwD,CAC1D7H,UAAW,MACXD,aAAc,MACdrT,WAAY,OACZG,YAAa,QAUjB,4BACI0Z,EACAuB,EACAC,G,MAEMC,GAAkB,+CACjBH,GAAkB,CACrBlb,YAAa,SACTmb,QAAAA,EAAeH,GAEjBM,GAAkB,+CACjBJ,GAAkB,CACrB/a,aAAc,OACdd,UAAW,QACsB,QAA7B,EAAA+b,QAAAA,EAAkBD,SAAW,QAAIF,GAGzCrB,EAAOC,QAEPD,EAAOE,oBACH,SAACxuB,EAAOwX,GAGJ,OAFAA,EAAQ8X,iBAAmB,YAEpB,IAAAW,uBAAsBjwB,EAAO+vB,EAAoBC,EAC5D,GACA,CACItB,QAAS,oBAGrB,C,sGCtDA,eACA,UACA,WA4DA,wBACIJ,EACA3Q,EACA8C,EACAD,EACA0P,GAEM,MACFA,GAAW,CAAC,EADRC,EAAW,cAAEzP,EAAgB,mBAAE0P,EAAc,iBAAEC,EAAgB,mBAAEC,EAAkB,qBAGrFlS,EADWkQ,EAAOiC,cACCC,cAAc/P,EAnDpB,MACC,QAmDdgQ,EAAUL,QAAAA,EAAmB3P,OAAU3S,EAAY,eAEzDsQ,EAAQ0D,MAAMnN,YAAY,UAAW8b,GAAW,MAEjC3iB,MAAX2iB,GAAwBhQ,IACxBrC,EAAQ0D,MAAMnN,YAAY,QAAS,QACnCyJ,EAAQ0D,MAAMnN,YAAY,UAAW,iBAGrCwb,GACA/R,EAAQsS,YAAYP,GAGxB,IAAM5P,GAAc,IAAAoQ,cAAavS,GAAS,OAAuBtQ,EAAsB6P,GAElF0S,GACD/B,EAAOsC,eAGX,IAAMC,EAA2C,CAC7CC,aAAc,EAAAC,aAAaC,aAC3BC,cAAe,WAAM,OACjB7S,QAAO,EACPT,KAAI,EACJuT,GAAI,GACJC,YAAY,EAJK,EAMrBzC,QAAS,gBAGPxD,EAAW,SACblrB,EACAwX,EACAqD,GAiBA,OAfA,IAAAuW,mBACIpxB,EACAugB,EACmB,iBAAZC,EAAuBA,EAAW,QACzCC,EACAC,EACAlJ,EACAqD,IAGJ,IAAA/B,uBAAsB9Y,GAEtBwX,EAAQ6Y,kBAAmB,EAC3B7Y,EAAQ6Z,YAAYrnB,KAAKuW,IAElB,CACX,EAQA,GANuB,iBAAZC,GACP,IAAAtO,mCAAkCoc,EAAQ9N,EAAU0K,EAAU2F,GAE9DvC,EAAOE,mBAAmBtD,EAAU2F,IAGnCR,EAAkB,CACnB,IAAIiB,OAAW,EAEf,GAAIhB,EAAoB,CACpB,IAAMxc,GAAS,IAAAyd,mBAAkBnT,GACzB8S,EAAmBpd,EAAM,GAArB0d,EAAe1d,EAAM,WAEjCwd,EACIJ,GAAMM,EACA,CACIN,GAAIA,EACJvT,KAAM6T,EACNC,MAAOnB,QAEXxiB,C,CAGdwgB,EAAOsC,aAAaU,E,CAGxB,OAAO/Q,CACX,C,qGCzJA,eACA,WAeA,uBAA4B+N,GACxBA,EAAOC,QAEPD,EAAOE,oBACH,SAAAxuB,GAKI,IAJA,IAAI4oB,GAAU,EACV8I,GAAY,EACZC,EAAa,EAEVD,GAAaC,IAfhB,GAewC,CACxC,IAAM5V,EAAiE,GACjEC,EAAyC,GACzCC,EAAgD,GAEtDyV,GAAY,IAAAE,kBAAiB5xB,EAAO+b,EAAeC,EAAiBC,IAEpE,IAAAnD,uBAAsB9Y,GAEtB4oB,EACIA,GACA7M,EAAc7b,OAAS,GACvB8b,EAAgB9b,OAAS,GACzB+b,EAAc/b,OAAS,C,CAG/B,OAAO0oB,CACX,GACA,CACI8F,QAAS,eAGrB,C,wGC/CA,eACA,WAYA,0BACIJ,EACAuD,QAAA,IAAAA,IAAAA,EAAA,UAEA,IAAMC,EAAgBxD,EAAOyD,mBACvBC,EAAU1D,EAAO2D,sBACjB7rB,EAAkC,CACpC8rB,QAASF,EAAQG,eAAiBH,EAAQI,SAAS,GACnDC,QAASL,EAAQI,QAAQ,GACzBE,WAAYhE,EAAOgE,cA0BvB,OAvBAhE,EAAOE,oBACH,SAAAxuB,GAWI,OAVA,IAAAuyB,0BACIvyB,EACA8xB,EACA1rB,EACAyrB,EACAvD,EAAOkE,eACPlE,EAAOgE,aACPhE,EAAOmE,oBAGJ,CACX,QACA3kB,EACA,CACI4kB,kBAAmB,CACfvT,MAAO,EAAAwT,4BAEXC,iBAAiB,IAIlBxsB,CACX,C,8GCjDA,eACA,WAOA,gCAAqCkoB,GACjC,IAAI5M,EAAkC,KAuBtC,OArBA4M,EAAOE,oBACH,SAAAxuB,GACI,WAAA6yB,wBACI7yB,GACA,SAACka,EAAQa,GACL,SAAIb,EAAOvD,YAAoC,SAAtBuD,EAAOpE,eAC5B,IAAA6E,eAAcI,EAAWb,GAAQ,SAAApD,GAC7B4K,EAAQ5K,CACZ,IACO,GAIf,IACA,SAACoD,EAAQ4Y,GAAQ,OAAA5Y,GAAU4Y,CAAV,GAZrB,GAcJ,CACIpE,QAAS,yBAIVhN,CACX,C,qGCjCA,eACA,WAQA,uBAA4B4M,EAAiBnK,GACzCmK,EAAOC,QAEP,IAAM/P,EAAY8P,EAAOyE,mBACzB,IAAAC,UAAS7O,GAAM,SAAA8O,GACPA,IAAY3E,EAAO4E,cAAoC,WAApB1U,aAAS,EAATA,EAAWb,QAC9C,IAAA7L,6BAA4Bwc,EAAQ,eAAe,SAAC5M,G,QAC1CyR,EAA0C,QAA5B,EAAuB,QAAvB,OAAAC,kBAAiB1R,UAAM,eAAE2R,WAAG,QAAI,GAC9CC,EAAc5R,EAAM2R,IAE1B3R,EAAM2R,IAAMJ,EACZvR,EAAMpJ,QAAU,CAAC,EACjBoJ,EAAM5N,OAAO+N,MAAQ,GACrBH,EAAM5N,OAAO6Z,OAAS,GACtBjM,EAAM6R,IAAM,GAEZjF,EAAOkF,aAAa,YAAa,CAC7B9R,MAAOlD,EAAUkD,MACjB4R,YAAW,EACXG,OAAQR,EACRE,YAAW,GAEnB,GAER,GACJ,C,qGClCA,eA6BA,SAASO,EAAmBpF,EAAiB+E,GACzC/E,EAAOE,oBACH,SAACxuB,EAAOwX,GACJ,IAAMkK,GAAQ,IAAAiS,aAAYN,EAAK,CAAEO,gBAAiB,KAC5CC,GAAM,IAAAC,8BASZ,OAPA,IAAAvJ,YAAWsJ,EAAKnS,IAChB,IAAAqS,YAAW/zB,EAAO6zB,EAAKrc,EAAS,CAC5Bwc,YAAa,aAEjBtS,EAAM/K,YAAa,GACnB,IAAA8K,cAAazhB,EAAO0hB,IAEb,CACX,GACA,CACIgN,QAAS,eAGrB,CAjCA,uBAA4BJ,EAAiB2F,GACzC3F,EAAOC,QAEsB,iBAAlB0F,EACPP,EAAmBpF,EAAQ2F,IAE3B,IAAAjB,UAASiB,GAAgB,SAAAhB,GACjBA,IAAY3E,EAAO4E,cACnBQ,EAAmBpF,EAAQ2E,EAEnC,GAER,C,yGC3BA,eASA,2BAAgC3E,EAAiB4F,GAC7C5F,EAAOC,SAEP,IAAAzc,6BAA4Bwc,EAAQ,mBAAmB,SAAC5M,GACpDA,EAAM6R,IAAMW,CAChB,GACJ,C,wGCfA,eACA,WAUA,0BAA+B5F,EAAiB3M,EAAuBC,GACnE0M,EAAOC,SAEP,IAAAzc,6BAA4Bwc,EAAQ,kBAAkB,SAAC5M,IACnD,IAAAyS,wBAAuBzS,EAAOC,EAAQC,EAC1C,GACJ,C,2GCjBA,eASA,6BAAkC0M,EAAiB8F,EAAmBC,GAClE/F,EAAOC,SAEP,IAAAzc,6BAA4Bwc,EAAQ,qBAAqB,SAAC5M,GACtDA,EAAM5N,OAAOsgB,UAAYA,EACrBC,GACA3S,EAAM5N,OAAOgU,aAAeuM,EAC5B3S,EAAM5N,OAAOW,WAAa4f,EAC1B3S,EAAM5N,OAAOc,YAAcyf,EAC3B3S,EAAM5N,OAAOiU,UAAYsM,GACP,OAAXA,WACA3S,EAAM5N,OAAOgU,oBACbpG,EAAM5N,OAAOW,kBACbiN,EAAM5N,OAAOc,mBACb8M,EAAM5N,OAAOiU,UAE5B,GACJ,C,6GC1BA,eACA,WACA,WAOA,+BAAoCuG,GAChC,IAAIpY,EAAO,GACP4N,EAAqB,KAmCzB,OAjCAwK,EAAOE,oBACH,SAAAxuB,G,QACQ4oB,GAAU,IAAAiK,wBACV7yB,GACA,SAAAka,GAAU,QAAEA,EAAOvD,cAAgBuD,EAAOxT,IAAhC,IACV,SAACwT,EAAQ4Y,GAAQ,QAAE5Y,EAAOxT,MAAQwT,EAAOxT,KAAKoN,OAAOqR,MAAQ2N,EAAIpsB,KAAMoN,OAAOqR,IAA7D,IAEjBxP,GAAW,IAAA2e,qBACXt0B,GACA,GACA,GAEEwsB,EAAe7W,EAAS,GAc9B,OAZuB,GAAnBA,EAASzV,QAA2C,mBAA5BssB,EAAa1W,cACrCH,GAAW,IAAA9C,qBAAoB7S,EAAOwsB,IAEzBtsB,OAAS,IAClB0oB,GAAU,GACV,IAAAnH,cAAazhB,EAAO2V,EAAS,GAAIA,EAASA,EAASzV,OAAS,KAIpEgW,EAAOP,EAAS9Q,KAAI,SAAAnD,GAAK,MAAkB,QAAjBA,EAAEoU,YAAwBpU,EAAEwU,KAAO,EAApC,IAAyCnR,KAAK,IACvE+e,GAAuB,QAAjB,EAAW,QAAX,EAAAnO,EAAS,UAAE,eAAEjP,YAAI,eAAEoN,OAAOqR,OAAQ,KAEjCyD,CACX,GACA,CACI8F,QAAS,wBAIV,CAACxY,EAAM4N,EAClB,C,mHC/CA,SACA,WACA,WAYMyQ,EAAY,eAEZ9R,EAAe,eAEf+R,EAAY,UAelB,sBACIlG,EACA5nB,EACA+tB,EACAC,EACAxa,GAEAoU,EAAOC,QAEP,IAAMzK,GAuHV,SAAkBpd,GACd,OAAOA,EAAKhC,MAAM,8BAAgC,GAAKgC,CAC3D,CAzHiBiuB,CAASjuB,IAAS,IAAI0U,OACnC,GAAI0I,EAAK,CACL,IAGI,EAHE,GAAW,IAAAtR,WAAUsR,GACrB,EAAU,EAAW,EAASZ,cA2F5C,SAAyBY,GACrB,IAAKA,EACD,OAAOA,EAQX,IAAI8Q,EAAS,GAYb,OAXI9Q,EAAI+Q,OAAON,GAAa,IAEpBK,EAD4B,GAA5B9Q,EAAI+Q,OAAOpS,GACF,UACuB,GAAzBqB,EAAI+Q,OAAOL,GACT,SAGA,WAIVI,EAAS9Q,CACpB,CAlH4DgR,CAAgBhR,GAC9D,EAA4B,GAGlCwK,EAAOE,oBACH,SAACxuB,EAAOwX,G,MACE7B,GAAW,IAAA2e,qBACbt0B,GACA,GACA,GAGE+0B,EAAepf,EAChB9Q,KAAI,SAAAnD,GAAK,MAAkB,QAAjBA,EAAEoU,YAAwBpU,EAAEwU,KAAO,EAApC,IACTnR,KAAK,IACJmR,EAAOwe,GAAeK,GAAgB,GAE5C,GACKpf,EAASkB,MAAK,SAAAnV,GAAK,MAAiB,mBAAjBA,EAAEoU,WAAF,KAChBif,GAAgB7e,GACA,GAAnBP,EAASzV,QAA0C,SAA3ByV,EAAS,GAAGG,YAErCH,EAASjQ,SAAQ,SAAAhE,GACb,IAAMgF,EAAOsuB,EACT,EACAP,EACAva,EACiB,QAAjBxY,EAAEoU,cAEN,IAAAmf,SAAQvzB,EAAGgF,GACPhF,EAAEgF,MACF,EAAMsD,KAAKtI,EAAEgF,KAErB,SACG,GACHiP,EAASmE,OAAM,SAAApY,GAAK,MAAiB,mBAAjBA,EAAEoU,WAAF,KACjBI,GAAQA,GAAQ6e,EACrB,CACE,IAAMje,GAAU,IAAAqS,YAAWjT,IAAS,EAAW,EAAS6O,YAAcjB,IAAM,EAAF,8BACxD,QAAX,EAAAnO,EAAS,UAAE,eAAE7B,QACbwa,EAAOyD,qBAER8B,GAAM,IAAAC,8BACN,EAAOkB,EAAW,EAASP,EAAava,IAE9C,IAAA+a,SAAQne,EAAS,IACjB,IAAAyT,YAAWsJ,EAAK/c,GAEZA,EAAQpQ,MACR,EAAMsD,KAAK8M,EAAQpQ,OAGvB,IAAAqtB,YAAW/zB,EAAO6zB,EAAKrc,EAAS,CAC5Bwc,YAAa,Y,CAKrB,OADA,IAAAkB,8BAA6Bl1B,GACtB2V,EAASzV,OAAS,CAC7B,GACA,CACI4wB,aAAc,EAAAC,aAAaoE,WAC3BC,cAAe,SAACC,EAAc3tB,IACrB,GAAc,EAAMkC,QAAQyrB,IAAqC,IAClE,EAAa3tB,EAErB,EACAupB,cAAe,WAAM,UACrBvC,QAAS,c,CAIzB,EAEA,IAAMsG,EAAa,SACflR,EACA2Q,EACAva,EACAsL,GAEA,YAFA,IAAAA,IAAAA,GAAA,GAEO,CACHlN,QAAS,CAAC,EACVxE,OAAQ,CACJqR,KAAMrB,EACN2Q,YAAW,EACXva,OAAM,EACNsL,UAAWA,GAGvB,C,mGCtIA,eACA,WASA,sBAA2B8I,GACvBA,EAAOC,QAEPD,EAAOE,oBACH,SAAAxuB,IACI,IAAA6yB,wBACI7yB,GACA,SAAAka,GAAU,QAAEA,EAAOvD,cAAgBuD,EAAOxT,IAAhC,IACV,SAACwT,EAAQ4Y,GACL,OAAA5Y,EAAOvD,cACJuD,EAAOxT,MAAQwT,EAAOxT,KAAKoN,OAAOqR,MAAQ2N,EAAIpsB,KAAMoN,OAAOqR,IAD9D,IAIR,IAAMxP,GAAW,IAAA2e,qBACbt0B,GACA,GACA,GAEAs1B,GAAY,EAUhB,OARA3f,EAASjQ,SAAQ,SAAAoR,GACTA,EAAQpQ,OACR4uB,GAAY,SAELxe,EAAQpQ,KAEvB,IAEO4uB,CACX,GACA,CACI5G,QAAS,cAGrB,C,4GC5CA,eAQA,8BAAmCJ,EAAiBjuB,GAChDiuB,EAAOC,QAEPD,EAAOE,oBACH,SAAAxuB,GACI,OAAO,IAAAqS,yBAAwBrS,EAAOK,EAC1C,GACA,CACIquB,QAAS,sBAGrB,C,sGCnBA,eAQA,wBAA6BJ,EAAiBxM,GAC1CwM,EAAOC,QAEPD,EAAOE,oBACH,SAAAxuB,GACI,OAAO,IAAAoS,mBAAkBpS,EAAO8hB,EACpC,GACA,CACI4M,QAAS,gBAGrB,C,sGCnBA,eAUA,wBAA6BJ,EAAiBnH,QAAA,IAAAA,IAAAA,GAAA,GAC1CmH,EAAOC,QAEPD,EAAOE,oBACH,SAACxuB,EAAOwX,GAGJ,OAFAA,EAAQ8X,iBAAmB,YAEpB,IAAAnd,aAAYnS,EAAO,KAAMmnB,EACpC,GACA,CACIuH,QAAS,gBAGrB,C,yGCvBA,eAUA,2BAAgCJ,EAAiBnH,QAAA,IAAAA,IAAAA,GAAA,GAC7CmH,EAAOC,QAEPD,EAAOE,oBACH,SAACxuB,EAAOwX,GAGJ,OAFAA,EAAQ8X,iBAAmB,YAEpB,IAAAnd,aAAYnS,EAAO,KAAMmnB,EACpC,GACA,CACIuH,QAAS,mBAGrB,C,4GCvBA,eAQA,8BACIJ,EACAiH,IAEA,IAAAvjB,+BACIsc,EACA,sBACA,SAAAxa,GACIA,EAAO8f,gBAAkB2B,EAAU3B,gBACnC9f,EAAOkU,WAAauN,EAAUvN,WAC9BlU,EAAOmU,SAAWsN,EAAUtN,SAC5BnU,EAAOub,WAAakG,EAAUlG,WAC9Bvb,EAAO0hB,OAASD,EAAUC,OAC1B1hB,EAAO2hB,cAAgBF,EAAUE,cACjC3hB,EAAO4hB,yBAA2BH,EAAUG,yBAC5C5hB,EAAOsJ,UAAYmY,EAAUnY,UAC7BtJ,EAAO0R,UAAY+P,EAAU/P,SACjC,QACA1X,GACA,EAER,C,4GC7BA,eAWA,gCACIwgB,EACAqH,EACAC,GAEAtH,EAAOC,SAEP,IAAAvc,+BAA8Bsc,EAAQ,wBAAwB,SAAChF,EAAGC,EAAIzS,GAClE,GAA4B,SAAxBA,aAAO,EAAPA,EAAShB,aACT,OAAQ6f,GACJ,IAAK,YACD7e,EAAQZ,KAAOY,EAAQZ,KAAK6M,kBAAkB6S,GAC9C,MAEJ,IAAK,YACD9e,EAAQZ,KAAOY,EAAQZ,KAAK2f,kBAAkBD,GAC9C,MAEJ,IAAK,aAGD,IAFA,IAAME,EAAYhf,EAAQZ,KAAK6M,kBAAkB6S,GAAUhxB,MAAM,KAExDvC,EAAI,EAAGA,EAAIyzB,EAAU51B,OAAQmC,IAClCyzB,EAAUzzB,GACNyzB,EAAUzzB,GAAG0zB,OAAO,GAAGF,kBAAkBD,GACzCE,EAAUzzB,GAAG6D,MAAM,GAG3B4Q,EAAQZ,KAAO4f,EAAU/wB,KAAK,KAC9B,MAEJ,IAAK,WACD,IAMMixB,EAAQ,IAAIrS,OAAO,8BAA4C,KAErE7M,EAAQZ,KAAOY,EAAQZ,KAClB6M,kBAAkB6S,GAClBxf,QAAQ4f,GAAO,SAAAtxB,GAAS,OAAAA,EAAMmxB,kBAAkBD,EAAxB,IAI7C,GACJ,C,wGCzDA,eACA,WACA,WAWMK,EAAa,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAU9E,0BACI3H,EACA4H,EACAC,QAAA,IAAAA,IAAAA,EAAA,GAEA7H,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,kBACA,SAACxa,EAAQwV,EAAGC,EAAIxO,GAAc,OAMtC,SACImb,EACApiB,EACAiH,EACAob,GAEA,GAAIriB,EAAOmU,SAAU,CACjB,IAAMmO,GAAW,IAAAhf,oBAAmBtD,EAAOmU,cAAUna,EAAuB,MAE5E,GAAIsoB,EAAW,EAAG,CACd,IAAMC,EAOlB,SAAwBC,EAAYC,EAAoBJ,GACpDG,EAAmB,GAAdC,EAAkB31B,KAAK6B,MAAM6zB,GAAM11B,KAAK0W,KAAKgf,GAClD,IAAM3Q,EAAOwQ,EAAUA,EAAUj2B,OAAS,GAC1C,GAAIo2B,GAAMH,EAAU,GAChBG,EAAK11B,KAAKC,IAAIy1B,EAAKC,EA9CL,QA+CX,GAAID,EAAK3Q,GAAS2Q,GAAM3Q,GAAsB,GAAd4Q,EACnCD,GAAU,GACVA,EAAmB,GAAdC,EAAkB31B,KAAK6B,MAAM6zB,GAAM11B,KAAK0W,KAAKgf,GAClDA,EAAK11B,KAAKD,IAAIC,KAAKC,IAAwB,IAAnBy1B,EAAKC,GAAkB5Q,GAjDjC,UAkDX,GAAkB,GAAd4Q,GACP,IAAK,IAAIl0B,EAAI,EAAGA,EAAI8zB,EAAUj2B,OAAQmC,IAClC,GAAIi0B,EAAKH,EAAU9zB,GAAI,CACnBi0B,EAAKH,EAAU9zB,GACf,K,OAIR,IAASA,EAAI8zB,EAAUj2B,OAAS,EAAGmC,GAAK,EAAGA,IACvC,GAAIi0B,EAAKH,EAAU9zB,GAAI,CACnBi0B,EAAKH,EAAU9zB,GACf,K,CAIZ,OAAOi0B,CACX,CAhC4BE,CAAeJ,EAAoB,YAAVF,EAAuB,GAAK,EAAGC,IAExE,IAAAM,qBAAoBJ,EAAU,KAAMviB,EAAQiH,E,EAGxD,CArBsC2b,CAAuBR,EAAQpiB,EAAQiH,EAAWob,EAAlD,QAC9BroB,GACA,EAER,C,4GCrCA,eACA,WAQA,8BAAmCwgB,EAAiBsF,GAChDtF,EAAOC,QAEP,IAAIoI,EAA4D,KAC5DC,GAA4B,GAEhC,IAAA5kB,+BACIsc,EACA,sBACA,SAACxa,EAAQwV,EAAGxS,EAASiE,GACO,OAApB6Y,SACO9f,EAAO8f,gBAEd9f,EAAO8f,gBAAkBA,EAGzB9c,GAAWiE,GAAoC,mBAAvBjE,EAAQhB,cAEhC8gB,GADAD,EAAgB5b,GACiBpF,SAAS/L,QAAQkN,GAE1D,QACAhJ,OACAA,GACA,SAAA9N,G,MACI,GAAI22B,GAAiBC,GAAoB,EAAG,CACxC,IAAM5b,GAAS,IAAAwG,uBAC6B,QAAxC,EAAAmV,EAAchhB,SAASihB,UAAiB,eAAE9iB,QAG9C6iB,EAAchhB,SAAShM,OAAOitB,EAAmB,EAAG,EAAG5b,IACvD,IAAAyG,cAAazhB,EAAOgb,EAAQA,E,CAEpC,GAER,C,oGC3CA,eAQA,uBAA4BsT,EAAiBuI,GACzCvI,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,eACA,SAACxa,EAAQwV,EAAGxS,GACRhD,EAAOkU,WAAa6O,GAEhB/f,aAAO,EAAPA,EAASuG,QACTvG,EAAQuG,KAAKvJ,OAAOkU,WAAa6O,EAEzC,QACA/oB,GACA,EAER,C,2HCxBA,eA4BA,SAAgB2oB,EACZxO,EACAnU,EACAiH,G,MAKA,GAHAjH,EAAOmU,SAAWA,EAGU,QAAxB,EAAAlN,aAAS,EAATA,EAAW7B,qBAAa,eAAE+O,SAAU,CACpC,IAAM,EAAOlN,EAAU7B,cAAc+O,SAErClN,EAAUpF,SAASjQ,SAAQ,SAAAoR,GAClBA,EAAQhD,OAAOmU,WAChBnR,EAAQhD,OAAOmU,SAAW,EAElC,WAEOlN,EAAU7B,cAAc+O,Q,CAEvC,CAnCA,uBAA4BqG,EAAiBrG,GACzCqG,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,eACA,SAACxa,EAAQwV,EAAGC,EAAIxO,GAAc,OAAA0b,EAAoBxO,EAAUnU,EAAQiH,EAAtC,QAC9BjN,GACA,EAER,EAMA,uB,qGC5BA,eAQA,wBAA6BwgB,EAAiBlR,GAC1CkR,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,eACc,OAAdlR,EACM,SAACtJ,EAAQwV,EAAGxS,UACDhD,EAAOsJ,WAEVtG,aAAO,EAAPA,EAASpQ,cACFoQ,EAAQpQ,KAAKoN,OAAOsJ,SAEnC,EACA,SAACtJ,EAAQwV,EAAGxS,GACRhD,EAAOsJ,UAAYA,GAEftG,aAAO,EAAPA,EAASpQ,QACToQ,EAAQpQ,KAAKoN,OAAOsJ,UAAYA,EAExC,OACNtP,GACA,EAER,C,yHChCA,WAcA,4BACI8M,EACA5T,EACA8vB,EACAC,G,MAEM7gB,EAAO0E,EAAY1E,KACnB2C,EAAQ7R,EAAO2O,SAAS/L,QAAQgR,GAChCoc,GAAgB,IAAA7N,YAClBjT,EAAKzR,UAAUqyB,EAAOC,GACtBnc,EAAY9G,OACZ8G,EAAYlU,KACZkU,EAAYyC,MAGV4Z,EAAkC,CAACD,GAoBzC,OAnBIF,EAAQ,GACRG,EAAY/vB,SACR,IAAAiiB,YACIjT,EAAKzR,UAAU,EAAGqyB,GAClBlc,EAAY9G,OACZ8G,EAAYlU,KACZkU,EAAYyC,OAIpB0Z,EAAM7gB,EAAKhW,QACX+2B,EAAYjtB,MACR,IAAAmf,YAAWjT,EAAKzR,UAAUsyB,GAAMnc,EAAY9G,OAAQ8G,EAAYlU,KAAMkU,EAAYyC,OAI1F4Z,EAAYvxB,SAAQ,SAAAoR,GAAW,OAACA,EAAQH,WAAaiE,EAAYjE,UAAlC,KAC/B,EAAA3P,EAAO2O,UAAShM,OAAM,6BAACkP,EAAO,IAAC,YAAKoe,IAAW,IAExCD,CACX,C,oGClDA,eACA,WAOA,sBAA2B1I,EAAiB4B,GACxC5B,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,cACA,SAACxa,EAAQojB,GACLpjB,EAAOub,WAAa6H,EAAc,OAAS,QAC/C,IACA,SAACpjB,EAAQwV,EAAGvO,G,MACR,WAAAoc,aACgC,IAArBrjB,EAAOub,WACY,QAApB,EAAAtU,aAAS,EAATA,EAAW5B,iBAAS,eAAErF,OAAOub,WAC7Bvb,EAAOub,W,QAErBvhB,GACA,SAACspB,EAAQC,EAAc7f,IACf0Y,aAAO,EAAPA,EAASoH,wBACT9f,EAAQkB,aAAe,CACnBqO,eAAgBsQ,EAAe,kBAAoB,kBAG/D,GAER,C,oGChCA,eACA,WAGME,EAAgC,CAClCzjB,OAAQ,CACJkU,WAAY,cAQpB,sBAA2BsG,GACvBA,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,cACA,SAAChF,EAAG4N,EAAapgB,GACTA,IACIogB,GACA,IAAAM,SAAQ1gB,EAASygB,UAEVzgB,EAAQuG,KAG3B,IACA,SAACiM,EAAGxS,GAAY,SAAEA,aAAO,EAAPA,EAASuG,KAAX,GAExB,C,sGC/BA,eAOA,wBAA6BiR,EAAiB4B,GAC1C5B,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,gBACA,SAACxa,EAAQojB,GACLpjB,EAAO0hB,SAAW0B,CACtB,IACA,SAAApjB,GAAU,QAAEA,EAAO0hB,MAAT,QACV1nB,GACA,SAACspB,EAAQC,EAAc7f,IACf0Y,aAAO,EAAPA,EAASoH,wBACT9f,EAAQkB,aAAe,CACnBqO,eAAgBsQ,EAAe,oBAAsB,oBAGjE,GAER,C,6GC1BA,eAOA,+BAAoC/I,GAChCA,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,uBACA,SAACxa,EAAQojB,GACLpjB,EAAO2hB,gBAAkByB,CAC7B,IACA,SAAApjB,GAAU,QAAEA,EAAO2hB,aAAT,GAElB,C,wGClBA,eAOA,2BAAgCnH,GAC5BA,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,mBACA,SAACxa,EAAQojB,GACLpjB,EAAO4hB,yBAA2BwB,EAAc,MAAQ,EAC5D,IACA,SAAApjB,GAAM,MAAI,MAAqD,QAAtB,QAA/B,EAAAA,EAAO4hB,gCAAwB,eAAE9wB,MAAM,KAAK2C,MAAc,GAE5E,C,2GClBA,eAOA,6BAAkC+mB,GAC9BA,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,qBACA,SAACxa,EAAQojB,GACLpjB,EAAO4hB,yBAA2BwB,EAAc,QAAU,EAC9D,IACA,SAAApjB,GAAM,MAAI,MAAqD,UAAtB,QAA/B,EAAAA,EAAO4hB,gCAAwB,eAAE9wB,MAAM,KAAK2C,MAAgB,GAE9E,C,yGClBA,eAOA,2BAAgC+mB,EAAiB4B,GAC7C5B,EAAOC,SAEP,IAAAvc,+BACIsc,EACA,mBACA,SAACxa,EAAQojB,EAAapgB,GAClBhD,EAAO0R,YAAc0R,GAEjBpgB,aAAO,EAAPA,EAASpQ,QACToQ,EAAQpQ,KAAKoN,OAAO0R,YAAc0R,EAE1C,IACA,SAACpjB,EAAQgD,GAAO,QAAK,QAAEhD,EAAO0R,cAAoC,QAArB,EAAa,QAAb,EAAA1O,aAAO,EAAPA,EAASpQ,YAAI,eAAEoN,cAAM,eAAE0R,UAAS,IAC7E,GACA,SAAC4R,EAAQC,EAAc7f,IACf0Y,aAAO,EAAPA,EAASoH,wBACT9f,EAAQkB,aAAe,CACnBqO,eAAgBsQ,EAAe,uBAAyB,uBAGpE,GAER,C,+HC9BA,WA2YA,SAASI,EACLxiB,EACAmN,EACAsV,GAEA,IAAM/a,GAAc,IAAA/I,aAAYqB,GAEhCyiB,EAAUhyB,SAAQ,SAAAiyB,GACdhb,EAAY7I,OAAO6jB,GAAOvV,CAC9B,KAEA,IAAAlN,yBAAwByH,GAAa,SAAAxH,GAGjC,OAFAA,EAAWA,GAAY,CAAC,GACfC,gBAAiB,EACnBD,CACX,GACJ,CAhXA,kCACImZ,EACA3M,EACA6I,GAEA8D,EAAOE,oBACH,SAAAxuB,GACU,IAAC43B,GAAD,aAAe,IAAAC,uBAAsB73B,GAAM,GAAhC,GAEjB,GAAI43B,EAAY,CACZ,IAAMzM,GAAM,IAAAC,kBAAiBwM,GACvBE,EAAuB,CACzBC,KAAK,EACLC,QAAQ,EACRC,MAAM,EACNC,OAAO,GAIP9V,EAAe,GACbtO,EAAS8jB,EAAW9jB,OAClB+N,EAAwBF,EAAM,MAAvBG,EAAiBH,EAAM,MAAhBxd,EAAUwd,EAAM,MAChCI,GAAkB,IAAAC,qBAAoBlO,EAAOuO,WAC7CJ,EAAcF,EAAgB5d,MAC9B+d,EAAcH,EAAgBF,MAC9BM,EAAcJ,EAAgBD,MAGhCM,EADAP,GACe,IAAAzK,oBAAmByK,GAAS,KACpCK,GAGQ,MAGfJ,EACAM,EAAkBA,EAAY,IAAIN,EAC3BK,EACPC,EAAkBA,EAAY,IAAID,EAElCC,GAA8B,SAG9Bje,EACAie,EAAkBA,EAAY,IAAIje,EAC3B8d,IACPG,EAAkBA,EAAY,IAAIH,GAItC,IAAM/K,EAAuC,OAA/B0gB,EAAW9jB,OAAOC,UAEhC,GAAIoX,EAAK,CAEL,IADA,IAAMgN,EAAiC,CAAC3N,GACjC2N,EAAWj4B,QACd,OAAQi4B,EAAW5wB,OACf,IAAK,YAED6a,EAAe,GACf+V,EAAWnuB,KAAK,cAChB,MACJ,IAAK,aAOD,IANA,IAAMouB,EAAgC,CAClC,YACA,eACA,aACA,eAGI3b,EAAW0O,EAAIE,SACnB5O,GAAY0O,EAAIG,QAChB7O,IAEA,IACI,IAAID,EAAW2O,EAAIb,YACnB9N,GAAY2O,EAAII,WAChB/O,IAIAib,EAFaG,EAAW9iB,KAAK2H,GAAUzH,MAAMwH,GAErB4F,EAAcgW,GAK9CN,EAAUC,KAAM,EAChBD,EAAUE,QAAS,EACnBF,EAAUG,MAAO,EACjBH,EAAUI,OAAQ,EAClB,MACJ,IAAK,cACD,IAAMG,EAAgC,CAAC,cACvC,IACQ5b,EAAW0O,EAAIE,SACnB5O,GAAY0O,EAAIG,QAChB7O,IAOAgb,EAJIG,EAAW9iB,KAAK2H,GAAUzH,MACtBkC,EAAQiU,EAAII,WAAaJ,EAAIb,aAGblI,EAAciW,GAI1CnhB,EAAS4gB,EAAUI,OAAQ,EAASJ,EAAUG,MAAO,EACrD,MACJ,IAAK,eACD,IAAMK,EAAiC,CAAC,eACxC,IACQ7b,EAAW0O,EAAIE,SACnB5O,GAAY0O,EAAIG,QAChB7O,IAOAgb,EAJIG,EAAW9iB,KAAK2H,GAAUzH,MACtBkC,EAAQiU,EAAIb,YAAca,EAAII,YAGdnJ,EAAckW,GAI1CphB,EAAS4gB,EAAUG,MAAO,EAASH,EAAUI,OAAQ,EACrD,MACJ,IAAK,aACD,IAAMK,EAA+B,CAAC,aACtC,IACQ/b,EAAW2O,EAAIb,YACnB9N,GAAY2O,EAAII,WAChB/O,IAIAib,EAFaG,EAAW9iB,KAAKqW,EAAIE,UAAUrW,MAAMwH,GAEzB4F,EAAcmW,GAI1CT,EAAUC,KAAM,EAChB,MACJ,IAAK,gBACD,IAAMS,EAAkC,CAAC,gBACzC,IACQhc,EAAW2O,EAAIb,YACnB9N,GAAY2O,EAAII,WAChB/O,IAIAib,EAFaG,EAAW9iB,KAAKqW,EAAIG,SAAStW,MAAMwH,GAExB4F,EAAcoW,GAI1CV,EAAUE,QAAS,EACnB,MACJ,IAAK,gBAED,IAAMS,EAAYtN,EAAII,YAAcJ,EAAIb,YAClCoO,EAAYvN,EAAIG,SAAWH,EAAIE,SAErC,GAAIoN,GAAaC,EACb,MAGJ,GAAID,EAAW,CAMX,IALAhB,EACIG,EAAW9iB,KAAKqW,EAAIE,UAAUrW,MAAMmW,EAAIb,aACxClI,EACA,CAAC,iBAGG3F,EAAW0O,EAAIE,SAAW,EAC9B5O,GAAY0O,EAAIG,QAAU,EAC1B7O,IAIAgb,EADIG,EAAW9iB,KAAK2H,GAAUzH,MAAMmW,EAAIb,aAChBlI,EAAc,CAClC,YACA,iBAGRqV,EACIG,EAAW9iB,KAAKqW,EAAIG,SAAStW,MAAMmW,EAAIb,aACvClI,EACA,CAAC,cAEL,K,CAGJ,GAAIsW,EAAW,CAQX,IAPAjB,EACIG,EAAW9iB,KAAKqW,EAAIE,UAAUrW,MAC1BkC,EAAQiU,EAAII,WAAaJ,EAAIb,aAEjClI,EACA,CAAC,gBAGG5F,EAAW2O,EAAIb,YAAc,EACjC9N,GAAY2O,EAAII,WAAa,EAC7B/O,IAGAib,EADaG,EAAW9iB,KAAKqW,EAAIE,UAAUrW,MAAMwH,GACzB4F,EAAc,CAClC,aACA,gBAGRqV,EACIG,EAAW9iB,KAAKqW,EAAIE,UAAUrW,MAC1BkC,EAAQiU,EAAIb,YAAca,EAAII,YAElCnJ,EACA,CAAC,eAEL,K,CAqCJ,IAhCAqV,EACIG,EAAW9iB,KAAKqW,EAAIE,UAAUrW,MAC1BkC,EAAQiU,EAAII,WAAaJ,EAAIb,aAEjClI,EACA,CAAC,eAAgB,gBAGrBqV,EACIG,EAAW9iB,KAAKqW,EAAIE,UAAUrW,MAC1BkC,EAAQiU,EAAIb,YAAca,EAAII,YAElCnJ,EACA,CAAC,eAAgB,eAGrBqV,EACIG,EAAW9iB,KAAKqW,EAAIG,SAAStW,MACzBkC,EAAQiU,EAAII,WAAaJ,EAAIb,aAEjClI,EACA,CAAC,YAAa,gBAGlBqV,EACIG,EAAW9iB,KAAKqW,EAAIG,SAAStW,MACzBkC,EAAQiU,EAAIb,YAAca,EAAII,YAElCnJ,EACA,CAAC,YAAa,eAIV5F,EAAW2O,EAAIb,YAAc,EACjC9N,EAAW2O,EAAII,WACf/O,IAGAib,EADaG,EAAW9iB,KAAKqW,EAAIE,UAAUrW,MAAMwH,GACzB4F,EAAc,CAClC,eACA,aACA,gBAIR,IACQ5F,EAAW2O,EAAIb,YAAc,EACjC9N,EAAW2O,EAAII,WACf/O,IAGAib,EADaG,EAAW9iB,KAAKqW,EAAIG,SAAStW,MAAMwH,GACxB4F,EAAc,CAClC,YACA,aACA,gBAIR,IACQ3F,EAAW0O,EAAIE,SAAW,EAC9B5O,EAAW0O,EAAIG,QACf7O,IAGAgb,EADaG,EAAW9iB,KAAK2H,GAAUzH,MAAMmW,EAAIb,aACzBlI,EAAc,CAClC,YACA,eACAlL,EAAQ,aAAe,gBAI/B,IACQuF,EAAW0O,EAAIE,SAAW,EAC9B5O,EAAW0O,EAAIG,QACf7O,IAGAgb,EADaG,EAAW9iB,KAAK2H,GAAUzH,MAAMmW,EAAII,YACzBnJ,EAAc,CAClC,YACA,eACAlL,EAAQ,cAAgB,eAIhCiU,EAAIb,cACJa,EAAIE,WACJF,EAAII,aACJJ,EAAIG,UACJ6M,EAAWnuB,KAAK,cAChB,MACJ,IAAK,iBAEDmuB,EAAWnuB,KAAK,cAChBmuB,EAAWnuB,KAAK,iBAChBmuB,EAAWnuB,KAAK,eAChBmuB,EAAWnuB,KAAK,iBA8DhD,SACI4tB,EACAzM,EACA/I,EACA0V,EACA5gB,GAGA,GAAI4gB,EAAUC,KAAO5M,EAAIE,SAAW,GAAK,EACrC,IAAK,IAAI7O,EAAW2O,EAAIb,YAAa9N,GAAY2O,EAAII,WAAY/O,IAE7Dib,EADaG,EAAW9iB,KAAKqW,EAAIE,SAAW,GAAGrW,MAAMwH,GAC7B4F,EAAc,CAAC,iBAI/C,GAAI0V,EAAUE,QAAU7M,EAAIG,QAAU,EAAIsM,EAAW9iB,KAAK5U,OACtD,IAASsc,EAAW2O,EAAIb,YAAa9N,GAAY2O,EAAII,WAAY/O,IAE7Dib,EADaG,EAAW9iB,KAAKqW,EAAIG,QAAU,GAAGtW,MAAMwH,GAC5B4F,EAAc,CAAC,cAI/C,GAAI0V,EAAUG,MAAQ9M,EAAIb,YAAc,GAAK,EACzC,IAAK,IAAI7N,EAAW0O,EAAIE,SAAU5O,GAAY0O,EAAIG,QAAS7O,IAEvDgb,EADaG,EAAW9iB,KAAK2H,GAAUzH,MAAMmW,EAAIb,YAAc,GACvClI,EAAc,CAAClL,EAAQ,aAAe,gBAItE,GAAI4gB,EAAUI,OAAS/M,EAAII,WAAa,EAAIqM,EAAW9iB,KAAK,GAAGE,MAAM9U,OACjE,IAASuc,EAAW0O,EAAIE,SAAU5O,GAAY0O,EAAIG,QAAS7O,IAEvDgb,EADaG,EAAW9iB,KAAK2H,GAAUzH,MAAMmW,EAAII,WAAa,GACtCnJ,EAAc,CAAClL,EAAQ,cAAgB,cAG3E,CAzFoByhB,CAAgBf,EAAYzM,EAAK/I,EAAc0V,EAAW5gB,E,CAG9D,IAAM0hB,GAAY,IAAAC,kBAAiBjB,GAMnC,OALIgB,IAEA,IAAAE,8BAA4B,IAAAllB,aAAYgkB,GAAY9iB,KAAM8jB,IAGvD,C,CAEP,OAAO,CAEf,GACA,CACIlK,QAAS,eAGrB,C,mGClYA,eACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WAEA,WAUA,qBAA0BJ,EAAiB9D,GACvC8D,EAAOC,QAwEX,SAA8BD,GAC1B,GAAIA,EAAOyK,iBAAiBC,SAAU,CAClC,IAAMxa,EAAY8P,EAAOyE,kBAEF,UAAnBvU,aAAS,EAATA,EAAWb,OAAoBa,EAAUya,MAAMC,YAC/C1a,EAAUya,MAAME,UAAS,GACzB7K,EAAO8K,gBAAgB,CACnBzb,KAAM,QACNsb,MAAOza,EAAUya,MACjBI,YAAY,I,CAI5B,CAnFIC,CAAqBhL,IAErB,IAAAzc,6BAA4Byc,EAAQ,aAAa,SAAAsJ,GAC7C,OAAQpN,GACJ,IAAK,gBACL,IAAK,kBACL,IAAK,kBACD,IAAA+O,4BAA2B3B,EAAYpN,GACvC,MACJ,IAAK,eACL,IAAK,kBACL,IAAK,mBACD,IAAAgP,0BAAyB5B,EAAYpN,GACrC,MACJ,IAAK,cACL,IAAK,YACL,IAAK,cACD,IAAAvW,YAAW2jB,EAAYpN,GACvB,MAEJ,IAAK,gBACD,IAAAiP,mBAAkB7B,GAClB,MAEJ,IAAK,aACD,IAAA8B,gBAAe9B,GACf,MAEJ,IAAK,eACD,IAAA+B,aAAY/B,GACZ,MAEJ,IAAK,cACL,IAAK,eACD,IAAAnmB,gBAAemmB,EAAYpN,GAC3B,MAEJ,IAAK,aACL,IAAK,eACD,IAAA9Y,mBAAkBkmB,EAAYpN,GAC9B,MAEJ,IAAK,aACL,IAAK,cACD,IAAAoP,eAAchC,EAAYpN,GAC1B,MAEJ,IAAK,cACD,IAAAqP,iBAAgBjC,GAChB,MAEJ,IAAK,YACL,IAAK,cACD,IAAAkC,kBAAiBlC,EAAYpN,GAC7B,MAEJ,IAAK,qBACD,IAAAuP,4BAA2BnC,GAC3B,MAEJ,IAAK,mBACD,IAAAoC,0BAAyBpC,GAGrC,GACJ,C,oHC3FA,WAcA,uBAA4BtJ,EAAiBxa,EAA6BmmB,GACtE3L,EAAOC,QAEPD,EAAOE,oBACH,SAAAxuB,GACU,IAAC43B,GAAD,aAAe,IAAAC,uBAAsB73B,GAAM,GAAhC,GAEjB,QAAI43B,IAEAA,EAAW9iB,KAAKpP,SAAQ,SAAAqP,GACpBA,EAAIC,MAAMtP,SAAQ,SAAAuP,IACd,IAAAC,0BAAwB,IAAAtB,aAAYqB,IAAO,SAAAE,GAIvC,OAHIA,UACOA,EAASC,eAEbD,CACX,GACJ,GACJ,KACA,IAAAK,kBAAiBoiB,EAAY9jB,EAAQmmB,IAC9B,EAIf,GACA,CACIvL,QAAS,eAGrB,C,oHC3CA,WACA,WACA,WA6FA,SAASwL,EAAkBvN,GACvB,OAAIA,GAAW,EACJ,IACAA,GAAW,EACX,IAEA,EAEf,CAzEA,uBACI2B,EACA3B,EACA7X,EACAqlB,EACArmB,EACAsmB,GAEA9L,EAAOC,QAEPD,EAAOE,oBACH,SAACxuB,EAAOwX,G,UACE6iB,GAAiB,IAAArZ,iBAAgBhhB,EAAO,GAAIwX,GAASqD,YAE3D,GAAIwf,EAAgB,CAChB,IAAMxG,GAAM,IAAAC,8BACNhZ,GAAQ,IAAAwf,sBAAqBzG,EAAKlH,EAAS7X,EAAMslB,GACnDtmB,IACAgH,EAAMhH,QAAS,EAAH,eAAQA,KAGxB,IAAAymB,gBAAezf,EAAOwT,EAAOyD,oBAAsBsI,EAAerf,OAAOlH,QAgCzF,SAAuBgH,GAGnB,IAFA,IAAM6R,EAAU/rB,KAAKC,IAAG,MAARD,MAAI,mCAAQka,EAAMhG,KAAKjQ,KAAI,SAAAkQ,GAAO,OAAAA,EAAIC,MAAM9U,MAAV,MAAiB,IAE1DmC,EAAI,EAAGA,EAAIsqB,EAAStqB,SACDyL,IAApBgN,EAAMkS,OAAO3qB,GACbyY,EAAMkS,OAAO3qB,GAAK63B,EAAkBvN,GAC7B7R,EAAMkS,OAAO3qB,GAAK,EAAAm4B,+BACzB1f,EAAMkS,OAAO3qB,GAAK,EAAAm4B,6BAG9B,CAzCgBC,CAAc3f,IAEd,IAAA4f,wBAAuBL,EAAgBvf,GAGvCqf,EAAsBA,GAAuB,CAAE3O,cAAe,QAC9D,IAAAhW,kBAAiBsF,EAAOqf,IACxB,IAAApG,YAAW/zB,EAAO6zB,EAAKrc,EAAS,CAC5B6iB,eAAc,EACdrG,YAAa,aAGjB,IAAM2G,EAAoC,QAAvB,EAAa,QAAb,EAAA7f,EAAMhG,KAAK,UAAE,eAAEE,MAAM,UAAE,eAAEb,OAAO,GAEnD,GAA6B,cAAzBwmB,aAAU,EAAVA,EAAY3mB,WAA0B,CACtC,IAAMgH,GAAS,IAAAwG,uBAA4C,QAAtB,EAAAmZ,EAAWhlB,SAAS,UAAE,eAAE7B,QAC7D6mB,EAAWhlB,SAASzO,QAAQ8T,IAC5B,IAAAyG,cAAazhB,EAAOgb,E,CAGxB,OAAO,C,CAEP,OAAO,CAEf,GACA,CACI0T,QAAS,eAGrB,C,0HCjFA,WAaA,6BAAkCJ,EAAiBnqB,GAC/CmqB,EAAOC,QAEPD,EAAOE,oBACH,SAAAxuB,GACU,IAAC8a,GAAD,aAAU,IAAA+c,uBAAsB73B,GAAM,GAAhC,GAEZ,QAAI8a,IACAA,EAAMhG,KAAKpP,SAAQ,SAAAqP,GACf,OAAAA,EAAIC,MAAMtP,SAAQ,SAAAuP,IACV,IAAA2lB,0BAAyB3lB,KACzB,IAAA4lB,8BACI,IAAAjnB,aAAYqB,GACZ9Q,GACA,EAGZ,GARA,KAWG,EAIf,GACA,CACIuqB,QAAS,qBAGrB,C,qIClCA,wCACIJ,EACAwM,G,MAEMC,EAAYzM,EAAOkE,eACnBhb,EAAyB,CAC3B8a,WAAYhE,EAAOgE,aACnB0I,eAAe,EAAF,eAAOF,EAAOhnB,QAC3BmnB,iBAAkB3M,EAAOmE,kBACzByI,uBAAuB,EACvBC,mBAAmB,EACnBC,gBAAYttB,EACZutB,UAAWN,EAAUO,qBACrBC,qBAAsB,IAO1B,MAJoF,QAAhD,QAAhC,EAAAjN,EAAOiC,cAAciL,mBAAW,eAAEC,iBAAiBX,EAAO1c,SAASrK,aACnEyD,EAAQkkB,WAAY,GAGjBlkB,CACX,C,qHC7BA,eASA,uCACI8W,EACAI,EACAxD,IAEA,IAAAlZ,+BACIsc,EACAI,GACA,SAACpF,EAAGC,EAAIzS,GACwB,UAAxBA,aAAO,EAAPA,EAAShB,cACToV,EAASpU,EAEjB,QACAhJ,OACAA,EAER,C,0ICzBA,WA8EA,SAAS6tB,EAAwBC,GAC7B,OAAO,SAAC/d,EAAO7W,EAAQwQ,GACnB,IAAMqkB,EAAkBrkB,EAExBqkB,EAAgB90B,KAAO80B,EAAgB90B,MAAQ,GAE/C,IAAI+0B,GAAkB,EAClBD,EAAgB90B,KAAK,IAAM8W,IAC3Bge,EAAgB90B,KAAKG,QAAQ2W,GAC7Bie,GAAkB,GAMtB,IAHA,IAAMC,EAAUC,EAA0BxkB,EAASokB,EAAQ50B,GACvD6R,EAAQ,EAEHsG,EAAQnY,EAAOoY,WAAYD,EAAOA,EAAQA,EAAME,YACrD4c,EAA6BL,EAAQ/iB,EAAOrB,EAASqG,EAAOke,EAAS/0B,IAErE,IAAAwY,kBAAiB3B,EAAOsB,EAAO3H,GAE/BqB,IAGJojB,EAA6BL,EAAQ/iB,EAAOrB,EAASqG,EAAOke,EAAS/0B,GAEjE80B,GACAD,EAAgB90B,KAAKumB,OAE7B,CACJ,CAEA,SAAS2O,EACLL,EACA/iB,EACArB,EACAqG,EACAke,EACAtgB,GAGI5C,GAASkjB,EAAQ,KAChBljB,GAASkjB,EAAQ,IAAMA,EAAQ,GAAK,KACpCljB,EAAQkjB,EAAQ,IAAMA,EAAQ,GAAK,KAEpCG,EAAmBre,EAAOrG,EAASiE,EAAW5C,EAAO+iB,GACrDG,EAAQ,IAAM,GAGdljB,GAASkjB,EAAQ,KACjBvkB,EAAQ2kB,eAAgB,EACxBD,EAAmBre,EAAOrG,EAASiE,EAAW5C,IAG9CA,GAASkjB,EAAQ,KAAOljB,EAAQkjB,EAAQ,IAAMA,EAAQ,GAAK,KAC3DG,EAAmBre,EAAOrG,EAASiE,EAAW5C,EAAO+iB,GACrDG,EAAQ,IAAM,GAGdljB,GAASkjB,EAAQ,KACjBG,EAAmBre,EAAOrG,EAASiE,EAAW5C,GAC9CrB,EAAQ2kB,eAAgB,GAGxBtjB,GAASkjB,EAAQ,IACjBG,EAAmBre,EAAOrG,EAASiE,EAAW5C,EAAO+iB,EAE7D,CArHA,6CACItN,EACAzT,EACAqQ,EAKAgF,GAEA,IAAM0L,EAA4B,CAC9BQ,MAAOvhB,GAGXyT,EAAOE,oBACH,SAACxuB,EAAOwX,GAGJ,GAFA0T,EAASlrB,EAAOwX,EAASokB,EAAOx1B,QAE5Bw1B,aAAM,EAANA,EAAQx1B,OAAQ,CACV,MAAwBw1B,EAAOx1B,OAA7B2U,EAAS,YAAEC,EAAM,SACnBnC,EAAQkC,EAAUpF,SAAS/L,QAAQoR,GAErCnC,GAAS,IACT,IAAAjF,aAAYmH,GAAWpF,SAAShM,OAAOkP,EAAO,E,CAGtD,OAAO,CACX,GACAqX,EACA,CACIwC,kBAAmB,CACfvT,MAAOwc,EAAwBC,GAC/BS,kBAAmBC,EAAuBV,IAE9ChJ,iBAAiB,GAG7B,EAkFA,IAAM0J,EAAyB,SAACV,GAAsD,gBAClF/d,EACA0e,EACA/kB,GAEA,IAAIglB,EAAMD,EAASE,WAAa,GAC1BV,EAAUC,EAA0BxkB,EAASokB,EAAQW,GACrD,eAAuBR,EAAO,GAA7BjF,EAAK,KAAEC,EAAG,KAAE2F,EAAM,KAEnBC,EAAsB,SACxBC,EACAC,EACAjB,IAEA,IAAAkB,gBAAejf,EAAO2e,EAAI/3B,UAAU,EAAGm4B,GAAWplB,GAClD0kB,EAAmBre,EAAOrG,EAAS+kB,EAAUM,EAAgBjB,GAE7DG,EAAQ,IAAMa,EACdb,EAAQ,IAAMa,EACdb,EAAQ,GAAKH,GAAU,EAAIG,EAAQ,GAAKa,EAExCJ,EAAMA,EAAI/3B,UAAUm4B,EACxB,EAGIb,EAAQ,IAAM,IACbA,EAAQ,IAAMA,EAAQ,IAAMA,EAAQ,GAAK,KACzCA,EAAQ,GAAKA,EAAQ,IAAMA,EAAQ,GAAK,IAEzCY,EAAoBZ,EAAQ,GAAIW,EAAQd,GAGxCG,EAAQ,IAAM,IACdY,EAAoBZ,EAAQ,GAAIjF,GAEhCtf,EAAQ2kB,eAAgB,GAGxBJ,EAAQ,IAAM,GAAKA,EAAQ,GAAKA,EAAQ,KAAOA,EAAQ,GAAKA,EAAQ,IAAMA,EAAQ,GAAK,IACvFY,EAAoBZ,EAAQ,GAAIW,EAAQd,GAGxCG,EAAQ,IAAM,IACdY,EAAoBZ,EAAQ,GAAIhF,GAEhCvf,EAAQ2kB,eAAgB,GAGxBJ,EAAQ,IAAM,GAAKA,EAAQ,IAAMA,EAAQ,IACzCY,EAAoBZ,EAAQ,GAAIW,EAAQd,IAG5C,IAAAkB,gBAAejf,EAAO2e,EAAKhlB,EAC/B,CArDsF,EAuDtF,SAAS0kB,EACLre,EACArG,EACAiE,EACAmO,EACAgS,GAEA,IAAM5gB,GAAS,IAAA+hB,sBAAqBlf,EAAOrG,EAASiE,EAAWmO,GAE/D5O,EAAOrE,YAAcilB,EAErB,IAAM5iB,GAAO,IAAAuR,YAAW1M,EAAO7C,EAAQxD,EAAQwlB,YAAahiB,EAAOlH,QAE/D8nB,GAAUpkB,EAAQzQ,OAClB60B,EAAOx1B,OAAS,CACZW,MAAM,EAAF,iCAAMyQ,EAAQzQ,OAAI,GACtBgU,UAAW/B,EACXgC,OAAM,GAGlB,CAEA,SAASghB,EACLxkB,EACAokB,EACAqB,GAEM,oBAAe,IAAAje,4BAA2BxH,EAASylB,GAAiB,GAG1E,MAAO,CAHK,KAAK,KACFrB,EAAOQ,MAAM10B,MAAQu1B,EAAmBrB,EAAOQ,MAAMxS,QAAU,EAGlF,C,yHCxOA,eACA,WASA,2CACI0E,EACAI,EACAwO,GAEA5O,EAAOE,oBACH,SAACxuB,EAAOwX,IACJ,IAAAjE,4BAA2BvT,GAE3B,IAAM0oB,GAAa,IAAAC,uBAAsB3oB,GAAO,GAKhD,OAHA0oB,EAAWhjB,QAAQw3B,GACnB1lB,EAAQ8X,iBAAmB,WAEpB5G,EAAWxoB,OAAS,CAC/B,GACA,CACIwuB,QAAO,GAGnB,C,sIC9BA,WACA,WACA,WA8BA,yCACIJ,EACAI,EACAyO,EAMAC,EAKAC,EACAC,GAMAhP,EAAOE,oBACH,SAACxuB,EAAOwX,GACJ,IAAI+lB,GAAuB,IAAAlkB,kCACvBrZ,IACEq9B,GACF,GACA,GAEAG,EACAD,EAAqBr9B,QAAU,GAC/Bq9B,EAAqBzjB,OAAM,SAAApY,GAAK,MAAoB,mBAApBA,EAAE,GAAGoU,WAAL,IAGpC,GAAI0nB,EAAsB,CACtB,IAAM,EAAOD,EAAqB,GAAG,GAC/B,EAAOA,EAAqB,GAAG,IAErCA,GAAuB,IAAA1qB,qBACnB7S,EACAu9B,EAAqB,GAAG,IAC1B14B,KAAI,SAAAnD,GAAK,OAACA,EAAG,EAAM,EAAV,KAEcxB,OAAS,IAC9Bs9B,GAAuB,E,CAK/B,IAAMC,EAIA,GACAC,EAIA,GAENH,EAAqB73B,SAAQ,SAAA+Q,GACE,UAAvBA,EAAK,GAAGX,YAuD5B,SACIwY,EACAwM,EACA2C,EAKAC,EACA3iB,GAEM,MAAuC+f,EAAO6C,aAA5CzM,EAAE,KAAcvT,EAAI,aAAEwT,EAAU,aAExC,GAAID,GAAMvT,EAAM,CACZ,IAAMigB,EAAsC,GACtCC,EAA+D,CACjE/C,OAAQ,CAAE5J,GAAE,EAAEvT,KAAI,EAAEwT,aAAcA,EAAY/S,QAAS0c,EAAO1c,SAC9DoM,UAAW,eACXoT,iBAAgB,GAGpBtP,EAAOkF,aAAa,kBAAmBqK,GAEvCD,EAAiBl4B,SAAQ,SAAA+Y,GACrB,GAAIqc,EAAO1c,QAAQO,SAASF,EAAKqf,SAAU,CACvC,IAAM7f,GAAgB,IAAArM,8BAA6B0c,EAAQwM,GACrDtjB,GAAU,IAAA0G,yBAAwBD,EAAeQ,EAAKsf,mBAG5DvmB,EAAQ2kB,eAAgB,EAExB,IAAMn8B,GAAQ,IAAAme,mBAAkBM,EAAKqf,QAAStmB,IAC3B,IAAA6B,kCACfrZ,GACA,GACA,GACA,GAGO0F,SAAQ,SAAA+Q,GACfgnB,EAAmBzzB,KAAK,CAACyM,EAAK,GAAG3C,OAAQ2C,EAAK,GAAIA,EAAK,IAC3D,IAEAinB,EAAmB1zB,KAAK,CAAC8wB,EAAQrc,EAAMze,G,CAE/C,IACI49B,EAAiB19B,OAAS,GAC1Bu9B,EAAmBzzB,KAAK,CAAC8wB,EAAOhnB,OAAQgnB,EAAQ/f,G,CAG5D,CAxGoBijB,CACI1P,EACA7X,EAAK,GACLgnB,EACAC,EACAjnB,EAAK,IAGTgnB,EAAmBzzB,KAAK,CAACyM,EAAK,GAAG3C,OAAQ2C,EAAK,GAAIA,EAAK,IAE/D,IAIA,IAAM4gB,IAAe+F,GACfK,EAAmB3jB,OAAM,SAAC,G,IAAA,oBAAChG,EAAM,KAAEgD,EAAO,KAAEiE,EAAS,KACjD,OAAAqiB,EAAwBtpB,EAAQgD,EAASiE,EAAzC,IAwBV,OAnBA0iB,EAAmB/3B,SAAQ,SAAC,G,IAAA,oBAACoO,EAAM,KAAEgD,EAAO,KAAEiE,EAAS,KACnDoiB,EAAoBrpB,GAASujB,EAAcvgB,EAASiE,EACxD,IAGAuiB,SAAAA,EAAsBt9B,EAAOq3B,EAAc7f,GAG3CimB,EAAmB/3B,SAAQ,SAAC,G,IAAA,oBAAQqV,GAAN,KAAI,KAAW,MACrCA,IACA,IAAAkjB,mBAAkBljB,EAE1B,IAyEZ,SACIuT,EACAoP,GAEAA,EAAmBh4B,SAAQ,SAAC,G,IAAA,oBAACo1B,EAAM,KAAErc,EAAI,KAAEze,EAAK,KACtCie,GAAgB,IAAArM,8BAA6B0c,EAAQwM,GACrDoD,GAAoB,IAAAC,yBAAwBlgB,EAAeQ,EAAK2f,oBAEtE,IAAAC,mBAAkB/P,EAAOiC,cAAe9R,EAAKqf,QAAS99B,EAAOk+B,EACjE,GACJ,CAhFYI,CAAkBhQ,EAAQoP,GAItBF,GACAhmB,EAAQ8X,iBAAmBiO,EAAqB,GAAG,GAAGzpB,OACtDwa,EAAOC,SACA,GAEAkP,EAAmBv9B,OAAS,CAE3C,GACA,CACIwuB,QAAO,GAGnB,C,oIClJA,WACA,WAwBA,uCACIJ,EACAI,EACAxD,EACAqT,GAEAjQ,EAAOC,QACPD,EAAOE,oBACH,SAAAxuB,GACU,oBAA6B,IAAA63B,uBAAsB73B,GAAM,GAAxDw+B,EAAkB,KAAEz3B,EAAI,KAE/B,GAAIy3B,EAAoB,CACpB,IAAM5G,GAAa,IAAAhkB,aAAY4qB,GAI/B,GAFAtT,EAAS0M,KAEJ,IAAA6G,qBAAoB7G,GAAa,CAClC,IAAM7c,GAAY,IAAA2jB,kCAAiC1+B,EAAO+G,EAAM6wB,GAEhE,GAAI7c,EAAW,CACX,IAAMC,GAAS,IAAAwG,uBAAsBxhB,EAAM8T,QAE3CiH,EAAUpF,SAASzO,QAAQ8T,IAC3B,IAAAmF,yBAAwBpF,IACxB,IAAA0G,cAAazhB,EAAOgb,E,EAU5B,OANA,IAAAuf,gBAAe3C,EAAY53B,EAAM8T,SAE7B,IAAA6qB,aAAY/G,KACZ,IAAApiB,kBAAiBoiB,OAAY9pB,GAAyB,IAGnD,C,CAEP,OAAO,CAEf,GACA,CACI4gB,QAAO,EACP6P,kBAAiB,GAErB,CACIK,qBAAsB,YAGlC,C,gICxEA,eAiBA,kDACItQ,EACApD,EAOAgF,GAEA,IAAI9pB,GAAS,EA0Cb,OAxCAkoB,EAAOE,oBAAmB,SAACxuB,EAAOwX,GAC9B,IAAMqnB,GAAgC,IAAAxlB,kCAClCrZ,GACA,GAEA8+B,GAAU,EAgCd,OA7BID,EAA8B3+B,OAAS,GACY,mBAAnD2+B,EAA8B,GAAG,GAAG/oB,aACpC+oB,EAA8B,GAAG,KAEjC,IAAAlkB,eACIkkB,EAA8B,GAAG,GACjCA,EAA8B,GAAG,IACjC,SAAC7jB,EAAQD,EAAWgkB,GAChB,IAAMje,EAAkB/F,EAAUpF,SAASopB,EAAc,GAErDje,GAAmD,SAAhCA,EAAgBhL,cACnC1P,GAAS,EAIToR,EAAQ8X,iBAAmB,WAE3BwP,EAAU5T,EACNlrB,EACA8gB,EACA/F,EACAC,EAAOlH,OACP0D,GAGZ,IAIDsnB,CACX,GAAG5O,GAEI9pB,CACX,C,4ICvEA,WAyBA,4BAAiCytB,GAC7B,IAAMmL,GAAS,IAAAC,SAAQpL,EAAIqL,iBAAiB,UACtC94B,EAAoB,GAqB1B,OAnBA44B,EAAOt5B,SAAQ,SAAAy5B,G,MAZKC,EAaVC,EAAQF,EAAUE,MAExB,GAAIA,EACA,IAAK,IAAIC,EAAY,EAAGA,EAAYD,EAAME,SAASr/B,OAAQo/B,IAAa,CACpE,IAAM1a,EAAOya,EAAME,SAASD,GAExB1a,EAAKjH,MAAQ6hB,QAAQC,YAAc7a,EAAKwa,cACxCh5B,EAAO4D,KAAK,CACR01B,WArBAN,EAqB0Bxa,EAAKwa,aAnB5CA,EAAax6B,MADN,gBACmBC,KAAI,SAAA3D,GAAK,OAAAA,EAAEka,MAAF,KAoBtBlF,KAAM0O,EAAK9C,MAAM6d,S,CAMb,QAApB,EAAAR,EAAUtgB,kBAAU,SAAE+gB,YAAYT,EACtC,IAEO/4B,CACX,EAKA,4BAAiCqY,EAAkB8gB,GAC/C,I,eAASl9B,G,QACC,EAAsBk9B,EAASl9B,GAA7Bq9B,EAAS,YAAExpB,EAAI,O,IAEvB,IAAuB,+BAAAwpB,IAAS,8BAAE,CAA7B,IAAMG,EAAQ,QACVA,GAAaA,EAASzkB,SAIb,IAAA6jB,SAAQxgB,EAAKygB,iBAAiBW,IAKtCn6B,SAAQ,SAAAgC,GACV,OAAAA,EAAKo4B,aAAa,QAAS5pB,GAAQxO,EAAKq4B,aAAa,UAAY,IAAjE,G,qGAdH19B,EAAIk9B,EAASr/B,OAAS,EAAGmC,GAAK,EAAGA,I,EAAjCA,EAkBb,C,6ICzEA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WASM29B,EAAyD,CAC3DtN,kBAAmB,CAAC,EACpBuN,qBAAsB,CAAC,EACvBC,wBAAyB,CAAC,EAC1BC,sBAAuB,GACvBC,yBAA0B,GAC1BC,gBAAiB,CAAC,EAClBC,oBAAqB,CAAC,EACtBC,2BAA2B,GAM/B,gDACIC,EACAxF,EACAyF,EACAC,EACA3F,GAEA,IAAM4F,GAAgB,gCACfX,GACAU,GAGP,OAAO,IAAAxiB,0BAAuB,8BAEtB8c,cAAa,IACV,IAAA4F,gCAA+BJ,IAAS,CAC3CjF,qBAAsB,GACtBsF,gBAAiB9F,aAAS,EAATA,EAAW+F,mBAEhCL,EACA,CACI/N,kBAAmB,CACf,QAAS,EAAAqO,mBACTjG,QAAQ,IAAAkG,4BAA2BL,GACnC,KAAK,IAAAM,6BAA4BN,IAErCV,qBAAsB,CAClBxP,QAAS,EAAAyQ,yBACTC,WAAY,EAAAC,6BAEhBlB,wBAAyB,CACrBzkB,UAAW,CAAC,EAAA4lB,2BACZvG,OAAQ,CAAC,EAAAwG,0BAGjBX,EAER,C,6GCpEA,eACA,WACA,WACA,WAeA,+BACIY,EACArR,EACAsR,EACArkB,GAEA,IAAM0W,EAAM0N,GAAO,IAAAE,kBAAiBD,GAAoBE,UAAUH,GAAQ,KAE1E,GAAI1N,aAAG,EAAHA,EAAK8N,KAAM,CACX,IAAMnqB,GAAU,IAAAoqB,sCACZ/N,EACA1W,OACArP,EACAoiB,GAEEqP,EAAW1L,GAAM,IAAAgO,kBAAiBhO,GAAO,GAK/C,OAHA,IAAAiO,kBAAiBjO,EAAK0L,IACtB,IAAAwC,aAAYlO,EAAI8N,KAAMnqB,EAAQwqB,cAAcC,eAAgBzqB,EAAQ0B,cAAe1B,IAE5E,IAAA2G,mBAAkB0V,EAAI8N,KAAMnqB,E,CAEnC,OAAO,IAAA0qB,kBAAiB/kB,EAEhC,C,iKC1CA,eAMa,EAAAglB,YAAqC,CAC9C,IACA,OACA,UACA,OACA,UACA,QACA,IACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,SACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,SACA,MACA,MACA,KACA,KACA,KACA,WACA,aACA,SACA,OACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,MACA,QACA,MACA,MACA,QACA,SACA,KACA,OACA,MACA,OACA,OACA,WACA,QACA,MACA,KACA,WACA,SACA,SACA,IACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,UACA,SACA,QACA,OACA,SACA,SACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,QACA,KACA,QACA,OACA,KACA,KACA,IACA,KACA,MACA,MACA,OAMS,EAAAC,eAAwC,CACjD,SACA,QACA,OACA,WACA,QACA,QACA,WACA,SACA,OACA,OACA,WACA,SACA,QACA,SACA,OACA,SACA,QACA,WACA,QACA,QACA,SAGJ,IAAMC,EAAiB,iDACjBC,EAAkB,OAElBC,EAAoB,CACtB,SACA,QACA,MACA,UACA,OACA,QACA,QACA,OACA,UACA,cACA,SACA,WACA,UACA,MACA,UACA,WACA,WACA,OACA,UACA,SACA,SACA,OACA,OACA,WACA,QACA,OACA,QACA,OACA,OACA,MACA,MACA,YACA,QACA,MACA,WACA,OACA,UACA,UACA,cACA,WACA,MACA,WACA,WACA,OACA,UACA,QACA,WACA,QACA,OACA,QACA,OACA,aACA,MACA,UACA,SACA,QACA,OACA,QACA,WACA,SACA,QACA,YACA,OACA,SACA,SACA,QACA,QACA,OACA,WAGEC,EAAgD,CAClD,mBAAoB,cACpB,sBAAuB,eACvB,sBAAuB,OACvB,sBAAuB,MACvB,sBAAuB,IACvB,sBAAuB,UACvB,qBAAsB,OACtB,sBAAuB,OACvB,qBAAsB,IACtB,oBAAqB,eACrB,oBAAqB,OACrB,oBAAqB,MACrB,qBAAsB,eACtB,qBAAsB,OACtB,qBAAsB,MACtB,mBAAoB,eACpB,mBAAoB,OACpB,mBAAoB,MACpB,gBAAiB,cACjB,gBAAiB,OACjB,gBAAiB,MACjBC,SAAU,UACV,4BAA6B,MAC7B,YAAa,aACb,cAAe,MACf,eAAgB,MAChBC,QAAS,MACT,cAAe,MACf,eAAgB,MAChB,gBAAiB,MACjB,iBAAkB,MAClB/gB,OAAQ,MACR,aAAc,MACd,cAAe,MACf,eAAgB,MAChB,gBAAiB,MACjB,iBAAkB,WAClBghB,MAAO,OACP,aAAc,SACd,yBAA0B,SAC1B,oBAAqB,SACrB,cAAe,MACf,iBAAkB,SAClBC,QAAS,IACT,aAAc,QACd,cAAe,MACf,iBAAkB,OAClBC,OAAQ,IACR,eAAgB,MAChB,cAAe,UAmDnB,SAAgBC,EACZjP,EACAzE,EACA2T,EACA1C,EACAC,GAIA,IAFA,IAAMxC,EAAUjK,EAAIrD,cAAcpB,GAEzB/sB,EAAI,EAAGA,EAAI0gC,EAAW7iC,OAAQmC,IAAK,CACxC,IAAM2gC,EAAYD,EAAW1gC,GACvB,EAAO2gC,EAAUj7B,KAAKO,cAAc8S,OACpC/a,EAAQ2iC,EAAU3iC,MAElB4iC,EAAY3C,aAAmB,EAAnBA,EAAsB,GAClCjpB,EACM,SAAR,EACM6rB,EAAc9T,EAAK/uB,EAAOggC,GACN,mBAAb4C,EACPA,EAAU5iC,EAAO+uB,GACI,kBAAd6T,EACPA,EACI5iC,EACA,KACJkiC,EAAkB34B,QAAQ,IAAS,GAA8B,GAAzB,EAAKA,QAAQ,SACrDvJ,EACA,KAGNgX,SAECA,EAAS3S,MAAM,+BAEhBo5B,EAAQgC,aAAa,EAAMzoB,E,CAInC,OAAOymB,CACX,CAEA,SAASoF,EACLxpB,EACArZ,EACAggC,GAEA,IAAM8C,EAAQ9iC,EAAMuE,MAAM,KACpBwB,EAAmB,GAiCzB,OA/BA+8B,EAAMz9B,SAAQ,SAAA09B,GACV,IAAMC,EAAaD,EAAKx5B,QAAQ,KAC1B7B,EAAOq7B,EAAKl9B,MAAM,EAAGm9B,GAAYjoB,OACnC/a,EAAgB+iC,EAAKl9B,MAAMm9B,EAAa,GAAGjoB,OAE/C,GAAIrT,GAAQ1H,EAAO,EAkC3B,SAAuBA,GACnB,OAAyC,GAAlCA,EAAMuJ,QAAQ04B,EACzB,EAnCgBgB,CAAcjjC,KACdA,EA2BhB,SAA4BA,GACxB,IAAMqE,EAAQ29B,EAAekB,KAAKljC,GAClC,OAAOqE,aAAK,EAALA,EAAQ,KAAM,EACzB,CA9BwB8+B,CAAmBnjC,IAG/B,IAAM4iC,EAAY5C,aAAe,EAAfA,EAAkBt4B,GAC9B07B,EACkB,mBAAbR,EACDA,EAAU5iC,EAAOqZ,IACH,IAAdupB,EACA,KACA5iC,EAGJojC,GACgB,WAAlBA,GACkB,WAAlBA,GACAA,EAAe75B,QAAQ,cAAgB,IACtC7B,EAAK27B,WAAW,MACjBlB,EAAkBz6B,IAAS07B,GAE3Br9B,EAAO4D,KAAQjC,EAAI,IAAI07B,E,CAGnC,IAEOr9B,EAAOrB,KAAK,IACvB,CA7HA,2BAAgB4+B,EACZ7F,EACA8F,EACAC,EACAxD,EACAC,GAEA,IAAMlR,EAAM0O,EAAQpkB,QAAQpR,cACtBw7B,EACFD,EAAej6B,QAAQwlB,IAAQ,EACzB,KACA0T,EACIhF,EAAQiG,cACRH,EAAYh6B,QAAQwlB,IAAQ,EAAIA,EAAM,OACtC0O,EAAQiF,WACR1C,EACAC,GAGd,GAAIwD,EACA,IAAK,IAAI3kB,EAAQ2e,EAAQ1e,WAAYD,EAAOA,EAAQA,EAAME,YAAa,CACnE,IAAM2kB,GAAW,IAAAplB,cAAaO,EAAO,gBAC/BwkB,EACIxkB,EACAykB,EACAC,EACAxD,EACAC,IAEJ,IAAA1hB,cAAaO,EAAO,aACpBA,EAAM8kB,YACN,KAEFD,IACAF,SAAAA,EAAkBpT,YAAYsT,G,CAK1C,OAAOF,CACX,EAKA,0B,oHCnTA,wCAA6CxV,EAAiB9P,GAC1D,GAAI8P,EAAOyK,iBAAiBC,UAA+B,UAAnBxa,aAAS,EAATA,EAAWb,MAAiB,CAChE,IAAMsb,EAAQ,IAAIiL,MAClBjL,EAAMkL,eAAe3lB,EAAUkD,OAC/BuX,EAAMmL,YAAY5lB,EAAUkD,OAC5B4M,EAAO8K,gBAAgB,CACnBH,MAAK,EACLtb,KAAM,QACN0b,YAAY,G,CAGxB,C,mHCjBA,eAWA,qCAA0CgL,GACtC,IAAIC,EACA3J,EACAve,GAEJ,IAAAD,mBAAkBkoB,GAAY,SAAC/a,EAAGib,EAAW5wB,EAAOgC,GAChD,GAAI2uB,EAIA,OAHIC,GAAanoB,IAAgBue,aAAU,EAAVA,EAAYhlB,SAAS6uB,SAASF,KAC3D3J,EAAWhlB,SAAShM,OAAOgxB,EAAWhlB,SAAS/L,QAAQ06B,GAAkB,IAEtE,EAGX,IAAMtpB,EAASrF,aAAQ,EAARA,EAAUmH,MAAK,SAAAhG,GAAW,MAAuB,mBAAvBA,EAAQhB,WAAR,IAOzC,OANKwuB,GAAmBtpB,IACpBoB,EAAemoB,EACf5J,EAAiC,cAApBhnB,aAAK,EAALA,EAAOK,WAA2BL,OAAQ7F,EACvDw2B,EAAkBtpB,IAGf,CACX,GACJ,C,2HCjCA,eACA,WACA,WACA,WACA,WAOA,WAca,EAAAoa,cAA+B,SAACC,EAAc3tB,IACnD,IAAAkX,cAAalX,EAAM,kBAAmB,IAAA+8B,iBAAgB/8B,EAAM,WAC5D,IAAA8G,MAAK9G,EAAKq8B,cAAer8B,EAAM,QAE/B,IAAAkX,cAAalX,EAAM,kBAAoBA,EAAKg9B,mBAC5Ch9B,EAAKi9B,gBAAgB,oBAEzB,IAAAC,wBAAuBvP,EAAc3tB,EACzC,EASA,6BACI4mB,EACAuW,EACAC,GAEA,IAAMtmB,EAAY8P,EAAOyE,kBAEzB,IADA,IAAAgS,8BAA6BzW,EAAQ9P,GACjCA,IAAgC,SAAlBA,EAAUb,OAAoBa,EAAUya,MAAMC,WAAY,CACxE,IAAMmL,EAAa/V,EAAO0W,oBAAoB,iBAC9C,IAAAC,sBAAqBZ,GAEE,UAAnB7lB,EAAUb,MACV,IAAAxB,mBAAkBkoB,GAAY,SAAC/a,EAAGlN,GAC9B,SAAIA,aAAY,EAAZA,EAActB,UACd,IAAAoqB,iBAAgB9oB,EAAatB,QAEtB,EAGf,IAC0B,UAAnB0D,EAAUb,OACjB,IAAAwnB,2BAA0Bd,GAE9B,IAAM7sB,GAAU,IAAA2mB,2BAEhB3mB,EAAQ4d,cAAgB,EAAAA,cACxB,IAAMvB,EAAMvF,EAAOiC,cACb6U,EAAUvR,EAAIrD,cAAc,OAE5B6U,GAAmB,IAAAhH,mBAAkBxK,EAAKuR,EAASf,EAAY7sB,GAC/D8tB,EAAWD,EAkBzB,SAA6BxR,EAAerV,G,MACpC8mB,EAAyB,KAE7B,GAAuB,UAAnB9mB,EAAUb,KAAkB,CAC5B,IAAM7C,EAAQ0D,EAAU1D,MAClByqB,EACwC,IAAvB,QAAnB,EAAAzqB,EAAM0qB,qBAAa,eAAEC,mBAAyB3qB,EAAM0qB,cAAgB1qB,GAExEwqB,EAAWzR,EAAI6R,eACNC,WAAWJ,E,KACM,UAAnB/mB,EAAUb,MACjB2nB,EAAWzR,EAAI6R,eACNC,WAAWnnB,EAAUkD,OAE9B4jB,EAAW9mB,EAAUya,MAGzB,OAAOqM,CACX,CApC4CM,CAAoB/R,EAAKwR,GAAoB,KACjF,GAAIC,EAQA,MAAO,CACHO,YARmBvX,EAAOkF,aAAa,gBAAiB,CACxDsS,WAAYV,EACZnM,MAAOqM,EACPS,SAAUjB,EACVD,MAAK,IACP,WAIEmB,aAAa,IAAAC,oBAAmB5B,G,CAI5C,OAAO,IACX,C,wHCxFA,WAMA,2BAAgCvpB,GAC5B,IAAMqQ,GAAM,IAAAC,kBAAiBtQ,GAC7BA,EAAMhG,KAAOgG,EAAMhG,KACdjQ,KAAI,SAAAkQ,GACD,OAAO,EAAP,8BACOA,GAAG,CACNC,MAAOD,EAAIC,MAAMY,QAAO,SAAAX,GAAQ,OAAAA,EAAK0B,UAAL,KAExC,IACCf,QAAO,SAAAb,GAAO,OAAAA,EAAIC,MAAM9U,OAAS,CAAnB,WAEZ4a,EAAMhH,OAAO+N,MAEpB/G,EAAMkS,OAAS7B,EACTrQ,EAAMkS,OAAOpX,QAAO,SAAC0T,EAAGzQ,GAAU,OAAAA,IAASsS,aAAG,EAAHA,EAAKb,cAAezR,IAASsS,aAAG,EAAHA,EAAKI,WAA3C,IAClC,EACV,C,6HCVA,SAAgB0Z,EACZjlC,GAEAkmC,EAA6BlmC,GAAO,GAgGxC,SAAgBA,GACZ,IAAI2T,EAAQ3T,EAAMmU,OAAO,GACzB,GAA2B,GAAvBnU,EAAMmU,OAAOjU,OAAa,CAC1B,KAA0B,cAAnByT,EAAMK,WAIT,GAHAhU,EAAMmU,OAASR,EAAMQ,OACrBR,EAAQ3T,EAAMmU,OAAO,GAEjBnU,EAAMmU,OAAOjU,OAAS,EACtB,OAIe,aAAnByT,EAAMK,YACNL,EAAMwyB,YAAa,EACnBxyB,EAAMG,OAAS,CAAC,EAM5B,SAAwC9M,GAEpC,QAAc8G,IADA9G,EAAOkS,cAEjB,IAAK,IAAIL,EAAQ,EAAGA,EAAQ7R,EAAO2O,SAASzV,OAAQ2Y,IAAS,CACzD,IAAM/B,EAAU9P,EAAO2O,SAASkD,GAChC/B,EAAQhD,QAAS,EAAH,8BACP9M,EAAOkS,eACPpC,EAAQhD,O,CAI3B,CAhBYsyB,CAA+BzyB,G,CAG3C,CAhHI0yB,CAAOrmC,EACX,CAEA,SAASkmC,EACLlmC,EACAsmC,GAEA,I,UAASztB,EAAQ7Y,EAAMmU,OAAOjU,OAAS,EAAG2Y,GAAS,EAAGA,IAAS,CAC3D,IAAMlF,EAAQ3T,EAAMmU,OAAO0E,GAE3B,OAAQlF,EAAMK,WACV,IAAK,aACDkyB,EAA6BvyB,EAAO2yB,IAER,WAAxB3yB,EAAMO,eACuB,GAAvBP,EAAMQ,OAAOjU,QAAgByT,EAAMgD,WACZ,GAAvBhD,EAAMQ,OAAOjU,SAEnBF,EAAMmU,OAAOxK,OAAOkP,EAAO,GAE/B,MACJ,IAAK,UACL,IAAK,SACIlF,EAAMgD,WAGP2vB,GAA0B,EAF1BtmC,EAAMmU,OAAOxK,OAAOkP,EAAO,GAI/B,MACJ,IAAK,YACD,IAAMoe,EAAqC,G,IAC3C,IAAsB,+BAAAtjB,EAAMgC,WAAQ,8BAAE,CAAjC,IAAMmB,EAAO,QACa,WAAvBA,EAAQhB,aACRmvB,EAAqBnuB,IACjBA,EAAQ3C,OAAOjU,OAAS,GAAK4W,EAAQH,aACrCsgB,EAAYjtB,KAAK8M,IAEdA,EAAQH,YAAqC,mBAAvBG,EAAQhB,aACrCmhB,EAAYjtB,KAAK8M,E,mGAGzBnD,EAAMgC,SAAWshB,EACY,GAAzBtjB,EAAMgC,SAASzV,OACfF,EAAMmU,OAAOxK,OAAOkP,EAAO,GAE3BytB,GAA0B,EAE9B,MACJ,IAAK,QAED,IADA,IAAMC,EAAuC,GACpClkC,EAAI,EAAGA,EAAIsR,EAAMmB,KAAK5U,OAAQmC,IAAK,CAExC,IADA,IAAM0S,EAAMpB,EAAMmB,KAAKzS,GACdiqB,EAAI,EAAGA,EAAIvX,EAAIC,MAAM9U,OAAQosB,KAC5BrX,EAAOF,EAAIC,MAAMsX,IACb3V,WAGN2vB,GAA0B,EAF1BJ,EAA6BjxB,EAAMqxB,GAO3C,IADA,IAAME,EAAoC,GACjCjlC,EAAI,EAAGA,EAAIwT,EAAIC,MAAM9U,OAAQqB,MAC5B0T,EAAOF,EAAIC,MAAMzT,IACdoV,YAAc1B,EAAKd,OAAOjU,OAAS,IACxCsmC,EAASx8B,KAAKiL,GAGtBF,EAAIC,MAAQwxB,EAERzxB,EAAIC,MAAM9U,OAAS,GACnBqmC,EAAav8B,KAAK+K,E,CAI1B,GACKuxB,GACsB,GAAvBC,EAAarmC,QACmB,GAAhCqmC,EAAa,GAAGvxB,MAAM9U,QACrBqmC,EAAa,GAAGvxB,MAAM,GAAG2B,WAII,GAAvB4vB,EAAarmC,OACpBF,EAAMmU,OAAOxK,OAAOkP,EAAO,GAE3BlF,EAAMmB,KAAOyxB,MANf,CACE,IAAMtxB,EAAOsxB,EAAa,GAAGvxB,MAAM,IACnC,EAAAhV,EAAMmU,QAAOxK,OAAM,6BAACkP,EAAO,IAAC,YAAK5D,EAAKd,SAAM,G,GAS5D,OAAOmyB,CACX,CAjGA,wB,uGCZA,eA+GA,SAASG,EAAenY,EAAiB7P,GAGrC,OAFA6P,EAAOkF,aAAa,wBAAyB,CAAEsS,WAAYrnB,IAAQ,GAE5DA,EAAKioB,SAChB,CA/DA,yBACIpY,EACAqY,EACAC,GAEA,IAAI5mC,EAEJ,YALA,IAAA2mC,IAAAA,EAAA,QAKQA,GACJ,IAAK,gBACD,OAAOrY,EAAOkE,eAAeqU,iBACjC,IAAK,YAGD,OAFA7mC,EAAQsuB,EAAO0W,oBAAoB,UAE5B,IAAAiB,oBACHjmC,OACA8N,EACA84B,GAGR,IAAK,WACD,IAAMd,EAAaxX,EAAOkE,eAAesU,gBAgBzC,OAdIxY,EAAOgE,eACP,IAAAyU,gBACIjB,GACA,EACA,cACAxX,EAAOmE,kBACP,CACIuU,aAAc1Y,EAAO2Y,6BACjB,gCAMTR,EAAenY,EAAQwX,GAGlC,QACI9lC,EAAQsuB,EAAO0W,oBAAoB,SAEnC,IAAMnR,EAAMvF,EAAOiC,cACb2W,EAAMrT,EAAIrD,cAAc,OAY9B,OAVA,IAAA6N,mBACIxK,EACAqT,EACAlnC,GACA,IAAAm+B,8BACIrwB,EACA84B,IAIDH,EAAenY,EAAQ4Y,GAE1C,C,yGC7GA,IAGMC,EAAW,SAEXC,EAAwB,KAoB9B,SAASC,EAAmB9F,EAAc+F,QAAA,IAAAA,IAAAA,EAAA,GAMtC,IALA,IAAMC,EAAgBhG,EAAKj5B,cACvBk/B,EAAaD,EAAc39B,QAAQu9B,EAAUG,GAC7CxhB,EAAe0hB,EAAaL,EAC5BM,EAAWlG,EAAK98B,UAAUqhB,EAAcA,EAAe,IAEnDshB,EAAsBrjB,KAAK0jB,IAAaD,GAAc,GAE1D1hB,GADA0hB,EAAaD,EAAc39B,QAAQu9B,EAAUK,EAAa,IAC9BL,EAC5BM,EAAWlG,EAAK98B,UAAUqhB,EAAcA,EAAe,GAI3D,MAAO,CAAE0hB,WAAU,EAAEE,cADCH,EAAc39B,QAjChB,WAiCyC09B,GAEjE,CAEA,SAASK,EACLpG,EACAvmB,EACA4sB,EACAC,GAGA,IADA,IAAI3W,EAAKqQ,EAAK33B,QAAQoR,EAAQ6sB,GACvB3W,GAAM,GAAKA,EAAK0W,GAEnB1W,GADAqQ,EAAOA,EAAK98B,UAAU,EAAGysB,GAAMqQ,EAAK98B,UAAUysB,EAAKlW,EAAO9a,SAChD0J,QAAQoR,EAAQkW,EAAK,GAEnC,OAAOqQ,CACX,CA1CA,6BAAkCA,GAG9B,I,MAFI,EAAgC8F,EAAmB9F,GAAjDiG,EAAU,aAAEE,EAAa,gBAExBF,GAAc,GACjBjG,EAAOoG,EAAuBpG,EAfb,UAeqCmG,EAAeF,GACrEjG,EAAOoG,EAAuBpG,EAfZ,UAeqCmG,EAAeF,GAGnEA,GAAF,EAAgCH,EAFjC9F,EAAOoG,EAAuBpG,EAff,SAeqCmG,EAAeF,GAETE,EAAgB,IAA7D,WAAEA,EAAa,gBAGhC,OAAOnG,CACX,C,6GCvBA,eAUA,+BACIf,EACAsH,EACAC,EACAtpB,IAEKqpB,EAAc5xB,MAAsB,gBAAd6xB,GAA+BtpB,IACtDqpB,EAAc5xB,KAAOuI,EAAKunB,aAAe8B,EAAc5xB,MAGnD,IAAA8xB,EAAuBF,EAAa,aAAtB5xB,EAAS4xB,EAAa,KACtCG,EAAWzH,EAAS0H,yBAE1B,GACkB,WAAbH,GAA0BC,GACb,eAAbD,IAA+B7xB,GAAQ8xB,EAC1C,CAEE,IAAMG,EAAM3H,EAAShQ,cAAc,OACnC2X,EAAIrmB,MAAMsmB,SAAW,OACrBD,EAAI9U,IAAM2U,EACVC,EAASvX,YAAYyX,E,KACD,eAAbJ,GAA8BtpB,GACrC,IAAA4pB,gBAAeJ,EAAUxpB,GAClBvI,GACPA,EAAKtR,MAAM,MAAMc,SAAQ,SAAC4iC,EAAMzvB,EAAO0vB,IACnCD,EAAOA,EACFlyB,QAAQ,MAlCP,KAmCDA,QAAQ,MAnCP,KAoCDA,QAAQ,MAAO,IACfA,QAAQ,QAAS,OAEbouB,SAAS,QACd8D,EAiChB,SAAgClM,EAAeoM,QAAA,IAAAA,IAAAA,EAAA,GAG3C,IAFA,IACIC,EADAH,EAAOlM,GAE8B,IAAjCqM,EAASH,EAAK1+B,QAAQ,QAAc,CACxC,IAAM8+B,EAAaJ,EAAKpiC,MAAM,EAAGuiC,GAC3BE,EAAYL,EAAKpiC,MAAMuiC,EAAS,GAChCG,EA7EK,GA6EqBF,EAAWxoC,OAASsoC,GA7EzC,EA+EXF,EAAOI,EADQ1iC,MAAM4iC,GAAUC,KA/ErB,KA+EqC9jC,KAAK,IACvB4jC,C,CAEjC,OAAOL,CACX,CA5CuBQ,CAAuBR,IAGlC,IAAM/L,EAAWiE,EAASuI,eAAeT,GAMrB,GAAhBC,EAAMroC,QAAwB,GAAT2Y,GAErBovB,EAASvX,YAAY6L,GACrB0L,EAASvX,YAAY8P,EAAShQ,cAAc,QACrC3X,EAAQ,GAAKA,EAAQ0vB,EAAMroC,OAAS,EAE3C+nC,EAASvX,aACL,IAAAliB,MAAKgyB,EAAkB,IAAR8H,EAAa9H,EAAShQ,cAAc,MAAQ+L,EAAU,QAIzE0L,EAASvX,YAAY6L,EAE7B,IAGJ,OAAO0L,CACX,C,sHCzDA,0CACI3Z,EACAwZ,EACAG,EACAe,EACAjB,G,QAEMkB,EAAkD,CACpD9I,sBAAuB,GACvBC,yBAA0B,GAC1BF,wBAAyB,CAAC,EAC1BD,qBAAsB,CAAC,EACvBvN,kBAAmB,CAAC,EACpB2N,gBAAiB,CAAC,EAClBC,oBAAqB,CAAC,EACtBC,4BAA6BjS,EAAOyK,iBAAiBmQ,mBAAmBC,WACnE5I,2BAGHuE,EAA0B,CAC5BsE,UAAW,cACXtB,cAAa,EACbG,SAAQ,EACRoB,WAAwC,QAA5B,EAAAL,EAAkBK,kBAAU,QAAI,GAC5CC,UAAsC,QAA3B,EAAAN,EAAkBM,iBAAS,QAAI,GAC1CC,eAAgBP,EAAkB7zB,SAClC4yB,UAAWA,EACXkB,iBAAgB,EAChBO,wBAAyBR,EAAkBQ,uBAG/C,OAAOlb,EAAOkF,aAAa,cAAesR,GAAO,EACrD,C,+IC5CA,WACA,WAuBM2E,EAAiC,CACnCC,qBAAsB,SAAChiC,EAAMiW,GAAS,MAAS,SAARA,OAAkB7P,EAAYpG,CAA/B,GAM1C,SAAgBiiC,EAAmB3pC,GAC/B,OAAO,IAAA4pC,YAAW5pC,EAAOypC,EAC7B,CAyFA,SAASI,EAAiBxF,GAYtB,OATgC,GAA5BA,EAAWlwB,OAAOjU,QACiB,UAAnCmkC,EAAWlwB,OAAO,GAAGH,WACc,cAAnCqwB,EAAWlwB,OAAO,GAAGH,WACoB,IAAzCqwB,EAAWlwB,OAAO,GAAGwB,SAASzV,QACmB,OAAjDmkC,EAAWlwB,OAAO,GAAGwB,SAAS,GAAGG,aAEjCuuB,EAAWlwB,OAAOxK,OAAO,GAGO,IAA7B06B,EAAWlwB,OAAOjU,QAAmD,UAAnCmkC,EAAWlwB,OAAO,GAAGH,SAClE,CAxGA,uBAOA,6BACIsa,EACAwb,EACAC,GAGI,IAAA9B,EAMA6B,EAAW,SALXb,EAKAa,EAAW,iBAJXE,EAIAF,EAAW,gBAHX/B,EAGA+B,EAAW,UAFXhC,EAEAgC,EAAW,cADXN,EACAM,EAAW,sBAEfxb,EAAOE,oBACH,SAACxuB,EAAOwX,GACJ,IAAKuyB,GAAgBjC,EAAcmC,iBAAkB,CACjD,IAAMC,EAAcP,EAAmB7B,EAAcmC,kBACrDjqC,EAAMmU,OAAS+1B,EAAY/1B,M,CAG/B,IAAMg2B,GAAoB,IAAAvI,sCACtBtT,EAAOiC,mBACPziB,EACAwgB,EAAOyK,iBAAiBmQ,mBAAmBC,WAC3CF,EACA3a,EAAOkE,gBAGX2X,EAAkBjxB,cAkC9B,SACIlZ,EACA+nC,GAEA,IAAMqC,GAAkB,IAAA9V,qBAAoBt0B,GAAO,GAA8B,GAEjF,GAAIoqC,EAAiB,CACjB,IAAMhkC,GAAS,IAAAikC,sBAAqBD,GAQpC,MAPiB,UAAbrC,IAIA3hC,EAAOgX,UA3FA,cA8FJhX,C,CAGX,MAAO,CAAC,CACZ,CArD8CkkC,CAAyBtqC,EAAO+nC,GAElE,IAAM1D,GAAa,IAAAlmB,mBAAkB8pB,EAAUkC,GACzCI,EAAgC,CAClCvW,YAA0B,eAAb+T,EAA6B,2BAA6B,OACvEyC,WAAYX,EAAiBxF,GAC7BoG,+BAAgCjB,GAG9B3uB,EAAcmvB,EACdA,EAAgBhqC,EAAOqkC,IACvB,IAAAtQ,YAAW/zB,EAAOqkC,EAAY7sB,EAAS+yB,GAY7C,OAVI1vB,IACArD,EAAQ8X,kBAAmB,EAAH,6CACjB,EAAAob,oBACA1qC,EAAM8T,QACQ,UAAbi0B,GAA0ByB,EAExB3uB,EAAYG,OAAOlH,OAmD7C,SAA8BuwB,GAC1B,GAAgC,GAA5BA,EAAWlwB,OAAOjU,OAAa,CACzB,IAACy6B,GAAD,YAAe0J,EAAWlwB,OAAM,GAArB,GAEjB,GAA4B,aAAxBwmB,EAAW3mB,UAA0B,CACrC,IAAM8C,EAAU6jB,EAAWhlB,SAASglB,EAAWhlB,SAASzV,OAAS,GAEjE,OAAO,EAAP,eACO4W,EAAQhD,O,EAKvB,MAAO,CAAC,CACZ,CAlE0B62B,CAAqBtG,MAK5B,CACX,GACA,CACIvT,aAAc,EAAAC,aAAa6Z,MAC3B3Z,cAAe,WAAM,OAAA6W,CAAA,EACrB+C,qBAAqB,EACrBnc,QAAS,SAGrB,C,+FCnGA,eACA,WACA,WACA,WACA,WACA,WAyEA,SAASoc,EACLvJ,EACAwJ,GAEA,OAAOxJ,EAAOwJ,EAAWrJ,UAAUH,GAAQ,IAC/C,CAhEA,iBACIjT,EACAwZ,EACAkD,G,WAAA,IAAAA,IAAAA,EAAA,UAEA1c,EAAOC,QACP,IAAIwb,GAAe,EAEdjC,EAAcmC,mBACfF,GAAe,EAEfzb,EAAOE,oBAAmB,SAAAxuB,GAGtB,OAFA8nC,EAAcmC,kBAAmB,IAAAN,oBAAmB3pC,IAE7C,CACX,KAIJ,IAAM+qC,EAAazc,EAAO2c,iBACrBF,EAAWG,YAAcpD,EAAcqD,UACxCrD,EAAcqD,SAAU,IAAAC,mBAAkBtD,EAAcqD,UAE5D,IAAMtX,EAAMiX,EAAkBhD,EAAcqD,QAASJ,GAC/ChD,EAC0B,mBAArBiD,EACDA,EAAkBnX,EAAKiU,GACvBkD,EAGJhC,GAAoB,IAAAqC,kBAAiBxX,EAAKiU,GAG1CwD,GAAiB,IAAAC,qBACnBjd,EAAOiC,cACPuX,EACAC,EAIC,QAHA,EAAAD,EAAcqD,SAAWrD,EAAcvG,KAClC1N,EACAiX,EAAkBhD,EAAcvG,KAAMwJ,UAC3C,eAAEpJ,MAIDmI,GAAc,IAAA0B,gCAChBld,EACAwZ,EACAwD,EACAtC,EACAjB,IAIJ,IAAAjG,kBAAiBgI,EAAY7B,SAAUe,EAAkByC,iBAGzD,IAAAC,mBAAkBpd,EAAQwb,EAAaC,EAC3C,C,yHC5EA,WACA,WASM4B,EAAiB,6BACjBC,EAAe,2BAgFrB,SAASC,EAAmBhY,GAGxB,OAFiB,IAAAoL,SAAQpL,EAAI8N,KAAKzC,iBAAiB,MAEnCroB,MAAK,SAAAi1B,GAAM,WAAAltB,cAAaktB,EAAI,kBAAmB,IAAAC,gBAAeD,EAAnD,GAC/B,CApEA,4BACIjY,EACAiU,GAEA,IAAI1hC,EAA4B,CAC5B+O,SAAU,CAAC,EACXs2B,eAAgB,IAcpB,OAXI5X,IACAztB,GAAS,EAAH,8BA+Bd,SACI0hC,G,MAKMqD,EAA+B,QAArB,EAAArD,EAAcqD,eAAO,QAAI,GACnC7D,EAAa6D,EAAQvhC,QAAQ+hC,GAC7BK,EAAWb,EAAQc,YAAYL,GACjCvC,EAAa,GACbC,EAAY,GAUhB,OARIhC,GAAc,GAAK0E,GAAY1E,EAAaqE,IAC5CtC,EAAa8B,EAAQ1mC,UAAU,EAAG6iC,GAClCgC,EAAY6B,EAAQ1mC,UAAUunC,EAAWJ,IACzC9D,EAAcvG,KAAO4J,EAAQ1mC,UAAU6iC,EAAaqE,GAAuBK,IAE3ElE,EAAcvG,KAAO4J,EAGlB,CAAE9B,WAAU,EAAEC,UAAS,EAClC,CAnDe4C,CAAoBpE,IAAc,CACrC2D,gBAAgB,IAAA5J,kBAAiBhO,GACjC1e,UAAU,IAAAg3B,0BAAyBtY,GACnC2V,sBAAuBqC,EAAmBhY,KAG9CiU,EAAcsE,wBAMtB,SAA8BvY,GAG1B,I,MAFMwY,EAAyB,GAEtBltB,EAAQ0U,EAAI8N,KAAKviB,WAAYD,EAAOA,EAAQA,EAAME,aACnD,IAAAT,cAAaO,EAAO,cACiB,QAAf,EAAAA,EAAMsd,iBAAS,eAAErmB,QAAQ,iBAAkB,IAAIgF,SAGjEixB,EAAariC,KAAK,KAEf,IAAA4U,cAAaO,EAAO,iBAC3BktB,EAAariC,KAAKmV,EAAMzF,SAIhC,OAAO2yB,CACX,CAtBgDC,CAAqBzY,IAG1DztB,CACX,C,4FC1CA,gBAAqBkoB,GACjBA,EAAOC,QAEP,IACMge,EADUje,EAAO2D,sBACEua,KAAK,GAE1BD,GACAje,EAAOme,gBAAgBF,EAE/B,C,4FCTA,gBAAqBje,GACjBA,EAAOC,QAEP,IAAMyD,EAAU1D,EAAO2D,sBAEnBD,EAAQG,eACR7D,EAAOsC,eAGX,IAAM2b,EAAWva,EAAQwa,MAAM,GAE3BD,GACAje,EAAOme,gBAAgBF,EAE/B,C,yGCpBA,eAOA,WACA,WAWa,EAAAG,gBAAmC,SAACC,EAAMC,EAAoBC,GAC/D,IAAAC,EAA+CH,EAAI,UAAxCI,EAAoCJ,EAAI,aAA1BK,EAAsBL,EAAI,YAAbM,EAASN,EAAI,KACvDJ,EAA4B,KAEhC,IAAKO,EAAUI,mBAAoB,CAE/B,IAAMC,EAAyD,CAC3D/D,UAAW,wBACXgE,gBAAiB,CAAC,GAEtBT,EAAKU,IAAI7Z,aAAamZ,EAAMQ,GAA4B,GAGxD,IAAM3uB,GAAY,IAAA8uB,yBAAwBX,GACpCpL,EAAOwL,EAAarG,UAG1B,GAAIsG,IAAgBD,EAAc,CAC9B,IAAMQ,GAAgB,IAAAC,0BAAyBR,EAAaL,EAAK5R,WACjE,IAAK8R,GAAgBU,EAAe,CAChC,IAAM5P,GAAe,IAAApM,mBAAkBgc,GACvC,GAAI5P,EAAanM,YAAcmM,EAAazM,GAAI,CAC5C,IAAM,EAA8B,CAChCkY,UAAW,kBACX5e,UAAW,sBACXsQ,OAAQ,CACJnd,KAAMggB,EAAanM,WACnBN,GAAIyM,EAAazM,GACjB9S,QAASmvB,EACTpc,WAAYwM,EAAaxM,YAE7BM,WAAO3jB,GAGX6+B,EAAKU,IAAI7Z,aAAamZ,EAAM,GAAO,GAG/B,EAAMlb,QACNob,EAAe,CACX,CACIlvB,KAAMggB,EAAanM,WACnBN,GAAIyM,EAAazM,GACjBO,MAAO,EAAMA,Q,GAQrC8a,EAAW,CACPhL,KAAI,EACJ6L,gBAAiBD,EAA2BC,gBAC5CP,aAAY,EACZva,aAAcwa,EAAUxa,WACxB9T,UAAS,GAGTwuB,IAAgBD,IAChBR,EAASkB,iBAAkB,IAAAC,SAAQV,EAAa,EAAGD,IAGvDE,EAAKU,iBAAiBC,YAAYrB,IAAYK,GAC9CK,EAAKU,iBAAiBxb,eAAgB,C,CAG1C,OAAOoa,CACX,C,iHCtFA,eAEA,WAwEA,SAASsB,EAAmBnvB,EAAiBD,GAIzC,IAHA,IAAI/W,EAAoBgX,EACpBovB,GAAe,EAEZpmC,GAAQ+W,EAAKE,SAASjX,KACrB,IAAAkX,cAAalX,EAAM,kBAAmB,IAAA+8B,iBAAgB/8B,EAAM,WAC5DomC,EAAevT,EAAe7yB,IAASomC,GAG3CpmC,EAAOA,EAAKmX,WAGhB,OAAOivB,CACX,CAEA,SAASvT,EAAezf,GAIpB,I,MAHIgzB,GAAe,EACfC,EAAwC,KAEnC5uB,EAAQrE,EAAMsE,WAAYD,EAAOA,EAAQA,EAAME,YAGpD,QAFY,IAAAT,cAAaO,EAAO,gBAAkBA,EAAMzF,QAAU,MAG9D,IAAK,KACIq0B,IACDA,EAAQjzB,EAAMipB,cAAcvT,cAAc,SAC1C1V,EAAMkzB,aAAaD,EAAO5uB,IAG9B4uB,EAAMrd,YAAYvR,GAClBA,EAAQ4uB,EACRD,GAAe,EAEf,MACJ,IAAK,QACGC,IACA,IAAA1F,gBAAe0F,EAAO5uB,GAAO,GACb,QAAhB,EAAAA,EAAMN,kBAAU,SAAE+gB,YAAYzgB,GAC9BA,EAAQ4uB,EACRD,GAAe,GAEfC,EAAQ5uB,EAEZ,MACJ,QACI4uB,EAAQ,KAKpB,IAAME,EAAYnzB,EAAMokB,iBAAiB,YACnCgP,EAAQpzB,EAAMqzB,cAAc,SAUlC,OARID,GACAD,EAAUvoC,SAAQ,SAAA0oC,GACTF,EAAMvvB,SAASyvB,IAChBF,EAAMxd,YAAY0d,EAE1B,IAGGN,CACX,CAjIA,mCAAwCnB,GAC5B,IAAAI,EAAsBJ,EAAI,aAAZU,EAAQV,EAAI,IAC5BnuB,EAAY6uB,EAAIta,gBAAgB4Z,GAGtC,GAAuB,UAAnBnuB,aAAS,EAATA,EAAWb,MAAiB,CACtB,MAA2Da,EAAUya,MAAnEoV,EAAc,iBAAEC,EAAW,cAAEC,EAAY,eAAEC,EAAS,YACxDV,EAAeD,EAAmBQ,EAAgBtB,GAMtD,GAJIwB,GAAgBF,IAChBP,EAAeD,EAAmBU,EAAcxB,IAAiBe,GAGjEA,EAAc,CACd,IAAMxI,EAAWyH,EAAahJ,cAAc2B,cAE5CJ,EAASmJ,SAASJ,EAAgBC,GAClChJ,EAASoJ,OAAOH,EAAcC,GAC9BnB,EAAIjU,gBACAuT,EACA,CACIhvB,KAAM,QACNsb,MAAOqM,EACPjM,aAAc7a,EAAU6a,aAE5B,E,EAKZ,OAAQ7a,aAAS,EAATA,EAAWb,MACf,IAAK,QACD,MAAO,CACHA,KAAM,QACNgxB,QAASnwB,EAAUkD,MAAMwP,IAGjC,IAAK,QACD,MAAO,CACHvT,KAAM,QACNixB,QAASpwB,EAAU1D,MAAMoW,GACzB5G,YAAa9L,EAAU8L,YACvBiB,WAAY/M,EAAU+M,WACtBF,SAAU7M,EAAU6M,SACpBC,QAAS9M,EAAU8M,SAG3B,IAAK,QACD,IAAM2N,EAAQza,EAAUya,MAExB,MAAO,CACHtb,KAAM,QACNmZ,OAAO,IAAA4W,SAAQzU,EAAMoV,eAAgBpV,EAAMqV,YAAavB,GACxDhW,KAAK,IAAA2W,SAAQzU,EAAMsV,aAActV,EAAMuV,UAAWzB,GAClD1T,aAAc7a,EAAU6a,YAGhC,QACI,MAAO,CACH1b,KAAM,QACNmZ,MAAO,GACPC,IAAK,GACLsC,YAAY,GAG5B,C,iGCxEA,eAgBA,mBAAwB3xB,EAAmBkiB,EAAgBilB,G,QAEnD7nC,EADEZ,EAAmB,GAGzB,IAAKsB,IAASmnC,EAASlwB,SAASjX,GAC5B,OAAOtB,EAGX,IAAI,IAAAwY,cAAalX,EAAM,aAAc,CAGjC,IAFAV,EAASU,EAAKmX,WAEPnX,EAAKonC,kBAAmB,IAAAlwB,cAAalX,EAAKonC,gBAAiB,cAC9DllB,IAAwC,QAA9B,EAAAliB,EAAKonC,gBAAgBrS,iBAAS,eAAEv8B,SAAU,EACpDwH,EAAOA,EAAKonC,gBAGhB1oC,EAAOc,QAAQ0iB,E,MAEf5iB,EAASU,EACTA,EAAOA,EAAKqnC,WAAWnlB,GAG3B,EAAG,CACCA,EAAS,EAGT,IAFA,IAAIolB,GAAiB,EAEZ1tC,GAAiB0F,aAAM,EAANA,EAAQoY,aAAc,KAAM9d,GAAKA,GAAKoG,EAAMpG,EAAIA,EAAE+d,YAAa,CACrF,IAAI,IAAAT,cAAatd,EAAG,aAAc,CAC9B,GAA4B,KAAb,QAAX,EAAAA,EAAEm7B,iBAAS,eAAEv8B,SAAgB8uC,EAC7B,SAGJA,GAAiB,C,MAEjBA,GAAiB,EAGrBplB,G,CAGJxjB,EAAOc,QAAQ0iB,GACfliB,EAAOV,EACPA,GAASA,aAAM,EAANA,EAAQ6X,aAAc,I,OAC1BnX,GAAQA,GAAQmnC,GAEzB,OAAOzoC,CACX,C,kGC9DA,eAWa,EAAA6oC,SAAqB,SAACtC,EAAMj0B,GAC7B,IAAAxC,EAAyEwC,EAAY,KAA/EqO,EAAmErO,EAAY,eAA/D,EAAmDA,EAAY,cAA/DsO,OAAa,IAAG,KAAE,EAAE,EAA+BtO,EAAY,aAA3Cw2B,OAAY,IAAG,cAAW,EACpEC,EAA0BxC,EAAKG,UAAS,sBAE5CsC,EAsBR,SAAsBl5B,EAA0B8Q,GAC5C,OAAYlZ,MAARoI,IAIJA,EAAOA,EAAKE,QAAQ,cAAc,SAACkT,EAAG+lB,GAClC,IAAMx2B,EAAQ5T,SAASoqC,GACjBj5B,EAAU4Q,EAAcnO,GAC9B,OAAOzC,QAAAA,EAAW,EACtB,KAPWF,CAUf,CAlCyBo5B,CADJvoB,IAAkBooB,aAAqB,EAArBA,EAAwBpoB,KACb7Q,EAAM8Q,GAMpD,GAJK2lB,EAAKG,UAAUyC,oBAChB5C,EAAKG,UAAUyC,mBAAoB,IAAAC,uBAAsB7C,EAAKI,aAAahJ,gBAG3EqL,GAAkBzC,EAAKG,UAAUyC,kBAAmB,CAC5C,IAAAA,EAAsB5C,EAAKG,UAAS,kBACxCyC,EAAkBE,UAAYP,IAC9BK,EAAkBE,SAAWP,GAG7BE,GAAkBG,EAAkBvJ,cACpCoJ,GAzBO,KA4BPG,IACAA,EAAkBvJ,YAAcoJ,E,CAG5C,C,wGCnCA,eAWa,EAAAM,eAAiC,SAAC/C,EAAMgD,GACjD,IAAMC,GAAY,IAAAlrB,eAAcirB,GAAY,CAAC,GAAG9qC,KAAI,SAAAnG,GAC1C,MAA+CixC,EAASjxC,GAAtDmxC,EAAe,kBAAEC,EAAc,iBAAEC,EAAO,UAC1CC,EAAYtxC,EACZuxC,EAAU,SAACnL,GACTgL,GACAA,EAAehL,GAGI,MAAnB+K,GACAlD,EAAKU,IAAI7Z,aACLmZ,EACa,CACTvD,UAAWyG,EACX9J,SAAUjB,IAEd,EAGZ,EAIA,OAFA6H,EAAKK,YAAYkD,iBAAiBF,EAAWC,EAAS,CAAEF,QAAO,IAExD,WACHpD,EAAKK,YAAYmD,oBAAoBH,EAAWC,EAAS,CACrDF,QAAO,GAEf,CACJ,IAEA,OAAO,WAAM,OAAAH,EAAUlqC,SAAQ,SAAAkqC,GAAa,OAAAA,GAAA,GAA/B,CACjB,C,oGC1CA,eACA,WACA,WACA,WACA,WACA,QACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WAOa,EAAAQ,WAAyB,CAClCC,mBAAoB,EAAAA,mBACpBC,oBAAqB,EAAAA,oBACrB9hB,mBAAoB,EAAAA,mBACpB+hB,gBAAiB,EAAAA,gBACjBC,eAAgB,EAAAA,eAEhBzd,gBAAiB,EAAAA,gBACjBqG,gBAAiB,EAAAA,gBACjB7K,MAAO,EAAAA,MAEPme,gBAAiB,EAAAA,gBACjB+D,oBAAqB,EAAAA,oBAErBf,eAAgB,EAAAA,eAChBlc,aAAc,EAAAA,aAEdkd,iBAAkB,EAAAA,iBAClBC,mBAAoB,EAAAA,mBACpBC,eAAgB,EAAAA,eAEhB3B,SAAU,EAAAA,S,4GC3Cd,eACA,WAea,EAAAoB,mBAAyC,SAAC1D,EAAMkE,EAAQtS,G,MAElC,QAA/B,EAAAoO,EAAKmE,MAAMC,4BAAoB,SAAEC,iBACjC,IAAMpe,GACDie,GAAWA,EAAOje,sBAA0D,IAAhCie,EAAOjS,qBAExD,IAAKL,GAAqB3L,EAAiB,CACvC,IAAMqe,EAActE,EAAKmE,MAAMG,YAE/B,GAAIA,EAEA,OAAOtE,EAAKG,UAAUI,oBAChB,IAAAtD,YAAWqH,EAAa,CAAEvH,sBAAsB,IAChDuH,C,CAId,IAAMzyB,EACmB,QAArB+f,OACMzwB,EACAywB,GAAqBoO,EAAKU,IAAIta,gBAAgB4Z,SAAS7+B,EAC3DojC,GAAaL,IAAWtS,EACxBtgB,EAAgB0uB,EAAKU,IAAIiD,oBAAoB3D,EAAMuE,GAEzDjzB,EAAc2gB,qBAAuBiS,aAAM,EAANA,EAAQjS,qBAE7C,IAAMuS,EAAWxE,EAAKyE,YAAYlI,mBAC5BiB,EAAoB0G,GACpB,IAAA3yB,yBAAwBD,EAAekzB,EAASE,QAASF,EAAShI,WAAY0H,IAC9E,IAAAS,mCAAkCH,EAASI,WAAYtzB,GAEzDO,IACA2rB,EAAkB3rB,UAAYA,GAGlC,IAAMxe,GAAQ,IAAAme,mBAAkBwuB,EAAKK,YAAa7C,GAMlD,OAJI+G,IACA,IAAAM,aAAY7E,EAAKmE,MAAO9wC,EAAOwe,GAG5Bxe,CACX,C,4HC1DA,WAOa,EAAAswC,oBAA2C,SAAC3D,EAAMuE,G,UACnDpE,EAAuEH,EAAI,UAAhE74B,EAA4D64B,EAAI,OAAxD1R,EAAoD0R,EAAI,iBAAtCK,EAAkCL,EAAI,YAAzBmE,EAAqBnE,EAAI,MAAlB5R,EAAc4R,EAAI,UAEnFuE,EAAYA,IAAcvE,EAAKG,UAAUI,mBAEzC,IAAM11B,GAAO,eACT8a,WAAYwa,EAAUxa,WACtB0I,cAAelnB,EAAOknB,cACtBlJ,cAAmC,QAApB,EAAAhe,EAAOge,qBAAa,aAAIhkB,EACvCmtB,iBAAkBA,EAClBC,uBAAuB,EACvBC,mBAAmB,EACnBsW,sBAA+C,QAAzB,EAAA9E,EAAKpR,4BAAoB,eAAEiJ,SAAS,cAC1DpJ,WAAY8V,EAAYJ,EAAM1V,gBAAattB,EAC3CutB,UAAWN,EAAUO,qBACrBC,qBAA+C,QAAzB,EAAAoR,EAAKpR,4BAAoB,QAAI,GACnDmW,aAAc/E,EAAKmE,MAAMY,aACzB7Q,gBAAiB9F,EAAU+F,mBACxB,IAAAF,gCAA+BoM,EAAYjJ,gBAOlD,OAJI4I,EAAK5R,UAAU4W,kBACfn6B,EAAQkkB,WAAY,GAGjBlkB,CACX,C,wHCjCA,eAQA,0CACIgpB,G,MAEMoR,EAAwC,QAApB,EAAApR,EAAShF,mBAAW,eAAEC,iBAAiB+E,EAASqR,iBAC1E,MAAO,CAAEC,cAAc,IAAA16B,oBAAmBw6B,aAAiB,EAAjBA,EAAmB3pB,WATrC,GAU5B,C,0FCNa,EAAAsG,MAAe,SAAAoe,G,MACxB,IAAKA,EAAKG,UAAUI,mBAAoB,CAC5B,IAAAG,EAA8BV,EAAI,IAA7B5R,EAAyB4R,EAAI,UAAlBnuB,EAAcmuB,EAAI,UAErC5R,EAAUgX,YAA2C,UAAV,QAAnB,EAAAvzB,EAAUA,iBAAS,eAAEb,OAC9C0vB,EAAIjU,gBAAgBuT,EAAMnuB,EAAUA,WAAW,GAI9Cuc,EAAUgX,YACXpF,EAAKK,YAAYze,O,CAG7B,C,2HCpBA,WACA,WAoIA,SAASyjB,EACLrF,EACAn1B,EACAgH,G,QAEMsT,EAC0B,YAA5Bta,EAAQ8X,iBACuB,QAAzB,EAAAqd,EAAK74B,OAAOge,qBAAa,eAAEhe,OAC3B0D,EAAQ8X,iBACZ2iB,EACmC,YAArCz6B,EAAQ06B,0BACuB,QAAzB,EAAAvF,EAAK74B,OAAOge,qBAAa,eAAEqgB,gBAC3B36B,EAAQ06B,2BAGbpgB,GAAiBmgB,IACC,UAAnBzzB,aAAS,EAATA,EAAWb,OACXa,EAAUya,MAAMC,YAEhByT,EAAK74B,OAAOge,cAAgB,CACxBhe,OAAQge,GAAgB,EAAD,eAAMA,QAAkBhkB,EAC/CqkC,gBAAiBF,GAAyB,EAAD,eAAMA,QAA2BnkC,EAC1E+M,YAAa,CACTnT,KAAM8W,EAAUya,MAAMoV,eACtBzkB,OAAQpL,EAAUya,MAAMqV,cAIxC,CAEA,SAAS8D,EACL56B,EACAuuB,GAEA,OAAOvuB,EAAQ66B,+BACTvkC,EACA0J,EAAQ6Z,YACHxsB,KACG,SAACi2B,GAA0B,OACvBA,OAAM,EACNtQ,UAAW,YACXub,SAAQ,EAHe,IAM9Bn7B,OACG4M,EAAQ86B,gBAAgBztC,KAAI,SAAA0tC,GAAS,OACjCzX,OAAQyX,EAAMzX,OACdtQ,UAAW+nB,EAAM/nB,UACjBub,SAAQ,EAHyB,IAMvD,CAnKa,EAAAvX,mBAAyC,SAClDme,EACA6F,EACAtiB,EACA6N,G,QAEM,EACF7N,GAAW,CAAC,EADRkF,EAAa,gBAAE2Q,EAAQ,WAAExH,EAAiB,oBAAuBkU,EAAM,sBAEzEzyC,EAAQ2sC,EAAKU,IAAIgD,mBAAmB1D,EAAM5O,EAAmBQ,GAC7D/mB,EAAqC,CACvC6Z,YAAa,GACbihB,gBAAiB,GACjBvM,SAAQ,EACR2M,UAAW,GACXC,iBAAkBhG,EAAKmE,MAAMY,cAG3BK,EAAWpF,EAAK5R,UAAUgX,WAE1BnpB,EAAU4pB,EAAUxyC,EAAOwX,GACzB6Y,EAAwE7Y,EAAO,iBAA7Do7B,EAAsDp7B,EAAO,gBAA5Cq1B,EAAqCr1B,EAAO,aAA9Bo1B,EAAuBp1B,EAAO,mBAEvF,GAAIoR,EAAS,CACT,IAAMiqB,EAAWlG,EAAKM,KAAK4F,SACrBC,IACAziB,GAAwC,aAApBA,GAAqCwiB,GACzDE,IACoB,IAArB1iB,GAAiD,kBAApBA,KAA0CwiB,EACxEr0B,OAAS,EAETs0B,IACAnG,EAAKM,KAAK4F,UAAW,EAErBlG,EAAKU,IAAIX,gBAAgBC,IAAQC,EAAoBC,IAGzD,KAiER,SAAsBF,EAAkBn1B,GACpC,GAAIA,EAAQk7B,UAAUxyC,OAAS,EAAG,CAC9B,IAAM2hB,EAAQ8qB,EAAK5R,UAAU+F,iBAEvB,EAAWlgC,KAAKC,IAAIghB,EADF,IAExBrK,EAAQk7B,UAAUhtC,SAAQ,SAAAgc,GACtBA,EAAM5N,OAAOs0B,SAAc,EAAQ,IACvC,G,CAER,CAzEY4K,CAAarG,EAAMn1B,GAEnBgH,EAMK,QALD,EAAAmuB,EAAKU,IAAIkD,gBACL5D,EACA3sC,EACA+xC,OAAWjkC,EAAY,CAAEmlC,iBAAiB,GAC1C7d,UACH,aAAItnB,EAETkkC,EAAoBrF,EAAMn1B,EAASgH,IAE/Bi0B,GAA8B,UAAnBj0B,aAAS,EAATA,EAAWb,OAAsC,UAAnBa,aAAS,EAATA,EAAWb,QACpD,IAAAktB,qBAAoB8B,EAAMnuB,GAG9B,IAAM00B,EAAiC,CACnC9J,UAAW,iBACX+J,aAAcP,OAAkB9kC,EAAY9N,EAC5Cwe,UAAWo0B,OAAkB9kC,EAAY0Q,EACzC40B,QAAQljB,aAAO,EAAPA,EAASY,eAAgB,EAAAC,aAAasiB,OAC9CC,KAA4B,QAAtB,EAAApjB,aAAO,EAAPA,EAASe,qBAAa,oBAAtBf,GACNqjB,cAAerjB,aAAO,EAAPA,EAASxB,QACxB8kB,gBAAiBpB,EAAmB56B,EAASuuB,GAC7C0N,WACMV,GAAwBD,KAC1B5iB,aAAO,EAAPA,EAASY,eAAgB,EAAAC,aAAa2iB,UAG9C/G,EAAKU,IAAI7Z,aAAamZ,EAAMuG,GAAW,GAEnCtG,GAAyC,UAAnBpuB,aAAS,EAATA,EAAWb,QACjCgvB,EAAKM,KAAK0G,wBAA0B,CAChCjsC,KAAM8W,EAAUya,MAAMoV,eACtBzkB,OAAQpL,EAAUya,MAAMqV,cAI5BwE,GACAnG,EAAKU,IAAIX,gBAAgBC,GAAM,EAA8BE,GAG7DkG,IACApG,EAAKM,KAAKU,iBAAiBxb,eAAgB,E,SAG1C0gB,IACDlG,EAAKM,KAAK4F,UAAW,E,OAIzBD,IACAjG,EAAKmE,MAAMG,iBAAcnjC,EACzB6+B,EAAKmE,MAAM8C,qBAAkB9lC,GAGjCkkC,EAAoBrF,EAAMn1B,EAASm1B,EAAKU,IAAIta,gBAAgB4Z,IAG5Dn1B,EAAQkB,cACRi0B,EAAKU,IAAI4B,SAAStC,EAAMn1B,EAAQkB,aAExC,C,6GCxHA,eAMA,+BAAoCi0B,EAAkBnuB,GAClD,IAAMq1B,GAAO,IAAAC,uBACTnH,EAAKI,aAAahJ,cACA,SAAlBvlB,EAAUb,KACJ,CACIjW,KAAM8W,EAAUkD,MAChBkI,OAAQ,GAEZpL,EAAU6a,WACV,CACI3xB,KAAM8W,EAAUya,MAAMoV,eACtBzkB,OAAQpL,EAAUya,MAAMqV,aAE5B,CACI5mC,KAAM8W,EAAUya,MAAMsV,aACtB3kB,OAAQpL,EAAUya,MAAMuV,YAGhCuF,EAAcpH,EAAKU,IAAIsD,mBAAmBhE,GAC1CqH,EAAkBrH,EAAKsH,SAASD,gBAElCH,GAAQE,IACR,IAAAG,oBAAmBF,EAAiBD,EAAapH,EAAK5R,UAAW8Y,EAEzE,C,uGCzBa,EAAA9gB,gBAAmC,SAAA4Z,GAC5C,GAAIA,EAAKG,UAAUI,mBACf,OAAO,KAEP,IAAM1uB,EAAYmuB,EAAKnuB,UAAUA,UAEjC,OAAOA,GAAgC,SAAlBA,EAAUb,MAAoBgvB,EAAK5R,UAAUgX,WAM1E,SAAyBpF,G,MACfnuB,EAAsD,QAA1C,EAAAmuB,EAAKK,YAAYjJ,cAAcvI,mBAAW,eAAE2Y,eACxDlb,EAAQza,GAAaA,EAAU41B,WAAa,EAAI51B,EAAU61B,WAAW,GAAK,KAEhF,OAAO71B,GAAaya,GAAS0T,EAAKK,YAAYruB,SAASsa,EAAMqb,yBACvD,CACI32B,KAAM,QACNsb,MAAK,EACLI,WACI7a,EAAU+1B,WAAatb,EAAMsV,cAC7B/vB,EAAUg2B,aAAevb,EAAMuV,WAEvC,IACV,CAjBciG,CAAgB9H,GADhBnuB,CAGd,C,2HCfA,WAQa,EAAAmyB,mBAAyC,SAAAhE,GAClD,IAAMqH,EAAkBrH,EAAKsH,SAASD,gBAEtC,OAgCJ,SAA4Bh2B,EAAyB02B,QAAA,IAAAA,IAAAA,EAAA,IACjD,IAAMC,EAAQ32B,EACTnZ,KAAI,SAAAi5B,GAAW,WAAA8W,eAAc9W,EAAQ+W,wBAAtB,IACfjqC,OAAO8pC,GACP9+B,QAAO,SAACi+B,GAAoC,QAAEA,CAAF,IAE3CztC,EAAe,CACjB0uC,IAAKl0C,KAAKC,IAAG,MAARD,MAAI,mCAAQ+zC,EAAM9vC,KAAI,SAAArE,GAAK,OAAAA,EAAEs0C,GAAF,MAAM,IACtCC,OAAQn0C,KAAKD,IAAG,MAARC,MAAI,mCAAQ+zC,EAAM9vC,KAAI,SAAArE,GAAK,OAAAA,EAAEu0C,MAAF,MAAS,IAC5ChiC,KAAMnS,KAAKC,IAAG,MAARD,MAAI,mCAAQ+zC,EAAM9vC,KAAI,SAAArE,GAAK,OAAAA,EAAEuS,IAAF,MAAO,IACxCI,MAAOvS,KAAKD,IAAG,MAARC,MAAI,mCAAQ+zC,EAAM9vC,KAAI,SAAArE,GAAK,OAAAA,EAAE2S,KAAF,MAAQ,KAG9C,OAAO/M,EAAO0uC,IAAM1uC,EAAO2uC,QAAU3uC,EAAO2M,KAAO3M,EAAO+M,MAAQ/M,EAAS,IAC/E,CA9CW4uC,CACHhB,GAAmBrH,EAAKI,aAClB,CAACiH,GACD,CAACA,EAAiBrH,EAAKI,cAErC,C,6GChBA,eAQA,+BAAoCrlC,EAAYX,GAK5C,IAFA,IAAI6iB,EAAiB,EAEZvnB,EAAI,EAAGA,EAAI0E,EAAK7G,SACrB0pB,EAAS7iB,EAAK1E,GAGVA,EAAI0E,EAAK7G,OAAS,GAClBwH,IACA,IAAAkX,cAAalX,EAAM,iBACnBA,EAAKqnC,WAAW7uC,OAAS0pB,GAPAvnB,IASzBqF,EAAOA,EAAKqnC,WAAWnlB,GAM/B,MAAO,CAAEliB,KAAI,EAAEkiB,OAAM,EACzB,C,+GC7BA,eAMA,iCAAsC+iB,EAAkBJ,GACpD,IAAMja,EAAaqa,EAAKG,UAAUxa,WAElCqa,EAAK1R,iBAAiBga,iBAAiB3iB,KAEjCia,EAASja,cAAgBA,IAC3B,IAAAyU,gBACI4F,EAAKI,cACL,EACAza,EAAa,cAAgB,cAC7Bqa,EAAK1R,iBACL,CACI+L,aAAc2F,EAAKpR,qBAAqB3xB,QAAQ,+BAAiC,GAIjG,C,6GCtBA,eA0EA,SAASsrC,EACLC,EACAztC,GAEA,IAAItB,EAA6B,KAYjC,OAVI,IAAAwY,cAAalX,EAAM,mBACf,IAAA0tC,iBAAgB1tC,GAGhBtB,EAASivC,EAAyBF,GAFnB,IAAA5jB,mBAAkB7pB,GAEmBwpB,KAC7C,IAAAokB,wBAAuB5tC,KAC9BtB,EAOZ,SACI03B,EACAqX,GAEA,I,MAASztC,EAAOo2B,EAAQ1e,WAAY1X,EAAMA,EAAOA,EAAK2X,YAClD,IAAI,IAAA+1B,iBAAgB1tC,KAAS,IAAAkX,cAAalX,EAAM,gBAAiB,CAC7D,IACM,EAAuD,QAA9C,EAAA2tC,EAAyBF,GADzB,IAAA5jB,mBAAkB7pB,GACyBwpB,WAAG,eAAEsU,cAE/D,OAAO,IAAA5mB,cAAa,EAAQ,kBAAmB,IAAA02B,wBAAuB,GAChE,EACA,I,CAId,OAAO,IACX,CAvBqBC,CAA0B7tC,EAAMytC,KAI1C/uC,CACX,CAoBA,SAASivC,EACLF,EACAK,GAEA,IAAMjD,EAAQiD,EAAWL,EAAUK,QAAY1nC,EAE/C,OAAOykC,aAAK,EAALA,EAAOkD,YAAalD,EAAMzU,QAAU,IAC/C,CAxGA,+BAAoC6O,EAAkBJ,GASlD,I,QAPIQ,EAEAJ,EAAI,aADMwI,EACVxI,EAAI,iBACJ+I,EAAuB3I,EAAa3tB,WAI/Bu2B,EAFIhJ,EAAK5B,WAAWrJ,UAAU6K,EAAShL,MAAMI,KAE1BviB,WAAYu2B,GAAe,CACnD,IAAMC,EAAOD,EAAYt2B,YACnBw2B,EAAwBX,EAAoBC,EAAWQ,GAE7D,GAAIE,EAAuB,CAEvB,IAAI,IAAAP,wBAAuBO,GACvB,IAAK,IAAInuC,EAAOmuC,EAAsBz2B,WAAY1X,EAAMA,EAAOA,EAAK2X,aAC5D,IAAAT,cAAalX,EAAM,kBAAmB,IAAAouC,mBAAkBpuC,KACnC,QAArB,EAAAilC,EAAKmE,MAAM1V,kBAAU,SAAE2a,WAAWruC,IAK9CguC,GAAU,IAAAM,oBAAmBjJ,EAAc8I,EAAuBH,E,MAElE3I,EAAaiB,aAAa2H,EAAaD,IAEnC,IAAA92B,cAAa+2B,EAAa,kBACJ,IAAAM,sBAAqBN,GAE7BjwC,SAAQ,SAAAo4B,G,MACZ1f,EAAU82B,EAAoBC,EAAWrX,GAE/C,GAAI1f,EAAS,CACT,GAAIA,GAAWs3B,EAAS,CAIpB,IAAMQ,EAAa93B,EAAQ6lB,YAE3B8I,EAAaiB,aAAakI,EAAYR,GACtCA,EAAUQ,C,CAGI,QAAlB,EAAApY,EAAQjf,kBAAU,SAAEs3B,aAAa/3B,EAAS0f,E,CAElD,IAGR6X,EAAcC,C,CAGlB,KAAOF,GACGE,EAAOF,EAAQr2B,YAEH,QAAlB,EAAAq2B,EAAQ72B,kBAAU,SAAE+gB,YAAY8V,GAChCA,EAAUE,CAElB,C,oHCvEA,eAKA,sCAA2CjJ,EAAkBJ,GACzD,GAAIA,EAASkB,iBAAmBlB,EAASkB,gBAAgBvtC,OAAS,EAAG,CACjE,IAAMk2C,GAAsB,IAAAC,qBAAoB1J,EAAKI,aAAcR,EAASkB,iBACvE/lC,KACD0uC,IAAwBzJ,EAAKK,aAC7BL,EAAKU,IAAImD,eAAe7D,EAAMyJ,E,CAG1C,C,kHCdA,eACA,WAMA,oCAAyCzJ,EAAkBJ,GACvD,IAAM+J,EAAoB/J,EAAS/tB,UAC3BuuB,EAAiBJ,EAAI,aACzB4J,EAAoC,KAExC,IAEI,GAAID,EACA,OAAQA,EAAkB34B,MACtB,IAAK,QACD,IAAM64B,GAAW,IAAAH,qBAAoBtJ,EAAcuJ,EAAkBxf,OAC/D2f,GAAS,IAAAJ,qBAAoBtJ,EAAcuJ,EAAkBvf,KAC7DkC,EAAQ8T,EAAahJ,cAAc2B,cAEzCzM,EAAMwV,SAAS+H,EAAS9uC,KAAM8uC,EAAS5sB,QACvCqP,EAAMyV,OAAO+H,EAAO/uC,KAAM+uC,EAAO7sB,QAEjC2sB,EAAe,CACX54B,KAAM,QACNsb,MAAK,EACLI,WAAYid,EAAkBjd,YAElC,MACJ,IAAK,QACD,IAAMve,EAAQiyB,EAAaoB,eACvB,IAAAuI,mBAAkBJ,EAAkB1H,UAGpC9zB,IACAy7B,EAAe,CACX54B,KAAM,QACN7C,MAAOA,EACPwP,YAAagsB,EAAkBhsB,YAC/Be,SAAUirB,EAAkBjrB,SAC5BE,WAAY+qB,EAAkB/qB,WAC9BD,QAASgrB,EAAkBhrB,UAGnC,MACJ,IAAK,QACD,IAAM5J,EAAQqrB,EAAaoB,eACvB,IAAAuI,mBAAkBJ,EAAkB3H,UAGpCjtB,IACA60B,EAAe,CACX54B,KAAM,QACN+D,MAAOA,IAOvB60B,GACA5J,EAAKU,IAAIjU,gBAAgBuT,EAAM4J,E,CAErC,SAAM,CACZ,C,6GCjEA,eACA,WACA,WACA,WACA,WASa,EAAA9F,oBAA2C,SAAC9D,EAAMJ,GAC3DI,EAAKU,IAAI7Z,aACLmZ,EACA,CACIvD,UAAW,mBACXuN,WAAYpK,EAAShL,OAEzB,GAGJ,IACIoL,EAAKM,KAAK2J,aAAc,EAKxBjK,EAAKU,IAAImD,eAAe7D,EAAM,OAE9B,IAAAkK,qBAAoBlK,EAAMJ,IAC1B,IAAAuK,4BAA2BnK,EAAMJ,IACjC,IAAAwK,0BAAyBpK,EAAMJ,IAC/B,IAAAyK,uBAAsBrK,EAAMJ,GAE5B,IAAM,EAA6B,CAC/BnD,UAAW,iBACXgE,gBAAiBb,EAASa,gBAC1BP,aAAcN,EAASM,aACvBuG,OAAQ,EAAAriB,aAAakmB,YAGzBtK,EAAKU,IAAI7Z,aAAamZ,EAAM,GAAO,E,SAEnCA,EAAKM,KAAK2J,aAAc,C,CAEhC,C,wHC/CA,WACA,WAiBa,EAAArG,gBAAmC,SAC5C5D,EACA3sC,EACA6wC,EACAzb,EACA8hB,G,QAEMj5B,EAAgB0uB,EAAKU,IAAIiD,oBAAoB3D,GAAM,GACnDzO,EAAoB2S,GACpB,IAAA1S,yBACIlgB,EACA0uB,EAAKyE,YAAY+F,mBAAmB9F,QACpC1E,EAAKyE,YAAY+F,mBAAmBhO,WACpC0H,IAEJ,IAAAuG,mCACIzK,EAAKyE,YAAY+F,mBAAmB5F,WACpCtzB,GAGVigB,EAAkB9I,cAAgBA,EAEjB,QAAjB,EAAAuX,EAAK0K,oBAAY,cAAjB1K,EAAoB3sC,GAEpB,IAAMwe,GAAY,IAAA6f,mBACdsO,EAAKK,YAAYjJ,cACjB4I,EAAKK,YACLhtC,EACAk+B,GA+BJ,OA5BKyO,EAAKG,UAAUI,qBAEe,QAA/B,EAAAP,EAAKmE,MAAMC,4BAAoB,SAAEC,gBAAe,IAEhD,IAAAQ,aAAY7E,EAAKmE,MAAO9wC,EAAOwe,KAE1BqyB,aAAM,EAANA,EAAQoC,kBAAmBz0B,EAC5BmuB,EAAKU,IAAIjU,gBAAgBuT,EAAMnuB,GAE/BmuB,EAAKnuB,UAAUA,UAAYA,GAI/B04B,EAEAvK,EAAKG,UAAUwK,iBAAmBpZ,EAAkBoZ,iBAGpD3K,EAAKU,IAAI7Z,aACLmZ,GAAI,eAEAvD,UAAW,oBACRlL,EAAkBoZ,mBAEzB,GAID94B,CACX,C,4GC9EA,eAKA,+BAAoCqV,EAAeoF,EAAcI,G,WAAA,IAAAA,IAAAA,GAAA,GAC7D,IAAM7a,EAA2B,QAAf,EAAAqV,EAAI2H,mBAAW,eAAE2Y,eAEnC,GAAI31B,EAAW,CACX,IAAM+4B,EAAe/4B,EAAU41B,WAAa,GAAK51B,EAAU61B,WAAW,GACtE,GAAIkD,IAAgB,IAAAC,eAAcD,EAActe,GAC5C,OAEJza,EAAUi5B,kBAELpe,EAGD7a,EAAUk5B,iBACNze,EAAMsV,aACNtV,EAAMuV,UACNvV,EAAMoV,eACNpV,EAAMqV,aANV9vB,EAAUm5B,SAAS1e,E,CAU/B,C,gHCjBA,oCACI2e,EACAC,GAIA,I,YAFM9iC,EAAa8iC,EAAU,IAAlBzrB,EAAQyrB,EAAU,IAGzB9iC,GAAO,GACPqX,GAAO,GACPrX,EAAM6iC,EAAY13C,QAClBksB,GAA+B,QAAxB,EAAgB,QAAhB,EAAAwrB,EAAY7iC,UAAI,eAAE7U,cAAM,QAAI,IACrC,CACE,IAAMiT,EAAwB,QAAhB,EAAAykC,EAAY7iC,UAAI,eAAGqX,EAAM,GACjC0rB,EAA4B,QAApB,EAAAF,EAAY7iC,EAAM,UAAE,eAAGqX,GAErC,GAAa,YAATjZ,GAAgC,YAATA,EACvBiZ,QACG,IAAa,WAAT0rB,GAA+B,YAATA,EAG7B,MAAO,CAAE/iC,IAAG,EAAEqX,IAAG,GAFjBrX,G,EAKR,OAAO,IACX,C,4GChBA,gCACI6iC,EACAC,GAIA,I,UAFM9iC,EAAa8iC,EAAU,IAAlBzrB,EAAQyrB,EAAU,IAGzB9iC,GAAO,GACPqX,GAAO,GACPrX,EAAM6iC,EAAY13C,QAClBksB,GAA+B,QAAxB,EAAgB,QAAhB,EAAAwrB,EAAY7iC,UAAI,eAAE7U,cAAM,QAAI,IACrC,CACE,IAAM+U,EAAuB,QAAhB,EAAA2iC,EAAY7iC,UAAI,eAAGqX,GAEhC,IAAKnX,EACD,MACG,GAAmB,iBAARA,EACd,MAAO,CAAEA,KAAI,EAAEF,IAAG,EAAEqX,IAAG,GACR,YAARnX,GAA8B,YAARA,EAC7BmX,IAEArX,G,CAGR,OAAO,IACX,C,yGC1CA,cACA,WACA,WACA,WACA,WACA,WACA,WAaMgjC,EAAwB,gBACxBC,EAAyB,6BAGzBC,EAAiC,4CACjCC,EAAqB,eAgO3B,SAASC,EAAkBtkB,EAAeiK,EAAkC3E,G,MACxE,GAAI2E,GAAWjK,EAAIlV,SAASmf,GAAU,CAClC,IAAM7E,EAAQpF,EAAI6R,cACdrM,OAAkCvrB,EAGtC,GADAmrB,EAAM0M,WAAW7H,GACb3E,EACAF,EAAME,eACH,CACH,IAAM3a,EAA2B,QAAf,EAAAqV,EAAI2H,mBAAW,eAAE2Y,eAC7B,EAAQ31B,GAAaA,EAAU41B,WAAa,GAAK51B,EAAU61B,WAAW,GACxE71B,GAAa,IACb6a,EACI7a,EAAU+1B,WAAa,EAAMhG,cAC7B/vB,EAAUg2B,aAAe,EAAMhG,U,EAI3C,IAAA4J,qBAAoBvkB,EAAKoF,EAAOI,E,CAExC,CA9Oa,EAAAD,gBAAmC,SAACuT,EAAMnuB,EAAW65B,G,UACxDC,EAAoB3L,EAAKU,IAAIta,gBAAgB4Z,GAEnD,KAAI2L,GAAqB95B,IAAa,IAAA+5B,mBAAkBD,EAAmB95B,IAA3E,CAMA,IAAMg6B,EAAsB7L,EAAKnuB,UAAUg6B,oBAErC3kB,EAAM8Y,EAAKI,aAAahJ,cACxBzR,EAAaqa,EAAKG,UAAUxa,WAClCqa,EAAKnuB,UAAUg6B,qBAAsB,EACrC7L,EAAKU,IAAIuD,eAAejE,EAAMoL,EAAuB,MACrDpL,EAAKU,IAAIuD,eAAejE,EAAMqL,EAAwB,OAEtD,IAAAS,aAAY9L,GAAM,GAElB,IACI,OAAQnuB,aAAS,EAATA,EAAWb,MACf,IAAK,QACD,IAAM+D,EAAQlD,EAAUkD,MAExBirB,EAAKnuB,UAAUA,UAAYA,EAE3B,IAAMk6B,EAAsBpmB,EACtBqa,EAAKnuB,UAAUm6B,8BACfhM,EAAKnuB,UAAUo6B,0BAErBjM,EAAKU,IAAIuD,eACLjE,EACAoL,EACA,iDACIW,GAvCe,WAuCsC,cAEzD,EAAC,IAAAhC,oBAAkB,IAAAmC,gBAAen3B,EA7CrC,YA+CDirB,EAAKU,IAAIuD,eACLjE,EACAqL,EACAC,EACA,CAACC,IAGLC,EAAkBtkB,EAAKnS,GAAO,GAC9B,MACJ,IAAK,QACO,IAAA5G,EAAsD0D,EAAS,MAAxD8L,EAA+C9L,EAAS,YAA3C6M,EAAkC7M,EAAS,SAAjC+M,EAAwB/M,EAAS,WAArB8M,EAAY9M,EAAS,QACjEo5B,GAAc,IAAAkB,iBAAgBt6B,EAAU1D,OAC1CuS,EAAY,CACZtY,IAAKnU,KAAKD,IAAI0qB,EAAUC,GACxBc,IAAKxrB,KAAKD,IAAI2pB,EAAaiB,GAC3BtW,KAAmC,MAEnC8jC,EAAW,CACXhkC,IAAKnU,KAAKC,IAAIwqB,EAAUC,GACxBc,IAAKxrB,KAAKC,IAAIypB,EAAaiB,IAM/B,GAHA8B,GAAY,IAAA2rB,sBAAqBpB,EAAavqB,IAAcA,EAC5D0rB,GAAW,IAAAE,0BAAyBrB,EAAamB,IAAaA,EAG1DpwC,MAAM0kB,EAAUtY,MAChBpM,MAAM0kB,EAAUjB,MAChBzjB,MAAMowC,EAAShkC,MACfpM,MAAMowC,EAAS3sB,KAEf,OAGJ5N,EAAY,CACRb,KAAM,QACN7C,MAAK,EACLuQ,SAAUgC,EAAUtY,IACpBuV,YAAa+C,EAAUjB,IACvBd,QAASytB,EAAShkC,IAClBwW,WAAYwtB,EAAS3sB,IACrB8sB,mBAAoB16B,EAAU06B,oBAGlC,IAAMtK,GAAU,IAAAiK,gBAAe/9B,EA1F9B,SA2FKq+B,GAAgB,IAAAzC,mBAAkB9H,GAElCwK,EACe,GAAjB/rB,EAAUtY,KACO,GAAjBsY,EAAUjB,KACV2sB,EAAShkC,KAAO6iC,EAAY13C,OAAS,GACrC64C,EAAS3sB,MAAyC,QAAjC,EAAyB,QAAzB,EAAAwrB,EAAYmB,EAAShkC,YAAI,eAAE7U,cAAM,QAAI,GAAK,EACrD,CAACi5C,EAAkBA,EAAa,MAgE1D,SACIvB,EACAuB,EACAr+B,EACAuS,EACA0rB,GAEA,IAAMrZ,EAAsB,GAIxB2Z,EAAO,EACLC,GAAU,IAAAra,SAAQnkB,EAAMi0B,YACzBn5B,QACG,SAAClO,GACG,OAAC,QAAS,QAAS,SAASkC,SACxB,IAAAgV,cAAalX,EAAM,gBAAkBA,EAAKgS,QAAU,KACnD,CAFL,IAIP7U,KAAI,SAAA6C,GACD,IAAMtB,EAAS,CACX0lC,GAAIpkC,EAAKgS,QACTod,MAAOuiB,EACPtiB,IAAKrvB,EAAKqnC,WAAW7uC,OAASm5C,GAIlC,OADAA,EAAOjzC,EAAO2wB,IACP3wB,CACX,IAiCJ,OA/BAwxC,EAAYlyC,SAAQ,SAACqP,EAAK0H,GAWtB,IAVA,IAAI88B,EAAU,EAGRC,EAAaF,EAAQ1jC,QAAO,SAAA6jC,GAAO,OAAAA,EAAI3iB,OAASra,GAAYg9B,EAAI1iB,IAAMta,CAAnC,IAA6C,GAChFi9B,EAAmBF,EAAa,IAAMA,EAAW1N,GAAK,IAAM,IAC5D6N,EACFH,GAAc/8B,EAAW,GAAK+8B,EAAW1iB,MACnCra,EAAW,EAAI+8B,EAAW1iB,MAC1Bra,EAAW,EAEZm9B,EAAY,EAAGA,EAAY7kC,EAAI7U,OAAQ05C,IAAa,CACzD,IAAM3kC,EAAOF,EAAI6kC,GAEjB,GAAmB,iBAAR3kC,IACPskC,IAGI98B,GAAY4Q,EAAUtY,KACtB0H,GAAYs8B,EAAShkC,KACrB6kC,GAAavsB,EAAUjB,KACvBwtB,GAAab,EAAS3sB,KACxB,CACE,IAAMyT,EAAW,GAAGsZ,EAAgBO,EAAgB,iBAAiBC,EAAU,KAAK1kC,EAAKyE,QAAO,cAAc6/B,EAAO,IAErH7Z,EAAU11B,KAAK61B,EAAUA,EAAW,K,EAIpD,IAEOH,CACX,CA7H0Bma,CACIjC,EACAuB,EACAr+B,EACAuS,EACA0rB,GAGdpM,EAAKnuB,UAAUA,UAAYA,EAE3B,IAAMs7B,EAAsBxnB,EACtBqa,EAAKnuB,UAAUu7B,sCACfpN,EAAKnuB,UAAUw7B,kCACrBrN,EAAKU,IAAIuD,eACLjE,EACAoL,EACA,oBAAoB+B,EAAmB,cACvCV,GAEJzM,EAAKU,IAAIuD,eACLjE,EACAqL,EACAC,EACA,CAACC,KAGL,IAAAO,aAAY9L,GAAM,GAElB,IAAMsN,GAA6B,QAAd,EAAA5sB,EAAUpY,YAAI,eAAEilC,oBAAqB7sB,EAAUpY,KAEhEglC,GACA9B,EACItkB,EACComB,QAAgCnsC,GACjC,GAIR,MACJ,IAAK,SACD,IAAAsqC,qBAAoBvkB,EAAKrV,EAAUya,MAAOza,EAAU6a,YAEpDsT,EAAKnuB,UAAUA,UAAYmuB,EAAK5R,UAAUgX,WAAa,KAAOvzB,EAC9D,MAEJ,QACImuB,EAAKnuB,UAAUA,UAAY,K,SAInCmuB,EAAKnuB,UAAUg6B,oBAAsBA,C,CAGzC,IAAKH,EAA2B,CAC5B,IAAMnF,EAAmC,CACrC9J,UAAW,mBACX+Q,aAAc37B,GAGlBmuB,EAAKU,IAAI7Z,aAAamZ,EAAMuG,GAAW,E,EAE/C,C,mGC5KA,uBAA4BvG,EAAkByN,GAC1CzN,EAAKU,IAAIuD,eAAejE,EARA,0BAQ2ByN,EAThC,2BAS4D,KACnF,C,wGCZA,eAKA,0BAA+Btc,EAAsBuc,GACjDA,EAAWvc,EAAQ5M,IAAMmpB,EAKzB,IAHA,IAAMxmB,EAAMiK,EAAQiG,cAChB1hC,EAAI,GAEAy7B,EAAQ5M,IAAM2C,EAAIqL,kBAAiB,IAAAwX,mBAAkB5Y,EAAQ5M,KAAKhxB,OAAS,GAC/E49B,EAAQ5M,GAAKmpB,EAAW,IAAMh4C,IAGlC,OAAOy7B,EAAQ5M,EACnB,C,wGChBA,eACA,WASa,EAAA0f,eAAiC,SAC1CjE,EACAjuC,EACA47C,EACAC,EACAC,QAAA,IAAAA,IAAAA,EAX6B,KAa7B,IAAIC,EAAe9N,EAAKG,UAAU4N,cAAch8C,GAEhD,IAAK+7C,GAAgBH,EAAS,CAC1B,IAAMzmB,EAAM8Y,EAAKI,aAAahJ,cAE9B0W,EAAe5mB,EAAIrD,cAAc,SACjCqD,EAAI8mB,KAAKjqB,YAAY+pB,GAErBA,EAAaniC,QAAQsiC,kBAAoBl8C,EACzCiuC,EAAKG,UAAU4N,cAAch8C,GAAO+7C,C,CAGxC,IAAMpb,EAAQob,aAAY,EAAZA,EAAcpb,MAE5B,GAAIA,EAAO,CACP,IAAK,IAAIh9B,EAAIg9B,EAAME,SAASr/B,OAAS,EAAGmC,GAAK,EAAGA,IAC5Cg9B,EAAMwb,WAAWx4C,GAGrB,GAAIi4C,EAAS,CACT,IAAMQ,GAAe,IAAApE,oBACjB,IAAAmC,gBAAelM,EAAKI,aAjCb,eAmCLrN,EAAa6a,EAEW,iBAAjBA,EACP,CAAIO,EAAY,KAAKP,GAcvC,SAAwBO,EAAsBP,EAAwBQ,GAClE,IAAM30C,EAAmB,GAErB40C,EAA0B,GAC1B30C,EAAM,EAiBV,OAfAk0C,EAAa70C,SAAQ,SAAAu1C,GACb50C,GAAO00C,IACP30C,EAAO4D,KAAKgxC,EAAcj2C,KAAK,MAC/Bi2C,EAAgB,GAChB30C,EAAM,GAGV,IAAMw5B,EAAcib,EAAY,IAAIG,EAEpC50C,GAAOw5B,EAAS3/B,OAAS,EACzB86C,EAAchxC,KAAK61B,EACvB,IAEAz5B,EAAO4D,KAAKgxC,EAAcj2C,KAAK,MAExBqB,CACX,CAnCkB80C,CACIJ,EACAP,EACAC,EAAgBF,EAAQp6C,OAAS,GANrC,CAAC46C,GASPpb,EAAUh6B,SAAQ,SAAAm6B,GACdR,EAAM8b,WAActb,EAAQ,KAAKya,EAAO,IAC5C,G,EAGZ,C,sGC3Ca,EAAA9J,eAAiC,SAAC7D,EAAMK,GAEjD,GAAKA,IAAeL,EAAKI,aAAapuB,SAASquB,GAmC3C,OAAO,KA5BP,GALKA,IACDA,EAAcL,EAAKI,cAInBC,IAAgBL,EAAKK,YAAa,CAElC,IAAMoO,EAAuD,CACzDhS,UAAW,0BACX4D,YAAaL,EAAKK,aAEtBL,EAAKU,IAAI7Z,aAAamZ,EAAMyO,GAAwB,GAGpDzO,EAAKK,YAAYqO,gBAAkB,QACnCrO,EAAYqO,gBAAkB,OAG9B1O,EAAKK,YAAcA,EAGnBL,EAAKnuB,UAAUA,UAAY,KAC3BmuB,EAAKmE,MAAMG,iBAAcnjC,EACzB6+B,EAAKmE,MAAM8C,qBAAkB9lC,EAG7B,IAAM,EAAiC,CACnCs7B,UAAW,qBACX4D,YAAW,GAEfL,EAAKU,IAAI7Z,aAAamZ,EAAM,GAAO,E,CAK/C,C,0GCnDA,eACA,WASa,EAAA+D,iBAAqC,SAAC4K,EAAYC,GAC3D,IAAM5O,EAAO2O,EAEb,GAAIC,KAAU5O,EAAKG,UAAUI,mBACzB,GAAIqO,EAAM,CACN,IAAMv7C,EAAS2sC,EAAKmE,MAAMG,YAAkD,KAApCtE,EAAKU,IAAIgD,mBAAmB1D,GAC9D1E,EAAW0E,EAAKK,YAAYjJ,cAAcmE,yBAC1CpC,EAAa6G,EAAKK,YAAY/I,WAAU,IAE9C,IAAAoE,gBAAeJ,EAAUnC,GAEzB6G,EAAKU,IAAI7Z,aACLmZ,EACA,CACIvD,UAAW,sBAEf,IAKCuD,EAAKmE,MAAMG,aAAejxC,IAC3B2sC,EAAKmE,MAAMG,YAAcjxC,IAG7B,IAAAy4C,aAAY9L,GAAM,GAElBA,EAAKG,UAAUI,mBAAqBjF,C,MAEpC0E,EAAKG,UAAUI,mBAAqB,MAEpC,IAAAuL,aAAY9L,GAAM,GAElBA,EAAKU,IAAI7Z,aACLmZ,EACA,CACIvD,UAAW,sBAEf,GAGAuD,EAAKmE,MAAMG,eAEX,IAAA90B,mBAAkBwwB,EAAKmE,MAAMG,aAAa,WAAO,IAEjDtE,EAAKU,IAAIkD,gBAAgB5D,EAAMA,EAAKmE,MAAMG,YAAa,CACnDgC,iBAAiB,IAKrC,C,oGCtDA,IAAMuI,EAA+C,CACjD,cACA,gBACA,wBACA,eAUS,EAAAhoB,aAA6B,SAACmZ,EAAM8O,EAAaC,GAEpD/O,EAAKG,UAAUI,sBACbsO,EAA0B5xC,QAAQ6xC,EAAYrS,YAAiC,KAClFsS,GAAc/O,EAAKgP,QAAQ9kC,MAAK,SAAA+kC,GAAU,OAUnD,SAA4B9W,EAAoB8W,G,MAC5C,SAAIA,EAAOC,iBAAkD,QAAjC,EAAAD,EAAOE,kCAA0B,oBAAjCF,EAAoC9W,OAC5D8W,EAAOC,cAAc/W,IACd,EAIf,CAjBmDiX,CAAmBN,EAAaG,EAAhC,KAE3CjP,EAAKgP,QAAQj2C,SAAQ,SAAAk2C,GACbA,EAAOC,eACPD,EAAOC,cAAcJ,EAE7B,GAER,C,0GCjCA,eACA,WACA,WACA,WACA,WAaA,aASI,WAAY5K,EAAuBmL,GAAnC,WARQ,KAAA1tB,OAAyB,KA2GzB,KAAA2tB,WAAa,SAACC,GAClB,GAAI,EAAK5tB,OACL,OAAQ4tB,EAASv+B,MACb,IAAK,YAEI,EAAK8T,MAAM2J,WAAW+gB,mBACnBD,EAASE,WACTF,EAASG,eAGb,EAAKC,kBAET,MAEJ,IAAK,OACD,EAAKC,kBAAkB,EAAKjuB,QAAQ,GACpC,MAEJ,IAAK,YACD,IAAMwP,EAAUoe,EAASpe,QAEpB,EAAKrM,MAAM2J,WAAWohB,mBAAmB1e,IAC1C,EAAKwe,kBAGT,MAEJ,IAAK,UACD,EAAKA,kBAIrB,EAEQ,KAAAG,wBAA0B,W,OACf,QAAX,IAAKnuB,cAAM,eAAEyjB,aACb,EAAKwK,kBAAkB,EAAKjuB,OAEpC,EAxII/kB,KAAKkoB,MAAQ,CACT2J,WAAY,IAAI,EAAAshB,eACZ7L,EAAOtV,sBACHsV,EAAOtV,qBAAqB3xB,QACxB,4CACC,GAEbmnC,sBAAsB,IAAA4L,4BAA2BX,EAAYzyC,KAAK0yC,aAGlEpL,EAAO+L,qBACPrzC,KAAKkoB,MAAMigB,cAAe,IAAAmL,sBAElC,CAsKJ,OAjKI,YAAAC,QAAA,WACI,MAAO,OACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,EACd/kB,KAAK+kB,OAAOiC,cAAc2f,iBAAiB,kBAAmB3mC,KAAKkzC,yBAEnElzC,KAAKkoB,MAAMsf,qBAAqBiM,gBACpC,EAOA,YAAAC,QAAA,WACI1zC,KAAKkoB,MAAMsf,qBAAqBmM,gBAE5B3zC,KAAK+kB,SACL/kB,KAAK+kB,OACAiC,cACA4f,oBAAoB,kBAAmB5mC,KAAKkzC,yBACjDlzC,KAAK+kB,OAAS,KAEtB,EAKA,YAAA6uB,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAQA,YAAAoqB,cAAA,SAAc/W,GACV,GAAKv7B,KAAK+kB,OAIV,OAAQwW,EAAMsE,WACV,IAAK,qBACD7/B,KAAK+yC,kBAEL/yC,KAAKkoB,MAAMsf,qBAAqBmM,gBAChC3zC,KAAKkoB,MAAMsf,sBAAuB,IAAA4L,4BAC9B7X,EAAMkI,YACNzjC,KAAK0yC,YAET1yC,KAAKkoB,MAAMsf,qBAAqBiM,iBAChC,MAEJ,IAAK,mBACDzzC,KAAKgzC,kBAAkBhzC,KAAK+kB,QAC5B,MAEJ,IAAK,iBACO,IAAA6kB,EAA4BrO,EAAK,aAAnBtmB,EAAcsmB,EAAK,UAErCqO,GACA,IAAA3B,aAAYjoC,KAAKkoB,MAAO0hB,EAAc30B,GAEtCjV,KAAK+yC,kBAKrB,EA0CQ,YAAAA,gBAAR,W,SACoB,QAAX,EAAA/yC,KAAK+kB,cAAM,eAAE8uB,oBACd7zC,KAAKkoB,MAAMwf,iBAAcnjC,EACzBvE,KAAKkoB,MAAMmiB,qBAAkB9lC,EAIN,QAAvB,EAAAvE,KAAKkoB,MAAMigB,oBAAY,SAAE2L,QAEjC,EAEQ,YAAAd,kBAAR,SAA0BjuB,EAAiBgvB,GACvC,IAAIhvB,EAAO8uB,iBAAX,CAIA,IAAMxJ,EAAkBrqC,KAAKkoB,MAAMmiB,gBACnCrqC,KAAKkoB,MAAMmiB,qBAAkB9lC,EAE7B,IAAMyvC,EAAajvB,EAAOyE,wBAAqBjlB,EACzC9N,EAAQuJ,KAAKkoB,MAAMwf,aAErBqM,GACC1J,GACA2J,IACA,IAAAhF,mBAAkBgF,EAAY3J,GAa/BrqC,KAAKkoB,MAAMmiB,gBAAkBA,EATxB5zC,GACAu9C,GACAh0C,KAAKkoB,MAAM2J,WAAWoiB,mBAAmBx9C,EAAOu9C,EAAY3J,IAI7D,IAAApC,aAAYjoC,KAAKkoB,MAAOzxB,EAAOu9C,GAF/Bh0C,KAAK+yC,iB,CAOjB,EACJ,EA7LA,GAqMA,6BACIzL,EACAmL,GAEA,OAAO,IAAIyB,EAAY5M,EAAQmL,EACnC,C,4GC3NA,eAuBA,aAKI,aAHQ,KAAA0B,OAAS,EACT,KAAAhM,aAAiE,CAAC,EAGtEiM,EAAiBC,WACrB,CA+DJ,OA7DI,YAAAC,oBAAA,SAAoB/f,EAAsB/iB,GACtC,IAAMC,GAAS,IAAA8iC,oBAAmBhgB,GAC5BigB,EAAsBhjC,EAExBC,GACA+iC,EAAoBC,QAAUhjC,EAE9BzR,KAAKmoC,aAAa12B,GAAUD,IAE5BgjC,EAAoBC,QAAUz0C,KAAK00C,aAEnC10C,KAAK20C,iBAAiBpgB,EAAS/iB,GAEvC,EAEA,YAAAmjC,iBAAA,SAAiBpgB,EAAsB/iB,GACnC,IAAMgjC,EAAsBhjC,EAEvBgjC,EAAoBC,UACrBD,EAAoBC,QAAUz0C,KAAK00C,cAGvC,IAAMjjC,EAAS+iC,EAAoBC,QAE/BhjC,KACA,IAAAmjC,oBAAmBrgB,EAAS9iB,GAE5BzR,KAAKmoC,aAAa12B,GAAUD,EAEpC,EAMA,YAAAqjC,uBAAA,SACIC,GAEA,IAAMrjC,EAAUqjC,EAAwCL,QAExD,OAAOhjC,GAASzR,KAAKmoC,aAAa12B,IAAkB,IACxD,EAEA,YAAAqiC,MAAA,WACI9zC,KAAKmoC,aAAe,CAAC,CACzB,EAGA,YAAA4M,OAAA,WACIX,EAAiBC,UAAY,EAC7Br0C,KAAKm0C,OAAS,CAClB,EAEA,YAAAa,QAAA,WACI,OAAOh1C,KAAKmoC,YAChB,EAGQ,YAAAuM,WAAR,WACI,MAAU5D,aAAYsD,EAAiBC,UAAS,IAAIr0C,KAAKm0C,QAC7D,EApEe,EAAAE,UAAY,EAqE/B,C,CAtEA,GA2EA,gCACI,OAAO,IAAID,CACf,C,6BClDA,SAASa,EAAWC,EAAOC,EAAOj5C,GAC9B,OAAOA,EAAKqU,OAAM,SAAAvY,GAAK,OAAAk9C,EAAGl9C,IAAMm9C,EAAGn9C,EAAZ,GAC3B,C,qHAxCA,6BACIo9C,EACAC,GAEA,GAAID,GAAQC,EACR,OAAO,EAGX,OAAQD,EAAKhhC,MACT,IAAK,QACD,MAAoB,SAAbihC,EAAKjhC,MAAmBihC,EAAKl9B,OAASi9B,EAAKj9B,MAEtD,IAAK,QACD,MAAoB,SAAbk9B,EAAKjhC,MAAmBkhC,EAAuBF,EAAMC,GAGhE,QACI,GAAiB,SAAbA,EAAKjhC,KAAiB,CACtB,IAAMmhC,EAASH,EAAK1lB,MAEpB,GAAqB2lB,EAgDQ9nB,MAhDD,CAChB,IAAAA,EAAe8nB,EAAI,MAAZ7nB,EAAQ6nB,EAAI,IAE3B,OACIE,EAAOzQ,gBAAkBvX,EAAMpvB,MAC/Bo3C,EAAOvQ,cAAgBxX,EAAIrvB,MAC3Bo3C,EAAOxQ,aAAexX,EAAMlN,QAC5Bk1B,EAAOtQ,WAAazX,EAAInN,M,CAG5B,OAAO4tB,EAAcsH,EAAQF,EAAK3lB,M,CAGtC,OAAO,EAGvB,EAMA,IAAM8lB,EAA+C,CACjD,QACA,cACA,aACA,WACA,WAEEC,EAA6B,CAAC,iBAAkB,eAAgB,cAAe,aAKrF,SAAgBH,EAAuB58C,EAAoBC,GACvD,OAAOs8C,EAAQv8C,EAAIC,EAAI68C,EAC3B,CAKA,SAAgBvH,EAAcyH,EAAWC,GACrC,OAAOV,EAAQS,EAAIC,EAAIF,EAC3B,CATA,2BAOA,iB,uHCzEA,WAwGA,SAASG,EAAiBz3C,G,MAChB,EAA8E,QAAnD,EAAAA,EAA4B03C,+BAAuB,QAAI,CAAC,EAAjFrkC,EAAS,YAAEpF,EAAQ,WAE3B,OACIoF,GACuB,aAAvBA,EAAU/G,WACVhO,MAAMsE,QAAQyQ,EAAUpF,WACxB3P,MAAMsE,QAAQqL,IACdA,EAASmE,OAAM,SAAAhD,GAAW,OAAAiE,EAAUpF,SAAS6uB,SAAS1tB,EAA5B,GAElC,CAaA,SAASuoC,EAAsB33C,GAC3B,OAAOA,GAAQy3C,EAAiBz3C,GAAQA,EAAK03C,wBAA0B,IAC3E,CAEA,SAASE,EAAoBxhB,GACzB,IAAMjlB,EAASilB,EAAgCshB,wBACzCtkC,EAAQjC,aAAK,EAALA,EAAOiC,MAErB,MACwB,UAApBA,aAAK,EAALA,EAAO9G,YACPhO,MAAMsE,QAAQwQ,EAAMhG,OACpBgG,EAAMhG,KAAKgF,OACP,SAAApY,GAAK,OAAAsE,MAAMsE,QAAQ5I,aAAC,EAADA,EAAGsT,QAAUtT,EAAEsT,MAAM8E,OAAM,SAAAnY,GAAK,MAAqB,cAArBA,aAAC,EAADA,EAAGuS,eAAH,GAA9C,IAGF2E,EAEA,IAEf,CAGA,SAAS0mC,EAAQ73C,UACNA,EAAK03C,uBAChB,CAMA,iBACI,WAA6BI,GAAA,KAAAA,wCAAAA,CAAoD,CA+jBrF,OA7jBI,YAAAC,UAAA,SAAUC,EAAmB3kC,EAAkCjE,GACvC4oC,EACRN,wBAA0B,CAClCrkC,UAAS,EACTpF,SAAUmB,EAElB,EAEA,YAAA6oC,YAAA,SAAYC,GAGR,IAFA,IAAIC,EAA4B,KAEvB1gC,EAAQygC,EAAiBxgC,WAAYD,EAAOA,EAAQA,EAAME,YAC/D,IAAI,IAAAT,cAAaO,EAAO,aACpB,GAAK0gC,EAEE,CACH,IAAMppC,EAAO4oC,EAAsBQ,GAE/BppC,GAAQ0oC,EAAiBhgC,KACzB1I,EAAKd,SAAWc,EAAKd,SAAS/K,OAC1BuU,EAAMigC,wBAAwBzpC,UAElCwJ,EAAMigC,wBAAwBzpC,SAAW,G,MAR7CkqC,EAAe1gC,OAWZ,IAAAP,cAAaO,EAAO,iBAC3B0gC,EAAe,KAEft2C,KAAKo2C,YAAYxgC,IAEjB0gC,EAAe,IAG3B,EAEA,YAAAC,QAAA,SAAQC,EAAgCjlC,GACfilC,EACRX,wBAA0B,CAAEtkC,MAAK,EAClD,EAEA,YAAAklC,cAAA,SAAcllB,EAA4Bjd,GACtCtU,KAAK02C,uBAAuBnlB,EAAO1c,QAAQ0wB,gBAAiBhU,EAAQjd,GACpEtU,KAAK02C,uBAAuBnlB,EAAO1c,QAAQiB,YAAayb,EAAQjd,EACpE,EAEA,YAAAqiC,YAAA,SAAYC,EAAkBC,G,MACtBjB,EAAiBgB,IAAehB,EAAiBiB,GAC7CD,EAAW9gC,aAAe+gC,KAC1B,EAAAD,EAAWf,wBAAwBzpC,UAAS3L,KAAI,4CACzCo2C,EAAWhB,wBAAwBzpC,WAAQ,IAGlD4pC,EAAQa,KAGZb,EAAQa,GACRb,EAAQY,GAEhB,EAEA,YAAApK,WAAA,SAAWt6B,GACP4kC,EAAmB5kC,EACvB,EAEA,YAAA+hC,mBAAA,SACIx9C,EACAm6C,EACAmG,G,QAEIhc,EACJ,GAAIgc,EAAc,CACd,IAAI5hC,OAAS,EAGY,SAArB4hC,EAAa3iC,MACbpU,KAAKg3C,YAAYD,KAChB5hC,EAAY4hC,EAAaxpB,MAAMpvB,QAChC,IAAAkX,cAAaF,EAAW,cACxBygC,EAAiBzgC,IACjBA,EAAU0gC,wBAAwBzpC,SAASzV,OAAS,EAEpDqJ,KAAKi3C,uBAAuB9hC,IAE5B4lB,EAAkB/6B,KAAKk3C,0CACnBH,EACAnG,IAGJ,IAAA14B,cAAazhB,G,CAIrB,OAAQm6C,EAAax8B,MACjB,IAAK,QACD,IAAM+iC,EAAerB,EAAsBlF,EAAaz4B,OAClDA,EAAQg/B,aAAY,EAAZA,EAAc/qC,SAAS,GAErC,QAAI+L,IACAA,EAAM/K,YAAa,GACnB,IAAA8K,cAAazhB,EAAO0hB,IAEb,GAKf,IAAK,QACD,IAAMi/B,EAAerB,EAAoBnF,EAAar/B,OAEtD,GAAI6lC,EAAc,CACd,IAAMtzB,EAC4C,QAA9C,EAAAszB,EAAa7lC,MAAMhG,KAAKqlC,EAAa9uB,iBAAS,eAAErW,MAC5CmlC,EAAa7vB,aAEfyuB,EAC2C,QAA7C,EAAA4H,EAAa7lC,MAAMhG,KAAKqlC,EAAa7uB,gBAAQ,eAAEtW,MAC3CmlC,EAAa5uB,YAGrB,GAAI8B,GAAa0rB,EAGb,OAFA,IAAAt3B,cAAazhB,EAAOqtB,EAAW0rB,IAExB,C,CAIf,OAAO,EAEX,IAAK,QACD,IAAMzT,EAAW6U,EAAalhB,MAC9B,GAAIqM,EAAU,CAEN,IAAA+I,EAKA/I,EAAQ,eAJRgJ,EAIAhJ,EAAQ,YAHRiJ,EAGAjJ,EAAQ,aAFRkJ,EAEAlJ,EAAQ,UADRpM,EACAoM,EAAQ,UAIZ,UAFOtlC,EAAM4gD,0BAET1nB,EACA,QAAS3vB,KAAKs3C,uBACVxS,EACAC,EACAtuC,EAAM8T,OACNwwB,GAED,GACH+J,GAAkBE,IAClB,IAAA3vB,cAAayvB,EAAgB,aAM7B,OAJI8L,EAAa9gB,aACbr5B,EAAM4gD,2BAA4B,GAIlCzB,EAAiB9Q,MACf9kC,KAAKi3C,uBACHnS,EACAC,EACAE,EACAlK,GAIR,IAAMwc,EAAUv3C,KAAKs3C,uBAAuBxS,EAAgBC,GACtDyS,EAAUx3C,KAAKs3C,uBAAuBtS,EAAcC,GAE1D,SAAIsS,IAAWC,IACP5G,EAAa9gB,aACbr5B,EAAM4gD,2BAA4B,IAGtC,IAAAn/B,cAAazhB,EAAO8gD,EAASC,GACtB,G,EAU3B,OAAO,CACX,EAEA,YAAA5E,mBAAA,SAAmBC,EAA6BC,GAC5C,IAAI2E,GAAY,EACVxpC,EAAqC,CACvCypC,UAAW,GAITC,EAAY9E,EAAW,GAEJ,GAArBA,EAAWl8C,SAAe,IAAA0e,cAAasiC,EAAW,aAClDF,EAAYz3C,KAAK43C,mBAAmBD,EAAW1pC,GACxC4kC,EAAWl8C,OAAS,IAC3B8gD,GAAY,GAIhB,IAAMI,EAAc/E,EAAa,GAQjC,OANI2E,GAAoC,GAAvB3E,EAAan8C,OAC1B8gD,EAAYz3C,KAAK83C,qBAAqBD,EAAa5pC,GAC5C6kC,EAAan8C,OAAS,IAC7B8gD,GAAY,GAGTA,IAAcxpC,EAAQ8pC,eACjC,EAEA,YAAA9E,mBAAA,SAAmB1e,G,MACf,IAAI,IAAA2G,iBAAgB3G,EAAS,OAAQ,CACjC,IAAMyjB,EAAalC,EAAsBvhB,GAEzC,MAA4C,UAAjB,QAAvB,EAAAyjB,aAAU,EAAVA,EAAY5rC,SAAS,UAAE,eAAEG,eACzByrC,EAAW5rC,SAAS,GAAG7B,OAAOod,GAAK4M,EAAQ5M,IAEpC,E,CAIR,IAAI,IAAAuT,iBAAgB3G,EAAS,SAAU,CAC1C,IAAM6iB,EAAerB,EAAoBxhB,GAEzC,QAAI6iB,IACAA,EAAa7lC,MAAMhH,OAAOod,GAAK4M,EAAQ5M,IAEhC,E,CAKX,OAAO,CAEf,EAEQ,YAAA+uB,uBAAR,SACIv4C,EACAozB,EACA9zB,IAEI,IAAA4X,cAAalX,EAAM,kBAAmB,IAAAouC,mBAAkBpuC,IAASA,EAAK0X,aAC7C1X,EAAK0X,WAEbggC,wBAA0B,CAAEtkB,OAAM,EAAE9zB,OAAM,GAEnE,EAEQ,YAAAu5C,YAAR,SAAoB/hC,GACR,IAAAsY,EAAetY,EAAS,MAAjBuY,EAAQvY,EAAS,IAEhC,OAAOsY,EAAMpvB,MAAQqvB,EAAIrvB,MAAQovB,EAAMlN,QAAUmN,EAAInN,MACzD,EAEQ,YAAAi3B,uBAAR,SACIn5C,EACAkiB,EACAoR,EACAsJ,GAEA,OAAI,IAAA1lB,cAAalX,EAAM,aACfy3C,EAAiBz3C,GACV6B,KAAKi3C,uBAAuB94C,EAAMkiB,OAAQ9b,EAAWw2B,GAvT5E,SAA4B58B,G,MAClB,EAA6E,QAAvD,EAAAA,EAAgC03C,+BAAuB,QAAI,CAAC,EAAhFtkB,EAAM,SAAE9zB,EAAM,SAEtB,MACyB,WAArB8zB,aAAM,EAANA,EAAQ9mB,YACR8mB,EAAO1c,UACPpX,aAAM,EAANA,EAAQkN,iBACRlO,MAAMsE,QAAQtD,EAAOmN,OAE7B,CA+SuBqtC,CAAmB95C,GACnB6B,KAAKk4C,4BAA4B/5C,EAAMszB,QAE9C,EAEGpR,GAAUliB,EAAKqnC,WAAW7uC,OAC1BqJ,KAAKm4C,aAAah6C,EAAKi6C,WAAW,GAElCp4C,KAAKm4C,aAAah6C,EAAKqnC,WAAWnlB,IAAS,EAE1D,EAEQ,YAAA83B,aAAR,SAAqBh6C,EAAmBk6C,GACpC,IAAI5mC,EACE6mC,EAAcn6C,GAAQ23C,EAAsB33C,GAElD,GAAIm6C,EAAa,CACL,IAAA9mC,EAAwB8mC,EAAW,UAAxBlsC,EAAaksC,EAAW,SACrChpC,EAAQkC,EAAUpF,SAAS/L,QAAQ+L,EAAS,IAElD,GAAIkD,GAAS,EAAG,CACZ,IAAMipC,GACAF,GAAW7mC,EAAUpF,SAASkD,EAAQ,IAAOkC,EAAUpF,SAASkD,GACtEmC,GAAS,IAAAwG,uBAAsBsgC,EAAchuC,QAE7CiH,EAAUpF,SAAShM,OAAOi4C,EAAU/oC,EAAQ,EAAIA,EAAO,EAAGmC,E,EAIlE,OAAOA,CACX,EAEQ,YAAAwlC,uBAAR,SACIjkB,EACA+R,EACAE,EACAlK,G,kBAKIyd,EAHE,EAA0BxlB,EAAS6iB,wBAAjCrkC,EAAS,YAAEpF,EAAQ,WACrB8S,EAAQ9S,EAAS,GACjBgQ,EAAOhQ,EAASA,EAASzV,OAAS,GAGxC,GAA0B,SAAtBuoB,aAAK,EAALA,EAAO3S,cAA8C,SAArB6P,aAAI,EAAJA,EAAM7P,aAAuB,CAC7D,IAAMmhB,EAAqC,GACrCuF,EAAMD,EAASE,WAAa,GAC5BulB,EAAmC,GAEzC,QAAoBl0C,IAAhBwgC,EACA7lB,EAAMvS,KAAOsmB,EACbvF,EAAYjtB,KAAKye,GACjBu5B,EAAah4C,KAAKye,OACf,CAOH,GANI6lB,EAAc,IACd7lB,EAAMvS,KAAOsmB,EAAI/3B,UAAU,EAAG6pC,GAC9BrX,EAAYjtB,KAAKye,GACjBu5B,EAAah4C,KAAKye,SAGJ3a,IAAd0gC,EAAyB,CACzB,IAAMxzB,GAAS,IAAAwG,uBAA6C,QAAvB,EAAA8iB,aAAe,EAAfA,EAAiBxwB,cAAM,QAAI2U,EAAM3U,QACtEmjB,EAAYjtB,KAAKgR,GAEbszB,GAAiC,QAAlB,EAAA/R,EAASE,iBAAS,QAAI,IAAIv8B,SACrCuoB,EAAM/hB,OACN,IAAAuuB,SAAQja,EAAQyN,EAAM/hB,MAGtB+hB,EAAMpL,OACN,IAAAma,SAAQxc,EAAQyN,EAAMpL,OAI9B0kC,EAAa/mC,EACbwzB,EAAYF,C,MACT,GAAIE,EAAYF,EAAa,CAChC,IAAM2T,GAAS,IAAA94B,YACXqT,EAAI/3B,UAAU6pC,EAAaE,GACJ,QAAvB,EAAAlK,aAAe,EAAfA,EAAiBxwB,cAAM,QAAI2U,EAAM3U,OACjC2U,EAAM/hB,KACN+hB,EAAMpL,MAGV4kC,EAAOtrC,YAAa,EACpBsgB,EAAYjtB,KAAKi4C,GACjBD,EAAah4C,KAAKi4C,GAClBF,EAAaE,C,CAGjB,GAAIzT,EAAYhS,EAAIt8B,OAAQ,CACxB,IAAMgiD,GAAU,IAAA/4B,YACZqT,EAAI/3B,UAAU+pC,GACS,QAAvB,EAAAlK,aAAe,EAAfA,EAAiBxwB,cAAM,QAAI2U,EAAM3U,OACjC2U,EAAM/hB,KACN+hB,EAAMpL,MAEV4Z,EAAYjtB,KAAKk4C,GACjBF,EAAah4C,KAAKk4C,E,EAI1B,IAAIC,EAAapnC,EAAUpF,SAAS/L,QAAQ6e,GACxC25B,EAAYrnC,EAAUpF,SAAS/L,QAAQ+b,GAE3C,GAAIw8B,GAAc,GAAKC,GAAa,EAAG,CACnC,KACID,EAAa,GACqC,mBAAlDpnC,EAAUpF,SAASwsC,EAAa,GAAGrsC,aAEnCqsC,IAGJ,KACIC,EAAYrnC,EAAUpF,SAASzV,OAAS,GACS,mBAAjD6a,EAAUpF,SAASysC,EAAY,GAAGtsC,aAElCssC,KAGJ,EAAArnC,EAAUpF,UAAShM,OAAM,6BAACw4C,EAAYC,EAAYD,EAAa,IAAC,YAAKlrB,IAAW,G,CAGpF1tB,KAAKk2C,UAAUljB,EAAUxhB,EAAWinC,E,MACjC,GAA0B,WAAtBv5B,aAAK,EAALA,EAAO3S,cAA2B2S,GAAS9C,EAAM,CACxD,IAAMvH,EAAUqK,EAAMrK,QAChBvF,EAAQkC,EAAUpF,SAAS/L,QAAQ6e,GACnC45B,EAAY9lB,EAASiJ,cACrB8c,EAAWlkC,EAAQ0wB,iBAAmBuT,EACtCT,EAAUxjC,EAAQiB,aAAegjC,EAEnCxpC,GAAS,GAAKwpC,IAAa,IAAAvM,mBAAkBuM,KAAeC,GAAYV,KAClE5mC,GAAS,IAAAwG,uBACY,QAAvB,EAAA8iB,aAAe,EAAfA,EAAiBxwB,cAAM,SACiC,QAAnD,EAAAiH,EAAUpF,SAASisC,EAAU/oC,EAAQ,EAAIA,EAAQ,UAAE,QAAI4P,GAAO3U,QAGvEiH,EAAUpF,SAAShM,OAAOi4C,EAAU/oC,EAAQ,EAAIA,EAAO,EAAGmC,GAE1D+mC,EAAa/mC,E,CAIrB,OAAO+mC,CACX,EAEQ,YAAAN,4BAAR,SACI/5C,EACAszB,GAEA,IAAIhgB,EAEE,EAAqBtT,EAAK03C,wBAAxBtkB,EAAM,SAAE9zB,EAAM,SAChB6R,EAAQ7R,EAAOmN,OAAOvK,QAAQkxB,GAC9BunB,EAAY36C,EAAK89B,cACjBpnB,EAAU0c,EAAO1c,QACjBkkC,EAAWlkC,EAAQ0wB,iBAAmBuT,EACtCT,EAAUxjC,EAAQiB,aAAegjC,EAEvC,GAAIxpC,GAAS,GAAKwpC,IAAa,IAAAvM,mBAAkBuM,KAAeC,GAAYV,GAAU,CAClF5mC,GAAS,IAAAwG,uBAAsBwZ,GAE/B,IAAMhiB,GAAO,IAAAC,kBACT,OACAnL,EACAktB,GAGJhiB,EAAKrD,SAAS3L,KAAKgR,GACnBhU,EAAOmN,OAAOxK,OAAO24C,EAAWzpC,EAAQA,EAAQ,EAAG,EAAGG,E,CAG1D,OAAOgC,CACX,EAEQ,YAAAmmC,mBAAR,SAA2Bz5C,EAAY8P,GACnC,IAEI+qC,EAFAV,EAAkC,KAClChpC,GAAS,EAELi2B,EAAiCpnC,EAAI,gBAApB2X,EAAgB3X,EAAI,YAE7C,IACKm6C,EAAcxC,EA8H3B,SAAqB33C,GACjB,KAAOA,aAAI,EAAJA,EAAMi6C,WACTj6C,EAAOA,EAAKi6C,UAGhB,OAAOj6C,CACX,CApIiD86C,CAAY1T,OAChDyT,EAAkBV,EAAYlsC,SAASksC,EAAYlsC,SAASzV,OAAS,MACrE2Y,EAAQgpC,EAAY9mC,UAAUpF,SAAS/L,QAAQ24C,KAAqB,EAGrEh5C,KAAKk5C,UAAUZ,EAAY9mC,UAAWlC,EAAQ,EAAGnR,EAAM66C,EAAgBzuC,aACpE,IACF+tC,EAAcxC,EA+H3B,SAAsB33C,GAClB,KAAOA,aAAI,EAAJA,EAAM0X,YACT1X,EAAOA,EAAK0X,WAGhB,OAAO1X,CACX,CArIiDg7C,CAAarjC,OACjDkjC,EAAkBV,EAAYlsC,SAAS,MACvCkD,EAAQgpC,EAAY9mC,UAAUpF,SAAS/L,QAAQ24C,KAAqB,EAGrEh5C,KAAKk5C,UAAUZ,EAAY9mC,UAAWlC,EAAOnR,EAAM66C,EAAgBzuC,aAChE,GAAI0D,EAAQuD,WAAavD,EAAQypC,UAAY,EAEhD13C,KAAKk5C,UAAUjrC,EAAQuD,UAAWvD,EAAQypC,SAAUv5C,EAAM8P,EAAQ1D,YAC/D,SAAgChG,IAA5B0J,EAAQ8pC,gBAOf,OAAO,EAFP9pC,EAAQ8pC,gBAAkB55C,C,CAK9B,OAAO,CACX,EAEQ,YAAA25C,qBAAR,SAA6B35C,EAAY8P,GACrC,IACImrC,EADAd,EAAkC,KAGtC,GACIrqC,EAAQypC,SAAW,IAClBzpC,EAAQuD,YACR8mC,EAAcxC,EAAsB33C,MACpCi7C,EAAkBd,EAAYlsC,SAAS,IAC1C,CAME,GAJA6B,EAAQ1D,OAAS6uC,EAAgB7uC,OACjC0D,EAAQuD,UAAY8mC,EAAY9mC,UAChCvD,EAAQypC,SAAWY,EAAY9mC,UAAUpF,SAAS/L,QAAQi4C,EAAYlsC,SAAS,IAE3E6B,EAAQypC,SAAW,EAEnB,OAAO,EAGX,IAAK,IAAI5+C,EAAI,EAAGA,EAAIw/C,EAAYlsC,SAASzV,OAAQmC,IAAK,CAClD,IAAMwW,EAAQgpC,EAAY9mC,UAAUpF,SAAS/L,QAAQi4C,EAAYlsC,SAAStT,IAEtEwW,GAAS,GACTgpC,EAAY9mC,UAAUpF,SAAShM,OAAOkP,EAAO,E,CAkBrD,OAdIrB,EAAQ8pC,kBAER/3C,KAAKk5C,UACDjrC,EAAQuD,UACRvD,EAAQypC,SACRzpC,EAAQ8pC,gBACRO,EAAYlsC,SAAS,GAAG7B,QAK5B0D,EAAQ8pC,gBAAkB,OAGvB,C,CAEP,OAAO,CAEf,EAEQ,YAAAmB,UAAR,SACI1nC,EACAlC,EACA0jB,EACAzoB,G,MAEM8uC,EAAe9uC,GAAS,EAAD,eAAMA,QAAWhG,EAE1C80C,IACA,IAAAl+B,eAAck+B,GAAcl9C,SAAQ,SAAAhH,QACAoP,IAA5B,EAAA48B,mBAAmBhsC,WACZkkD,EAAalkD,EAE5B,IAGJ,IAAMwX,GAAO,IAAAiT,YAA+B,QAApB,EAAAoT,EAASyJ,mBAAW,QAAI,GAAI4c,GAEpD7nC,EAAUpF,SAAShM,OAAOkP,EAAO,EAAG3C,GACpC3M,KAAKk2C,UAAUljB,EAAUxhB,EAAW,CAAC7E,GACzC,EAEQ,YAAAuqC,0CAAR,SACIH,EACAnG,GAOA,GACI5wC,KAAKi2C,yCACgB,SAArBc,EAAa3iC,MACbpU,KAAKg3C,YAAYD,IACI,SAArBnG,EAAax8B,OACb,IAAAiB,cAAau7B,EAAalhB,MAAMqb,wBAAyB,cACzD6F,EAAalhB,MAAMqb,wBAAwB9O,eAAiB8a,EAAaxpB,MAAMpvB,MAC/Ey3C,EAAiBhF,EAAalhB,MAAMqb,0BAEhB,mBADpB6F,EAAalhB,MAAMqb,wBAAwB8K,wBAAwBrkC,UAAUpF,SAAS,GACjFG,YAEL,OAAOqkC,EAAalhB,MAAMqb,wBAAwB8K,wBAAwBrkC,UACrEpF,SAAS,EAGtB,EACJ,EAhkBA,GAklBA,SAAS0qC,EAAmB5kC,GACxB8jC,EAAQ9jC,GAER,IAAK,IAAI/T,EAAO+T,EAAU2D,WAAY1X,EAAMA,EAAOA,EAAK2X,YACpDghC,EAAmB34C,EAE3B,CAxlBa,EAAAg1C,eAAAA,C,oHC7Jb,eACA,WAQA,aAII,WACYV,EACAC,GAFZ,WACY,KAAAD,WAAAA,EACA,KAAAC,WAAAA,EA2BJ,KAAA4G,mBAAqB,SAACC,GAW1B,IAVA,IAAI9B,GAAY,EACZ+B,EAA2B,KAC3BC,EAAkC,KAClC5G,EAAqB,GACrBC,EAAuB,GACvB4G,GAAgB,EAEdC,EAAe,IAAIC,IACnBC,EAAgB,IAAID,IAEjB9gD,EAAI,EAAGA,EAAIygD,EAAU5iD,QAAU8gD,EAAW3+C,IAAK,CACpD,IAAM65C,EAAW4G,EAAUzgD,GACrB6X,EAASgiC,EAAShiC,OAExB,IAAIgpC,EAAaG,IAAInpC,GAArB,CAEO,IAAKkpC,EAAcC,IAAInpC,GAAS,CACnC,IACI,IAAAszB,0BAAyBtzB,EAAQ,EAAK6gB,aACtC,IAAAuoB,iCAAgCppC,EAAQ,EAAK6gB,WAC/C,CACEmoB,EAAaK,IAAIrpC,GAEjB,Q,CAEAkpC,EAAcG,IAAIrpC,E,CAI1B,OAAQgiC,EAASv+B,MACb,IAAK,aACG,EAAKod,UAAUyoB,eAAetpC,GAAQ,KAER,MAA1BgiC,EAASuH,gBACT,IAAA7kC,cAAa1E,EAAQ,gBAErB,EAAK+hC,WAAW,CAAEt+B,KAAM,YAAamgB,QAAS5jB,IAG9C8mC,GAAY,GAGpB,MAEJ,IAAK,gBACGgC,GAAsBA,GAAsB9G,EAAShiC,OAErD8mC,GAAY,GAEZgC,EAAqB9G,EAAShiC,OAC9B+oC,GAAgB,GAEpB,MAEJ,IAAK,YACIF,EAEMA,GAAe7G,EAAShiC,SAC/B8mC,GAAY,GAFZ+B,EAAc7G,EAAShiC,OAKvB8mC,IACA5E,EAAaA,EAAWxxC,OAAO5E,MAAMW,KAAKu1C,EAASE,aACnDC,EAAeA,EAAazxC,OAAO5E,MAAMW,KAAKu1C,EAASG,gB,EAOnE2E,IACI5E,EAAWl8C,OAAS,GAAKm8C,EAAan8C,OAAS,IAC/C,EAAK+7C,WAAW,CACZt+B,KAAM,YACNy+B,WAAU,EACVC,aAAY,IAIhB4G,GACA,EAAKhH,WAAW,CAAEt+B,KAAM,UAG5B,EAAKs+B,WAAW,CAAEt+B,KAAM,WAEhC,EA/GIpU,KAAKm6C,SAAW,IAAIC,iBAAiBp6C,KAAKs5C,oBAC1Ct5C,KAAKwxB,WAAY,IAAA6oB,iBAAgB5H,EACrC,CA8GJ,OA5GI,YAAAgB,eAAA,WACIzzC,KAAKm6C,SAASG,QAAQt6C,KAAKyyC,WAAY,CACnC8H,SAAS,EACTC,WAAW,EACXhhB,YAAY,EACZihB,eAAe,GAEvB,EAEA,YAAA9G,cAAA,WACI3zC,KAAKm6C,SAASO,YAClB,EAEA,YAAAjT,eAAA,SAAekT,GACX,IAAMpB,EAAYv5C,KAAKm6C,SAASS,cAE3BD,GACD36C,KAAKs5C,mBAAmBC,EAEhC,EAyFJ,EAxHA,GA6HA,sCACI9G,EACAC,GAEA,OAAO,IAAImI,EAAyBpI,EAAYC,EACpD,C,mGClIA,uBACIxqB,EACAzxB,EACAwe,GAIA,GAFAiT,EAAMwf,YAAcjxC,EAEG,UAAnBwe,aAAS,EAATA,EAAWb,MAAiB,CAExB,MAEAa,EAAS,MAFA6vB,EAAc,iBAAEC,EAAW,cAAEC,EAAY,eAAEC,EAAS,YAC7DnV,EACA7a,EAAS,WACbiT,EAAMmiB,gBAAkB,CACpBj2B,KAAM,QACN0b,WAAYA,EACZvC,MAAO,CACHpvB,KAAM2mC,EACNzkB,OAAQ0kB,GAEZvX,IAAK,CACDrvB,KAAM6mC,EACN3kB,OAAQ4kB,G,MAIhB/c,EAAMmiB,gBAAkBp1B,QAAAA,OAAa1Q,CAE7C,C,gICpCA,WAeA,aASI,WAAYoiB,GAAZ,I,EAAA,OARQ,KAAA5B,OAAyB,KAEzB,KAAA+1B,SAAgC,KAqDhC,KAAAC,mBAAqB,SAACC,G,MAC1B,GAAI,EAAKj2B,OAAQ,CACb,IAAM,EAAkB,GAClB,EAAai2B,EACbC,EAAeD,EAKf,EAtEQ,GAuEV,EAAWE,OACJ,EAAWvqC,OACkB,WAA9BsqC,aAAY,EAAZA,EAAcE,cAAyD,SAA9BF,aAAY,EAAZA,EAAcE,aACtDF,EAAatqC,OACd,EAAKyqC,eAAe,EAAKr2B,QAE/B,GACA,EAAKmD,MAAMmzB,qBAAqBl/C,SAAQ,SAAAm/C,G,MAC9Bx+B,EAA4D,QAApD,EAAAw+B,EAASC,oBAAoB,EAAY,UAAW,QAAI,IAClEz+B,aAAK,EAALA,EAAOnmB,QAAS,IACZ,EAASA,OAAS,GAClB,EAAS8J,KAAK,MAGlB,EAASA,KAAI,MAAb,GAAQ,mCAASqc,IAAK,IAE9B,IAGO,QAAX,IAAKiI,cAAM,SAAEkF,aAAa,cAAe,CACrCuS,SAAU,EACV1f,MAAO,G,CAGnB,EAhFI9c,KAAKkoB,MAAQ,CACTmzB,sBACmB,QAAf,EAAA10B,EAAQyrB,eAAO,eAAE/lC,OAAiCmvC,KAA0B,GAExF,CA2FJ,OAtFI,YAAAjI,QAAA,WACI,MAAO,aACX,EAMA,YAAAC,WAAA,SAAWzuB,GAAX,WACI/kB,KAAK+kB,OAASA,EACd,IAAM02B,EAEF,CACAC,YAAa,CACTnV,eAAgB,SAAChL,GACb,SAAKwf,mBAAmBxf,EAAxB,IAGZv7B,KAAK86C,SAAW96C,KAAK+kB,OAAOohB,eAA+CsV,EAC/E,EAKA,YAAA/H,QAAA,W,MACiB,QAAb,EAAA1zC,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,SAAW,KAChB96C,KAAK+kB,OAAS,IAClB,EAKA,YAAA6uB,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAsCQ,YAAAkzB,eAAR,SAAuBr2B,GACnB,IAAM9P,EAAY8P,EAAOyE,kBAEzB,OAAIvU,GACsB,SAAlBA,EAAUb,MACVa,EAAUya,MAAME,UAAS,IAGtB,IAAA5a,sBAAqBC,IAAc,MAEnC,IAEf,EACJ,EAzGA,GA2GA,SAASumC,EAAsB3R,G,MAC3B,SAA2C,QAAlC,EAA2BA,SAAO,eAAE0R,oBACjD,CAMA,mCACI50B,GAEA,OAAO,IAAIg1B,EAAkBh1B,EACjC,C,2ICtIA,eACA,WACA,WACA,WAkBA,aASI,WAAY2gB,GAAZ,WARQ,KAAAviB,OAAyB,KACzB,KAAA+1B,SAAgC,KAkGhC,KAAAc,QAAU,SAACrgB,GACf,GAAI,EAAKxW,QAAU82B,EAAiBtgB,GAAQ,CACxC,IAAM,EAAS,EAAKxW,OAEd+2B,EAAevgB,EAAMgD,cAEvBwd,EAA0BD,EAAc,KACxCvgB,EAAMygB,kBACN,IAAAC,wBACI,IAAAvmB,SAAQomB,EAAch/B,OACtB,EAAKoL,MAAMg0B,wBACbC,MAAK,SAAC5d,GACC,EAAO5U,eACR,IAAAyyB,OAAM,EAAQ7d,EAAe,EAAKrW,MAAMm0B,iBAEhD,I,CAGZ,EA5GIr8C,KAAKkoB,MAAQ,CACTg0B,uBAAwB5U,EAAO4U,wBAA0B,GACzDrgB,QAAS,KACTwgB,iBAAkB/U,EAAO+U,iBAEjC,CAwGJ,OAnGI,YAAA9I,QAAA,WACI,MAAO,WACX,EAMA,YAAAC,WAAA,SAAWzuB,GAAX,WACI/kB,KAAK+kB,OAASA,EACd/kB,KAAK86C,SAAW96C,KAAK+kB,OAAOohB,eAAe,CACvCiW,MAAO,CACH7V,eAAgB,SAAAyU,GAAK,SAAKY,QAAQZ,EAAb,GAEzBsB,KAAM,CACF/V,eAAgB,SAAAyU,GAAK,SAAKuB,UAAUvB,GAAG,EAAlB,GAEzBwB,IAAK,CACDjW,eAAgB,SAAAyU,GAAK,SAAKuB,UAAUvB,GAAG,EAAlB,IAGjC,EAKA,YAAAtH,QAAA,W,MACQ1zC,KAAKkoB,MAAM2T,UACkB,QAA7B,EAAA77B,KAAKkoB,MAAM2T,QAAQvmB,kBAAU,SAAE+gB,YAAYr2B,KAAKkoB,MAAM2T,SACtD77B,KAAKkoB,MAAM2T,QAAU,MAGrB77B,KAAK86C,UACL96C,KAAK86C,WAET96C,KAAK86C,SAAW,KAChB96C,KAAK+kB,OAAS,IAClB,EAKA,YAAA6uB,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAEQ,YAAAq0B,UAAR,SAAkBhhB,EAAcD,G,QAC5B,GAAKt7B,KAAK+kB,QAAW82B,EAAiBtgB,GAAtC,CAIA,IAAMkhB,GAAqB,IAAAC,mBAAkB18C,KAAK+kB,OAAQuW,EAAOC,GAEjE,GAAIkhB,EAAoB,CACZ,IAAAngB,EAA6BmgB,EAAkB,YAAlChgB,EAAgBggB,EAAkB,YACvDlhB,EAAMygB,iBACa,QAAnB,EAAAzgB,EAAMgD,qBAAa,SAAEoe,QAAQ,YAAargB,EAAYa,WACnC,QAAnB,EAAA5B,EAAMgD,qBAAa,SAAEoe,QAAQ,aAAclgB,GAEvCnB,GACAt7B,KAAK+kB,OAAOE,oBACR,SAACxuB,EAAOwX,GAQJ,MALI,UADA,IAAAwJ,iBAAgBhhB,EAAO,CAAC,EAAAmmD,iBAAkB3uC,GAASuJ,eAGnD,IAAAjI,uBAAsB9Y,IAGnB,CACX,GACA,CACI0uB,QAAS,MACToC,aAAc,EAAAC,aAAaq1B,K,EAK/C,EAqBJ,EAvHA,GAyHA,SAAShB,EAAiBtgB,GACtB,QAAUA,EAAyBgD,aACvC,CAMA,SAAgBwd,EACZD,EACA/2B,GAEA,SAAK+2B,aAAY,EAAZA,EAAch/B,UAIdiI,EAAOyK,iBAAiBstB,YAMtB,IAAApnB,SAAQomB,EAAah/B,OAAOxP,MAAK,SAAAJ,GAC5B,IAAAkH,EAASlH,EAAI,KACf6vC,EAA6B,SAAd7vC,EAAK8vC,MAA4B,KAAT5oC,EACvC6oC,EAAmC,IAA1B7oC,EAAK/T,QAAQ,SAC5B,OAAO08C,GAAgBE,CAC3B,IACJ,CApBA,8BA2BA,iCACI3V,GAEA,OAAO,IAAI4V,EAAgB5V,EAC/B,C,yGCrLA,eAYA,SAAS6V,EAAa/yC,GAClB,OAAIA,GAA4B,aAAnBA,EAAMK,UACRL,EAAMgC,SAASmE,OAClB,SAAAhD,GAAW,MAAwB,oBAAxBA,EAAQhB,aAA4D,MAAvBgB,EAAQhB,WAArD,IAIfnC,GAA4B,cAAnBA,EAAMK,UACRL,EAAMQ,OAAO2F,MAAM4sC,KAGrB/yC,CACb,CAOa,EAAAwyC,gBAAuC,SAAC3uC,GACzC,IAAAqD,EAA8BrD,EAAO,YAC7C,GAAoB,SADkBA,EAAO,eACdqD,aAAW,EAAXA,EAAa9T,MAAM,CAC9C,IAAM8R,GAAQ,IAAA2C,mCACVX,EAAY9T,KACZ,CAAC,YACD,CAAC,cAEC0P,EAAOoE,EAAY9T,KAAK8R,GAC9B,GAAIA,GAAS,GAAKpC,GAA+B,YAAvBA,EAAKvC,eAA8B,CACzD,IAAMyyC,EAAgB9rC,EAAY9T,KAAK8R,EAAQ,GAAG1E,OAAOvK,QAAQ6M,GAC3DmwC,EACFD,GAAiB,EACX9rC,EAAY9T,KAAK8R,EAAQ,GAAG1E,OAAOwyC,EAAgB,QACnD74C,EACJwS,EACFqmC,GAAiB,EACX9rC,EAAY9T,KAAK8R,EAAQ,GAAG1E,OAAOwyC,EAAgB,QACnD74C,GAEN,IAAA8sB,0BAAyBnkB,MACvBmwC,IAAiB,IAAAnoB,qBAAoBmoB,KACvCtmC,GACAomC,EAAapmC,MAEb,IAAA1M,aAAY6C,GAAMC,OAAS,G,EAI3C,C,iHC5DA,cACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WAQA,mCACIwZ,EACA8rB,GAEA,MAAO,CACHlL,OAAO,IAAA+V,mBAAkB32B,EAAS8rB,GAClCloC,QAAQ,IAAAgzC,oBAAmB52B,GAC3B62B,WAAW,IAAAC,uBAAsB92B,GACjC+jB,UAAU,IAAAgT,sBAAqB/2B,EAAS8rB,GACxClP,WAAW,IAAAoa,uBAAsBh3B,EAAS8rB,GAC1ClhB,QAAQ,IAAAqsB,sBACR3oC,WAAW,IAAA4oC,uBAAsBl3B,GACjCm3B,aAAa,IAAAC,yBAAwBp3B,GACrC+c,MAAM,IAAAsa,kBAAiBr3B,GAE/B,C,8GC/BA,eAcMs3B,EAAiE,CACnEC,QAAS,UACTC,MAAO,QACPC,SAAU,YAcd,aAYI,WAAYz3B,EAAwB8rB,GAApC,WAXQ,KAAA1tB,OAAyB,KACzB,KAAA+1B,SAAgC,KAEhC,KAAAG,aAAoC,KACpC,KAAAoD,MAAQ,EA6FR,KAAAC,YAAc,SAACtD,GACnB,IAAMuD,EAAYvD,EACZ78C,EAAOogD,EAAU5tC,OACjB4jB,GAAU,IAAAlf,cAAalX,EAAM,gBAAkBA,EAAOA,EAAK89B,cAE7D1H,IAAYA,EAAQ4G,mBACpBojB,EAAUvC,gBAElB,EAEQ,KAAAwC,OAAS,W,QACPl0B,EAAiB,QAAX,IAAKvF,cAAM,eAAEiC,cAET,QAAhB,EAAAsD,aAAG,EAAHA,EAAK2H,mBAAW,SAAEwsB,uBAAsB,WAChC,EAAK15B,SACL,EAAKA,OAAOsC,eACZ,EAAKtC,OAAOkF,aAAa,iBAAkB,CACvC4f,OAAQ,EAAAriB,aAAak3B,OAGjC,GACJ,EAEQ,KAAAC,SAAW,SAAC3D,G,MACL,QAAX,IAAKj2B,cAAM,SAAEkF,aAAa,SAAU,CAChCuS,SAAUwe,EACVvQ,gBAAiB,EAAKviB,MAAMuiB,iBAEpC,EAEQ,KAAAmU,qBAAsD,CAC1DrY,eAAgB,SAAAhL,G,UACNsE,EAAYoe,EAAa1iB,EAAMnnB,QAEjC,IAAAyqC,kBAAiBtjB,KAAU,IAAAujB,mBAAkBvjB,KAG7CA,EAAMwjB,kBAGV,IACMC,IADoD,QAAxC,EAA6B,QAA7B,EAAW,QAAX,IAAKj6B,cAAM,eAAEyK,wBAAgB,eAAEstB,iBAAS,YACvBvhB,EAAMyjB,aAAe,EAAK92B,MAAM+2B,SAE/D,EAAKl6B,QAAU8a,IAAcmf,GAC7B,EAAKj6B,OAAOkF,aAAa4V,EAAW,CAChCrD,SAAUjB,GAGtB,GAGI,KAAA2jB,kBAA2C,CAC/C3Y,eAAgB,SAAAhL,G,UACZA,EAAMwjB,kBAEN,IACMC,IADoD,QAAxC,EAA6B,QAA7B,EAAW,QAAX,IAAKj6B,cAAM,eAAEyK,wBAAgB,eAAEstB,iBAAS,YAEtCvhB,EAAqByjB,aAAe,EAAK92B,MAAM+2B,SAE/D,EAAKl6B,SAAWi6B,GAChB,EAAKj6B,OAAOkF,aAAa,QAAS,CAC9BuS,SAAUjB,GAGtB,GAGI,KAAA4jB,YAAc,SAAC5jB,GACf,EAAKxW,SACA,EAAKmD,MAAMk3B,0BACZ,EAAKr6B,OACAiC,cACA2f,iBAAiB,UAAW,EAAK0Y,WAAW,GACjD,EAAKn3B,MAAMk3B,yBAA0B,EACrC,EAAKl3B,MAAMo3B,WAAa/jB,EAAMgkB,MAC9B,EAAKr3B,MAAMs3B,WAAajkB,EAAMkkB,OAGlC,EAAK16B,OAAOkF,aAAa,YAAa,CAClCuS,SAAUjB,IAGVA,EAAMmkB,mBACN,EAAKzE,aAAe,MAEpB,EAAKA,cACL,EAAKl2B,OAAOkF,aAAa,cAAe,CACpCuS,SAAU,EAAKye,aACf0E,cAAepkB,IAI/B,EAEQ,KAAA8jB,UAAY,SAAC7iB,GACb,EAAKzX,SACL,EAAK66B,6BACL,EAAK76B,OAAOkF,aAAa,UAAW,CAChCuS,SAAQ,EACRqjB,WACI,EAAK33B,MAAMo3B,YAAc9iB,EAAS+iB,OAClC,EAAKr3B,MAAMs3B,YAAchjB,EAASijB,SAG1C,EAAKxE,eACL,EAAKA,aAAe,KAE5B,EAEQ,KAAA6E,cAAgB,SAACvkB,GACjB,EAAKxW,QACL,EAAKA,OAAOkF,aAAa,cAAe,CACpCuS,SAAUjB,GAGtB,EAEQ,KAAAwkB,mBAAqB,WACzB,EAAK73B,MAAM+2B,SAAU,CACzB,EAEQ,KAAAe,iBAAmB,SAACxjB,G,MACxB,EAAKtU,MAAM+2B,SAAU,EACV,QAAX,IAAKl6B,cAAM,SAAEkF,aAAa,iBAAkB,CACxCuS,SAAQ,GAEhB,EASQ,KAAAyjB,cAAgB,SAACjF,GACC,UAAlBA,EAAEG,aAA6C,QAAlBH,EAAEG,cAC/B,EAAKF,aAAeD,EAE5B,EAhOIh7C,KAAKkoB,MAAQ,CACT+2B,SAAS,EACTxU,gBAAiB9jB,EAAQ8jB,iBAAmBgI,EAC5C6M,WAAY,KACZE,WAAY,KACZJ,yBAAyB,EAEjC,CA0NJ,OArNI,YAAA7L,QAAA,WACI,MAAO,UACX,EAMA,YAAAC,WAAA,SAAWzuB,GAAX,I,IAAA,OACI/kB,KAAK+kB,OAASA,EAEd,IAAMkS,EAAWj3B,KAAK+kB,OAAOiC,cACvBy0B,EAEF,CAEA2C,SAAUp+C,KAAK4+C,qBACfV,QAASl+C,KAAK4+C,qBACdT,MAAOn+C,KAAK4+C,qBACZ/rB,MAAO7yB,KAAKk/C,kBAGZgB,UAAW,CAAE3Z,eAAgBvmC,KAAKm/C,aAClCgB,SAAU,CAAE5Z,eAAgB,SAAChL,GAAsB,SAAKukB,cAAcvkB,EAAnB,GAGnD6kB,iBAAkB,CAAE7Z,eAAgBvmC,KAAK+/C,oBACzCM,eAAgB,CAAE9Z,eAAgBvmC,KAAKggD,kBAGvCM,UAAW,CAAE/Z,eAAgBvmC,KAAKs+C,aAClCiC,KAAM,CAAEha,eAAgBvmC,KAAKw+C,QAG7BgC,YAAa,CAAEja,eAAgB,SAAChL,GAAwB,SAAK0kB,cAAc1kB,EAAnB,IAG5Dv7B,KAAK86C,SAAW96C,KAAK+kB,OAAOohB,eAA+CsV,GAG3Ez7C,KAAKkoB,MAAMuiB,gBAAgB9D,iBAAiB,SAAU3mC,KAAK2+C,UACvC,QAApB,EAAA1nB,EAAShF,mBAAW,SAAE0U,iBAAiB,SAAU3mC,KAAK2+C,UAClC,QAApB,EAAA1nB,EAAShF,mBAAW,SAAE0U,iBAAiB,SAAU3mC,KAAK2+C,SAC1D,EAKA,YAAAjL,QAAA,W,cACI1zC,KAAK4/C,6BAEL,IAAM3oB,EAAsB,QAAX,EAAAj3B,KAAK+kB,cAAM,eAAEiC,cACT,QAArB,EAAAiQ,aAAQ,EAARA,EAAUhF,mBAAW,SAAE2U,oBAAoB,SAAU5mC,KAAK2+C,UACrC,QAArB,EAAA1nB,aAAQ,EAARA,EAAUhF,mBAAW,SAAE2U,oBAAoB,SAAU5mC,KAAK2+C,UAC1D3+C,KAAKkoB,MAAMuiB,gBAAgB7D,oBAAoB,SAAU5mC,KAAK2+C,UACjD,QAAb,EAAA3+C,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,SAAW,KAChB96C,KAAK+kB,OAAS,KACd/kB,KAAKi7C,aAAe,KAEhBj7C,KAAKq+C,QACgB,QAArB,EAAApnB,aAAQ,EAARA,EAAUhF,mBAAW,SAAEwuB,aAAazgD,KAAKq+C,OACzCr+C,KAAKq+C,MAAQ,EAErB,EAKA,YAAAzK,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAkIQ,YAAA03B,2BAAR,WACQ5/C,KAAK+kB,QAAU/kB,KAAKkoB,MAAMk3B,0BAC1Bp/C,KAAKkoB,MAAMk3B,yBAA0B,EACrCp/C,KAAK+kB,OAAOiC,cAAc4f,oBAAoB,UAAW5mC,KAAKq/C,WAAW,GAEjF,EAOJ,EA9OA,GAsPA,gCACI/X,EACAmL,GAEA,OAAO,IAAIiO,EAAepZ,EAAQmL,EACtC,C,4GC1RA,eACA,WASA,WAgBMkO,EAAkB,cAKxB,aAOI,aANQ,KAAA57B,OAAyB,KAO7B/kB,KAAKkoB,MAAQ,CACT0jB,UAAW,CAAC,EAEpB,CAwPJ,OAnPI,YAAA2H,QAAA,WACI,MAAO,QACX,EAMA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,CAClB,EAKA,YAAA2uB,QAAA,WACI1zC,KAAK+kB,OAAS,KACd/kB,KAAKkoB,MAAM0jB,UAAY,CAAC,CAC5B,EAKA,YAAAgI,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAMA,YAAAoqB,cAAA,SAAc/W,GACV,GAAIv7B,KAAK+kB,OACL,OAAQwW,EAAMsE,WACV,IAAK,UACD7/B,KAAK4gD,mBAAmB5gD,KAAK+kB,OAAQwW,GACrC,MACJ,IAAK,iBACDv7B,KAAK6gD,0BAA0B7gD,KAAK+kB,OAAQwW,GAC5C,MACJ,IAAK,WACD,IAAAulB,6BAA4B9gD,KAAK+kB,OAAQwW,GACzC,MACJ,IAAK,kBACD,IAAAwlB,2BAA0B/gD,KAAK+kB,OAAQwW,GACvC,MACJ,IAAK,cACDv7B,KAAK6gD,0BAA0B7gD,KAAK+kB,QACpC,MACJ,IAAK,wBACD/kB,KAAKghD,iCAAiChhD,KAAK+kB,OAAQwW,EAAMgB,YAIzE,EAEQ,YAAAqkB,mBAAR,SAA2B77B,EAAiBwW,GAChC,IAAAiB,EAAyBjB,EAAK,SAApBskB,EAAetkB,EAAK,WAClCp9B,EAAoBq+B,EAAS7rB,OAEjC,GAAIkvC,GAAc7/C,KAAK+kB,OACnB,KAAO5mB,GAAQ6B,KAAK+kB,OAAOkE,eAAegxB,eAAe97C,IAAO,CAC5D,IAAI,IAAA0tC,iBAAgB1tC,GAAO,CACvB6B,KAAKiqB,aAAalF,EAAQ5mB,EAAqB,QAASq+B,GACxD,K,CAEAr+B,EAAOA,EAAKmX,U,CAI5B,EAEQ,YAAAurC,0BAAR,SAAkC97B,EAAiBwW,GAAnD,I,EAAA,OACU0lB,EACoB,QAAtB,EAAA1lB,aAAK,EAALA,EAAO0O,uBAAe,QAAIjqC,KAAK6oC,mBAAmB9jB,GAChDue,EAAe/H,aAAK,EAALA,EAAO+H,aAE5B2d,EAAiB9kD,SAAQ,SAAA6sC,GACb,IAAAzX,EAAgCyX,EAAK,OAA7B/nB,EAAwB+nB,EAAK,UAAlBxM,EAAawM,EAAK,SAEzC,EAEAzX,EAAM,aAFU5J,EAAE,KAAEM,EAAU,aAAEi5B,EAAY,eAC5CrsC,EACA0c,EAAM,QAEV,GAAItJ,IAAei5B,EACf,GAAiB,aAAbjgC,EAA0B,CAC1BsQ,EAAO6C,aAAazM,GAAK,EAAK2nB,eAAernB,EAAYN,QAAAA,EAAM,GAAI9S,GACnEA,EAAQssC,WAAY,IAAAC,0BAAyB7vB,EAAO6C,cAEhD7C,EAAO6C,aAAaxM,aACpB/S,EAAQi9B,gBAAkB,SAG9B,IAAMvR,EAAc,EAAKtW,aAAalF,EAAQlQ,EAASoM,EAAWub,GAElE,EAAKtU,MAAM0jB,UAAUra,EAAO6C,aAAazM,IAAM,CAC3C4M,QAAS1f,EACTq3B,WAAY3L,aAAW,EAAXA,EAAa8gB,eAGzBt8B,EAAOgE,eACP,IAAAyU,gBACI3oB,GACA,EACA,cACAkQ,EAAOmE,kBACP,CACIuU,aAAc1Y,EAAO2Y,6BACjB,+B,MAKb,GAAI/V,EAAI,CACX,IAAM25B,EAAW,EAAKp5B,MAAM0jB,UAAUjkB,GAElC25B,IACAA,EAASC,WAAY,GAGzB,EAAKt3B,aAAalF,EAAQlQ,EAASoM,EAAWub,E,CAG1D,IAEA8G,SAAAA,EAAcnnC,SAAQ,SAAA4rB,G,MACVJ,EAAcI,EAAW,GAArBG,EAAUH,EAAW,MAC3BlT,EAAkC,QAAxB,IAAKqT,MAAM0jB,UAAUjkB,UAAG,eAAE4M,QAEtC1f,GACA,EAAKoV,aACDlF,EACAlQ,EACA,yBACAtQ,EACA2jB,EAGZ,KAEA,IAAAs5B,oCAAmCz8B,EACvC,EAEQ,YAAA8jB,mBAAR,SAA2B9jB,GAA3B,WACUloB,EAA0B,GA4ChC,OA1CAkoB,EAAOE,oBAAmB,SAAAxuB,GAEtB,OADA,IAAAgrD,iBAAgBhrD,EAAOoG,IAChB,CACX,KAEA,IAAAse,eAAcnb,KAAKkoB,MAAM0jB,WAAWzvC,SAAQ,SAAAwrB,GACxC,IAAMqhB,EAAQ,EAAK9gB,MAAM0jB,UAAUjkB,GAEnC,IAAKqhB,EAAMuY,UAAW,CAClB,IAAMjyC,EAAQzS,EAAOyiB,WACjB,SAAAnnB,GACI,MAAe,aAAfA,EAAE8oB,WACF9oB,EAAEo5B,OAAO6C,aAAazM,IAAMA,GAC5BxvB,EAAEo5B,OAAO1c,SAAWm0B,EAAMzU,OAF1B,IAKR,GAAIjlB,GAAS,EAGTzS,EAAOuD,OAAOkP,EAAO,OAClB,CAEH,IAAM/E,GAAS,IAAAyd,mBAAkBghB,EAAMzU,SAEvC,IAAKhqB,EAAO22C,aAAc,CACtB,IAAM3vB,GAAS,IAAAnK,cACX4hB,EAAMzU,QACNhqB,EAAOqd,WACP,CAAC,EACDrd,EAAO0d,WACP1d,EAAOod,IAGX9qB,EAAO4D,KAAK,CACR8wB,OAAQA,EACRtQ,UAAW,a,GAK/B,IAEOpkB,CACX,EAEQ,YAAAmkD,iCAAR,SAAyCj8B,EAAiB7P,GAA1D,YACI,IAAAw3B,sBAAqBx3B,GAAM/Y,SAAQ,SAAAo4B,GAC/BA,EAAQ6G,gBAAgB,mBAExB,EAAKnR,aAAalF,EAAQwP,EAAS,0BACvC,GACJ,EAEQ,YAAAtK,aAAR,SACIlF,EACAlQ,EACAoM,EACAub,EACAtU,GAEA,IAAM3d,GAAS,IAAAyd,mBAAkBnT,GAEjC,OAAOtK,EAAOod,IAAMpd,EAAO0d,aAAe1d,EAAO22C,aAC3Cn8B,EAAOkF,aAAa,kBAAmB,CACnChJ,UAAWA,EACXub,SAAQ,EACRjL,OAAQ,CACJ5J,GAAIpd,EAAOod,GACXvT,KAAM7J,EAAO0d,WACbL,aAAcrd,EAAOqd,WACrB/S,QAAO,GAEXqT,MAAoB,qBAAbjH,EAAmCiH,OAAQ3jB,EAClD88C,cAA4B,aAAbpgC,QAAkC1c,IAErD,IACV,EAEQ,YAAA+qC,eAAR,SAAuBl7B,EAAcuT,EAAY9S,GAO7C,IANA,IAAM1Z,EAAQwlD,EAAgB3mB,KAAKrS,GAC7B+5B,GAAUvmD,EAAQwsB,EAAGg6B,OAAO,EAAGh6B,EAAGhxB,OAASwE,EAAM,GAAGxE,QAAUgxB,IAAOvT,EAGvEwtC,EAAQ,GAEHhjD,EAAOzD,GAASO,SAASP,EAAM,KAAQ,GAAKyD,IAAO,CACxDgjD,EAAQhjD,EAAM,EAAO8iD,EAAM,IAAI9iD,EAAQ8iD,EAEvC,IAAMx0C,EAAOlN,KAAKkoB,MAAM0jB,UAAUgW,GAElC,IAAK10C,GAAQA,EAAKqnB,SAAW1f,EACzB,K,CAIR,OAAO+sC,CACX,EACJ,EAnQA,GAyQA,gCACI,OAAO,IAAIC,CACf,C,oIC1SA,WAiBA,uCACI98B,EACA5vB,EACA2sD,G,MAEM7sC,EAAY8P,EAAO4E,aAAe,KAAO5E,EAAOyE,kBAEtD,GAAKvU,GAA+B,SAAlBA,EAAUb,KAA5B,CAIQ,IAAAsb,EAAsBza,EAAS,MAAxB6a,EAAe7a,EAAS,WACjC8sC,EAAajyB,EAAaJ,EAAMoV,eAAiBpV,EAAMsV,aACvD3kB,EAASyP,EAAaJ,EAAMqV,YAAcrV,EAAMuV,UAChD6T,GAAY,IAAAzjC,cAAa0sC,EAAY,gBACrCA,EACAA,EAAW9lB,cAIX+lB,EAAuB,aAAP7sD,MAFlB2jD,GAC2E,QAA3C,QAAhC,EAAA/zB,EAAOiC,cAAciL,mBAAW,eAAEC,iBAAiB4mB,GAAWtuC,YAI9DsuC,KACE,IAAAvM,mBAAkBuM,GAAYkJ,KAC1BA,GAA0B,GAAV3hC,IAAkB2hC,GAA0B,GAAV3hC,KACpD,IAAA0rB,wBAAuB+M,KAE3B/zB,EAAOE,oBAAmB,SAAAxuB,G,QAChBwrD,GAAS,IAAAnyC,kCACXrZ,GACA,GACA,GAEEmrB,EAAMqgC,EAAOnyB,EAAa,EAAImyB,EAAOtrD,OAAS,GAC9C2Y,EAA0C,QAAlC,EAAQ,QAAR,EAAAsS,aAAG,EAAHA,EAAM,UAAE,eAAExV,SAAS/L,QAAQuhB,EAAI,WAAG,SAAK,EAErD,GAAIA,GAAOA,EAAI,IAAMtS,GAAS,EAAG,CACvB,mBAA6BsS,EAAG,GAA/BrU,EAAO,KAAEiE,EAAS,KAAEhU,EAAI,KACzB0kD,EAAcJ,IAAapyB,EAAMC,WAAaqyB,KAAkBlyB,EAKhEqyB,EA8DtB,SACIC,EACA5kD,EACAgU,EACAwwC,GAEA,IAAIzwB,EAAoC,KAExC,GAAkC,WAA9B6wB,aAAa,EAAbA,EAAe71C,aAEfglB,EAAS6wB,MACN,CAEH,IAAMx3C,EAASpN,EAAK,GAAGoN,OACjBy3C,EAAYz3C,EAAOvK,QAAQmR,GAC3B8wC,EACFD,GAAa,EAAIz3C,EAAOo3C,EAAeK,EAAY,EAAIA,EAAY,GAAK,KAE9C,WAA1BC,aAAW,EAAXA,EAAa73C,aACb8mB,EAAS+wB,E,CAIjB,IAAMH,EAAkB5wB,EAClBywB,EACIzwB,EAAO1c,QAAQ0tC,uBACfhxB,EAAO1c,QAAQ2tC,mBACnB,KAEN,OAAO,IAAAntC,cAAa8sC,EAAiB,kBACjC,IAAA5V,mBAAkB4V,EAAiBH,GACjCG,EACA,IACV,CA/FwCM,CAJFP,EAChB30C,EACAiE,EAAUpF,SAAS41C,EAAe1yC,EAAQ,EAAIA,EAAQ,GAIxD9R,EACAgU,EACAwwC,GAGJ,GAAIG,EAAiB,CACjB,IAAMpmB,EAqB1B,SACI2mB,EACAR,EACAF,EACAG,EACAL,GAEA,IAAM/lB,EAAW2mB,EAAcC,aAuB/B,OArBIT,EACIF,EACAjmB,EAAS6mB,aAAaT,GAEtBpmB,EAAS8mB,cAAcV,IAGvBH,EACAjmB,EAASnB,eAAeunB,GAExBpmB,EAASlB,YAAYsnB,GAEpBL,IACGE,EACAjmB,EAAS6mB,aAAaT,GAEtBpmB,EAAS8mB,cAAcV,KAK5BpmB,CACX,CApDqC+mB,CACbpzB,EACAwyB,EACAF,EACAG,EACAL,GAGJ/8B,EAAO8K,gBAAgB,CACnBzb,KAAM,QACNsb,MAAOqM,EACPjM,YAAYiM,EAASpM,WAAoBG,G,EAKrD,OAAO,CACX,G,CAER,C,wRCxFA,WACA,WACA,WA4BMizB,EAAkB,wBAClBC,EAAiB,uBACjBC,EAAoB,IAAMD,EAAiB,KAAOD,EAClDG,EAAiB,IAOvB,SAAgBC,EAAuBhlD,EAAmB4mB,GACtD,IACMq+B,EADUjlD,EAAKklD,UAAUjuC,SAAS4tC,GACR7kD,EAAKokD,uBAAyBpkD,EAAKqkD,mBAC/DY,IAAiB,IAAAvX,iBAAgBuX,KACjCE,EACI,CAACF,EAAcb,uBAAwBa,EAAcZ,oBAAoBn2C,QACrE,SAAAkoB,GAAW,QAAEA,CAAF,KAGnBxP,EAAOE,oBAAmB,SAACxuB,EAAOwX,GAkB9B,OAjBA,IAAA2E,mBAAkBnc,GAAO,SAAC8sD,EAAOC,EAAep5C,EAAOq5C,GAC3B,cAApBr5C,aAAK,EAALA,EAAOK,YACPL,EAAMgC,SAASjQ,SAAQ,SAAAoR,GAEQ,QAAvBA,EAAQhB,aACRgB,EAAQZ,KAAKtM,QAAQ6iD,IAAmB,IAExC,IAAA9xC,eAAchH,EAAOmD,GAAS,SAAAA,GAC1BA,EAAQZ,KAAOY,EAAQZ,KAAKE,QAAQq2C,EAAgB,GACxD,GAER,GAER,IAEAj1C,EAAQ6Y,kBAAmB,GAEpB,CACX,IAER,CAwBA,SAASw8B,EAAwBI,GAC7BA,EAAMvnD,SAAQ,SAAAgC,GALlB,IAAoBokC,E,EAMZ,IAAK,IAAAltB,cAAalX,EAAM,gBAGxB,IAAI,IAAAouC,mBAAkBpuC,GAAO,CACzB,IAAMwlD,EAAUxlD,EAAKklD,UAAUjuC,SAAS2tC,GAClC5kD,EAAKqkD,mBACLrkD,EAAKokD,wBACL,IAAAltC,cAAasuC,EAAS,kBAAmB,IAAA9X,iBAAgB8X,IAZtD,QAAjB,EAAAphB,OADgBA,EAcOpkC,QAbrB,EAAFokC,EAAItG,qBAAa,SAAE5F,YAAYkM,E,MAqBnC,SAA6BpkC,EAAkCylD,GAC3D,QAD2D,IAAAA,IAAAA,GAAA,GACtDzlD,EAAL,CAIA,IACMilD,EADUjlD,EAAKklD,UAAUjuC,SAAS4tC,GACR7kD,EAAKokD,uBAAyBpkD,EAAKqkD,mBAC/DoB,GAAeR,IAAiB,IAAAvX,iBAAgBuX,KAIpDjlD,EAAKklD,UAAUQ,OAAOb,EAAgBD,GAEtC5kD,EAAK2lD,YACL3lD,EAAKqnC,WAAWrpC,SAAQ,SAAA4nD,G,QACdz0C,EAA+C,QAAvC,EAAc,QAAd,EAAAy0C,EAAGtnB,mBAAW,eAAEp8B,QAAQ6iD,UAAe,SAAK,EAC1D,GAAI5zC,GAAS,EAAG,CACZ,IAAMogB,EAAQ,IAAIiL,MAClBjL,EAAMwV,SAAS6e,EAAIz0C,GACnBogB,EAAMyV,OAAO4e,EAAIz0C,EAAQ,GACzBogB,EAAMs0B,gB,CAEd,I,CACJ,CA5BYC,CAAoB9lD,EAE5B,GACJ,CA2BA,SAAS+lD,EACLjvC,EACAkvC,G,cAEQz0B,EAAsBza,EAAS,MAAxB6a,EAAe7a,EAAS,WACnC9W,EAAoB2xB,EAAaJ,EAAMoV,eAAiBpV,EAAMsV,aAC9D3kB,EAASyP,EAAaJ,EAAMqV,YAAcrV,EAAMuV,UAEpD,GAAI9mC,EAAM,CACN,IAAMiwB,GAAM,IAAAg2B,cAAajmD,EAAMkiB,GAC/BliB,EAAOiwB,EAAIjwB,KACXkiB,EAAS+N,EAAI/N,M,CAGjB,IAAK,IAAAhL,cAAalX,EAAM,gBAWpBA,EAAOA,EAAKqnC,WAAW7uC,QAAU0pB,EAASliB,EAAOA,EAAKqnC,WAAWt4B,KAAKmT,OAXjC,CACrC,IAAMgkC,EAAcF,EACdjB,EAAiBiB,EACjBjB,EAGF/kD,EADAA,EAAKs+B,aAAe4nB,IAAgBlmD,EAAKs+B,aAAe,IAAI9lC,QAAU0pB,EACG,QAAlE,EAAgB,QAAhB,EAAAliB,EAAK2X,mBAAW,QAAsB,QAAlB,EAAA3X,EAAK89B,qBAAa,eAAEqoB,QAAQrB,UAAkB,QAAI,KAEvB,QAA/C,EAAmB,QAAnB,EAAA9kD,aAAI,EAAJA,EAAM89B,qBAAa,eAAEqoB,QAAQrB,UAAkB,QAAI,I,CAQlE,OAHI9kD,IAASA,EAAKomD,kBACdpmD,EAAOA,EAAK2X,cAET,IAAAT,cAAalX,EAAM,gBAAkBA,EAAO,IACvD,CAhIA,2BAqIA,8CAAmD4mB,GAC/C,IAAMy/B,EAASz/B,EAAOkE,eACtBq6B,EAAwBkB,EAAOC,cAAcxB,IAvGjD,SACIS,EACAn5C,GAEA,GAAIm5C,EAAM/sD,OAAS,EAAG,CAClB,IAAM,GAAU,IAAAi+B,2BAChB8uB,EAAMvnD,SAAQ,SAAAgC,IAEN,IAAAkX,cAAalX,EAAM,kBACnB,IAAA0tC,iBAAgB1tC,KACfA,EAAKg9B,oBAEN,IAAAupB,eAAcvmD,EAAKq8B,cAAer8B,EAAqBoM,EAAQ,EAEvE,G,CAER,CAwFIo6C,CAAsBH,EAAOC,cA7IJ,gBA6IyC1/B,EAAOyD,mBAC7E,EAKA,qCAA0CzD,EAAiBwW,GACvD,IAAMtmB,EAAY8P,EAAOyE,kBAEzB,GAAuB,UAAnBvU,aAAS,EAATA,EAAWb,OAAmBa,EAAUya,MAAMC,UAAW,CACzD,IAAMxxB,EAAO+lD,EAAkBjvC,EAAWsmB,EAAMiB,SAASuN,OAGrD5rC,aAAI,EAAJA,EAAM0X,cACN,IAAAR,cAAalX,EAAK0X,WAAY,cAC9B1X,EAAKmd,QAAQ2nC,IACb9kD,EAAKs+B,aAAeymB,EAAiB3nB,EAAMiB,SAASuN,MAEpDoZ,EAAuBhlD,EAAM4mB,E,CAGzC,EAKA,uCAA4CA,EAAiBwW,G,MACnDtmB,EAAY8P,EAAOyE,kBAEzB,GAAKvU,GAA+B,SAAlBA,EAAUb,KAA5B,CAIA,IAAMooB,EAAWjB,EAAMiB,SACjB9M,EAAQza,EAAUya,MAClBv6B,EAAMqnC,EAASrnC,IAErB,OAAQA,GACJ,IAAK,QACD,IAAMqvD,EAASz/B,EAAOkE,eAChBsI,GAAS,IAAA0S,0BAAyBvU,EAAMoV,eAAgB0f,GAE1DjzB,IAAU,IAAAlc,cAAakc,EAAQ,iBAAmBizB,EAAOvK,eAAe1oB,IACxEqzB,EAA0B7/B,EAAQwM,EAAQiL,GAG9C,MAEJ,IAAK,YACL,IAAK,aACIA,EAASqoB,QAAWroB,EAASsoB,SAAYtoB,EAASuoB,SAEnB,QAAhC,EAAAhgC,EAAOiC,cAAciL,mBAAW,SAAEwsB,uBAAsB,YACpD,IAAAuG,6BAA4BjgC,EAAQ5vB,EAAKqnC,EAASslB,SACtD,IAEJ,MAEJ,SACQ,IAAAjD,kBAAiBriB,IAAa9M,EAAMC,WAQpD,SACI5K,EACA2K,EACAu1B,EACAzoB,G,MAEMgoB,EAASz/B,EAAOkE,eAEtB,GAAIg8B,IAAe,IAAA1Y,mBAAkB0Y,IAAgBT,EAAOvK,eAAegL,GAAc,CACrF,IAAMC,GAAuB,IAAAnL,iCAAgCkL,EAAaT,GACpEW,EAA2B,UAAjB3oB,EAASrnC,IAErB+vD,GAAwBV,EAAOvK,eAAeiL,IAC9BD,EAAY5B,UAAUjuC,SAAS4tC,GAG3CtzB,EAAMmzB,cAAcqC,GAEpBx1B,EAAMkL,eAAesqB,GAGzBx1B,EAAME,UAAS,GAEXu1B,GACA3oB,EAASwf,iBAGbj3B,EAAOE,mBAAmB,EAAAmgC,8BAA+B,CACrDpwB,kBAAmB,CACf5gB,KAAM,QACN0b,YAAY,EACZJ,MAAK,MAITy1B,EACApgC,EAAOE,oBAAmB,SAACxuB,EAAOwX,GAC9B,IAAMpR,GAAS,IAAAwoD,yBAAwB5uD,EAAOwX,GAM9C,OAJIpR,GACA2/B,EAASwf,iBAGNn/C,CACX,KAEAkoB,EAAOsC,eAGS,QAFhB,EAAAtC,EACKiC,cACAiL,mBAAW,SAAEwsB,uBAAsB,WAChC,OAAA0E,EAAuB8B,EAAalgC,EAApC,I,CAKxB,CA9DgBugC,CAAuBvgC,EAAQ2K,EAAOw0B,EAAkBjvC,GAAYunB,G,CAKpF,EA+Da,EAAA4oB,8BAAuD,SAAC3uD,EAAOwX,GAexE,OAdA,IAAA2E,mBAAkBnc,GAAO,SAAC8sD,EAAOC,EAAer5C,GAC5C,GAAgC,cAA5BA,aAAa,EAAbA,EAAeM,WAA0B,CACzC,IAAML,GAAQ,IAAAC,aAAYF,UAEnBC,EAAMwyB,WACb,IAAM7B,EAAkB3wB,EAAMgC,SAASmH,MAAK,SAAAxX,GAAK,MAAiB,mBAAjBA,EAAEwQ,WAAF,IACb,oBAAhCwuB,aAAe,EAAfA,EAAiBxuB,eACjBnC,EAAMuF,eAAgB,EAAH,eAAQorB,EAAgBxwB,QAC3C0D,EAAQ8X,kBAAmB,EAAH,eAAQgV,EAAgBxwB,SAEpDH,EAAMgC,SAASzO,SAAQ,IAAAqa,Y,CAE/B,KAEO,CACX,EAMa,EAAAqtC,wBAAiD,SAAA5uD,G,MACtD8uD,EACAC,EASJ,IAPA,IAAA5yC,mBAAkBnc,GAAO,SAAC+G,EAAMgmD,EAAep5C,GACnB,cAApBA,aAAK,EAALA,EAAOK,aACP86C,EAAyBn7C,EACzBo7C,EAAuBhoD,EAAK,GAEpC,IAE4C,aAAxCgoD,aAAoB,EAApBA,EAAsB76C,gBAEtB,OAAO,EAGX,GAAI46C,GAA0BC,EAAsB,CAChD,IAAMhwB,EAAc+vB,EAAuBn5C,SAASkT,WAChD,SAAA/R,GAAW,MAAuB,mBAAvBA,EAAQhB,WAAR,IAGf,GAAIipB,GAAe,EAAG,CAClB,IAAMiwB,GAAiB,IAAAp7C,aAAYk7C,GAC7BG,EAAsBD,EAAer5C,SAAShM,OAAOo1B,GAErD3R,GAA+C,IAAAnU,kBACjD,EACA+1C,EAAel7C,OACfk7C,EAAe91C,cACf81C,EAAe71C,YAIf61C,EAAer5C,SAASmE,OACpB,SAAApY,GAAK,MAAiB,mBAAjBA,EAAEoU,aAAqD,MAAjBpU,EAAEoU,WAAxC,KAETm5C,EAAoBn1C,OAAM,SAAApY,GAAK,MAAiB,mBAAjBA,EAAEoU,WAAF,MAE/BsX,EAAQzX,SAAS3L,MAAK,IAAAuX,UAASytC,EAAel7C,UAGlD,EAAAsZ,EAAQzX,UAAS3L,KAAI,4CAAIilD,IAAmB,IAE5C,IAAMC,EAAsBH,EAAqB56C,OAAOvK,QAAQolD,GAC5DE,GAAuB,IACvB,IAAAt7C,aAAYm7C,GAAsB56C,OAAOxK,OACrCulD,EAAsB,EACtB,EACA9hC,E,EAMhB,OAAO,CACX,EAEA,IAAM+gC,EAA4B,SAC9B7/B,EACAlQ,EACA2nB,GAEA,IAAMjyB,GAAS,IAAAyd,mBAAkBnT,GAC7BtK,EAAOod,IAAMpd,EAAO0d,aAAe1d,EAAO22C,cAC1Cn8B,EAAOkF,aAAa,kBAAmB,CACnChJ,UAAW,QACXsQ,OAAQ,CACJ5J,GAAIpd,EAAOod,GACXvT,KAAM7J,EAAO0d,WACbL,aAAcrd,EAAOqd,WACrB/S,QAAO,GAEX2nB,SAAUA,GAGtB,C,uGC5YA,2BAAgBilB,EAAgBntC,EAAuCsxC,GACnEtxC,EAAM1J,OAAOzO,SAAQ,SAAAiO,GACjB,OAAQA,EAAMK,WACV,IAAK,aACDg3C,EAAgBr3C,EAAOw7C,GACvB,MAEJ,IAAK,SACDA,EAASnlD,KAAK,CACV8wB,OAAQnnB,EACR6W,UAAW,cAEf,MAEJ,IAAK,YACD7W,EAAMgC,SAASjQ,SAAQ,SAAAoR,GACnB,OAAQA,EAAQhB,aACZ,IAAK,SACDq5C,EAASnlD,KAAK,CACV8wB,OAAQhkB,EACR0T,UAAW,cAEf,MAEJ,IAAK,UACDwgC,EAAgBl0C,EAASq4C,GAGrC,IACA,MAEJ,IAAK,QACDx7C,EAAMmB,KAAKpP,SAAQ,SAAAqP,GACf,OAAAA,EAAIC,MAAMtP,SAAQ,SAAAuP,GAAQ,OAAA+1C,EAAgB/1C,EAAMk6C,EAAtB,GAA1B,IAIhB,GACJ,C,2HC3CA,WACA,WACA,WAyBMC,EAGF,CACAx7B,gBAAiB,kBACjBxW,UAAW,QACX4K,WAAY,aACZC,SAAU,YAQd,aAUI,WAAY4oB,GAAZ,WATQ,KAAAviB,OAAyB,KAGzB,KAAA+gC,gBAA+B,KAOnC9lD,KAAKkoB,MAAQ,CACTuJ,eAAe,EAAF,eAAO6V,EAAO1zB,sBAC3B2U,cAAe,MAGnB,IAAMkJ,EAAgBzxB,KAAKkoB,MAAMuJ,cAE7BA,EAAchT,aACdgT,EAAchT,YAAa,IAAAsnC,qBAAoBt0B,EAAchT,aAGjEze,KAAKgmD,kBAAoB,IAAIpM,KAE7B,IAAAz+B,eAAc0qC,GAAoB1pD,SAAQ,SAAAhH,GAClC,EAAK+yB,MAAMuJ,cAAct8B,IACzB,EAAK6wD,kBAAkBhM,IAAI6L,EAAmB1wD,GAEtD,GACJ,CAyKJ,OApKI,YAAAo+C,QAAA,WACI,MAAO,QACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,EAEd/kB,KAAKkoB,MAAMuJ,eAAgB,IAAAw0B,wBACvBjmD,KAAKkoB,MAAMuJ,cACX1M,EAAOyK,iBAEf,EAOA,YAAAkkB,QAAA,WACI1zC,KAAK+kB,OAAS,IAClB,EAKA,YAAA6uB,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAQA,YAAAoqB,cAAA,SAAc/W,GACV,GAAKv7B,KAAK+kB,OAIV,OAAQwW,EAAMsE,WACV,IAAK,QAKL,IAAK,iBACD7/B,KAAKkmD,2BAA2B3qB,EAAMiB,SAASuN,MAC/C,MAEJ,IAAK,UACD,IAAMoc,EACFnmD,KAAK+kB,OAAOyK,iBAAiBstB,WA5GzB,gBA4GsCvhB,EAAMiB,SAASrnC,KACzD,IAAA2pD,mBAAkBvjB,EAAMiB,WACxBx8B,KAAKomD,qBACLpmD,KAAK8lD,gBAAkB,MAEvB9lD,KAAKgmD,kBAAkBK,KAAO,IAC7BF,IACG,IAAAtH,kBAAiBtjB,EAAMiB,WArH5B,WAsHKjB,EAAMiB,SAASrnC,MACnB6K,KAAKsmD,yBAAyBtmD,KAAK+kB,UAEnC,IAAAwhC,oBAAmBvmD,KAAK+kB,OAAQ/kB,KAAKkoB,MAAMuJ,eAG/C,MAEJ,IAAK,UACL,IAAK,iBACDzxB,KAAK8lD,gBAAkB,KAElB9lD,KAAKwmD,yBACNxmD,KAAKomD,qBAIrB,EAEQ,YAAAF,2BAAR,SAAmCnc,GAC3B/pC,KAAK+kB,QAAUglB,GAAQ/pC,KAAKkoB,MAAMK,iBAClC,IAAAk+B,oBACIzmD,KAAK+kB,OACLglB,EACA/pC,KAAKkoB,MAAMK,cAAche,OACzBvK,KAAKkoB,MAAMK,cAAcqgB,iBAE7B5oC,KAAKomD,qBAEb,EAEQ,YAAAA,mBAAR,WACIpmD,KAAKkoB,MAAMK,cAAgB,IAC/B,EAOQ,YAAAi+B,sBAAR,WACI,IAAI3pD,GAAS,EAEb,GAAImD,KAAKkoB,MAAMK,eAAiBvoB,KAAK+kB,OAAQ,CACzC,IAAM9P,EAAYjV,KAAK+kB,OAAOyE,kBACxBkG,EACiB,UAAnBza,aAAS,EAATA,EAAWb,OAAmBa,EAAUya,MAAMC,UAAY1a,EAAUya,MAAQ,KAC1E,EAAmB1vB,KAAKkoB,MAAMK,cAAcjX,YAA1CnT,EAAI,OAAEkiB,EAAM,SAEhBqP,GAASA,EAAMoV,gBAAkB3mC,GAAQuxB,EAAMqV,aAAe1kB,IAC9DxjB,GAAS,E,CAIjB,OAAOA,CACX,EAEQ,YAAAypD,yBAAR,SAAiCvhC,G,QACvB9P,EAAY8P,EAAOyE,kBACnBkG,EAA2B,UAAnBza,aAAS,EAATA,EAAWb,MAAkBa,EAAUya,MAAQ,KACvDg3B,EAAoC,QAArB,EAAAh3B,aAAK,EAALA,EAAOoV,sBAAc,QAAI,KAE9C,GAAI4hB,GAAgBA,GAAgB1mD,KAAK8lD,gBAAiB,CAEtD9lD,KAAK8lD,gBAAkBY,EAQvB,IANA,IAAMl1B,EAAYzM,EAAOkE,eACrBsL,GAA8B,IAAAlf,cAAaqxC,EAAc,gBACvDA,EACAA,EAAazqB,cACb,EAAkB,IAAI2d,I,aAGxB,GAAwB,QAApB,EAAArlB,EAAQiC,oBAAY,oBAApBjC,EAAuB,SAAU,CACjC,IAAM,EAAQA,EAAQhc,MAOtB,GANA,EAAKytC,kBAAkB7pD,SAAQ,SAAAhH,GACvB,EAAMA,IACN,EAAgB6kD,IAAI7kD,EAE5B,IAEI,EAAgBkxD,MAAQ,EAAKL,kBAAkBK,K,cACxC,E,CAIf,IAAI,IAAA7jB,gBAAejO,G,cAInBA,EAAUA,EAAQ0H,a,UAlBf1H,aAAO,EAAPA,EAAS0H,gBAAiBzK,EAAUyoB,eAAe1lB,EAAQ0H,gBAAgB,C,oEAqBlF,OAAO,C,CAEP,OAAO,CAEf,EACJ,EAtMA,GA6MA,8BAAmCqL,GAC/B,OAAO,IAAIqf,EAAarf,EAC5B,C,2HCzPA,WAiEA,SAASsf,EACL7hC,EACA0M,EACAo1B,GAEA,OAAO,EAAP,6CACOp1B,GACA1M,EAAOyD,oBACPq+B,EAEX,CAlEA,8BAAmC9hC,EAAiB0M,GAChD,IAAMxc,EAAY8P,EAAOyE,kBAEF,UAAnBvU,aAAS,EAATA,EAAWb,OAAmBa,EAAUya,MAAMC,WAC9C5K,EAAOE,oBAAmB,SAACxuB,EAAOwX,GA+C9B,OA9CA,IAAA2E,mBAAkBnc,GAAO,SAAC+G,EAAMuiB,EAAGvO,EAAWpF,GAC1C,IAAMqF,EAASrF,aAAQ,EAARA,EAAW,GAC1B,GAC4B,cAAxBoF,aAAS,EAATA,EAAW/G,YACY,oBAAvBgH,aAAM,EAANA,EAAQlF,aACV,CACE,IAAM3B,EAASpN,EAAK,GAAGoN,OACjBk8C,EAAal8C,EAAOjU,OACpByb,EAAaxH,EAAOvK,QAAQmR,GAElC,GACIA,EAAUorB,YACmB,GAA7BprB,EAAUpF,SAASzV,QACnB6a,EAAUpF,SAAS,IAAMqF,GACzBq1C,EAAa,GACb10C,GAAc00C,EAAa,EAC7B,CAOE,IAAMzJ,EAAgBzyC,EAAOwH,EAAa,GAEV,cAA5BirC,aAAa,EAAbA,EAAe5yC,aACfwD,EAAQ8X,iBAAmB6gC,EACvB7hC,EACA0M,EACAhgB,EAAOlH,Q,MAGRiH,EAAUpF,SAASmE,OAAM,SAAApY,GAAK,MAAiB,QAAjBA,EAAEoU,WAAF,MACrC0B,EAAQ8X,iBAAmB6gC,EACvB7hC,EACA0M,EACAhgB,EAAOlH,Q,CAMnB,OAAO,CACX,KAGO,CACX,GAER,C,2HC/DA,WA4GA,SAASw8C,EAAsDC,EAAoBC,GAC/E,IAAM/qD,GAAO,IAAAif,eAAc8rC,GACvBpqD,GAAS,EAQb,OANAX,EAAKC,SAAQ,SAAAhH,GACL6xD,EAAgB7xD,KAAS8xD,EAAU9xD,KACnC0H,GAAS,EAEjB,IAEOA,CACX,CA9FA,8BACIkoB,EACAglB,EACAp6B,EACAi5B,GAEA,IAAI7c,GAAY,EAEhBhH,EAAOE,oBACH,SAACxuB,EAAOwX,GAkEJ,OAjEA,IAAA2E,mBAAkBnc,GAAO,SAACspB,EAAGC,EAAI5V,EAAOgC,GACpC,GACwB,cAApBhC,aAAK,EAALA,EAAOK,YACa,IAApB2B,aAAQ,EAARA,EAAUzV,SACiB,mBAA3ByV,EAAS,GAAGG,YACd,CACE,IAAMkF,EAASrF,EAAS,GAClB,EAAQhC,EAAMgC,SAAS/L,QAAQoR,GAC/B,EAAkBrH,EAAMgC,SAAS,EAAQ,GAE/C,GAAoC,SAAhC,aAAe,EAAf,EAAiBG,aAAuB,CACxC,IAAM,EAAO,EAAgBI,KACvBu6C,EAAS,EAAKvF,QAAQ5X,EAAKpzC,OAAQozC,EAAKpzC,QAG9C,IAAIuwD,GAAUnd,GAlCnB,KAkC4BA,GAjCvB,KAiC6Cmd,KAErCv3C,IACCo3C,EAAoB,EAAgBx8C,OAAQoF,MAE7C,IAAAyB,eAAchH,EAAO,GAAiB,SAAAmN,GAClCA,EAAgB5K,KAAO,EAAKzR,UACxB,EACA,EAAKvE,OAASozC,EAAKpzC,OAE3B,KAEA,IAAAya,eAAchH,EAAOqH,GAAQ,SAACA,EAAQrH,GAClCqH,EAAOlH,QAAS,EAAH,eAAQoF,GAErB,IAAMgQ,GAAU,IAAAC,YAjDjC,KAkDqBmqB,EAjDhB,IAiDuDA,GAAI,gCAEpC,EAAgBx/B,QAChBoF,IAIXvF,EAAMgC,SAAShM,OAAO,EAAO,EAAGuf,IAChC,IAAA/I,yBAAwBxM,EAC5B,IAEA2hB,GAAY,GAIZ6c,IACCme,EAAoB38C,EAAMG,OAAQq+B,IACrC,CACE,IAAMue,GAAmB,IAAA98C,aAAYD,GAErCxT,OAAO0gB,OAAO6vC,EAAiB58C,OAAQq+B,GACvC7c,GAAY,C,GAK5B,OAAO,CACX,IAEIA,KACA,IAAAxc,uBAAsB9Y,GACtBwX,EAAQ6Y,kBAAmB,GAGxBiF,CACX,GACA,CACI5G,QAAS,sBAGrB,C,+GC1GA,eACA,WAUMiiC,EAA+B,kBAOrC,aAYI,WAAYzgC,EAAwB8rB,GAApC,WAXQ,KAAA1tB,OAAyB,KAEzB,KAAAsiC,YAAmC,KACnC,KAAAvM,SAAgC,KAU0B,OAA1DrI,EAAWjc,aAAa4wB,KACxBpnD,KAAKqnD,YAAc,WACf5U,EAAWX,gBAAkB,OAC7BW,EAAWl6B,MAAM+uC,WAAa,MAClC,EACAtnD,KAAK86C,SAAW,WACZrI,EAAWl6B,MAAM+uC,WAAa,GAC9B7U,EAAWrX,gBAAgBgsB,EAC/B,GAEJpnD,KAAKunD,YAAc5gC,EAAQ6gC,uBACrB,WAAO,EACP,WACI,EAAKC,qBAAqBhV,EAC9B,EAENzyC,KAAKkoB,MAAQ,CACTa,aAAcpC,EAAQ+gC,WACtB/jB,mBAAoB,KACpBwN,cAAe,CAAC,EAChBvL,sBAAuBjf,EAAQif,sBAEvC,CA0GJ,OArGI,YAAA2N,QAAA,WACI,MAAO,WACX,EAMA,YAAAC,WAAA,SAAWzuB,G,QACP/kB,KAAK+kB,OAASA,EAGE,QAAhB,EAAA/kB,KAAKqnD,mBAAW,cAAhBrnD,MAGAA,KAAKunD,cAGL,IAAMxZ,EAAgE,QAA3B,EAAA/tC,KAAKkoB,MAAM6lB,wBAAgB,QAAI,CACtE4Z,mBAAoB,GACpBC,qBAAsB,IAG1B5nD,KAAK+kB,OAAOkF,aAAa,cAAe8jB,GAAkB,UACnD/tC,KAAKkoB,MAAM6lB,iBAGlB/tC,KAAKkoB,MAAM8d,mBAAoB,IAAAC,uBAAsBlhB,EAAOiC,cAChE,EAKA,YAAA0sB,QAAA,e,IAAA,OACe,QAAX,EAAA1zC,KAAK+kB,cAAM,SAAEkF,aAAa,gBAAiB,CAAC,GAAG,IAE/C,IAAA9O,eAAcnb,KAAKkoB,MAAMipB,eAAeh1C,SAAQ,SAAAhH,G,MACtCo/B,EAAU,EAAKrM,MAAMipB,cAAch8C,GAEpB,QAArB,EAAAo/B,EAAQ0H,qBAAa,SAAE5F,YAAY9B,UAC5B,EAAKrM,MAAMipB,cAAch8C,EACpC,IAEA,IAAM6wC,EAAoBhmC,KAAKkoB,MAAM8d,kBAEjCA,IAC+B,QAA/B,EAAAA,EAAkB/J,qBAAa,SAAE5F,YAAY2P,UACtChmC,KAAKkoB,MAAM8d,mBAGlBhmC,KAAK86C,WACL96C,KAAK86C,WACL96C,KAAK86C,SAAW,KAChB96C,KAAKqnD,YAAc,MAGvBrnD,KAAK+kB,OAAS,IAClB,EAKA,YAAA6uB,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAMA,YAAAoqB,cAAA,SAAc/W,GAEa,kBAAnBA,EAAMsE,WACLtE,EAAMsO,QAAU,EAAAriB,aAAaqgC,kBAC1BtsB,EAAMsO,QAAU,EAAAriB,aAAasgC,mBAEjC9nD,KAAKunD,aAEb,EAEQ,YAAAE,qBAAR,SAA6BhV,GACzB,GAAIzyC,KAAK+kB,OAAQ,CACL,IAAAgE,EAAe/oB,KAAKkoB,MAAK,WAC3BwJ,EAAmB1xB,KAAK+kB,OAAOmE,mBAErC,IAAA6+B,UACItV,EArIS,WAuIT,EACA1pB,EACA2I,IAEJ,IAAAq2B,UACItV,EA3IS,WA6IT,EACA1pB,EACA2I,E,CAGZ,EACJ,EA9IA,GAsJA,iCACI4V,EACAmL,GAEA,OAAO,IAAIuV,EAAgB1gB,EAAQmL,EACvC,C,gMC7KA,eACA,WACA,WACA,WACA,WAuBMwV,EAAK,UACLC,EAAO,YACPx5B,EAAO,YACPC,EAAQ,aAMD,EAAAw5B,+BAAiC,UAIjC,EAAAC,8CAAgD,UAE7D,iBASI,WAAYzhC,GAAZ,I,IAAA,OARQ,KAAA5B,OAAyB,KAEzB,KAAA+1B,SAAgC,KAChC,KAAAuN,oBAA2C,KAC3C,KAAA54B,UAAW,EACX,KAAA64B,OAAQ,EACR,KAAAC,eAAyB,EAyMzB,KAAAC,YAAc,SAACjtB,G,UACnB,GAAI,EAAKxW,QAAU,EAAKmD,MAAMugC,eAAgB,CAC1C,IAAMC,IAAsB,EAAKxgC,MAAMugC,eAAeE,OAChDvc,EAAc7Q,EAAM5qB,OACpB6gB,EAAY,EAAKzM,OAAOkE,eAExByG,EAAQ,EAAK3K,OAAOiC,cAAcmV,cAClChnB,EAAY,EAAK+S,MAAMugC,eAAetzC,UACtC2a,EACFsc,EAAYwc,wBAAwBzzC,IAAc0zC,KAAKC,4BAEvDh5B,GACAJ,EAAMwV,SAASkH,EAAa,GAC5B1c,EAAMyV,OACFhwB,GACA,IAAAE,cAAaF,EAAW,aACS,QAA3B,EAAmB,QAAnB,EAAAA,EAAU+d,iBAAS,eAAEv8B,cAAM,QAAI,EAC/Bwe,EAAUqwB,WAAW7uC,UAG/B+4B,EAAMwV,SAAS/vB,EAAW,GAC1Bua,EAAMyV,OAAOiH,EAAa,IAI9B,IAAM2c,EAAar5B,EAAMqb,wBACnBie,EAAoB,EAAKC,oBAAoBF,EAAY5zC,EAAWqc,GAE1E,GAAIw3B,EAAmB,CACnB,IAAML,GAAS,IAAAO,gBACXF,EAAkB3a,YAClBjC,EACA5a,GAGAw3B,EAAkBz3C,OAAS,EAAK2W,MAAMugC,eAAel3C,QAErD,EAAK2W,MAAMugC,eAAiBO,EAC5B,EAAK9gC,MAAMugC,eAAeE,OAASA,QAAAA,OAAUpkD,GAGjD,IAAM4kD,EAAUR,GAAU,EAAKS,qBAAqBT,IAEhDD,GAAqBS,IACrB5tB,EAAMygB,gB,KAEoC,UAAV,QAA7B,IAAKj3B,OAAOyE,yBAAiB,eAAEpV,OAEtC,EAAKyb,gBACD,CACIzb,KAAM,QACNsb,MAAK,EACLI,WAAU,GAEd,EAAK5H,MAAMugC,e,CAI3B,EAMQ,KAAAjK,OAAS,WACb,EAAK6K,kBACT,EAqUQ,KAAAC,wBAA0B,SAC9B/tB,EACAguB,GAEA,IAAK,EAAKjB,QAAUiB,GAAgD,UAA3BA,EAAkBn1C,KACvD,OAAO,KAGX,IAAMzD,EAAS4qB,EAAM5qB,OACrB,OACI,IAAA0E,cAAa1E,EAAQ,kBACrB,IAAAuqB,iBAAgBvqB,EAAQ,SACxBA,EAAOkF,aAAe0zC,EAAkBpxC,MAEjCoxC,EAAkBpxC,MAEtB,IACX,EAEQ,KAAAqxC,QAAU,W,OACT,EAAKthC,MAAM+mB,qBAAuB,EAAK/mB,MAAMjT,WAC9C,EAAK4a,gBAAgB,EAAK3H,MAAMjT,UAAW,EAAKiT,MAAMugC,gBAGxB,UAAV,QAApB,IAAKvgC,MAAMjT,iBAAS,eAAEb,OAAoB,EAAKqb,WAE/C,EAAKvH,MAAMjT,UAAY,MAGvB,EAAKszC,gBAAkB,EAAKxjC,SACjB,EAAKA,OAAO0kC,qBACpBC,UAAY,EAAKnB,eACpB,EAAKA,eAAiB,EAE9B,EAEQ,KAAAoB,OAAS,WACb,GAAI,EAAK5kC,OAAQ,CACR,EAAKmD,MAAMjT,YACZ,EAAKiT,MAAMjT,UAAY,EAAK8P,OAAOyE,mBAEvC,IAAMogC,EAAK,EAAK7kC,OAAO0kC,qBACvB,EAAKlB,eAAiBqB,EAAGF,S,CAEjC,EAEQ,KAAAG,kBAAoB,W,MACxB,IAAe,QAAX,IAAK9kC,cAAM,eAAEyjB,cAAe,EAAKzjB,OAAO8uB,iBAAkB,CAC1D,IAAMjD,EAAe,EAAK7rB,OAAOyE,kBAG3BvU,EAAY,EAAK8P,OAAOiC,cAAc4jB,eAC5C,GAAI31B,GAAaA,EAAU+1B,UAAW,CAClC,IAAM7yB,GAAQ,IAAA2xC,0BAAyB70C,GACvC,GAA0B,UAAtB27B,aAAY,EAAZA,EAAcx8B,OAAoB+D,EASJ,WAAvBy4B,aAAY,EAAZA,EAAcx8B,OAAoB+D,GACzC,EAAK4M,OAAO8K,gBAAgB,CACxBzb,KAAM,QACN+D,MAAK,QAZgC,CACzC,IAAMuX,EAAQza,EAAU61B,WAAW,GACnC,EAAK/lB,OAAO8K,gBAAgB,CACxBzb,KAAM,QACNsb,MAAK,EACLI,WACI7a,EAAU+1B,WAAatb,EAAMsV,cAC7B/vB,EAAUg2B,aAAevb,EAAMuV,W,EAYrB,UAAtB2L,aAAY,EAAZA,EAAcx8B,OACV,EAAKqb,WACL,EAAKvH,MAAMjT,UAAY27B,E,CAIvC,EA5pBI5wC,KAAKkoB,MAAQ,CACTjT,UAAW,KACXwzC,eAAgB,KAChBpZ,0BACqC,QAAjC,EAAA1oB,EAAQ0oB,iCAAyB,QAAI,EAAA8Y,+BACzC/Y,8BAA+BzoB,EAAQ0oB,+BACjC9qC,EACA,EAAA4jD,+BACN1X,kCAC6C,QAAzC,EAAA9pB,EAAQ8pB,yCAAiC,QACzC,EAAA2X,8CACJ5X,sCAAuC7pB,EAAQ8pB,uCACzClsC,EACA,EAAA6jD,8CAEd,CAktBJ,OAhtBI,YAAA7U,QAAA,WACI,MAAO,WACX,EAEA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,GAET/kB,KAAKkoB,MAAMknB,+BAAiCpvC,KAAKkoB,MAAMmnB,4BACxDrvC,KAAKkoB,MAAMknB,8BAAgCrqB,EACtCmE,kBACA6gC,aAAa/pD,KAAKkoB,MAAMmnB,+BAA2B9qC,EAAW,YAIlEvE,KAAKkoB,MAAMsoB,uCACZxwC,KAAKkoB,MAAMuoB,oCAEXzwC,KAAKkoB,MAAMsoB,sCAAwCzrB,EAC9CmE,kBACA6gC,aACG/pD,KAAKkoB,MAAMuoB,uCACXlsC,EACA,eAIZ,IAAMylD,EAAMhqD,KAAK+kB,OAAOyK,iBAClByH,EAAWj3B,KAAK+kB,OAAOiC,cAE7BhnB,KAAKyvB,WAAau6B,EAAIv6B,SACtBzvB,KAAKsoD,QAAU0B,EAAI1B,MACnBrxB,EAAS0P,iBAAiB,kBAAmB3mC,KAAK6pD,mBAC9C7pD,KAAKyvB,SACLzvB,KAAK86C,SAAW96C,KAAK+kB,OAAOohB,eAAe,CACvCnhB,MAAO,CAAEuhB,eAAgBvmC,KAAKwpD,SAC9BjJ,KAAM,CAAEha,eAAgBvmC,KAAKw+C,UAGjCx+C,KAAK86C,SAAW96C,KAAK+kB,OAAOohB,eAAe,CACvCnhB,MAAO,CAAEuhB,eAAgBvmC,KAAKwpD,SAC9BS,KAAM,CAAE1jB,eAAgBvmC,KAAK2pD,QAC7BpJ,KAAM,CAAEha,eAAgBvmC,KAAKw+C,SAGzC,EAEA,YAAA9K,QAAA,W,QACe,QAAX,EAAA1zC,KAAK+kB,cAAM,SAAEiC,cAAc4f,oBAAoB,kBAAmB5mC,KAAK6pD,mBAEnE7pD,KAAK86C,WACL96C,KAAK86C,WACL96C,KAAK86C,SAAW,MAGI,QAAxB,EAAA96C,KAAKqoD,2BAAmB,cAAxBroD,MACAA,KAAKqoD,oBAAsB,KAE3BroD,KAAKqpD,mBACLrpD,KAAK+kB,OAAS,IAClB,EAEA,YAAA6uB,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAEA,YAAAoqB,cAAA,SAAc/W,G,MACV,GAAKv7B,KAAK+kB,OAIV,OAAQwW,EAAMsE,WACV,IAAK,YACD7/B,KAAKm/C,YAAYn/C,KAAK+kB,OAAQwW,EAAMiB,UACpC,MAEJ,IAAK,UACDx8B,KAAKq/C,YACL,MAEJ,IAAK,UACDr/C,KAAKkqD,UAAUlqD,KAAK+kB,OAAQwW,EAAMiB,UAClC,MAEJ,IAAK,iBACDx8B,KAAKkoB,MAAMugC,eAAiB,KAC5B,MAEJ,IAAK,SACIzoD,KAAK+kB,OAAOyjB,aACbxoC,KAAKuoD,eAAiBhtB,EAAMkP,gBAAgBif,WAEhD,MAEJ,IAAK,qBACuB,QAAxB,EAAA1pD,KAAKqoD,2BAAmB,cAAxBroD,MACIA,KAAKyvB,SACLzvB,KAAKqoD,oBAAsBroD,KAAK+kB,OAAOohB,eAAe,CAClDnhB,MAAO,CAAEuhB,eAAgBvmC,KAAKwpD,SAC9BjJ,KAAM,CAAEha,eAAgBvmC,KAAKw+C,UAGjCx+C,KAAKqoD,oBAAsBroD,KAAK+kB,OAAOohB,eAAe,CAClDnhB,MAAO,CAAEuhB,eAAgBvmC,KAAKwpD,SAC9BS,KAAM,CAAE1jB,eAAgBvmC,KAAK2pD,QAC7BpJ,KAAM,CAAEha,eAAgBvmC,KAAKw+C,UAKjD,EAEQ,YAAAW,YAAR,SAAoBp6B,EAAiByX,G,UAE7BrkB,EADElD,EAAY8P,EAAOyE,kBAczB,GATuB,UAAnBvU,aAAS,EAATA,EAAWb,OAjKC,GAkKXooB,EAAS0e,SAjKG,GAkKR1e,EAAS0e,QACLl7C,KAAKmqD,iBAAiB3tB,IACtBx8B,KAAKspD,wBAAwB9sB,EAAUvnB,KAEhDjV,KAAK6vB,gBAAgB,KAAuB,OAI3C1X,EACkC,QAA/B,EAAAnY,KAAKmqD,iBAAiB3tB,UAAS,QAC/Bx8B,KAAKspD,wBAAwB9sB,EAAUvnB,KAC3CkD,EAAMgjB,kBAENn7B,KAAK6vB,gBACD,CACIzb,KAAM,QACN+D,MAAOA,GAEX,UAXR,CAqBA,IAAIswC,EAJmB,UAAnBxzC,aAAS,EAATA,EAAWb,OA3LC,GA2LkBooB,EAAS0e,QACvCl7C,KAAK6vB,gBAAgB,KAAuB,MAIhD,IAAMlf,EAAS6rB,EAAS7rB,OAExB,GACIA,GAnMY,GAoMZ6rB,EAAS0e,SACRuN,EAAiBzoD,KAAKipD,oBAAoBt4C,EAAQA,EAAQoU,EAAOkE,iBACpE,CAGE,GAFAjpB,KAAKkoB,MAAMugC,eAAiBA,EAExBjsB,EAAS4tB,QAAU,EAAG,CACtB,IAAMzB,GAAS,IAAAO,gBACXT,EAAepa,YACf7R,EAAS7rB,OACToU,EAAOkE,gBAGP0/B,IAEAF,EAAeE,OAASA,EACxB3oD,KAAKopD,qBAAqBT,GAC1BnsB,EAASwf,iB,CAIO,QAAxB,KAAAh8C,KAAKkoB,OAAMmiC,qBAAa,iBACxBrqD,KAAKkoB,MAAMmiC,cAAgBtlC,EAAOohB,eAAe,CAC7CmkB,UAAW,CACP/jB,eAAgBvmC,KAAKwoD,c,EAIrC,EA8DQ,YAAAnJ,UAAR,WACIr/C,KAAKqpD,kBACT,EAMQ,YAAAa,UAAR,SAAkBnlC,EAAiByX,GAAnC,I,IAAA,OACUrnC,EAAMqnC,EAASrnC,IACf8f,EAAY8P,EAAOyE,kBACnB+gC,EAAMxlC,EAAOiC,cAAciL,YAEjC,OAAQhd,aAAS,EAATA,EAAWb,MACf,IAAK,QAUD,IATK,IAAAo2C,eAAchuB,IAAcA,EAASslB,WAAY7sC,EAAUkD,MAAM7C,aACtD,WAARngB,GACA6K,KAAKyqD,2BAA2B1lC,EAAQ9P,EAAUkD,OAClDqkB,EAASuiB,mBACM,WAAR5pD,GAA4B,cAARA,GAC3B6K,KAAKyqD,2BAA2B1lC,EAAQ9P,EAAUkD,UAKrD,IAAAqyC,eAAchuB,IAAaA,EAASslB,WACrC7sC,EAAUkD,QACTnY,KAAKyvB,SACR,CACE,IAAMC,EAAQza,EAAUkD,MAAMqiB,cAAc2B,cAC5CzM,EAAM0M,WAAWnnB,EAAUkD,OAC3BnY,KAAK6vB,gBACD,CACIzb,KAAM,QACNsb,MAAK,EACLI,YAAY,GAEhB,K,CAGR,MAEJ,IAAK,QACD,GAAI36B,GAAO8yD,GAAM9yD,GAAO+yD,GAAQ/yD,GAAOu5B,GAAQv5B,GAAOw5B,GAlU1D,OAkUmEx5B,EAAY,CACvE,IAAMo4B,EAAQtY,EAAUya,MAAMoV,eAC9B9kC,KAAKkoB,MAAMugC,eAAiBzoD,KAAKipD,oBAC7B17B,EACAA,EACAxI,EAAOkE,gBAGPjpB,KAAKkoB,MAAMugC,iBAAmBjsB,EAASkjB,mBA1UnD,OA2UgBvqD,GACA6K,KAAK0qD,uBAAuB1qD,KAAK2qD,UAAUnuB,IAC3CA,EAASwf,kBAETuO,SAAAA,EAAK9L,uBAAsB,WAAM,SAAKiM,uBAAuBv1D,EAA5B,I,CAI7C,MAEJ,IAAK,QAGD,GAAiC,MAA7B6K,KAAKkoB,MAAMugC,eAAwB,CAC3B,IAAAl3C,EAAsD0D,EAAS,MAAxD6M,EAA+C7M,EAAS,SAA9C8L,EAAqC9L,EAAS,YAAjC8M,EAAwB9M,EAAS,QAAxB+M,EAAe/M,EAAS,WAEjEo5B,GAAc,IAAAkB,iBAAgBh+B,GACpC,GAAI88B,EAAa,CACb,IAAMuc,EAAU,CAAEp/C,IAAKsW,EAAUe,IAAK9B,GAChC4nC,EAAS,CAAEn9C,IAAKuW,EAASc,IAAKb,GAGpChiB,KAAKkoB,MAAMugC,eAAiB,CACxBl3C,MAAK,EACL88B,YAAW,EACXuc,QAAO,EACPjC,OAAM,EACNxzC,WAAqD,QAA1C,OAAAs6B,sBAAqBpB,EAAauc,UAAQ,eAAEl/C,OAAQ6F,E,EAI3E,GAA6B,QAAzB,EAAAvR,KAAKkoB,MAAMugC,sBAAc,eAAEE,OAAQ,CAC3B,IAAA7G,EAAkBtlB,EAAQ,SAAhB,EAAQA,EAAQ,IAElC,IAAIslB,GAAa,GAAOpzB,GAAQ,GAAOC,GAU5BmzB,GAAa,GAAOmG,GAAM,GAAOC,EAG1B,SAAP,IAAmB,IAAArJ,kBAAiBriB,IACvC,GAAOyrB,GAAM,GAAOC,GAAQ,GAAOx5B,GAAQ,GAAOC,IAClD3uB,KAAK6vB,gBAAgB,KAAuB7vB,KAAKkoB,MAAMugC,gBACvD8B,SAAAA,EAAK9L,uBAAsB,WAAM,SAAKiM,uBAAuB,EAA5B,MALrC1qD,KAAK6qD,iCAAiC,GAAO5C,GAAM,EAAI,EAAG,GAC1DzrB,EAASwf,sBAZkC,CAC3C,IAAMruC,EAEF,QADA48C,aAAG,EAAHA,EAAKr4B,iBAAiBlyB,KAAKkoB,MAAMugC,eAAel3C,OAAO/G,WAG3DxK,KAAK6qD,iCACD,GACC,GAAOn8B,GAAQ,EAAI,IAAM/gB,GAAS,EAAI,IAE3C6uB,EAASwf,gB,GAa7B,EAEQ,YAAA2O,UAAR,SAAkBnuB,GACd,OAAOA,EAASslB,SAAW,UAAY,UAC3C,EAEQ,YAAA4I,uBAAR,SACIv1D,G,gBAEA,GAAK6K,KAAK+kB,QAAW/kB,KAAKkoB,MAAMugC,eAAhC,CAIA,IAAMxzC,EAAYjV,KAAK+kB,OAAOyE,kBACxBgI,EAAYxxB,KAAK+kB,OAAOkE,eAE9B,GAAuB,UAAnBhU,aAAS,EAATA,EAAWb,MAAiB,CAExB,MAEAa,EAAS,MAFA0a,EAAS,YAAEmV,EAAc,iBAAEE,EAAY,eAAE+F,EAAuB,0BACzEjb,EACA7a,EAAS,WACPsY,EAAQuC,EAAakV,EAAeF,EACpCtX,EAAmBsC,EAAagV,EAAiBE,EACjD8lB,EAAW9qD,KAAKipD,oBAAoBle,EAAyBxd,EAAOiE,GAE1E,IAAKs5B,EACD,OAGJ,IAAInC,GAAS,IAAAO,gBAAe4B,aAAQ,EAARA,EAAUzc,YAAa7gB,EAAKgE,GACpDu5B,GAAU,EACR,EAAyC/qD,KAAKkoB,MAAMugC,eAAlDpa,EAAW,cAAW2c,EAAK,UAAEz5C,EAAK,QAE1C,GAAIo3C,GAAUmC,EAASv5C,OAASA,EAAO,CACnC,GAAIo3C,EAAO9lC,KAAOmoC,EAAMnoC,KAAQ1tB,GAAO8yD,GAAM9yD,GAAO+yD,EA+B7C,GAAW,WAAP/yD,GAA2B,YAAPA,EAE3B,IADA,IAAM81D,EAAiB,WAAP91D,EAER+1D,EAAOD,GAAW,EAAI,EACtBz/C,EAAgB,QAAV,EAAAm9C,EAAOn9C,WAAG,QAAI,EACpBqX,GAAiB,QAAV,EAAA8lC,EAAO9lC,WAAG,QAAI,GAAKqoC,GAE9BroC,GAAOqoC,EACT,CACE,GAAIroC,EAAM,GAAKA,GAAOwrB,EAAY7iC,GAAK7U,OAAQ,CAE3C,IADA6U,GAAO0/C,GACG,EAAG,CACTlrD,KAAKyqD,2BAA2BzqD,KAAK+kB,OAAQ+lC,EAASv5C,OACtD,K,CACG,GAAI/F,GAAO6iC,EAAY13C,OAAQ,CAClCqJ,KAAKyqD,2BACDzqD,KAAK+kB,OACL+lC,EAASv5C,OACT,GAEJ,K,CAEJsR,EAAMooC,EAAU5c,EAAY7iC,GAAK7U,OAAS,EAAI,C,CAElD,IAAM+U,EAAO2iC,EAAY7iC,GAAKqX,GAE9B,GAAmB,iBAARnX,EAAkB,CACzBq/C,GAAU,EACV/qD,KAAKmrD,yBACDz/C,EACA,EACA1L,KAAK+kB,QACL,GAEJ4jC,EAAOn9C,IAAMA,EACbm9C,EAAO9lC,IAAMA,EACb,K,OAIR7iB,KAAKkoB,MAAMugC,eAAiB,SAvE2B,CACvD,IAAM97B,EAASx3B,GAAO8yD,GAAM,EAAI,EAC1BmD,EAAqD,QAAxC,OAAA3b,sBAAqBpB,EAAa2c,UAAM,eAAEt/C,KACzD2/C,EAAkC,KAItC,IAFA1C,EAAS,CAAEn9C,IAAKw/C,EAAMx/C,IAAMmhB,EAAQ9J,IAAKmoC,EAAMnoC,KAExC8lC,EAAOn9C,KAAO,GAAKm9C,EAAOn9C,IAAM6iC,EAAY13C,SAC/C00D,GAA8C,QAAzC,OAAA5b,sBAAqBpB,EAAasa,UAAO,eAAEj9C,OAAQ,OAE9C0/C,GACNzC,EAAOn9C,KAAOmhB,EAMlBgD,GAAa07B,EACbrrD,KAAKmrD,yBACDE,EACAl2D,GAAO8yD,EAAKoD,EAAG7lB,WAAW7uC,OAAS,EACnCqJ,KAAK+kB,SAEDsmC,KAAsB,GAAf1C,EAAOn9C,KAAam9C,EAAOn9C,KAAO6iC,EAAY13C,SAC7DqJ,KAAKyqD,2BACDzqD,KAAK+kB,OACLxT,EACU,GAAVob,EACU,GAAVA,E,CA+CRgD,IACCg5B,EAAO9lC,KAAOmoC,EAAMnoC,KAAO8lC,EAAOn9C,KAAOw/C,EAAMx/C,MAChDm9C,EAAOn9C,KAAO,GACdm9C,EAAOn9C,KAAO6iC,EAAY13C,OAAS,GACnCgyD,EAAO9lC,MAA8B,QAAvB,EAAAwrB,EAAYsa,EAAOn9C,YAAI,eAAE7U,QAAS,IAErC,QAAX,EAAAqJ,KAAK+kB,cAAM,SAAE2gB,SAAS,CAAEloB,eAAgB,4B,CAI3CmS,IAAag5B,GAAWoC,IACzB/qD,KAAKkoB,MAAMugC,eAAiBqC,EAC5B9qD,KAAKopD,qBAAqBT,G,EAGtC,EAEQ,YAAAwC,yBAAR,SACIz/C,EACA4/C,EACAvmC,EACAwmC,GAEA,IAAM77B,EAAQ3K,EAAOiC,cAAcmV,cACnC,GAAIovB,GAAa7/C,EAAKmK,YAAcnK,EAAK0sC,UAAW,CAChD,IAAMoT,EAAY9/C,EAAKmK,WACjB41C,EAAU//C,EAAK0sC,UAEfsT,GAAW,IAAAtH,cAAaoH,EAAW,GAEnCG,GAAS,IAAAvH,cAAaqH,EAASA,EAAQjmB,WAAW7uC,QAExD+4B,EAAMwV,SAASwmB,EAASvtD,KAAMutD,EAASrrC,QACvCqP,EAAMyV,OAAOwmB,EAAOxtD,KAAMwtD,EAAOtrC,QAER,KAArBqP,EAAM10B,YACN00B,EAAME,UAAS,E,KAEhB,CAEG,OAAmB,IAAAw0B,cAAa14C,EAAM4/C,GAApCntD,EAAI,OAAEkiB,EAAM,SAEpBqP,EAAMwV,SAAS/mC,EAAMkiB,GACrBqP,EAAME,UAAS,E,CAGnB5vB,KAAK6vB,gBACD,CACIzb,KAAM,QACNsb,MAAK,EACLI,YAAY,GAEhB,KAER,EAEQ,YAAA+6B,iCAAR,SAAyCe,EAAmBC,G,MACxD,IAA6B,QAAzB,EAAA7rD,KAAKkoB,MAAMugC,sBAAc,eAAEE,SAAU3oD,KAAK+kB,OAAQ,CAC5C,MAA0B/kB,KAAKkoB,MAAMugC,eAAnCE,EAAM,SAAEta,EAAW,cACrB7iC,EAAMm9C,EAAOn9C,IAAMogD,EACnB/oC,EAAM8lC,EAAO9lC,IAAMgpC,EAErBrgD,GAAO,GAAKA,EAAM6iC,EAAY13C,QAAUksB,GAAO,GAAKA,EAAMwrB,EAAY7iC,GAAK7U,QAC3EqJ,KAAKopD,qBAAqB,CAAE59C,IAAG,EAAEqX,IAAG,G,CAGhD,EAEQ,YAAA4nC,2BAAR,SACI1lC,EACAwP,EACAu3B,EACAC,GAEA,IAGIpI,EAHEr5B,EAAMvF,EAAOiC,cACbvpB,EAAS82B,EAAQjf,WACjBhG,EAAQ7R,IAAU,IAAAi4B,SAAQj4B,EAAO+nC,YAAYnlC,QAAQk0B,GAG3D,GAAI92B,GAAoB,OAAV6R,GAAkBA,GAAS,EAAG,CACxC,IAAMogB,EAAQpF,EAAI6R,cAEd4vB,IACCpI,EAAUmI,EAAQv3B,EAAQiuB,mBAAqBjuB,EAAQguB,0BACxD,IAAAltC,cAAasuC,EAAS,iBAEtBj0B,EAAMs8B,mBAAmBrI,GACzBj0B,EAAME,UAAS,KAEfF,EAAMwV,SAASznC,EAAQ6R,GAASw8C,EAAQ,EAAI,IAC5Cp8B,EAAME,YAGV5vB,KAAK6vB,gBACD,CACIzb,KAAM,QACNsb,MAAOA,EACPI,YAAY,GAEhB,K,CAGZ,EAEQ,YAAAq6B,iBAAR,SAAyB5uB,GACrB,IAAM5qB,EAAS4qB,EAAM5qB,OAErB,OAAO,IAAA0E,cAAa1E,EAAQ,kBAAmB,IAAAuqB,iBAAgBvqB,EAAQ,OACjEA,EACA,IACV,EAqFQ,YAAAs4C,oBAAR,SACIF,EACAkD,EACAz6B,GAEA,IAAIjgB,EACA88B,EACAuc,EAEJ,OACKr5C,EAAQigB,EAAU06B,2BAA2BnD,EAAY,WAC1Dx3C,EAAM4pB,oBACLkT,GAAc,IAAAkB,iBAAgBh+B,MAC9Bq5C,GAAU,IAAA1B,gBAAe7a,EAAa4d,EAASz6B,IAEzC,CAAEjgB,MAAK,EAAE88B,YAAW,EAAEuc,QAAO,EAAEz1C,UAAW82C,GAE1C,IAEf,EAEQ,YAAA7C,qBAAR,SAA6BT,GACzB,GAAI3oD,KAAKkoB,MAAMugC,gBAAkBzoD,KAAK+kB,OAAQ,CACpC,MAMF/kB,KAAKkoB,MAAMugC,eALXl3C,EAAK,QACLq5C,EAAO,UACPvc,EAAW,cACXl5B,EAAS,YAIb,GAHiB,UAGJy1C,EAAQp/C,KAAOm9C,EAAOn9C,KAAOo/C,EAAQ/nC,KAAO8lC,EAAO9lC,IAe5D,OAdA7iB,KAAKkoB,MAAMugC,eAAeE,OAASA,EACnC3oD,KAAK6vB,gBACD,CACIzb,KAAM,QACN7C,MAAK,EACLuQ,SAAU8oC,EAAQp/C,IAClBuV,YAAa6pC,EAAQ/nC,IACrBd,QAAS4mC,EAAOn9C,IAChBwW,WAAY2mC,EAAO9lC,IACnB8sB,mBAAoB3vC,KAAKkoB,MAAMugC,gBAEnC,CAAEl3C,MAAK,EAAEq5C,QAAO,EAAEjC,OAAM,EAAEta,YAAW,EAAEl5B,UAAS,KAG7C,C,CAIf,OAAO,CACX,EAEQ,YAAA0a,gBAAR,SACI5a,EACAwzC,G,MAEW,QAAX,EAAAzoD,KAAK+kB,cAAM,SAAE8K,gBAAgB5a,GAC7BjV,KAAKkoB,MAAMugC,eAAiBA,CAChC,EAEQ,YAAAY,iBAAR,WACQrpD,KAAKkoB,MAAMmiC,gBACXrqD,KAAKkoB,MAAMmiC,gBACXrqD,KAAKkoB,MAAMmiC,mBAAgB9lD,EAEnC,EACJ,EA3uBA,GAkvBA,iCACIoiB,GAEA,OAAO,IAAIwlC,EAAgBxlC,EAC/B,C,sGCxxBA,0BACI0nB,EACA9Z,EACA/C,GAEA,IAAM65B,EAAK75B,EAAU06B,2BAA2B33B,EAX1B,SAYlB13B,EAAqC,KAsBzC,OAnBIwuD,GACAhd,EAAY/gC,MAAK,SAAC9B,EAAK0H,GACnB,IAAMD,EAAWo4C,EAAK7/C,EAAInL,QAAQgrD,IAA+B,EAEjE,OAAQxuD,EAASoW,GAAY,EAAI,CAAEzH,IAAK0H,EAAU2P,IAAK5P,GAAa,IACxE,IAICpW,GACDwxC,EAAY/gC,MAAK,SAAC9B,EAAK0H,GACnB,IAAMD,EAAWzH,EAAI8T,WACjB,SAAA5T,GAAQ,MAAe,iBAARA,GAAoBA,EAAK0J,SAASmf,EAAzC,IAGZ,OAAQ13B,EAASoW,GAAY,EAAI,CAAEzH,IAAK0H,EAAU2P,IAAK5P,GAAa,IACxE,IAGGpW,CACX,C,kHCrCA,eAKA,oCAAyCoY,GAC/B,MAaV,SACIA,GAEA,OAiBJ,SAAqBA,GACjB,QAAUA,EAAwB61B,UACtC,CAnBQshB,CAAYn3C,GACL,CACHE,UAAWF,EAAU8sC,WACrBsK,QAASp3C,EAAU+1B,UACnBjG,YAAa9vB,EAAUq3C,aACvBrnB,UAAWhwB,EAAUg2B,aAGlB,CACH91B,UAAWF,EAAU6vB,eACrBunB,QAASp3C,EAAU+vB,aACnBD,YAAa9vB,EAAU8vB,YACvBE,UAAWhwB,EAAUgwB,UAGjC,CA/B2DsnB,CAASt3C,GAAxDE,EAAS,YAAEk3C,EAAO,UAAEtnB,EAAW,cAAEE,EAAS,YAE5C3tC,EAAMD,KAAKC,IAAIytC,EAAaE,GAC5B7tC,EAAMC,KAAKD,IAAI2tC,EAAaE,GAElC,GAAI9vB,GAAak3C,GAAWl3C,GAAak3C,GAAW/0D,EAAMF,GAAO,EAAG,CAChE,IAAM+G,EAAOgX,aAAS,EAATA,EAAWqwB,WAAWt4B,KAAK9V,GACxC,IAAI,IAAAie,cAAalX,EAAM,kBAAmB,IAAA+8B,iBAAgB/8B,EAAM,OAC5D,OAAOA,C,CAGf,OAAO,IACX,C,sGClBA,eASMquD,EAAqB,CACvB,OACA,OACA,KACA,MACA,UACA,QACA,KACA,MACA,QACA,SACA,OACA,OACA,QACA,SACA,QACA,OAMJ,wBAA6BruD,EAAYkiB,G,YAC/BvjB,GAAM,IAAAuY,cAAalX,EAAM,aACH,QAAtB,EAAc,QAAd,EAAAA,EAAK+0B,iBAAS,eAAEv8B,cAAM,QAAI,EAC1BwH,EAAKqnC,WAAW7uC,OAGtB,IAFA0pB,EAAShpB,KAAKC,IAAID,KAAKD,IAAIipB,EAAQvjB,GAAM,GAElCqB,aAAI,EAAJA,EAAMi6C,WACT,GAAI/3B,GAAUliB,EAAKqnC,WAAW7uC,OAC1BwH,EAAOA,EAAKi6C,UACZ/3B,GAAS,IAAAhL,cAAalX,EAAM,aACA,QAAtB,EAAc,QAAd,EAAAA,EAAK+0B,iBAAS,eAAEv8B,cAAM,QAAI,EAC1BwH,EAAKqnC,WAAW7uC,WACnB,CACH,IAAM81D,EAAWtuD,EAAKqnC,WAAWnlB,GAEjC,IACI,IAAAhL,cAAao3C,EAAU,iBACvBD,EAAmBnsD,QAAQosD,EAASt8C,UAAY,EAEhD,MAEAhS,EAAOA,EAAKqnC,WAAWnlB,GACvBA,EAAS,C,CAKrB,MAAO,CAAEliB,KAAI,EAAEkiB,OAAM,EACzB,C,8GCvDA,IAEA,aAII,WAAYqsC,GAFJ,KAAAC,oBAA8B,EAGlC3sD,KAAK0sD,UAAYA,QAAAA,EAAa,CAC1BA,UAAW,GACXE,UAAW,EACXrwC,cAAe,EACfswC,mBAAoB,EACpBC,QAZW,IAcnB,CA0GJ,OAxGI,sBAAI,4BAAa,C,IAAjB,WACI,OAAO9sD,KAAK2sD,kBAChB,E,IAEA,SAAkB71D,GACdkJ,KAAK2sD,mBAAqB71D,CAC9B,E,gCAEA,YAAA+xB,QAAA,SAAQqiC,GACJ,IAAM6B,EAAW/sD,KAAK0sD,UAAUnwC,aAAe2uC,EAC/C,OAAO6B,GAAY,GAAKA,EAAW/sD,KAAK0sD,UAAUA,UAAU/1D,MAChE,EAEA,YAAAssC,KAAA,SAAKioB,G,QACGruD,EAA0B,KAU9B,OARImD,KAAK6oB,QAAQqiC,KACblrD,KAAK0sD,UAAUnwC,cAAgB2uC,EAC/BlrD,KAAK0sD,UAAUG,mBAAqB,EACpChwD,EAASmD,KAAK0sD,UAAUA,UAAU1sD,KAAK0sD,UAAUnwC,eAG7B,QAAxB,KAAAvc,KAAK0sD,WAAUM,iBAAS,gBAAG,QAEpBnwD,CACX,EAEA,YAAAwnC,YAAA,SAAYrB,EAAoBiqB,G,QACtBC,EAAkBltD,KAAK0sD,UAAUA,UAAU1sD,KAAK0sD,UAAUnwC,cAC1D4wC,EACFD,GACAA,EAAgBl1B,MAAQgL,EAAShL,OAChCk1B,EAAgBrpB,kBAChBb,EAASa,kBACTqpB,EAAgB5pB,eAChBN,EAASM,aACRe,GAAe6oB,GA+E7B,SAA2BA,EAA2BlqB,GAClD,OACIkqB,EAAgBl1B,OAASgL,EAAShL,MACjCk1B,EAAgBrpB,iBACbb,EAASa,iBACTtjC,KAAKC,UAAU0sD,EAAgBrpB,mBAC3BtjC,KAAKC,UAAUwiC,EAASa,mBAC9BqpB,EAAgBrpB,iBAAmBb,EAASa,iBAC7CqpB,EAAgB5pB,cACbN,EAASM,cACT4pB,EAAgB5pB,eAAiBN,EAASM,eAC5C4pB,EAAgB5pB,cAAgBN,EAASM,YAEnD,CA5FgDiG,CAAkB2jB,EAAiBlqB,GAE3E,GAAIhjC,KAAK0sD,UAAUnwC,aAAe,GAAK8nB,EAAa,CAChDrkC,KAAKotD,YACLptD,KAAK0sD,UAAUA,UAAUjsD,KAAKuiC,GAC9BhjC,KAAK0sD,UAAUnwC,eACfvc,KAAK0sD,UAAUE,WAAa5sD,KAAKqtD,kBAAkBrqB,GAGnD,IADA,IAAIsqB,EAAc,EAEdA,EAActtD,KAAK0sD,UAAUA,UAAU/1D,QACvCqJ,KAAK0sD,UAAUE,UAAY5sD,KAAK0sD,UAAUI,SAE1C9sD,KAAK0sD,UAAUE,WAAa5sD,KAAKqtD,kBAC7BrtD,KAAK0sD,UAAUA,UAAUY,IAE7BA,IAGAA,EAAc,IACdttD,KAAK0sD,UAAUA,UAAUtsD,OAAO,EAAGktD,GACnCttD,KAAK0sD,UAAUnwC,cAAgB+wC,EAE3BttD,KAAK0sD,UAAUG,mBAAqB,IACpC7sD,KAAK0sD,UAAUG,mBAAqBS,IAIxCL,IACAjtD,KAAK0sD,UAAUG,kBAAoB7sD,KAAK0sD,UAAUnwC,a,MAE/C4wC,GAEPntD,KAAK0sD,UAAUA,UAAUtsD,OAAOJ,KAAK0sD,UAAUnwC,aAAc,EAAGymB,GAG5C,QAAxB,KAAAhjC,KAAK0sD,WAAUM,iBAAS,gBAAG,MAC/B,EAEA,YAAAI,UAAA,W,QACI,GAAIptD,KAAK6oB,QAAQ,GAAI,CAEjB,IADA,IAAI0kC,EAAc,EAEVz0D,EAAIkH,KAAK0sD,UAAUnwC,aAAe,EACtCzjB,EAAIkH,KAAK0sD,UAAUA,UAAU/1D,OAC7BmC,IAEAy0D,GAAevtD,KAAKqtD,kBAAkBrtD,KAAK0sD,UAAUA,UAAU5zD,IAGnEkH,KAAK0sD,UAAUA,UAAUtsD,OAAOJ,KAAK0sD,UAAUnwC,aAAe,GAC9Dvc,KAAK0sD,UAAUE,WAAaW,EAC5BvtD,KAAK0sD,UAAUG,mBAAqB,EAEZ,QAAxB,KAAA7sD,KAAK0sD,WAAUM,iBAAS,gBAAG,Q,CAEnC,EAEA,YAAAQ,oBAAA,WACI,OACIxtD,KAAK0sD,UAAUG,mBAAqB,GACpC7sD,KAAK0sD,UAAUnwC,aAAevc,KAAK0sD,UAAUG,mBAAqB,CAE1E,EAEQ,YAAAQ,kBAAR,SAA0BrqB,G,QACtB,OAA4B,QAArB,EAAa,QAAb,EAAAA,EAAShL,YAAI,eAAErhC,cAAM,QAAI,CACpC,EACJ,EAtHA,GA6HA,kCAAuC+1D,GACnC,OAAO,IAAIe,EAAqBf,EACpC,C,0GCrIA,eACA,WACA,WAUMgB,EAAY,YACZC,EAAS,SACTC,EAAQ,QAKd,aAQI,WAAYjnC,GAPJ,KAAA5B,OAAyB,KAQ7B/kB,KAAKkoB,MAAQ,CACTkc,kBAAkB,IAAAypB,wBAAuBlnC,EAAQ+lC,WACjDrf,aAAa,EACb/D,UAAU,EACVc,wBAAyB,KACzB0jB,aAAc,KAEtB,CAmNJ,OA9MI,YAAAva,QAAA,WACI,MAAO,MACX,EAMA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,CAClB,EAKA,YAAA2uB,QAAA,WACI1zC,KAAK+kB,OAAS,IAClB,EAKA,YAAA6uB,SAAA,WACI,OAAO5zC,KAAKkoB,KAChB,EAMA,YAAAqqB,2BAAA,SAA2BhX,GACvB,QACMv7B,KAAK+kB,QACY,WAAnBwW,EAAMsE,WACNtE,EAAMiB,SAASrnC,KAAOu4D,IACrBnyB,EAAMiB,SAASsoB,SAChB9kD,KAAKwtD,oBAAoBxtD,KAAK+kB,OAEtC,EAMA,YAAAutB,cAAA,SAAc/W,GACV,GAAKv7B,KAAK+kB,OAIV,OAAQwW,EAAMsE,WACV,IAAK,cACD,IAAMpX,EAAUzoB,KAAKkoB,MAAMkc,iBACrBzb,EAAUF,EAAQG,eAAiBH,EAAQI,SAAS,GACpDC,EAAUL,EAAQI,QAAQ,GAE3BF,GAAYG,GAGb9oB,KAAKmjC,kBAET,MACJ,IAAK,UACDnjC,KAAKkqD,UAAUlqD,KAAK+kB,OAAQwW,EAAMiB,UAClC,MACJ,IAAK,WACDx8B,KAAK+tD,WAAW/tD,KAAK+kB,OAAQwW,EAAMiB,UACnC,MACJ,IAAK,iBACDx8B,KAAKguD,oBACLhuD,KAAKmjC,kBACL,MACJ,IAAK,iBACDnjC,KAAKiuD,iBAAiB1yB,GACtB,MACJ,IAAK,wBACDv7B,KAAKkuD,wBAAwB3yB,EAAMiB,UACnC,MAEJ,IAAK,YACGx8B,KAAKkoB,MAAMkc,iBAAiBxb,eAC5B5oB,KAAKmjC,kBAIrB,EAEQ,YAAA+mB,UAAR,SAAkBnlC,EAAiBopC,GACvB,IAAA/pB,EAAqBpkC,KAAKkoB,MAAK,iBAKvC,GAAKimC,EAAIh5D,KAAOu4D,IAAcS,EAAItJ,QAAWsJ,EAAIh5D,KAAOw4D,GACpD,GAAIQ,EAAIh5D,KAAOu4D,IAAcS,EAAIrJ,SAAW9kD,KAAKwtD,oBAAoBzoC,GACjEopC,EAAInS,kBACJ,IAAAtY,MAAK3e,GACL/kB,KAAKkoB,MAAMkiB,wBAA0B,KACrCpqC,KAAKkoB,MAAM4lC,aAAeK,EAAIh5D,SAC3B,IAAKg5D,EAAIzO,iBAAkB,CAC9B,IAAMzqC,EAAY8P,EAAOyE,mBAOrBvU,GACmB,SAAlBA,EAAUb,MACNa,EAAUya,MAAMC,WACjB3vB,KAAKkoB,MAAM4lC,cAAgBK,EAAIh5D,MAC/B6K,KAAKouD,oBAAoBrpC,EAAQopC,IAErCnuD,KAAKmjC,kBAITiB,EAAiBxb,eAAgB,EACjC5oB,KAAKkoB,MAAM4lC,aAAeK,EAAIh5D,G,OAE3B,IAAA2pD,mBAAkBqP,IAErB/pB,EAAiBxb,eACjB5oB,KAAKmjC,kBAETnjC,KAAKkoB,MAAM4lC,aAAe,MACnB9tD,KAAKkoB,MAAM4lC,cAAgBJ,GAAa1tD,KAAKkoB,MAAM4lC,cAAgBH,GACtEvpB,EAAiBxb,eACjB5oB,KAAKmjC,iBAGjB,EAEQ,YAAA4qB,WAAR,SAAmBhpC,EAAiBopC,GAChC,IAAIA,EAAIpJ,QAAR,CAMA,IAAM9vC,EAAY8P,EAAOyE,kBAGpBvU,IAAgC,SAAlBA,EAAUb,OAAoBa,EAAUya,MAAMC,YACjD,KAAXw+B,EAAIh5D,KAAyC,KAA3B6K,KAAKkoB,MAAM4lC,cAC9BK,EAAIh5D,KAAOy4D,GAEX5tD,KAAKmjC,kBAEDgrB,EAAIh5D,KAAOy4D,IAGX5tD,KAAKkoB,MAAMkc,iBAAiBxb,eAAgB,IAGhD5oB,KAAKguD,oBAGThuD,KAAKkoB,MAAM4lC,aAAeK,EAAIh5D,G,CAClC,EAEQ,YAAA+4D,wBAAR,SAAgC3yB,GAIxBA,EAAMpmC,KAAO6K,KAAKkoB,MAAM4lC,cACxB9tD,KAAKmjC,kBAGTnjC,KAAKkoB,MAAM4lC,aAAevyB,EAAMpmC,IAChC6K,KAAKkoB,MAAMkc,iBAAiBxb,eAAgB,CAChD,EAEQ,YAAAqlC,iBAAR,SAAyB1yB,GAChBv7B,KAAKkoB,MAAMmlB,aAAgB9R,EAAM2O,UAClClqC,KAAKguD,mBAEb,EAEQ,YAAAA,kBAAR,WACIhuD,KAAKkoB,MAAMkc,iBAAiBgpB,YAC5BptD,KAAKkoB,MAAM4lC,aAAe,KAC1B9tD,KAAKkoB,MAAMkc,iBAAiBxb,eAAgB,CAChD,EAEQ,YAAA4kC,oBAAR,SAA4BzoC,G,MAClB9P,EAAY8P,EAAOyE,kBAEzB,OACIxpB,KAAKkoB,MAAMkc,iBAAiBopB,uBACT,UAAnBv4C,aAAS,EAATA,EAAWb,OACXa,EAAUya,MAAMC,WAChB1a,EAAUya,MAAMoV,iBAAoD,QAAlC,EAAA9kC,KAAKkoB,MAAMkiB,+BAAuB,eAAEjsC,OACtE8W,EAAUya,MAAMqV,aAAe/kC,KAAKkoB,MAAMkiB,wBAAwB/pB,MAE1E,EAEQ,YAAA8iB,gBAAR,W,MACe,QAAX,EAAAnjC,KAAK+kB,cAAM,SAAEsC,eACbrnB,KAAKkoB,MAAMkiB,wBAA0B,IACzC,EAEQ,YAAAgkB,oBAAR,SAA4BrpC,EAAiBwW,GAGzC,OAFYxW,EAAOyK,iBAER84B,MAAQ/sB,EAAMwpB,QAAUxpB,EAAMupB,OAC7C,EACJ,EAnOA,GA0OA,4BAAiCxd,GAC7B,OAAO,IAAI+mB,EAAW/mB,EAC1B,C,+GC/PA,WACA,WAuCA,aAQI,WAAYmL,EAA4B9rB,GAAxC,I,EAAA,YAAwC,IAAAA,IAAAA,EAAA,IAPhC,KAAAyc,KAA0B,KAsZ1B,KAAAkrB,oBAA4C,SAACnwD,EAAMiW,GACvD,GAAY,SAARA,EAAJ,CAIA,IAAMvX,EAASsB,EAAKu8B,WAAU,GAE9B,GAAI,EAAK3R,aAAc,CACnB,IAAMwlC,EAAe,EAAKrlC,mBAE1B,IAAAsU,gBAAe3gC,GAAQ,EAAsB,cAAe0xD,EAAc,CACtE9wB,aAAc,EAAKC,6BAA6B,gCAGpD7gC,EAAO0b,MAAM3d,MAAQiC,EAAO0b,MAAM3d,OAAS,UAC3CiC,EAAO0b,MAAM8R,gBAAkBxtB,EAAO0b,MAAM8R,iBAAmB,S,CAGnE,OAAOxtB,C,CACX,EAjaImD,KAAKojC,MAAO,IAAAorB,kBAAiB/b,EAAY9rB,GAEzC,IAAM8nC,EACkB,QAApB,EAAA9nC,EAAQ8nC,oBAAY,SAAI,IAAA91B,kBAAiB34B,KAAKojC,KAAK74B,OAAOknB,eAE9DzxB,KAAKojC,KAAKU,IAAIkD,gBACVhnC,KAAKojC,KACLqrB,EACA,CAAE/kB,iBAAiB,QACnBnlC,GACA,GAEJvE,KAAKojC,KAAKgP,QAAQj2C,SAAQ,SAAAk2C,GAAU,OAAAA,EAAOmB,WAAW,EAAlB,GACxC,CAqZJ,OAhZI,YAAAE,QAAA,WAGI,I,MAFMtQ,EAAOpjC,KAAK0uD,UAET51D,EAAIsqC,EAAKgP,QAAQz7C,OAAS,EAAGmC,GAAK,EAAGA,IAAK,CAC/C,IAAMu5C,EAASjP,EAAKgP,QAAQt5C,GAE5B,IACIu5C,EAAOqB,S,CACT,MAAOsH,GAEmB,QAAxB,EAAA5X,EAAKurB,2BAAmB,cAAxBvrB,EAA2BiP,EAAQ2I,E,EAI3C5X,EAAK1R,iBAAiBk9B,QAEtB5uD,KAAKojC,KAAO,IAChB,EAMA,YAAAzZ,WAAA,WACI,OAAQ3pB,KAAKojC,IACjB,EAWA,YAAA3H,oBAAA,SAAoB2B,GAChB,IAAMgG,EAAOpjC,KAAK0uD,UAElB,OAAQtxB,GACJ,IAAK,YACL,IAAK,eACD,OAAO,IAAAiD,YACH+C,EAAKU,IAAIgD,mBAAmB1D,EAAM,CAC9B/Z,iBAAiB,IAErB,CACI8W,qBAAsBngC,KAAKsuD,sBAIvC,IAAK,QACD,IAAM1tB,GAAoB,IAAAmH,mCACtB3E,EAAKyE,YAAYlI,mBAAmBqI,WACpC5E,EAAKU,IAAIiD,oBAAoB3D,GAAM,IAGvC,OAAO,IAAA/C,aAAW,IAAAzrB,mBAAkBwuB,EAAKI,aAAc5C,GAAoB,CACvET,qBAAsBngC,KAAKsuD,sBAG3C,EAKA,YAAA9+B,eAAA,WACI,OAAOxvB,KAAK0uD,UAAU7mB,WAC1B,EAKA,YAAAre,gBAAA,WACI,IAAM4Z,EAAOpjC,KAAK0uD,UAElB,OAAOtrB,EAAKU,IAAIta,gBAAgB4Z,EACpC,EAMA,YAAAvT,gBAAA,SAAgB5a,GACZ,IAAMmuB,EAAOpjC,KAAK0uD,UAElBtrB,EAAKU,IAAIjU,gBAAgBuT,EAAMnuB,EACnC,EAMA,YAAAgyB,eAAA,SAAexD,GACX,IAAML,EAAOpjC,KAAK0uD,UAElBtrB,EAAKU,IAAImD,eAAe7D,EAAMK,EAClC,EAUA,YAAAxe,mBAAA,SACIgkB,EACAtiB,EACA6N,GAEA,IAAM4O,EAAOpjC,KAAK0uD,UAElBtrB,EAAKU,IAAI7e,mBAAmBme,EAAM6F,EAAWtiB,EAAS6N,EAC1D,EAKA,YAAAhM,iBAAA,W,QACI,OAAkD,QAA3C,EAAmC,QAAnC,EAAAxoB,KAAK0uD,UAAUnkD,OAAOge,qBAAa,eAAEhe,cAAM,QAAI,IAC1D,EAKA,YAAA0e,aAAA,WACI,OAAOjpB,KAAK0uD,UAAUl9B,SAC1B,EAMA,YAAAnK,aAAA,SAAaU,GACT,IAAMqb,EAAOpjC,KAAK0uD,UAElB,OAAOtrB,EAAKU,IAAIX,gBACZC,GACA,EACArb,EAAc,CAACA,QAAexjB,EAEtC,EAMA,YAAA2+B,gBAAA,SAAgBF,GACZ,IAAMI,EAAOpjC,KAAK0uD,UAElBtrB,EAAKU,IAAIoD,oBAAoB9D,EAAMJ,EACvC,EAMA,YAAAhc,YAAA,WACI,OAAOhnB,KAAK0uD,UAAU7mB,YAAY5Q,QACtC,EAKA,YAAAjS,MAAA,WACI,IAAMoe,EAAOpjC,KAAK0uD,UAClBtrB,EAAKU,IAAI9e,MAAMoe,EACnB,EAMA,YAAAoF,SAAA,WAEI,OADaxoC,KAAK0uD,UACNl9B,UAAUgX,UAC1B,EAWA,YAAAve,aAAA,SACI4V,EACAkK,EACAoI,QAAA,IAAAA,IAAAA,GAAA,GAEA,IAAM/O,EAAOpjC,KAAK0uD,UACZnzB,GAAS,eACXsE,UAAS,GACNkK,GAIP,OAFA3G,EAAKU,IAAI7Z,aAAamZ,EAAM7H,EAAO4W,GAE5B5W,CACX,EAMA,YAAA4K,eAAA,SAAeC,GACX,IAAMhD,EAAOpjC,KAAK0uD,UAClB,OAAOtrB,EAAKU,IAAIqC,eAAe/C,EAAMgD,EACzC,EAKA,YAAA1d,oBAAA,WAGI,OAFa1oB,KAAK0uD,UAENhrB,KAAKU,gBACrB,EAMA,YAAArb,WAAA,WACI,OAAO/oB,KAAK0uD,UAAUnrB,UAAUxa,UACpC,EAMA,YAAA8lC,iBAAA,SAAiB9lC,GACb,IAAMqa,EAAOpjC,KAAK0uD,YAEZ3lC,GAAcqa,EAAKG,UAAUxa,cAC/B,IAAAyU,gBACI4F,EAAKI,cACL,EACAza,EAAa,cAAgB,cAC7Bqa,EAAK1R,iBACL,CACI+L,aAAcz9B,KAAK09B,6BAA6B,gCAIxD0F,EAAKG,UAAUxa,aAAeA,EAE9Bqa,EAAKU,IAAI7Z,aACLmZ,EACA,CACIvD,UAAW,iBACXgK,OAAQ9gB,EACF,EAAAvB,aAAaqgC,iBACb,EAAArgC,aAAasgC,kBACnB5d,UAAU,IAEd,GAGZ,EAKA,YAAA2J,eAAA,WACI,QAAS7zC,KAAK0uD,UAAUnrB,UAAUI,kBACtC,EAUA,YAAAmrB,gBAAA,WACI,IAAM1rB,EAAOpjC,KAAK0uD,UAClBtrB,EAAKU,IAAIqD,iBAAiB/D,GAAM,EACpC,EAKA,YAAA2rB,eAAA,WACI,IAAM3rB,EAAOpjC,KAAK0uD,UAClBtrB,EAAKU,IAAIqD,iBAAiB/D,GAAM,EACpC,EAKA,YAAAla,gBAAA,WACI,OAAOlpB,KAAK0uD,UAAUh9B,gBAC1B,EASA,YAAAs9B,sBAAA,WACI,OAAOhvD,KAAK0uD,UAAUz2B,kBAC1B,EAQA,YAAAyJ,cAAA,WACI,OAAO1hC,KAAK0uD,UAAUltB,UAC1B,EAKA,YAAAioB,mBAAA,WACI,OAAOzpD,KAAK0uD,UAAUhkB,SAASD,eACnC,EAKA,YAAArD,mBAAA,WACI,OAAOpnC,KAAK0uD,UAAU5qB,IAAIsD,mBAAmBpnC,KAAK0uD,UACtD,EASA,YAAArnB,eAAA,SACIlyC,EACA47C,EACAC,GAEA,IAAM5N,EAAOpjC,KAAK0uD,UAElBtrB,EAAKU,IAAIuD,eAAejE,EAAMjuC,EAAK47C,EAASC,EAChD,EAMA,YAAAtL,SAAA,SAASv2B,GACL,IAAMi0B,EAAOpjC,KAAK0uD,UAElBtrB,EAAKU,IAAI4B,SAAStC,EAAMj0B,EAC5B,EAMA,YAAAuuB,6BAAA,SAA6BuxB,GACzB,OAAOjvD,KAAK0uD,UAAU18B,qBAAqB3xB,QAAQ4uD,IAAgB,CACvE,EAMU,YAAAP,QAAV,WACI,IAAK1uD,KAAKojC,KACN,MAAM,IAAI1sC,MAAM,8BAEpB,OAAOsJ,KAAKojC,IAChB,EAsBJ,EA3aA,GAAa,EAAA8rB,OAAAA,C,yGCxCb,eAqBA,aACI,WAAoBzc,EAAiC9rB,GAAjC,KAAA8rB,WAAAA,EAAiC,KAAA9rB,QAAAA,CAA+B,CAsKxF,OApKI,YAAA89B,cAAA,SAAcnuB,GACV,OAAO,IAAAZ,SAAQ11B,KAAKyyC,WAAW9c,iBAAiBW,GACpD,EAEA,YAAAgH,eAAA,WACI,OAAOt9B,KAAKyyC,WAAWhW,aAAe,EAC1C,EAEA,YAAAwd,eAAA,SAAe97C,EAAYgxD,GACvB,QAAOA,GAAehxD,GAAQ6B,KAAKyyC,aAAqBzyC,KAAKyyC,WAAWr9B,SAASjX,EACrF,EAEA,YAAA4zB,mBAAA,W,MACUq9B,GAAuD,QAAvC,EAAApvD,KAAKyyC,WAAWnH,+BAAuB,eAAEhzB,QAAS,EAClE+2C,EAAcrvD,KAAKyyC,WAAW6c,YAEpC,OAAOD,EAAc,GAAKD,EAAgB,EACpC/3D,KAAKqD,MAAO00D,EAAgBC,EAAe,KAAO,IAClD,CACV,EAEA,YAAAE,gBAAA,SAAgB/wD,EAAc1H,GACZ,OAAVA,EACAkJ,KAAKyyC,WAAWrX,gBAAgB58B,GAEhCwB,KAAKyyC,WAAWlc,aAAa/3B,EAAM1H,EAE3C,EAEA,YAAA04D,gBAAA,SAAgBhxD,GACZ,OAAOwB,KAAKyyC,WAAWjc,aAAah4B,EACxC,EAEA,YAAAixD,YAAA,SAAiDl3C,GAC7C,OAAOvY,KAAKyyC,WAAWl6B,MAAMA,EACjC,EAEA,YAAA2zC,2BAAA,SAA2BwD,EAAiBp5B,GACxC,IAAMq5B,GAAe,IAAAt6C,cAAaq6C,EAAW,gBACvCA,EACAA,EAAUzzB,cACV2zB,EAAiBt5B,EAChBq5B,aAAY,EAAZA,EAAcrL,QAAQhuB,GACvBq5B,EAEN,OAAOC,GACH5vD,KAAKi6C,eAAe2V,IACpBA,GAAkB5vD,KAAKyyC,WACrBmd,EACA,IACV,EAOA,YAAAC,wBAAA,SAAwBH,GAGpB,IAFA,IAAIvxD,EAAoBuxD,EAEjBvxD,GAAQ6B,KAAKi6C,eAAe97C,IAAO,CACtC,IAAI,IAAAkX,cAAalX,EAAM,kBAAmB,IAAAqkC,gBAAerkC,GACrD,OAAOA,EAGXA,EAAOA,EAAK89B,a,CAGhB,OAAOj8B,KAAKyyC,UAChB,EAEA,YAAAjK,SAAA,WACI,IAAMsnB,EAAgB9vD,KAAKyyC,WAAWjY,cAAcs1B,cACpD,SAAUA,IAAiB9vD,KAAKyyC,WAAWr9B,SAAS06C,GACxD,EAKA,YAAA1nB,cAAA,W,MACUqK,EAAazyC,KAAKyyC,WAClBl6B,EAA4C,QAApC,EAAAk6B,EAAWjY,cAAcvI,mBAAW,eAAEC,iBAAiBugB,GAErE,MAA2B,QAApBl6B,aAAK,EAALA,EAAO/N,UAClB,EAKA,YAAA+sB,eAAA,W,MACUkb,EAAazyC,KAAKyyC,WAClBl6B,EAA4C,QAApC,EAAAk6B,EAAWjY,cAAcvI,mBAAW,eAAEC,iBAAiBugB,GAC/DtnC,GAAc,IAAA0C,oBAAmB0K,aAAK,EAALA,EAAOpN,aACxCG,GAAe,IAAAuC,oBAAmB0K,aAAK,EAALA,EAAOjN,cAC/C,OAAOtL,KAAKyyC,WAAWsd,aAAe5kD,EAAcG,EACxD,EAKA,YAAAiyB,cAAA,WACI,OAAIv9B,KAAK2mB,QAAQqpC,qBACDhwD,KAAKyyC,WAAWjY,cAAcy1B,eAAeC,qBACvCC,WAAWnwD,KAAKyyC,YAAY,GAIvCzyC,KAAKyyC,WAAW/X,WAAU,EAEzC,EAOA,YAAA01B,mBAAA,SACIC,EACA3+B,G,QAEM4+B,EAAStwD,KAAKyyC,WAAWjY,cAAcvI,YAEvC1Z,EAAQ+3C,aAAM,EAANA,EAAQp+B,iBAAiBlyB,KAAKyyC,YAE5C,OAAOl6B,EACD,CACImG,SAAUnG,EAAMmG,SAChBD,WAAYlG,EAAMkG,WAClBqH,WAAYvN,EAAMuN,WAClBjS,WAAW,IAAA08C,UACPvwD,KAAKyyC,YACL,IACE4d,EACF3+B,EACAnZ,EAAM3d,OAEVyvB,iBAAiB,IAAAkmC,UACbvwD,KAAKyyC,YACL,IACE4d,EACF3+B,EACAnZ,EAAM8R,iBAEV4B,OAA2B,UAAnB1T,EAAMi4C,UACdC,cAAel4C,EAAMk4C,cACrBvqC,WAAY3N,EAAM2N,WAClBgG,cAAmC,QAApB,EAAA3T,EAAMm4C,sBAAc,eAAEz1B,SAAS,gBAC9C9O,yBAA0B5T,EAAM0J,cAChChG,UAA+B,QAApB,EAAA1D,EAAMm4C,sBAAc,eAAEz1B,SAAS,cAE9C,CAAC,CACX,EAUA,YAAA01B,gBAAA,SAAgBhkD,EAAcikD,EAAoBC,GAC9C,OAAO,IAAAF,iBAAgB3wD,KAAKyyC,WAAY9lC,EAAMikD,EAAWC,GAAW,EACxE,EACJ,EAvKA,GA4KA,2BACIpe,EACA9rB,GAEA,YAFA,IAAAA,IAAAA,EAAA,IAEO,IAAImqC,EAAcre,EAAY9rB,EACzC,C,gHCtMA,eAOA,aACI,WACqBzR,EACV60C,EACSgH,EACTC,GAHU,KAAA97C,KAAAA,EACV,KAAA60C,aAAAA,EACS,KAAAgH,YAAAA,EACT,KAAAC,iBAAAA,CACR,CA+BP,OA7BI,YAAAtlB,iBAAA,SAAiB3iB,EAAqB5zB,EAAc87D,GAApD,WACQ97D,GAAO87D,GAIFjxD,KAAK+wD,YAAY57D,KAClB6K,KAAK+wD,YAAY57D,GAAO87D,GAGxBloC,GACA/oB,KAAKkV,KAAKqD,MAAMnN,YAAYjW,EAAK87D,EAAUC,gBAM3CnoC,GACAnyB,OAAOsF,KAAK8D,KAAK+wD,aAAa50D,SAAQ,SAAAhH,GAClC,EAAK+f,KAAKqD,MAAMnN,YAAYjW,EAAK,EAAK47D,YAAY57D,GAAK+7D,cAC3D,GAGZ,EAEA,YAAAtC,MAAA,sBACIh4D,OAAOsF,KAAK8D,KAAK+wD,aAAa50D,SAAQ,SAAAhH,GAClC,EAAK+f,KAAKqD,MAAM44C,eAAeh8D,EACnC,GACJ,EACJ,EArCA,GA0CA,kCACI+f,EACA60C,EACAgH,EACAC,GAEA,YAHA,IAAAD,IAAAA,EAAA,SACA,IAAAC,IAAAA,EAA2C,EAAAI,yBAEpC,IAAIC,EAAqBn8C,EAAM60C,EAAcgH,EAAaC,EACrE,C,gJCxDA,WACA,WACA,WACA,WACA,WACA,WAyDA,SAASM,EACL7e,EACA9rB,G,UAEM4qC,EAAgD,QAApC,EAAA9e,EAAWjY,cAAcvI,mBAAW,eAAEs/B,UAClDC,EAAgC,QAApB,EAAAD,aAAS,EAATA,EAAWC,iBAAS,QAAI,GACpCC,EAAkC,QAArB,EAAAF,aAAS,EAATA,EAAWE,kBAAU,QAAI,GAE5C,MAAO,CACHx6B,SAAUwb,EAAWjY,cACrBmF,oBAAoB,IAAA+xB,0BAAyB/qC,GAC7CinB,oBAAoB,IAAA+jB,0BAAyBhrC,GAC7C2hC,OAAqC,GAA9BmJ,EAAWpxD,QAAQ,OAC1By8C,UAAW,WAAWtiC,KAAKg3C,GAC3BI,MAAO,cAAcp3C,KAAKg3C,GAC1B/hC,SACI+hC,EAAUnxD,QAAQ,gBAAkB,GACpCmxD,EAAUnxD,QAAQ,UAAY,GAC9BmxD,EAAUnxD,QAAQ,WAAa,EACnCwxD,iBAAkBC,EAAoBN,GAE9C,CAEA,SAASM,EAAoBN,GAIzB,SACI,sVAAsVh3C,KAClVg3C,KAEJ,0kDAA0kDh3C,KACtkDg3C,EAAUt2D,UAAU,EAAG,IAMnC,CAoBA,SAAgB62D,EAAqBn3D,GACjC,OAAOA,CACX,CAvGA,4BAAiC63C,EAA4B9rB,G,UACnDqrC,GAAc,IAAAC,yBAAwBtrC,EAAS8rB,GAC/CjR,GAAa,IAAAtJ,kBAAiBvR,EAAQsR,oBAE5C,OAAO,EAAP,4BACIuL,aAAciP,EACdhP,YAAagP,EACb3O,KAAK,EAAF,8BAAO,EAAA+C,YAAelgB,EAAQurC,iBACjCC,aAAa,EAAF,eAAO,EAAAtrB,YAClBuL,SAAS,EAAF,sCACH4f,EAAYzqB,MACZyqB,EAAYznD,OACZynD,EAAYxU,UACZwU,EAAYtnB,SACZsnB,EAAY/8C,UACZ+8C,EAAYzgC,S,aACO,QAAf,EAAA5K,EAAQyrB,eAAO,QAAI,IAAI/lC,QAAO,SAAAlU,GAAK,QAAEA,CAAF,MAAI,IAC3C65D,EAAYtuB,KACZsuB,EAAYlU,YACZkU,EAAYzuB,Y,GAEhBsE,YAAaypB,EAAwB7e,EAAY9rB,GACjD+K,kBAAkB,IAAA0gC,wBACd3f,EACoB,QAApB,EAAA9rB,EAAQojC,oBAAY,QAAIgI,EACxBprC,EAAQoqC,YACRpqC,EAAQqqC,kBAEZ/4B,mBACItR,EAAQsR,sBAAuB,IAAAo6B,cAAa1rC,EAAQsR,oBAC9CtR,EAAQsR,oBACR,IAAAq6B,0BAAyB9wB,GACnCA,WAAYA,EACZhQ,WAAW,IAAA6oB,iBAAgB5H,EAAY,CACnCud,qBAAkD,QAA5B,EAAArpC,EAAQqL,4BAAoB,eAAEiJ,SAAS,2BAiDzE,SAAwB+2B,GACpB,MAAO,CACHtnB,SAAUsnB,EAAYtnB,SAASkJ,WAC/B4J,UAAWwU,EAAYxU,UAAU5J,WACjCrM,MAAOyqB,EAAYzqB,MAAMqM,WACzBrpC,OAAQynD,EAAYznD,OAAOqpC,WAC3BrQ,UAAWyuB,EAAYzuB,UAAUqQ,WACjCriB,OAAQygC,EAAYzgC,OAAOqiB,WAC3B3+B,UAAW+8C,EAAY/8C,UAAU2+B,WACjCkK,YAAakU,EAAYlU,YAAYlK,WACrClQ,KAAMsuB,EAAYtuB,KAAKkQ,WAE/B,CA3DW2e,CAAeP,IAAY,CAC9BrD,oBAAqBhoC,EAAQgoC,oBAC7B7gB,aAAcnnB,EAAQmnB,aACtB9b,qBAAsBrL,EAAQqL,sBAAuB,EAAD,iCAAKrL,EAAQqL,uBAAoB,GAAI,IAEjG,EA4DA,wB,6ICxHA,eACA,WAkBA,oCACIrL,G,MAEMmhB,EAA4B,CAAC,EAC7BlI,EAA+D,QAAhC,EAAAjZ,EAAQ6rC,gCAAwB,QAAI,CAAC,EAE1E,MAAO,CACH1qB,QAAO,EACPlI,WAAU,EACVoI,YAAY,IAAAyqB,wBAAuB,CAAC3qB,EAASlI,IAErD,EAOA,oCACIjZ,G,MAEMmhB,EAA4B,CAC9B4qB,iBAAkB,CACdrlD,SAAU,EAAAslD,wBACVC,UAAW,EAAAC,2BAGbjzB,EAA+D,QAAhC,EAAAjZ,EAAQmsC,gCAAwB,QAAI,CAAC,EAE1E,MAAO,CACHhrB,QAAO,EACPlI,WAAU,EACVoI,YAAY,IAAA+qB,wBAAuB,CAACjrB,EAASlI,IAErD,C,gLCpDA,eAAS,wEAAAsvB,MAAM,IAGf,eAAS,qFAAA8D,mBAAmB,IAC5B,eAAS,+EAAAC,aAAa,IACtB,eAAS,sEAAAvvB,IAAI,IACb,eAAS,sEAAAwvB,IAAI,IACb,eAAS,uEAAA9W,KAAK,IAGd,eAAS,2DAAA19C,IAAA,oBAAAg+C,iBAAiB,G,gHCNb,EAAA5kB,0BAAsD,SAACvtB,EAAQgqB,GAEjD,OAAnBA,EAAQpkB,SAAuC,KAAnBokB,EAAQpkB,iBAC7B5F,EAAO+N,aACP/N,EAAO6Z,OAEtB,C,4ICXA,eAcM+uC,EAA6B,cAEnC,SAASC,EACLtkD,EACAyO,EACAL,GAEA,GAAgB,MAAZpO,EAAkB,CAClB,IAAMukD,GAAY,IAAA31C,yBAAwBH,EAAeL,QAAAA,EAAc,GACjEo2C,EAAW,EAAAC,oBAAoBh2C,GAErC,OAAO+1C,EAAWA,EAASzmD,QAAQsmD,EAA4BE,QAAa9uD,C,CAE5E,OAAO,EAAAivD,sBAAsBj2C,EAErC,CAEA,SAASk2C,EAAkBl2C,EAAuBzO,GAC9C,IAAMyJ,EACU,MAAZzJ,EACM,EAAAykD,oBAAoBh2C,GACpB,EAAAi2C,sBAAsBj2C,GAEhC,OAAOhF,aAAK,EAALA,EAAOlY,QAAQ,OAAQ,CAClC,CAKa,EAAAsyD,wBAGT,CACAe,mBAAoB,EAAAC,uBACpBC,gBAAiB,SAAChoD,EAAUrB,EAAQ0D,G,MAC1B4lD,EAAQ5lD,EAAQ6lD,WAAWh/C,UAAUne,OAAS,EAEpD,GAAIk9D,GAAS,EAAG,CACZ,IAAM/kD,EAA2D,QAAhD,EAAAb,EAAQ6lD,WAAWh/C,UAAU++C,EAAQ,GAAG/kD,gBAAQ,QAAI,KAC/DyO,GAAgB,IAAAD,sBAAqBxO,EAAUlD,QAAAA,EAAY,CAAC,EAAGioD,QAE/CtvD,IAAlBgZ,IACIk2C,EAAkBl2C,EAAezO,GACjCvE,EAAOgT,cAAgB61C,EACnBtkD,EACAyO,EACAtP,EAAQ6lD,WAAWC,iBAAiBF,WAGjCtpD,EAAOgT,c,CAI9B,GAMS,EAAAs1C,yBAGT,CACAa,mBAAoB,EAAAC,uBACpBC,gBAAiB,SAAChoD,EAAUrB,EAAQ0D,G,MAC1B4lD,EAAQ5lD,EAAQ6lD,WAAWh/C,UAAUne,OAAS,EAEpD,GAAIk9D,GAAS,EAAG,CACZ,IAAM/kD,EAA2D,QAAhD,EAAAb,EAAQ6lD,WAAWh/C,UAAU++C,EAAQ,GAAG/kD,gBAAQ,QAAI,KAC/DyO,GAAgB,IAAAD,sBAAqBxO,EAAUlD,QAAAA,EAAY,CAAC,EAAGioD,GAErE,QAAsBtvD,IAAlBgZ,EACA,GAAKk2C,EAAkBl2C,EAAezO,UAe3BvE,EAAOgT,kBAf+B,CAC7C,IAIMy2C,EAAsBZ,EACxBtkD,EACAyO,EALAtP,EAAQ6lD,WAAWC,iBAAiBF,GAAS,EACvC5lD,EAAQ6lD,WAAWC,iBAAiBF,GACpC,GAONG,IACAzpD,EAAOgT,cAAgBy2C,E,EAO3C,E,yICzGJ,eAQMC,EAAmB,UACnBC,EAAoB,OACpBC,EAAc,eAKP,EAAA94B,uBAAwC,SAAC5kC,EAAO0H,GACzD,IAAM6Y,EAAcvgB,EAEhBugB,GACAA,EAAYnC,SACa,UAAzBmC,EAAYvM,YACZ,IAAA4K,cAAalX,EAAM,kBACnB,IAAA+8B,iBAAgB/8B,EAAM,UACrB,IAAAqkC,gBAAexrB,EAAYnC,UAC5BmC,EAAYnC,QAAQ0D,MAAM2O,SAAWitC,GACrCn9C,EAAYnC,QAAQ0D,MAAMD,OAAS47C,IAEnC/1D,EAAKklD,UAAUrJ,IAAIia,GACnB91D,EAAKoa,MAAM2O,QAAU,QACrB/oB,EAAKoa,MAAMD,MAAQ,GAE3B,EAKa,EAAAyf,uBAAyD,SAAChY,EAAGwU,GAClEA,EAAQ8uB,UAAUjuC,SAAS6+C,KAC3B1/B,EAAQ8uB,UAAUQ,OAAOoQ,GACzB1/B,EAAQhc,MAAM2O,QAAUitC,EACxB5/B,EAAQhc,MAAMD,MAAQ47C,EAE9B,C,gHCrCa,EAAAv8B,yBAAwD,SAACptB,EAAQgqB,GAC1E,IAAMrN,EAAUqN,EAAQhc,MAAM2O,QAE1BA,GAAsB,QAAXA,IACX3c,EAAO2c,QAAUA,EAEzB,C,oHCXA,eAWMktC,EAAmE,CACrEn9C,UAAU,GAMd,sCACI0P,GAEA,IAAM0T,EAAc,EAAAzB,YAAYv3B,OAAOslB,EAAQiQ,uBACzC0D,EAAiB,EAAAzB,eAAex3B,OAAOslB,EAAQkQ,0BAC/CC,EAAkBlgC,OAAO0gB,OAAO,CAAC,EAAG88C,EAAwBztC,EAAQmQ,iBACpEu9B,EAAiB1tC,EAAQoQ,oBAE/B,OAAO,SAACziB,EAAOigB,EAAStmB,GACpB,IAAMssB,GAAmB,IAAAH,iBACrB7F,EACA8F,EACAC,EACAxD,EACAu9B,GAGA95B,GACAtsB,EAAQiI,yBAAyBqb,OAAOjd,EAAOimB,EAAkBtsB,EAEzE,CACJ,C,yICvCA,eACA,WAca,EAAAqmD,kBAAoC,SAAAx9D,GAC7C,MAAgB,QAATA,EAAkB,KAAOA,CACpC,EAEA,IAAMs9D,EAAmE,CACrEn9C,UAAU,EACViQ,QAAS,EAAAotC,mBAMb,uCACI3tC,GAEA,IAAM0T,EAAc,EAAAzB,YAAYv3B,OAAOslB,EAAQiQ,uBACzC0D,EAAiB,EAAAzB,eAAex3B,OAAOslB,EAAQkQ,0BAC/CC,EAAkBlgC,OAAO0gB,OAAO,CAAC,EAAG88C,EAAwBztC,EAAQmQ,iBACpEu9B,EAAiB1tC,EAAQoQ,oBAE/B,OAAO,SAACziB,EAAOigB,EAAStmB,GACpB,IAAM4X,EAAM0O,EAAQpkB,QAAQpR,cACtBw1D,EACFl6B,EAAYh6B,QAAQwlB,IAAQ,EACtB,SAACvR,EAAOigB,EAAStmB,G,QACPssB,GAAmB,IAAAhB,wBACrBhF,EAAQiG,cACRjG,EAAQpkB,QACRokB,EAAQiF,WACR1C,EACAu9B,IAGJ,IAAAv1B,gBAAevE,EAAkBhG,GACI,QAArC,KAAAtmB,EAAQiI,0BAAyB,YAAI,gBAAG5B,EAAOimB,EAAkBtsB,EACrE,EACAqsB,EAAej6B,QAAQwlB,IAAQ,OAC/BthB,EACA0J,EAAQiI,yBAAyBs+C,KAE3CD,SAAAA,EAAYjgD,EAAOigB,EAAStmB,EAChC,CACJ,C,4GCzDA,eAMa,EAAAupB,mBAA6C,SAACljB,EAAO3H,EAAMsB,G,QAC9D2pB,EAAa3pB,EAAQwlB,YAAYmE,YAEnC,IAAA68B,uBAAsB78B,KACtBjrB,EAAKumB,UAAoE,QAAxD,EAAc,QAAd,EAAAvmB,EAAKumB,iBAAS,eAAErmB,QAAQ,gBAAiB,aAAe,QAAI,IAGjFoB,EAAQiI,yBAAyB,SAAS5B,EAAO3H,EAAMsB,EAC3D,C,mHCPa,EAAA4pB,4BAA8D,SACvEttB,EACAgqB,EACAtmB,EACAymD,G,QATkB,OAWdngC,EAAQhc,MAAMqf,aACyB,QAAvC,KAAA3pB,EAAQ0mD,sBAAqB/8B,kBAAU,gBAAGrtB,EAAQgqB,EAAStmB,EAASymD,GAE5E,C,6GCbA,iCAAsCz9B,GAClC,IAAM0G,EAAM1G,EAAShQ,cAAc,OAanC,OAXA0W,EAAIplB,MAAMq8C,KAAO,2BACjBj3B,EAAIplB,MAAMs8C,SAAW,cACrBl3B,EAAIplB,MAAM6L,OAAS,MACnBuZ,EAAIplB,MAAM2gB,SAAW,SACrByE,EAAIplB,MAAMtB,SAAW,WACrB0mB,EAAIplB,MAAMqf,WAAa,SACvB+F,EAAIplB,MAAMD,MAAQ,MAClBqlB,EAAIuI,SAAW,YAEfjP,EAASmB,KAAKjR,YAAYwW,GAEnBA,CACX,C,6BCOA,SAAgB00B,EACZp6B,GAEA,MAA+D,mBAAhDA,EAAkCE,SACrD,C,+IApBa,EAAAm6B,yBAA2B,SAAC9wB,GACrC,OAAO,SAACxJ,GAAiB,OAAAwJ,EAAWrJ,UAAUH,GAAMI,KAAK+E,SAAhC,CAC7B,EAKA,4BAAiClF,GAC7B,OAAOA,GAAsBo6B,EAAap6B,GACpCA,EAoBV,SAAwCA,GACpC,IAAM68B,EAAU78B,GAAsB,EAAA88B,wBACtC,MAAO,CACH58B,UAAW,SAACH,GAAiB,WAAIg9B,WAAYC,gBAAgBH,EAAQ98B,GAAO,YAA/C,EAC7B2J,YAAa1J,EAErB,CAzBUi9B,CAA+Bj9B,EACzC,EAKA,iBASa,EAAA88B,wBAAoD,SAAC/8B,GAC9D,OAAOA,CACX,C,oHC9Ba,EAAAm9B,6BAAyD,CAClEl7D,EAAG,CACCgiB,WAAW,EACXpI,eAAWtP,GAEf6wD,WAAY,CACR52C,UAAW,MACXD,aAAc,MACdrT,WAAY,OACZG,YAAa,QAEjByI,KAAM,CACF2K,WAAY,aAEhB42C,GAAI,CACAnqD,WAAY,QAEhBoqD,GAAI,CACA92C,UAAW,MACXD,aAAc,OAElB+G,GAAI,CACAQ,WAAY,OACZpH,SAAU,OAEd6G,GAAI,CACAO,WAAY,OACZpH,SAAU,SAEd8G,GAAI,CACAM,WAAY,OACZpH,SAAU,UAEd+G,GAAI,CACAK,WAAY,OACZpH,SAAU,OAEdgH,GAAI,CACAI,WAAY,OACZpH,SAAU,UAEdiH,GAAI,CACAG,WAAY,OACZpH,SAAU,UAEdtlB,EAAG,CACColB,UAAW,MACXD,aAAc,OAElBg3C,IAAK,CACD92C,WAAY,YACZmZ,WAAY,MACZpZ,UAAW,MACXD,aAAc,OAElBi3C,GAAI,CACA1vC,WAAY,Q,4HC5Dd2vC,EAA6C,CAC/CvuC,QAAS,SAMA,EAAAwuC,oBAAuC,CAChDC,QAASF,EACTG,QAASH,EACTI,MAAOJ,EACPt+D,EAAG,CACC2uB,WAAY,QAEhBsvC,WAAY,CACRluC,QAAS,QACT1I,UAAW,MACXD,aAAc,MACdrT,WAAY,OACZG,YAAa,QAEjB8X,GAAIsyC,EACJ9rD,OAAQ,CACJud,QAAS,QACTrc,UAAW,UAEfwqD,GAAI,CAAEnuC,QAAS,QAAS4uC,kBAAmB,QAC3Cn4B,IAAK83B,EACLH,GAAI,CACApuC,QAAS,QACT1I,UAAW,MACXD,aAAc,OAElBw3C,GAAIN,EACJO,GAAI,CACAxF,UAAW,UAEfyF,SAAUR,EACVS,WAAYT,EACZU,OAAQV,EACRW,OAAQX,EACRY,KAAMZ,EACNnwC,GAAI,CACA4B,QAAS,QACTpB,WAAY,OACZpH,SAAU,OAEd6G,GAAI,CACA2B,QAAS,QACTpB,WAAY,OACZpH,SAAU,SAEd8G,GAAI,CACA0B,QAAS,QACTpB,WAAY,OACZpH,SAAU,UAEd+G,GAAI,CACAyB,QAAS,QACTpB,WAAY,QAEhBJ,GAAI,CACAwB,QAAS,QACTpB,WAAY,OACZpH,SAAU,UAEdiH,GAAI,CACAuB,QAAS,QACTpB,WAAY,OACZpH,SAAU,UAEd43C,OAAQb,EACRp7D,GAAIo7D,EACJ38D,EAAG,CACC03D,UAAW,UAEf+F,GAAI,CACArvC,QAAS,aAEbsvC,KAAMf,EACNgB,IAAKhB,EACLiB,IAAI,EAAF,8BAAOjB,GAAY,CAAEkB,mBAAoB,SAC3Cv9D,EAAG,CACC8tB,QAAS,QACT1I,UAAW,MACXD,aAAc,OAElBg3C,IAAK,CACDruC,QAAS,QACTzI,WAAY,YACZmZ,WAAY,MACZpZ,UAAW,MACXD,aAAc,OAElB5mB,EAAG,CACC+4D,eAAgB,gBAEpBkG,QAASnB,EACToB,OAAQ,CACJnG,eAAgB,gBAEpBoG,OAAQ,CACJhxC,WAAY,QAEhBggB,IAAK,CACD7jB,cAAe,MACfvD,SAAU,WAEdq4C,IAAK,CACD90C,cAAe,QACfvD,SAAU,WAEdnN,MAAO,CACH2V,QAAS,QACT8vC,UAAW,cAEf3L,GAAI,CACAnkC,QAAS,cAEbsuC,GAAI,CACAtuC,QAAS,aACTpB,WAAY,QAEhBmxC,EAAG,CACCvG,eAAgB,aAEpBwG,IAAI,EAAF,8BAAOzB,GAAY,CAAEkB,mBAAoB,S,sGC7HlC,EAAAQ,eAAiB,CAI1BC,IAAK,EAILC,KAAM,EAINC,KAAM,EAINC,OAAQ,EAIRC,WAAY,EAIZC,UAAW,EAIXC,cAAe,EAIfC,OAAQ,EAIRC,gBAAiB,EAIjBC,OAAQ,EAIRC,UAAW,GAIXC,SAAU,GAIVC,UAAW,GAIXC,IAAK,G,oGCvDI,EAAAzwC,aAAe,CAIxB0wC,SAAU,WAIVtsC,WAAY,aAIZke,OAAQ,SAIRquB,YAAa,cAIb92B,MAAO,QAIPqM,WAAY,aAIZmP,IAAK,MAIL6B,KAAM,OAINj3B,aAAc,eAIdogC,iBAAkB,mBAIlBC,kBAAmB,oBAInBsQ,UAAW,YAKXjuB,SAAU,WAKVkuB,WAAY,aAKZC,QAAS,U,0GC9DA,EAAAn3B,mBAAoE,CAC7E9W,gBAAiB,GACjB5L,WAAY,GACZC,SAAU,GACVoH,WAAY,GACZmG,QAAQ,EACRwkC,cAAe,GACfvqC,WAAY,GACZgG,eAAe,EACfC,yBAA0B,GAC1BtY,UAAW,GACXoI,WAAW,E,yGCbF,EAAAs8C,kBAAoB,CAI7BnB,IAAK,EAILoB,QAAS,EAITC,YAAa,EAIbC,mBAAoB,EAIpBC,yBAA0B,EAI1BC,WAAY,EAIZC,sBAAuB,EAIvBC,4BAA6B,EAI7BC,eAAgB,EAIhBC,WAAY,EAIZC,sBAAuB,GAIvBC,4BAA6B,GAI7BC,eAAgB,GAIhBC,WAAY,GAIZC,sBAAuB,GAIvBC,4BAA6B,GAI7BC,eAAgB,GAIhBC,WAAY,GAIZC,sBAAuB,GAIvBC,4BAA6B,GAI7BC,eAAgB,GAIhB1B,IAAK,G,mHC3FT,eAKa,EAAA1E,sBAAmB,MAC3B,EAAAgF,kBAAkBC,SAAU,UAC7B,EAAC,EAAAD,kBAAkBE,aAAc,gBACjC,EAAC,EAAAF,kBAAkBG,oBAAqB,gBACxC,EAAC,EAAAH,kBAAkBI,0BAA2B,iBAC9C,EAAC,EAAAJ,kBAAkBK,YAAa,cAChC,EAAC,EAAAL,kBAAkBQ,gBAAiB,oBACpC,EAAC,EAAAR,kBAAkBM,uBAAwB,oBAC3C,EAAC,EAAAN,kBAAkBO,6BAA8B,qBACjD,EAAC,EAAAP,kBAAkBS,YAAa,cAChC,EAAC,EAAAT,kBAAkBY,gBAAiB,oBACpC,EAAC,EAAAZ,kBAAkBU,uBAAwB,oBAC3C,EAAC,EAAAV,kBAAkBW,6BAA8B,qBACjD,EAAC,EAAAX,kBAAkBa,YAAa,cAChC,EAAC,EAAAb,kBAAkBgB,gBAAiB,oBACpC,EAAC,EAAAhB,kBAAkBc,uBAAwB,oBAC3C,EAAC,EAAAd,kBAAkBe,6BAA8B,qBACjD,EAAC,EAAAf,kBAAkBiB,YAAa,cAChC,EAAC,EAAAjB,kBAAkBoB,gBAAiB,oBACpC,EAAC,EAAApB,kBAAkBkB,uBAAwB,oBAC3C,EAAC,EAAAlB,kBAAkBmB,6BAA8B,qB,0GCtBxC,EAAAE,kBAAoB,CAI7BxC,IAAK,EASLyC,QAAS,EASTC,oBAAqB,EAQrBC,gBAAiB,EASjBC,cAAe,EASfC,0BAA2B,EAU3BC,cAAe,EAUfC,cAAe,EAQfC,cAAe,EAKfC,MAAO,EAKPpC,IAAK,E,qHCzFT,eAKa,EAAAzE,wBAAqB,MAC7B,EAAA2D,eAAeE,MAAO,OACvB,EAAC,EAAAF,eAAeI,QAAS,SACzB,EAAC,EAAAJ,eAAeU,QAAS,SACzB,EAAC,EAAAV,eAAeG,MAAO,OACvB,EAAC,EAAAH,eAAeM,WAAY,OAC5B,EAAC,EAAAN,eAAeS,iBAAkB,OAClC,EAAC,EAAAT,eAAeK,YAAa,OAC7B,EAAC,EAAAL,eAAeO,eAAgB,OAChC,EAAC,EAAAP,eAAeQ,QAAS,OACzB,EAAC,EAAAR,eAAea,WAAY,OAC5B,EAAC,EAAAb,eAAeY,UAAW,OAC3B,EAAC,EAAAZ,eAAeW,WAAY,O,oNCjBhC,WACA,WACA,UAoCA,SAAgB/vB,EACZuyB,EACA5lD,GAEA,OAAO9d,OAAO0gB,OACV,CAAC,EACD5C,EASG,CAAEke,eAAe,GAMjB,CACHa,aAd8B/e,aAAa,EAAbA,EAAeyd,WAWQ,CAAE3nB,UAAW,OAAU,CAAC,EAI7EmF,cAAe,CAAC,EAEhBmkD,WAAY,CACR3mD,OAAQ,GACR4mD,iBAAkB,KAMnB,CACH52D,KAAM,CACFoN,OAAQ,CAAC,EACTwE,QAAS,CAAC,GAEd+E,KAAM,CACFvJ,OAAQ,CAAC,GAEbgwD,eAAgB,CACZhwD,OAAQ,CAAC,EACT4F,QAAS,KAjCbmqD,EAER,CAwCA,SAAgB7H,EACZ9rC,GAEA,MAAO,CACH6zC,kBAAmB5jE,OAAO0gB,OAAM,MAAb1gB,QAAM,oBACrB,CAAC,EACD,EAAA6jE,sBAAmB,YAChB9zC,EAAQrrB,KAAI,SAAAnD,GAAK,OAAAA,aAAC,EAADA,EAAGgxB,iBAAH,MAAqB,IAE7CsP,cAAeiiC,EACX/zC,EAAQrrB,KAAI,SAAAnD,GAAK,OAAAA,aAAC,EAADA,EAAGu+B,oBAAH,IACjB/P,EAAQrrB,KAAI,SAAAnD,GAAK,OAAAA,aAAC,EAADA,EAAGw+B,uBAAH,KAErBzgB,yBAA0B,EAAAukD,oBAC1B9F,qBAAoB,uBACpB39B,0BAA2BrQ,EAAQrZ,MAAK,SAAAnV,GAAK,SAAEA,aAAC,EAADA,EAAG6+B,0BAAL,IAErD,CASA,SAAgB0jC,EACZC,EACAC,QADA,IAAAD,IAAAA,EAAA,SACA,IAAAC,IAAAA,EAAA,IAEA,IAAMC,EAAoBjkE,OAAO0gB,OAAM,MAAb1gB,QAAM,oBAAQ,CAAC,IAAC,YAAK+jE,IAAS,IAElD99D,GAAS,IAAAse,eAAc,EAAA2/C,8BAA8BruD,QACvD,SAAC5P,EAAQ1H,G,MACC2B,GAAQ,IAAAgkE,6BAA6B3lE,GACtCmG,KACG,SAAAy/D,GACI,YAAkCx2D,IAAjCs2D,EAAkBE,GACb,EAAApG,qBAAqBoG,GACrBF,EAAkBE,EAFxB,KAIP15D,OAAM,4CACAu5D,EAAuBt/D,KACtB,SAAA0/D,GAAO,MAAI,OAAe,QAAd,EAAAA,aAAO,EAAPA,EAAU7lE,UAAI,QAAI,EAA0B,MAC3D,IAKT,OAFA0H,EAAO1H,GAAO2B,EAEP+F,CACX,GACA,CACI8P,KAAM,KAUd,OANAiuD,EAAuBz+D,SAAQ,SAAA6+D,IACvBA,aAAO,EAAPA,EAASruD,QACT9P,EAAO8P,KAAO9P,EAAO8P,KAAKtL,OAAO25D,EAAQruD,MAEjD,IAEO9P,CACX,CA/HA,mCACI6X,G,IACA,wDAEA,OAAOqzB,EAAkC0qB,EAAuB9rC,GAAUjS,EAC9E,EAOA,sCAoDA,2BA0BA,sB,6GCpHA,eACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WAMa,EAAA+lD,oBAA2C,CACpDxgE,EAAG,EAAAghE,cACH9jE,EAAG,EAAA+jE,sBACH9F,WAAY,EAAA8F,sBACZ/3C,GAAI,EAAAg4C,YACJrnD,KAAM,EAAAsnD,cACN/F,GAAI,EAAAgG,yBACJC,IAAK,EAAAJ,sBACLv9B,IAAK,EAAAu9B,sBACL5F,GAAI,EAAA+F,yBACJtF,GAAI,EAAAsF,yBACJrF,GAAI,EAAAkF,sBACJK,KAAM,EAAAC,cACN1iE,EAAG,EAAAoiE,sBACHt8B,IAAK,EAAA68B,eACLn2C,GAAI,EAAAo2C,iBACJn2C,GAAI,EAAAm2C,iBACJl2C,GAAI,EAAAk2C,iBACJj2C,GAAI,EAAAi2C,iBACJh2C,GAAI,EAAAg2C,iBACJ/1C,GAAI,EAAA+1C,iBACJrhE,GAAI,EAAAshE,YACJpF,GAAI,EAAAqF,kBACJlF,GAAI,EAAAmF,cACJziE,EAAG,EAAA0iE,WACHvG,IAAK,EAAA8F,yBACL1jE,EAAG,EAAAujE,sBACHtE,QAAS,EAAAsE,sBACT1G,KAAM,EAAA0G,sBACNrE,OAAQ,EAAAqE,sBACRpE,OAAQ,EAAAoE,sBACRp1B,IAAK,EAAAo1B,sBACLnE,IAAK,EAAAmE,sBACL3pD,MAAO,EAAAwqD,eACP9E,EAAG,EAAAiE,sBACHhE,GAAI,EAAA2E,cAEJ,IAAK,EAAAG,iBACL,QAAS,EAAAC,cACTnpC,kBAAmB,EAAAopC,2BACnB3nC,QAAS,EAAA4nC,iBACT5qC,OAAQ,EAAA6qC,gBACRxmD,MAAO,EAAAymD,eACPvjB,UAAW,EAAAwjB,mB,2GCpEf,eACA,WASA,6BACIpnD,EACAjH,G,MAEMxX,GAAQ,IAAA8zB,4BAA2Btc,EAAQwjB,eAUjD,MAR+B,UAAV,QAAjB,EAAAxjB,EAAQgH,iBAAS,eAAEb,OAAmBnG,EAAQgH,UAAU6a,aACxDr5B,EAAM4gD,2BAA4B,GAGtCppC,EAAQusD,kBAAkB5kD,MAAMnf,EAAOye,EAAMjH,IAE7C,IAAAsB,uBAAsB9Y,GAEfA,CACX,C,uHCzBA,WACA,WACA,WACA,WAOM8lE,EAAuB,CAAC,IAAK,QAKnC,0BACIjoD,EACAigB,EACAtmB,EACA0B,G,MAEMC,EAAY3B,EAAQssD,eAAepqD,QAAUlC,EAAQssD,oBAAiBh2D,EACtEi4D,EAAqBD,EAAqBl8D,QAAQk0B,EAAQpkB,UAAY,GAE5E,IAAAqoB,aAAYjE,EAAStmB,EAAQwqB,cAAcruB,MAAO6D,EAAQwlB,YAAaxlB,GAEvE,IAAMwlB,GAAc,EAAH,eAAQxlB,EAAQwlB,aAUjC,IARA,IAAA+E,aAAYjE,EAAStmB,EAAQwqB,cAAcvmB,UAAWuhB,EAAaxlB,GAEnE,EAAAwuD,cAActgE,SAAQ,SAAAoc,GACdkb,EAAYlb,KACZtK,EAAQwlB,YAAYlb,GAASkb,EAAYlb,GAEjD,KAEKikD,EAAoB,CACrB,IAAMhrD,GAAY,IAAA9B,kBACd,EACA+jB,EACA9jB,EACAC,GAGgB,QAApB,EAAA3B,EAAQk6B,oBAAY,SAAEmM,oBAAoB/f,EAAS/iB,IAEnD,IAAAqF,UAASvC,EAAO9C,E,CAGpBvD,EAAQusD,kBAAkB5kD,MAAMtB,EAAOigB,EAAStmB,EACpD,C,oHClDA,WACA,WACA,WAMa,EAAAktD,YAA+C,SAAC7mD,EAAOigB,EAAStmB,G,MACnEkV,GAAK,IAAAnL,UAAS/J,EAAQ0B,eACtB,gBAAe,IAAA8F,4BAA2BxH,EAASsmB,GAAQ,GAA1DhH,EAAK,KAAEC,EAAG,KAEbD,GAAS,IACTtf,EAAQ2kB,eAAgB,GAGxB3kB,EAAQ2kB,gBACRzP,EAAG/V,YAAa,GAGpB,IAAMoE,GAAY,IAAAwP,YAAW1M,EAAO6O,EAAIlV,EAAQwlB,aAE5CjG,GAAO,IACPvf,EAAQ2kB,eAAgB,GAGV,QAAlB,EAAA3kB,EAAQ4jB,kBAAU,SAAEqkB,UAAU3hB,EAAS/iB,EAAW,CAAC2R,GACvD,C,mKC3BA,WACA,WACA,WAsCA,SAAgBlN,EACZ3B,EACAsB,EACA3H,IAGI,IAAAoH,cAAaO,EAAO,kBACI,QAAvBA,EAAM2C,MAAM2O,SAAqBjZ,EAAQ+oB,2BAE1C/oB,EAAQusD,kBAAkBjmC,QAAQjgB,EAAOsB,EAAO3H,IACzC,IAAAoH,cAAaO,EAAO,cAC3B3H,EAAQusD,kBAAkB,SAASlmD,EAAOsB,EAAO3H,EAEzD,CAWA,SAAgB+H,EACZ1G,EACArB,EACAqG,EACAoB,EACAC,EACAzD,G,MAEI5C,GAASoG,IACTzH,EAAQ2kB,eAAgB,GAExB,IAAAD,oBAAmBre,EAAOrG,EAASiE,EAAW5C,IAG9CA,GAASqG,GAA4C,UAAV,QAAjB,EAAA1H,EAAQgH,iBAAS,eAAEb,QACxCnG,EAAQgH,UAAUya,MAAMC,YACzB,IAAAgD,oBAAmBre,EAAOrG,EAASiE,EAAW5C,GAElDrB,EAAQ2kB,eAAgB,EAEhC,CArEa,EAAAypC,eAA+C,SACxD/nD,EACA7W,EACAwQ,GAKA,IAHM,oBAAmC,IAAAwH,4BAA2BxH,EAASxQ,GAAO,GAA7EiY,EAAe,KAAEC,EAAa,KACjCrG,EAAQ,EAEHsG,EAAQnY,EAAOoY,WAAYD,EAAOA,EAAQA,EAAME,YACrDE,EAAuB1G,EAAOrB,EAASqG,EAAOoB,EAAiBC,EAAelY,GAE9EwY,EAAiB3B,EAAOsB,EAAO3H,GAE/BqB,IAGJ0G,EAAuB1G,EAAOrB,EAASqG,EAAOoB,EAAiBC,EAAelY,EAClF,EAQA,qBAwBA,0B,uGChEA,eACA,WACA,WAMa,EAAA29D,cAA+C,SAAC9mD,EAAOigB,EAAStmB,IACzE,IAAAyuD,aAAYzuD,EAAS,CAAE6F,KAAM,gBAAiB,YAC1C,IAAA0kB,aAAYjE,EAAStmB,EAAQwqB,cAAc3kB,KAAM7F,EAAQ6F,KAAKvJ,OAAQ0D,IAEtE,IAAAitD,uBAAsB5mD,EAAOigB,EAAStmB,EAC1C,GACJ,C,4GCdA,eASa,EAAAquD,mBAA6C,SAAChoD,EAAOnW,EAAM8P,G,QAC9DyhB,EAAmC,UAAV,QAAjB,EAAAzhB,EAAQgH,iBAAS,eAAEb,MAAkBnG,EAAQgH,UAAUya,MAAQ,KAEzEA,IACIvxB,EAAKiX,SAASsa,EAAMoV,kBACpB72B,EAAQ2kB,eAAgB,GAExB,IAAAD,oBAAmBre,EAAOrG,IAGC,UAAV,QAAjB,EAAAA,EAAQgH,iBAAS,eAAEb,OAAmBjW,EAAKiX,SAASsa,EAAMsV,gBACrD/2B,EAAQgH,UAAUya,MAAMC,YACzB,IAAAgD,oBAAmBre,EAAOrG,GAG9BA,EAAQ2kB,eAAgB,GAGpC,C,0GC3BA,eAaa,EAAAupC,iBAAkD,SAAC7nD,EAAOigB,EAAStmB,GAC5E,IAAMkC,EAAUokB,EAAQpkB,QAAQpR,cAC1Bw1D,EAQV,SAAkChgC,EAAsBtmB,GACpD,OAAO,IAAA49B,iBAAgBtX,IAAuC,SAA3BA,EAAQud,gBACrC7jC,EAAQusD,kBAAkBjpC,OAC1B,IACV,CAZuBorC,CAAyBpoC,EAAStmB,IAczD,SAAqCsmB,EAAsBtmB,GACvD,OAAO,IAAAs+B,mBAAkBhY,GAAWtmB,EAAQusD,kBAAkB1hB,UAAY,IAC9E,CAfQ8jB,CAA4BroC,EAAStmB,IACrCA,EAAQusD,kBAAkBrqD,IACzBA,EAAQ9P,QAAQ,MAAQ,GAAK4N,EAAQusD,kBAAkB5kD,OACxD3H,EAAQusD,kBAAkB,KAC9BjG,EAAUjgD,EAAOigB,EAAStmB,EAC9B,C,yGCrBA,eACA,WACA,UACA,WACA,WACA,WASa,EAAAmuD,gBAAiD,SAAC9nD,EAAOigB,EAAStmB,GAC3E,IAAM4uD,GACF,IAAAr6B,gBAAejO,IACW,gBAAzBA,EAAQhc,MAAM2O,SAAoD,QAAvBqN,EAAQhc,MAAMD,OAE9D,IAAAokD,aACIzuD,EACA,CAAEV,QAASsvD,EAAgB,aAAUt4D,EAAWiN,UAAW,UAC3D,W,MACUwF,GAAc,IAAAoQ,cAAamN,GAAS,EAAqBtmB,EAAQ0B,eAQvE,IANA,IAAA6oB,aAAYjE,EAAStmB,EAAQwqB,cAAclH,OAAQva,EAAYod,aAAcnmB,GAEzEA,EAAQ2kB,gBACR5b,EAAY5J,YAAa,GAGzByvD,GACA,IAAAhmD,UAASvC,EAAO0C,OACb,CACH,IAAMxF,GAAY,IAAAwP,YAAW1M,EAAO0C,GAClB,QAAlB,EAAA/I,EAAQ4jB,kBAAU,SAAEqkB,UAAU3hB,EAAS/iB,EAAW,CAACwF,G,CAE3D,GAER,C,uGCvCA,eACA,WACA,WAGM8lD,EAAY,CAAC,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,QAmBtD,EAAAtB,cAAmD,SAAClnD,EAAOigB,EAAStmB,IAC7E,IAAAyuD,aACIzuD,EACA,CACIV,SAAS,IAAAi1B,gBAAejO,GAAW,uBAAyB,iBAEhE,WACI,IAxBS8xB,EACX0W,EAuBQt+C,EAAa8V,EAAQiC,aAAa,QAClC9X,GAzBG2nC,EAyBoB9xB,EAAQiC,aAAa,QAxBpDumC,EAAUrhE,SAAS2qD,GAAQ,IAE7B1kD,OAAOvC,MAAM29D,QACb,EACOA,EAAU,EACVD,EAAU,GACVC,EAAUD,EAAUnmE,OACpBmmE,EAAUA,EAAUnmE,OAAS,GAE7BmmE,EAAUC,EAAU,IAgBjBlpD,EAAY0gB,EAAQiC,aAAa,SACjCjsB,EAAS0D,EAAQ0B,cAEnB8O,IACAlU,EAAOkU,WAAaA,GAGpBC,IACAnU,EAAOmU,SAAWA,GAGlB7K,IACAtJ,EAAOsJ,UAAYA,IAGvB,IAAA2kB,aAAYjE,EAAStmB,EAAQwqB,cAAclrB,QAASU,EAAQ0B,cAAe1B,GAE3EA,EAAQusD,kBAAkB5kD,MAAMtB,EAAOigB,EAAStmB,EACpD,GAER,C,iLCrDA,WACA,WACA,WACA,UACA,WACA,WACA,WAea,EAAAwuD,cAA0D,CACnE,aACA,cACA,cACA,gBAWS,EAAApB,yBAA0D,SACnE/mD,EACAigB,EACAtmB,GAEA+uD,EAAiC1oD,EAAOigB,EAAStmB,GAAS,EAC9D,EAKa,EAAAgvD,8BAA+D,SACxE3oD,EACAigB,EACAtmB,GAEA+uD,EAAiC1oD,EAAOigB,EAAStmB,GAAS,EAC9D,EAEA,IAAM+uD,EAAmC,SACrC1oD,EACAigB,EACAtmB,EACAivD,IAEA,IAAAR,aAAYzuD,EAAS,CAAEV,QAAS,uBAAwBiE,UAAW,iBAAkB,YACjF,IAAAgnB,aAAYjE,EAAStmB,EAAQwqB,cAAcruB,MAAO6D,EAAQwlB,YAAaxlB,IACvE,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAcC,eAAgBzqB,EAAQ0B,cAAe1B,GAElF,IAAM1D,GAAM,iBACL0D,EAAQwlB,cAGf,IAAA+E,aAAYjE,EAAStmB,EAAQwqB,cAAcvmB,UAAW3H,EAAQ0D,GAE9D,IAAMkC,EACkC,UAApC,IAAAgtD,iBAAgB5oC,GAASrN,QAAqBqN,EAAQpkB,QAAQpR,cAAgB,MAC5Eq+D,GAAkB,IAAA1sD,uBAAsBP,EAAS5F,GAevD,GAVA,EAAAkyD,cAActgE,SAAQ,SAAAoc,UACXtK,EAAQwlB,YAAYlb,EAC/B,IAEAtK,EAAQusD,kBAAkB5kD,MAAMwnD,EAAiB7oC,EAAStmB,GAEtDsmB,EAAQhc,MAAMmG,UAAgD,GAApChjB,SAAS64B,EAAQhc,MAAMmG,YACjD0+C,EAAgBC,cAAe,GAyB3C,SAAmCD,GAC/B,IAAMvnD,EAAaunD,EAAgBxyD,OAAO,GAE1C,MAC+B,OAA3BwyD,EAAgBjtD,SACiB,GAAjCitD,EAAgBxyD,OAAOjU,QACC,aAAxBkf,EAAWpL,WACXoL,EAAW+mB,UAEnB,CA/BY0gC,CAA0BF,KAAqBF,EAAsB,CAGrE,IAAM1rD,EAAY4rD,EAAgBxyD,OAAO,GAErCwyD,EAAgBC,eAChB7rD,EAAU7B,cAAgB/Y,OAAO0gB,OAAO,CAAC,EAAG9F,EAAU7B,cAAe,CACjE+O,SAAU,OAIlB9nB,OAAO0gB,OAAO9F,EAAUjH,OAAQ6yD,EAAgB7yD,SAChD,IAAAqM,yBAAwBpF,IACxB,IAAAqF,UAASvC,EAAO9C,E,MAEhB,IAAAqF,UAASvC,EAAO8oD,EAExB,KAEA,IAAAvmD,UAASvC,GAAO,IAAA5E,kBAAgB,EAAqBzB,EAAQwlB,aACjE,C,0GC5GA,eACA,WACA,WACA,WACA,WACA,WACA,WACA,WAGM8pC,EAAuD,SAACjpD,EAAOigB,EAAStmB,GAC1E,IAAM7D,GAAQ,IAAAozD,oBAAmBjpC,GAC3BkpC,EAAmBxvD,EAAQ2kB,eAEjC,IAAA8pC,aACIzuD,EACA,CACIV,QAAS,QACTiE,UAAW,QACXrU,KAAM,UAEV,YACI,IAAA0Z,UAASvC,EAAOlK,IAEhB,IAAAouB,aAAYjE,EAAStmB,EAAQwqB,cAAcilC,QAAStzD,EAAMG,OAAQ0D,GAElEA,EAAQusD,kBAAkB5kD,MAAMxL,EAAOmqB,EAAStmB,EACpD,IAGAwvD,GAAoBxvD,EAAQ2kB,gBAC5BxoB,EAAMgD,YAAa,EAE3B,EAEMuwD,EAAyD,SAACrpD,EAAOigB,EAAStmB,G,MACtEV,GAAU,IAAAqwD,sBAAqBrpC,EAAStmB,EAAQ0B,eAChD8tD,EAAmBxvD,EAAQ2kB,eAEjC,IAAAirC,eAActwD,EAASU,GACvB,IAAMuD,GAAY,IAAAwP,YAAW1M,EAAO/G,GAClB,QAAlB,EAAAU,EAAQ4jB,kBAAU,SAAEqkB,UAAU3hB,EAAS/iB,EAAW,CAACjE,KAEnD,IAAAmvD,aACIzuD,EACA,CACIV,QACI,UAER,YACI,IAAAirB,aAAYjE,EAAStmB,EAAQwqB,cAAcilC,QAASnwD,EAAQhD,OAAQ0D,GAEpEA,EAAQusD,kBAAkB5kD,MAAMrI,EAASgnB,EAAStmB,EACtD,IAGAwvD,GAAoBxvD,EAAQ2kB,gBAC5BrlB,EAAQH,YAAa,EAE7B,EAKa,EAAA4uD,iBAAkD,SAAC1nD,EAAOigB,EAAStmB,KAC1D,IAAAu0B,gBAAejO,GAAWgpC,EAAwBI,GAE1DrpD,EAAOigB,EAAStmB,EAC9B,C,0GCpEA,eACA,WACA,WACA,WACA,WACA,WACA,WAMa,EAAAytD,iBAAyD,SAACpnD,EAAOigB,EAAStmB,IACnF,IAAAyuD,aACIzuD,EACA,CAAEV,QAAS,uBAAwBiE,UAAW,eAAgB+oD,eAAgB,UAC9E,WACI,IAAM5qD,EAA2C,CAAC,GAElD,IAAA6oB,aAAYjE,EAAStmB,EAAQwqB,cAAcC,eAAgB/oB,EAAe1B,IAK1E,IAAAkN,eAAcxL,GAAexT,SAAQ,SAAAhH,UAC1B8Y,EAAQ0B,cAAcxa,EACjC,IAEA8Y,EAAQssD,gBAAiB,IAAAv0C,0BAAyBuO,EAAQpkB,QAASR,IAEnE,IAAAmuD,gBAAexpD,EAAOigB,EAAStmB,EACnC,KAGJ,IAAA4I,UAASvC,GAAO,IAAA5E,kBAAgB,EAAqBzB,EAAQwlB,aACjE,C,qGCnCA,eACA,WACA,WACA,WAMa,EAAAkoC,YAA+C,SAACrnD,EAAOigB,EAAStmB,IACzE,IAAAyuD,aACIzuD,EACA,CACIuD,UAAW,iBAEf,YACI,IAAAgnB,aAAYjE,EAAStmB,EAAQwqB,cAAcslC,QAAS9vD,EAAQwlB,YAAaxlB,GAEzE,IAAM5T,GAAK,IAAA2jE,eAAc,KAAM/vD,EAAQwlB,aAEnCc,EAAQ8xB,OACRhsD,EAAGgsD,KAAO9xB,EAAQ8xB,MAGlBp4C,EAAQ2kB,gBACRv4B,EAAG+S,YAAa,IAGpB,IAAAyJ,UAASvC,EAAOja,EACpB,GAER,C,wGC/BA,eACA,WACA,WACA,WACA,WAMa,EAAAohE,eAAqD,SAACnnD,EAAOigB,EAAStmB,IAC/E,IAAAyuD,aAAYzuD,EAAS,CAAEV,QAAS,iBAAkB,W,UACxC0wD,EAAuChwD,EAAQ0B,cAG/Cma,EAAiC,QAA3B,EAAAyK,EAAQiC,aAAa,cAAM,QAAI,IAE3C,IAAAgC,aAAYjE,EAAStmB,EAAQwqB,cAAclrB,QAAS0wD,EAAahwD,IACjE,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAActgB,MAAO8lD,EAAahwD,IAC/D,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAcruB,MAAO6D,EAAQwlB,YAAaxlB,GAEvE,IAAMkK,GAAQ,IAAAiS,aAAYN,EAAKm0C,GACzBj0C,EAAMuK,EAAQvK,IACdk0C,EAAQ3pC,EAAQ2pC,OAEtB,IAAA1lC,aAAYjE,EAAStmB,EAAQwqB,cAAc1pB,QAASoJ,EAAMpJ,QAASd,IACnE,IAAA4vD,eAAc1lD,EAAOlK,GAEjB+b,IACA7R,EAAM6R,IAAMA,GAEZk0C,IACA/lD,EAAM+lD,MAAQA,GAEdjwD,EAAQ2kB,gBACRza,EAAM/K,YAAa,GAEQ,UAAV,QAAjB,EAAAa,EAAQgH,iBAAS,eAAEb,OAAmBnG,EAAQgH,UAAUkD,OAASoc,IACjEpc,EAAMgmD,4BAA6B,EACnChmD,EAAM/K,YAAa,GAGvB,IAAMoE,GAAY,IAAAwP,YAAW1M,EAAO6D,GAClB,QAAlB,EAAAlK,EAAQ4jB,kBAAU,SAAEqkB,UAAU3hB,EAAS/iB,EAAW,CAAC2G,GACvD,GACJ,C,+GC7CA,eACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WAUMimD,EAA8D,CAChE,eACA,YACA,gBACA,aACA,cACA,eACA,iBACA,oBACA,kBACA,mBACA,QACA,SACA,WACA,YACA,WACA,aAEEC,EAAmC,CAAC,MACpCC,EAA4B,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAK,KACtE/B,EAAuB,CAAC,IAAK,QAKtB,EAAArB,sBAAuD,SAAC5mD,EAAOigB,EAAStmB,GACjF,IAAMiJ,GAAU,IAAAsrB,gBAAejO,GACzBgqC,EAAmBrnD,GAAoC,gBAAzBqd,EAAQhc,MAAM2O,QAElD,GACIq3C,GA0DR,SAAuChqC,GACnC,OAAO8pC,EAAiC/wD,MAAK,SAAAkxD,GAAQ,OAAAjqC,EAAQkqC,aAAaD,EAArB,GACzD,CA3DQE,CAA8BnqC,IAE9B,IAAA0oC,+BAA8B3oD,EAAOigB,EAAStmB,QAC3C,GAAIswD,GA0Df,SAAkChqC,GAE9B,GAAI+pC,EAA0Bj+D,QAAQk0B,EAAQpkB,UAAY,EACtD,OAAO,EAGX,IAAMoI,EAAQgc,EAAQhc,MAChBm8C,GAAe,IAAAyI,iBAAgB5oC,GAE/BoqC,EAAUpmD,EAAMqmD,iBAAiB,oBAGvC,SAAID,GAAsB,eAAXA,OAOXP,EAA6B9wD,MACzB,SAAAnY,GAAO,OAAAuG,SAAU6c,EAAMpjB,IAAoBu/D,EAAav/D,IAAmB,IAAM,CAA1E,MAOS,QAApBojB,EAAMrN,YAA6C,QAArBqN,EAAMlN,eAKpCkpB,EAAQiC,aAAa,UAK7B,CA/FmCqoC,CAAyBtqC,IACpD,IAAA8mC,0BAAyB/mD,EAAOigB,EAAStmB,QACtC,IAAI,IAAA89B,wBAAuBxX,GAC9BtmB,EAAQusD,kBAAkB5kD,MAAMtB,EAAOigB,EAAStmB,QAC7C,GAAIiJ,EAAS,CAChB,IAAMtH,EAAY3B,EAAQssD,eAAepqD,QAAUlC,EAAQssD,oBAAiBh2D,EACtEi4D,EAAqBD,EAAqBl8D,QAAQk0B,EAAQpkB,UAAY,GAE5E,IAAAusD,aAAYzuD,EAAS,CAAEV,QAAS,uBAAwBiE,UAAW,iBAAkB,WACjF,IAAM7B,EAA2C,CAAC,GAElD,IAAA6oB,aAAYjE,EAAStmB,EAAQwqB,cAAcC,eAAgB/oB,EAAe1B,GAC1ErX,OAAO0gB,OAAOrJ,EAAQ0B,cAAeA,IAErC,IAAAmuD,gBAAexpD,EAAOigB,EAAStmB,EAAS0B,EAC5C,IAEIuH,IAAYslD,IACZ,IAAA3lD,UACIvC,GACA,IAAA5E,kBACI,EACAzB,EAAQwlB,iBACRlvB,EACAqL,G,MAKZ,IAAA8sD,aACIzuD,EACA,CACIV,QAAS,eACTiE,UAAW,eACXrU,KAAM,gBAEV,YACI,IAAAq7B,aAAYjE,EAAStmB,EAAQwqB,cAAclrB,QAASU,EAAQ0B,cAAe1B,GAEvEA,EAAQ9Q,KAAKoN,OAAOqR,MAA2B,KAAnB2Y,EAAQpkB,UACpC,IAAAqoB,aACIjE,EACAtmB,EAAQwqB,cAAcqmC,iBACtB7wD,EAAQ9Q,KAAKoN,OACb0D,GAIRA,EAAQusD,kBAAkB5kD,MAAMtB,EAAOigB,EAAStmB,EACpD,GAGZ,C,uGCxGA,eACA,WACA,WACA,WACA,WAOa,EAAAgtD,cAA+C,SAAC3mD,EAAOigB,EAAStmB,GACzE,IAAMzP,EAAO+1B,EAAQiC,aAAa,QAC5B5a,EAAO2Y,EAAQiC,aAAa,QAElC,GAAIh4B,GAAQod,EAAM,CACd,IAAM,IAAapd,IAASod,EACtB0rB,EAA6B,CAG/BnqC,KAAM,EAAW,QAAU,gBAG/B,IAAAu/D,aAAYzuD,EAASq5B,GAAQ,WAIzB,IAHA,IAAA9O,aAAYjE,EAAStmB,EAAQwqB,cAAct7B,KAAM8Q,EAAQ9Q,KAAKoN,OAAQ0D,IACtE,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAc1pB,QAASd,EAAQ9Q,KAAK4R,QAASd,GAEtE,IAAasmB,EAAQ1e,WAAY,CAEjC,IAAMkpD,GAAY,IAAAn/C,YAAW,GAAI3R,EAAQ0B,cAAe,CACpDZ,QAASd,EAAQ9Q,KAAK4R,QACtBxE,OAAQ0D,EAAQ9Q,KAAKoN,SAGrB0D,EAAQ2kB,gBACRmsC,EAAU3xD,YAAa,IAG3B,IAAA4T,YAAW1M,EAAOyqD,E,MAElB,IAAA7D,uBAAsB5mD,EAAOigB,EAAStmB,EAE9C,G,MAGA,IAAAitD,uBAAsB5mD,EAAOigB,EAAStmB,EAE9C,C,0GC/CA,eACA,WACA,WAMa,EAAA2tD,kBAAqD,SAACtnD,EAAOigB,EAAStmB,G,MACvE6lD,EAAe7lD,EAAO,WAE9B,GAAI6lD,EAAWkL,YAAclL,EAAW3mD,OAAOxW,OAAS,GACpD,IAAA+lE,aACIzuD,EACA,CACIV,QAAS,yBAEb,YACI,IAAAirB,aACIjE,EACAtmB,EAAQwqB,cAAcC,eACtBzqB,EAAQ0B,cACR1B,GAGJ,IAAMZ,GAAW,IAAAiR,gBAAew1C,EAAW3mD,OAAQc,EAAQ0B,gBAC3D,IAAA6oB,aACIjE,EACAtmB,EAAQwqB,cAAcwmC,gBACtB5xD,EAAS9C,OACT0D,GAGJ6lD,EAAWkL,WAAYp0D,OAAOnK,KAAK4M,IAEnC,IAAAmrB,aACIjE,EACAtmB,EAAQwqB,cAAcymC,eACtB7xD,EAASF,OAAOE,EAASF,OAAOxW,OAAS,GAAG4T,OAC5C0D,GAGJA,EAAQusD,kBAAkB5kD,MAAMvI,EAAUknB,EAAStmB,GAEnD,IAAM4H,EAAaxI,EAASzC,OAAO,GAGL,GAA1ByC,EAASzC,OAAOjU,QACQ,aAAxBkf,EAAWpL,WACXoL,EAAW+mB,aAEXhmC,OAAO0gB,OAAOjK,EAAS9C,OAAQsL,EAAWtL,QAC1CsL,EAAWtL,OAAS,CAAC,EAE7B,QAED,CACH,IAAM40D,EAAqC,QAArB,EAAArL,EAAWkL,kBAAU,eAAEp0D,OACvCw0D,EAAWD,aAAa,EAAbA,GAAgBA,aAAa,EAAbA,EAAexoE,QAAS,GAEzDsX,EAAQusD,kBAAkB,KACC,eAAvB4E,aAAQ,EAARA,EAAU30D,WAA4B20D,EAAW9qD,EACjDigB,EACAtmB,E,CAGZ,C,uGClEA,eACA,WACA,WAMa,EAAA4tD,cAAuE,SAChFvnD,EACAigB,EACAtmB,IAEA,IAAAyuD,aACIzuD,EACA,CACIV,QAAS,uBACTiE,UAAW,yBAEf,WACI,IAAMrO,GAA+B,IAAA0L,iBACjC0lB,EAAQpkB,QACRlC,EAAQwlB,aAEJqgC,EAAe7lD,EAAO,YAE9B,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAc1pB,QAAS5L,EAAM4L,QAASd,IACnE,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAc4mC,gBAAiBl8D,EAAMoH,OAAQ0D,IAC1E,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAcm6B,UAAWzvD,EAAMoH,OAAQ0D,IACpE,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAclrB,QAASU,EAAQ0B,cAAe1B,GAE3E,IAAMqxD,EAAqBxL,EAAWkL,WAEtClL,EAAWkL,WAAalL,EAAWkL,YAAc1qD,EACjDw/C,EAAW3mD,OAAO1M,KAAK0C,GAEvB,IACI8K,EAAQusD,kBAAkB5kD,MAAMtB,EAAOigB,EAAStmB,E,SAEhD6lD,EAAW3mD,OAAOnP,MAClB81D,EAAWkL,WAAaM,C,CAEhC,GAER,C,oGC5CA,eACA,WACA,WACA,WACA,WACA,WAMa,EAAAxD,WAA4C,SAACxnD,EAAOigB,EAAStmB,IACtE,IAAAyuD,aACIzuD,EACA,CAAEssD,eAAgB,QAAShtD,QAAS,uBAAwBiE,UAAW,iBACvE,WACIvD,EAAQssD,gBAAiB,IAAAv0C,0BAAyBuO,EAAQpkB,SAE1D,IAAMR,EAA2C,CAAC,GAElD,IAAA6oB,aAAYjE,EAAStmB,EAAQwqB,cAAcC,eAAgB/oB,EAAe1B,GAC1ErX,OAAO0gB,OAAOrJ,EAAQ0B,cAAeA,IAErC,IAAAmuD,gBAAexpD,EAAOigB,EAAStmB,EAAS0B,EAC5C,KAGJ,IAAAkH,UAASvC,GAAO,IAAA5E,kBAAgB,EAAqBzB,EAAQwlB,aACjE,C,uHC5BA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WA2RA,SAAS8rC,EAAqB9hE,EAAiC4tD,GAI3D,IAHA,IAAMmU,EAAe/hE,EAAO8N,KAAK5U,OAE7B8oE,GAAW,EACN3mE,EAAI,EAAGA,EAAI2E,EAAO8N,KAAK5U,OAAQmC,IAAK,CAEzC,IADA,IAAM0S,EAAM/N,EAAO8N,KAAKzS,GACfiqB,EAAI,EAAGA,EAAIvX,EAAIC,MAAM9U,OAAQosB,IAClC,GAAIvX,EAAIC,MAAMsX,KAAOsoC,EAAI,CACrBoU,EAAU3mE,EACV,K,CAGR,IAAiB,IAAb2mE,EACA,K,CAIR,OAAOD,EAAeC,CAC1B,CAEA,SAASC,EAAUvxC,GAIf,IAHA,IAAMtxB,EAAmB,GACrB8iE,EAAU,EAEL7mE,EAAIq1B,EAAUx3B,OAAS,EAAGmC,GAAK,EAAGA,IAGvC,GAAkB,iBAFZs1B,EAAMD,EAAUr1B,IAEM,CACxB6mE,EAAUvxC,EACV,K,CAIR,IAASt1B,EAAIq1B,EAAUx3B,OAAS,EAAGmC,GAAK,EAAGA,IAAK,CAC5C,IAAMs1B,OACM7pB,KADN6pB,EAAMD,EAAUr1B,IAElB+D,EAAO/D,GAAK,GAEZ+D,EAAO/D,GAAK6mE,EAAUvxC,EACtBuxC,EAAUvxC,E,CAIlB,OAAOvxB,CACX,CA7Sa,EAAAk/D,eAAqD,SAC9DznD,EACAkiC,EACAvoC,IAEA,IAAAyuD,aACIzuD,EACA,CAAEV,QAAS,uBAAwBiE,UAAW,yBAC9C,W,SACI,IAAAgnB,aAAYge,EAAcvoC,EAAQwqB,cAAcruB,MAAO6D,EAAQwlB,YAAaxlB,GAE5E,IAAMsD,GAAQ,IAAA+R,aAAYkzB,EAAajrC,KAAK5U,OAAQsX,EAAQwlB,aACtDg1B,EAA4C,UAAV,QAAjB,EAAAx6C,EAAQgH,iBAAS,eAAEb,MAAkBnG,EAAQgH,UAAY,KAE1EyzC,GADgBD,aAAc,EAAdA,EAAgBl3C,QACKilC,EACrCnhB,EAwUlB,SAAoC9jB,EAAyBtD,GACzD,OAAQA,EAAQonB,sBACZ,KAAK,EACL,IAAK,MACD,OAAO,EAEX,IAAK,WACD,IAAMuqC,GAAgB,IAAA5qD,sBAAqB/G,EAAQgH,WAEnD,QACM2qD,IACDA,GAAiBruD,GACdA,EAAM6D,SAASwqD,IACfA,EAAcxqD,SAAS7D,IAGnC,QACI,OAAO,EAEnB,CA3VyCsuD,CAA2BrpB,EAAcvoC,GAElEA,EAAQ2jB,oBACRrgB,EAAMuuD,cAAgBtpB,GAGR,QAAlB,EAAAvoC,EAAQ4jB,kBAAU,SAAE0kB,QAAQC,EAAcjlC,IAE1C,IAAAinB,aAAYge,EAAcvoC,EAAQwqB,cAAclnB,MAAOA,EAAMhH,OAAQ0D,IACrE,IAAAuqB,aAAYge,EAAcvoC,EAAQwqB,cAAcsnC,YAAaxuD,EAAMhH,OAAQ0D,IAC3E,IAAAuqB,aACIge,EACAvoC,EAAQwqB,cAAcC,eACtBzqB,EAAQ0B,cACR1B,IAEJ,IAAAuqB,aAAYge,EAAcvoC,EAAQwqB,cAAc1pB,QAASwC,EAAMxC,QAASd,IACxE,IAAA4I,UAASvC,EAAO/C,GAOhB,IALA,IAAMyuD,EAA0C,CAAC,GAC3CC,EA4QlB,SACI1uD,EACAtD,EACApR,GAKA,I,QAHI8iE,EAAU,EACVM,GAAc,EAETrqD,EAAQrE,EAAMsE,WAAYD,EAAOA,EAAQA,EAAME,YACpD,IAAI,IAAAT,cAAaO,EAAO,iBAAoC,YAAjBA,EAAMzF,QAAuB,CACpE8vD,GAAc,EAEd,IAAK,IAAIp9C,EAAMjN,EAAMC,WAAYgN,EAAKA,EAAMA,EAAI/M,YAC5C,IAAI,IAAAT,cAAawN,EAAK,iBAAkC,OAAfA,EAAI1S,QAAkB,CAC3D,IAAM+vD,EAAwB,CAAC,GAE/B,IAAA1nC,aAAY3V,EAAK5U,EAAQwqB,cAAc0nC,YAAaD,EAAWjyD,GAE/D,IAAK,IAAInV,EAAI,EAAGA,EAAI4C,SAAiC,QAAxB,EAAAmnB,EAAI2T,aAAa,eAAO,QAAI,KAAM19B,IAC3D,QAAwByL,IAApB27D,EAAU5nD,MACVzb,EAAO4D,UAAK8D,OACT,CACH,IAAM+T,GAAQ,IAAAzK,oBACK,QAAf,EAAAqyD,EAAU5nD,aAAK,QAAI,QACnB/T,EACA,MAGJ1H,EAAO4D,KAAK6X,EAAQqnD,GACpBA,GAAWrnD,C,GAQnC,OAAO2nD,CACX,CAlTgCG,CAAgB5pB,EAAcvoC,EAAS+xD,GACrDK,EAAyB,CAAC,GAC1BvuC,EAAY7jB,EAAQ6jB,WAAa,E,WAE9BtmB,GACL,IAAM80D,EAAK9pB,EAAajrC,KAAKC,GACvB+0D,EAAWhvD,EAAMhG,KAAKC,GAEtBg5B,EAAQ87B,EAAGhrD,YAGb,IAAAD,cAAamvB,EAAO,mBACnB,IAAAtJ,iBAAgBsJ,EAAO,WACpB,IAAAtJ,iBAAgBsJ,EAAO,WACvB,IAAAtJ,iBAAgBsJ,EAAO,WAE3B,IAAAhM,aAAYgM,EAAOv2B,EAAQwqB,cAAc8nC,SAAUA,EAASh2D,OAAQ0D,GAC7DA,EAAQ2jB,oBACf2uC,EAAST,cAAgBQ,IAG7B,IAAA9nC,aAAY8nC,EAAIryD,EAAQwqB,cAAc8nC,SAAUA,EAASh2D,OAAQ0D,IAEjE,IAAAyuD,aAAYzuD,EAAS,CAAEuD,UAAW,eAAgBjE,QAAS,iBAAkB,WACzE,IAiTSgnB,EAjTH92B,EAAS6iE,EAAGrkC,cACZukC,EAAmB/iE,IAgThB82B,EAhT8C92B,GAkTnE,IAAAy9B,iBAAgB3G,EAAS,WACzB,IAAA2G,iBAAgB3G,EAAS,WACzB,IAAA2G,iBAAgB3G,EAAS,UAlTTisC,KAEA,IAAAhoC,aACI/6B,EACAwQ,EAAQwqB,cAAcruB,MACtB6D,EAAQwlB,YACRxlB,IAEJ,IAAAuqB,aACI/6B,EACAwQ,EAAQwqB,cAAcC,eACtBzqB,EAAQ0B,cACR1B,KAIR,IAAAuqB,aAAY8nC,EAAIryD,EAAQwqB,cAAcruB,MAAO6D,EAAQwlB,YAAaxlB,IAClE,IAAAuqB,aACI8nC,EACAryD,EAAQwqB,cAAcC,eACtBzqB,EAAQ0B,cACR1B,GAGJsyD,EAASn8C,OAAS1oB,SAAS4kE,EAAG/nD,MAAM6L,SAAW,EAE/C,I,iBACQq8C,EAAeC,GAInB,KAAOH,EAAS90D,MAAMi1D,GAAYA,KAElC,IAAMrV,EAAKiV,EAAG70D,MAAMg1D,GACdE,EAAyB1yD,EAAQ2kB,cACvC,GAAIyC,EAAsB,CACtB,IAAMurC,EAASF,EAAYrV,EAAGwV,QACxBC,EAASt1D,EAAM6/C,EAAG0V,QAClBC,OAA4Cz8D,IAA5By7D,EAAgBY,GAChCK,OAA0C18D,IAAzB87D,EAAaS,GAEpC,GAAIE,GAAiBC,EAAgB,CACjC,IAAM32B,GAAO,IAAAgB,uBAAsB+f,GAEnC,GAAI/gB,EAAKhyB,MAAQ,GAAKgyB,EAAKlmB,OAAS,EAAG,CACnC,GAAI48C,EAAe,CACf,IAAM5yC,EAAM4xC,EAAgBU,GAE5BV,EAAgBY,IACG,iBAAPxyC,EAAkBA,EAAM,GAChCkc,EAAKhyB,MAAQwZ,C,CAGjBmvC,IACAZ,EAAaS,GACTT,EAAa70D,GAAO8+B,EAAKlmB,OAAS0N,E,IAMtD,IAAA4qC,aACIzuD,EACA,CAAEuD,UAAW,eAAgBjE,QAAS,iBACtC,YACI,IAAAirB,aACI6yB,EACAp9C,EAAQwqB,cAAcruB,MACtB6D,EAAQwlB,YACRxlB,IAEJ,IAAAuqB,aACI6yB,EACAp9C,EAAQwqB,cAAcyoC,mBACtBjzD,EAAQ0B,cACR1B,GAGJ,IAAMoV,GAAU,iBACTpV,EAAQwlB,aAET1kB,EAAyB,CAAC,GAEhC,IAAAypB,aACI6yB,EACAp9C,EAAQwqB,cAAc0oC,UACtB99C,EACApV,IAEJ,IAAAuqB,aACI6yB,EACAp9C,EAAQwqB,cAAcsnC,YACtB18C,EACApV,IAEJ,IAAAuqB,aAAY6yB,EAAIp9C,EAAQwqB,cAAc1pB,QAASA,EAASd,GAExD,IACI,IAAI4yD,EAAU,EACdA,IAA0B,GAAdxV,EAAGwV,QAAe,EAAIxV,EAAGwV,SACrCA,IAAWH,IAEX,IACI,IAAIK,EAAU,EAGdA,IACe,GAAd1V,EAAG0V,QACEP,EACIjB,EAAqB9hE,EAAQ4tD,GAC7B,EACJA,EAAG0V,SACTA,IACF,CACE,IAAMK,EAAmB,GAAXP,GAA2B,GAAXE,EACxBr1D,GAAO,IAAA6X,iBACTs9C,EAAU,EACVE,EAAU,EACI,MAAd1V,EAAGl7C,QACHkT,GAGJ3X,EAAKqD,SAAU,EAAH,eAAQA,GAEpB,IAAMsyD,EAAa9vD,EAAMhG,KAAKC,EAAMu1D,EAAU,GAM9C,GAJIM,IACAA,EAAW51D,MAAMi1D,GAAah1D,GAG9B01D,EAAO,CAGHnzD,EAAQ2jB,oBAAsBquC,IAC9Bv0D,EAAKo0D,cAAgBzU,GAGnB,MAAyBp9C,EAAQ6lD,WAA/BkL,EAAU,aAAE7xD,EAAM,SAE1Bc,EAAQ6lD,WAAWkL,gBAAaz6D,EAChC0J,EAAQ6lD,WAAW3mD,OAAS,GAE5B,IACIc,EAAQusD,kBAAkB5kD,MAAMlK,EAAM2/C,EAAIp9C,E,SAE1CA,EAAQ6lD,WAAWkL,WAAaA,EAChC/wD,EAAQ6lD,WAAW3mD,OAASA,C,EAIpC,IAAMm0D,EAAwBrzD,EAAQ2kB,eAGjC+tC,GAA0BW,GAC1B5Y,GACGD,GACAj9C,GAAOi9C,EAAe3mC,UACtBtW,GAAOi9C,EAAe1mC,SACtB2+C,GAAajY,EAAe1nC,aAC5B2/C,GAAajY,EAAezmC,cAEhCtW,EAAK0B,YAAa,E,CAIlC,I,EA1IeszD,C,EAAfD,EAAY,EAAGC,EAAY,EAC/BD,EAAYH,EAAG70D,MAAM9U,OACrB8pE,I,EAFIA,EAAeC,GAAAA,EAAY,CA6IvC,IAEA,IAAK,IAAI79C,EAAM,EAAGA,EAAM09C,EAAS90D,MAAM9U,OAAQksB,IACtC09C,EAAS90D,MAAMoX,KAChB09C,EAAS90D,MAAMoX,IAAO,IAAAU,kBAClB,GACA,GACA,EACAtV,EAAQwlB,a,EAvMfjoB,EAAM,EAAGA,EAAMgrC,EAAajrC,KAAK5U,OAAQ6U,I,EAAzCA,GA6MT+F,EAAMkS,OAASi8C,EAAUM,GAEzB,IAAMuB,EAAU7B,EAAUW,GAE1B9uD,EAAMhG,KAAKpP,SAAQ,SAACqP,EAAK1S,GACjByoE,EAAQzoE,GAAK,IACb0S,EAAI4Y,OAASm9C,EAAQzoE,GAE7B,GACJ,GAER,C,uGClSA,eACA,WA4BA,SAAS0oE,EACLltD,EACA0e,EACA/kB,G,MAEMuD,GAAY,IAAAiwD,iBAAgBntD,EAAOrG,EAAQwlB,aAC3CiuC,EAAelwD,EAAUpF,SAASzV,OAExCsX,EAAQusD,kBAAkB1nC,kBAAkBxe,EAAO0e,EAAU/kB,GAE7D,IAAMyf,EAAclc,EAAUpF,SAASzP,MAAM+kE,GAC3B,QAAlB,EAAAzzD,EAAQ4jB,kBAAU,SAAEqkB,UAChBljB,EACAxhB,EACAkc,EAAYrhB,QAAO,SAAClU,GAA6B,MAAkB,SAAlBA,aAAC,EAADA,EAAGoU,YAAH,IAEzD,CAjCa,EAAA0vD,cAAwC,SACjD3nD,EACA0e,EACA/kB,GAEIA,EAAQwqB,cAAc9rB,KAAKhW,OAAS,GACpC,IAAA+lE,aAAYzuD,EAAS,CAAEV,QAAS,iBAAkB,WAC9CU,EAAQwqB,cAAc9rB,KAAKxQ,SAAQ,SAAAwlE,GAC/BA,EAAO1zD,EAAQ0B,cAAeqjB,EAAU/kB,EAC5C,IACAuzD,EAAsBltD,EAAO0e,EAAU/kB,EAC3C,IAEAuzD,EAAsBltD,EAAO0e,EAAU/kB,EAE/C,C,oHC3BA,eACA,WACA,WAMa,EAAAiuD,2BAAqD,SAAC5nD,EAAO0e,EAAU/kB,GAChF,IAAIglB,EAAMD,EAASE,WAAa,GAC1BV,GAAU,IAAA/c,4BAA2BxH,EAAS+kB,GAC9C4uC,EAAiBpvC,EAAQ,GAC3BqvC,EAAervC,EAAQ,GAE3B,GAAIovC,GAAkB,EAAG,CACrB,IAAME,EAAU7uC,EAAI/3B,UAAU,EAAG0mE,IACjC,IAAAruC,gBAAejf,EAAOwtD,EAAS7zD,GAC/BA,EAAQ2kB,eAAgB,GAExB,IAAAD,oBAAmBre,EAAOrG,EAAS+kB,EAAU4uC,GAE7C3uC,EAAMA,EAAI/3B,UAAU0mE,GACpBC,GAAgBD,C,CAGhBC,GAAgB,IACVC,EAAU7uC,EAAI/3B,UAAU,EAAG2mE,IACjC,IAAAtuC,gBAAejf,EAAOwtD,EAAS7zD,IAG3BA,EAAQgH,WACmB,SAA1BhH,EAAQgH,UAAUb,MAAoBnG,EAAQgH,UAAUya,MAAMC,YAE/D,IAAAgD,oBAAmBre,EAAOrG,EAAS+kB,EAAUR,EAAQ,IAGzDvkB,EAAQ2kB,eAAgB,EACxBK,EAAMA,EAAI/3B,UAAU2mE,KAGxB,IAAAtuC,gBAAejf,EAAO2e,EAAKhlB,EAC/B,C,4GCzCA,eACA,WAMA,8BACIqG,EACArG,EACAiE,EACAmO,GAEA,IAAM5O,GAAS,IAAA+hB,sBAAqBlf,EAAOrG,EAASiE,EAAWmO,IAE/D,IAAAW,YAAW1M,EAAO7C,EAAQxD,EAAQwlB,YAAahiB,EAAOlH,OAC1D,C,wGChBA,eAQA,0BAAiEw3D,EAAOC,GACpE,GAAID,GAAMC,EACN,OAAO,EAEP,IAAMC,GAAQ,IAAA9mD,eAAc4mD,GACtBG,GAAQ,IAAA/mD,eAAc6mD,GAE5B,OAAOC,EAAMtrE,QAAUurE,EAAMvrE,QAAUsrE,EAAM1xD,OAAM,SAAApb,GAAO,OAAA4sE,EAAG5sE,IAAQ6sE,EAAG7sE,EAAd,GAElE,C,8GCjBA,eACA,UAgBA,gCACImf,EACArG,EACAiE,EACAmO,GAEA,IAAM8hD,EAAW7tD,EAAM1J,OAAO0J,EAAM1J,OAAOjU,OAAS,GAC9CyrE,EACDD,GAAkC,aAAtBA,EAAS13D,UAEhB03D,EAASvyD,UACT,CACI6O,WAAY0jD,EAASvyD,UAAUrF,OAAOkU,WACtCC,SAAUyjD,EAASvyD,UAAUrF,OAAOmU,UAExCyjD,EAASxyD,cACT,CACI8O,WAAY0jD,EAASxyD,cAAc8O,WACnCC,SAAUyjD,EAASxyD,cAAc+O,UAErC,CAAC,EAXD,CAAC,EAaL6J,EACFta,EAAQsa,eACRta,EAAQsa,cAAcjX,YAAYnT,OAAS+T,GAC3CjE,EAAQsa,cAAcjX,YAAY+O,SAAWA,EACvCpS,EAAQsa,cAAche,YACtBhG,EAEJgG,EAAoC3T,OAAO0gB,OAC7C,CAAC,EACDrJ,EAAQwjB,cACR2wC,EACAn0D,EAAQ0B,cACR4Y,GAGE9W,GAAS,IAAAwG,uBAAsB1N,GAIrC,OAFA,IAAAszD,eAAcpsD,EAAQxD,GAEfwD,CACX,C,6GCxDA,iCAAsC8iB,GAClC,OAAOA,EAAQ+W,uBACnB,C,wGCLA,eASA,2BAAgC/W,GAC5B,IAAM1O,EAAM0O,EAAQpkB,QAAQpR,cAE5B,OAAO,EAAA22D,oBAAoB7vC,IAAQ,CAAC,CACxC,C,kHCJA,sCACI5X,EACAylB,G,MAEMhE,EAAmC,UAAV,QAAjB,EAAAzhB,EAAQgH,iBAAS,eAAEb,MAAkBnG,EAAQgH,UAAUya,MAAQ,KAK7E,MAAO,EAHaA,aAAK,EAALA,EAAOoV,iBAAkBpR,EAAmBhE,EAAMqV,aAAe,GACnErV,aAAK,EAALA,EAAOsV,eAAgBtR,EAAmBhE,EAAMuV,WAAc,EAGpF,C,wGCnBA,cAEMo9B,EAAuB,CAAC,QAAS,YAAa,QAAS,aAAc,QAO3E,0BAA+B9tC,GAC3B,IACM+tC,GADmC,QAAzB/tC,EAAQhc,MAAM2O,QAAoB,KAAOqN,EAAQhc,MAAM2O,WACnC,IAAAi2C,iBAAgB5oC,GAASrN,SAAW,GAExE,OAAOm7C,EAAqBhiE,QAAQiiE,IAAqB,CAC7D,C,qGCdA,cAcA,uBACI/tC,EACAymC,EACAzwD,EACA0D,GAEA,IAAMymD,GAAe,IAAAyI,iBAAgB5oC,GAErCymC,EAAQ7+D,SAAQ,SAAAwlE,GACZA,SAAAA,EAASp3D,EAAQgqB,EAAStmB,EAASymD,EACvC,GACJ,C,oHCzBA,WA6BM6N,EAA+E,CACjF,mBAEEC,EAA2D,CAC7D,aACA,cACA,cACA,gBAiGJ,SAASC,EACLl4D,EACAm4D,GAEA,OAAQA,GACJ,IAAK,QACD,MAAO,CAAC,EAEZ,UAAKn+D,EACD,OAAOgG,EAEX,QACI,IAAM,GAAS,EAAH,eAAQA,GAepB,IAbA,IAAA4Q,eAAc5Q,GAAQpO,SAAQ,SAAAhH,IAEN,wBAAfutE,GACGH,EAAwCliE,QACpClL,IACC,GACO,wBAAfutE,GACGF,EAAsBniE,QAAQlL,IAAyC,WAEpE,EAAOA,EAEtB,IAEmB,gBAAfutE,GAAgD,wBAAfA,EAAuC,CACxE,IAAMjvC,EAAclpB,EAIhBkpB,EAAYkvC,oBACJ,EAAmCC,oBAC3CnvC,EAAYmvC,qBAAsB,E,CAI1C,OAAO,EAEnB,CAnIA,uBACI30D,EACA0Y,EACAhF,GAGI,IAuEJpX,EAvEIoF,EAKA1B,EAAO,cAJPwlB,EAIAxlB,EAAO,YAHD40D,EAGN50D,EAAO,KAFD60D,EAEN70D,EAAO,KADS80D,EAChB90D,EAAO,eACHV,EAAmDoZ,EAAO,QAAjDnV,EAA0CmV,EAAO,UAAtCxpB,EAA+BwpB,EAAO,KAAhC7S,EAAyB6S,EAAO,KAA1B4zC,EAAmB5zC,EAAO,eAElE,IACI1Y,EAAQ0B,cAAgB8yD,EAAoB9yD,EAAepC,GAC3DU,EAAQwlB,YAAcgvC,EAAoBhvC,EAAajiB,GACvDvD,EAAQ9Q,KAchB,SACI0lE,EACA1lE,GAEA,OAAQA,GACJ,IAAK,cACD,MAAO,CACHoN,OAAQ,CACJ0R,WAAW,GAEflN,QAAS,CAAC,GAGlB,IAAK,QACD,MAAO,CACHxE,OAAQ,CAAC,EACTwE,QAAS,CAAC,GAIlB,QACI,MAAO,CACHA,QAAS8zD,EAAW9zD,QACpBxE,QAAQ,EAAF,eAAOs4D,EAAWt4D,SAGxC,CAxCuBy4D,CAAkBH,EAAY1lE,GAC7C8Q,EAAQ6F,KAyChB,SAA2BgvD,EAA8BhvD,GACrD,OAAQA,GACJ,IAAK,cACD,MAAO,CACHvJ,OAAQ,CACJkU,WAAY,cAGxB,IAAK,QACD,MAAO,CACHlU,OAAQ,CAAC,GAEjB,QACI,OAAOu4D,EAEnB,CAxDuBG,CAAkBH,EAAYhvD,GAC7C7F,EAAQssD,gBA0DZhwD,EA1DoDw4D,EA8D3C,UA9D4DxI,EA+DtD,CACHhwD,OAAQ,CAAC,EACT4F,QAAS,IAGN5F,GAlEXoX,G,SAEA1T,EAAQ0B,cAAgBA,EACxB1B,EAAQwlB,YAAcA,EACtBxlB,EAAQ9Q,KAAO0lE,EACf50D,EAAQ6F,KAAOgvD,EACf70D,EAAQssD,eAAiBwI,C,CAEjC,C,wTCvEA,WACA,WACA,WACA,SAQMG,EAAmB,UACnBC,EAAuB,IAAMD,EAC7BE,EAAqB,UACrBC,EAAmB,QACnBC,EAAyB,cAEzBC,EAAmB,wBACnBC,EAAkB,uBAClBC,EAAyB,2BACzBC,EAAkC,IAAMD,EAsK9C,SAASE,EAAYphC,EAAoB4e,GACrC,OAAO5e,aAAE,EAAFA,EAAI8gB,UAAUjuC,SAAS+rC,KA3KT,KA2KuB5e,EAAG9F,YACxC8F,OACDh+B,CACV,CAEA,SAASq/D,EAAgBt5C,EAAeiK,EAAkB8jB,G,MAChDmc,EAAOlqC,EAAIrD,cAAc,QAM/B,OAJAutC,EAAKrT,UAAY9I,EAAUmrB,EAAkBD,EAC7C/O,EAAKrtC,YAAYmD,EAAIkV,eApLA,MAqLH,QAAlB,EAAAjL,EAAQjf,kBAAU,SAAEmvB,aAAa+vB,EAAMnc,EAAU9jB,EAAQze,YAAcye,GAEhEigC,CACX,CA/KA,2BAAgCr2D,GAC5B,OAAO,IAAAkX,cAAalX,EAAM,iBAAmBA,EAAKklD,UAAUjuC,SAAS8tD,EACzE,EAOA,oCACI/tD,EACAqc,GAEA,OAAOA,EAAU06B,2BAA2B/2C,EAAWguD,EAC3D,EAQA,2CACIhlE,EACAqzB,GAEA,OAAOA,EAAU06B,2BAA2B/tD,EAAMulE,EACtD,EAOA,gCAAqCxuD,GACjC,OAAO,IAAAwgB,SAAQxgB,EAAKygB,iBAAiB,IAAMutC,GAC/C,EAOA,6BAAkCruD,GAC9B,IAAIgvD,GAAW,EACTt5D,EAAmC,CAAC,EAW1C,OATAsK,EAAQwuC,UAAUlnD,SAAQ,SAAAqC,GACtBqlE,EAgBR,SACI1iB,EACA52C,GAEA,GAAI42C,GAAa+hB,EACb,OAAO,EACyC,GAAzC/hB,EAAU9gD,QAAQ+iE,GACzB74D,EAAO0d,WAAak5B,EAAUjmD,UAAUkoE,GACM,GAAvCjiB,EAAU9gD,QAAQgjE,GACzB94D,EAAOod,GAAKw5B,EAAUjmD,UAAUmoE,GACoB,GAA7CliB,EAAU9gD,QAAQijE,KACzB/4D,EAAOqd,WAAmE,KAAtDu5B,EAAUjmD,UAAUooE,IAEhD,CA7BmBQ,CAAqBtlE,EAAM+L,IAAWs5D,CACrD,IAEKA,IACDt5D,EAAO22C,cAAe,EACtB32C,EAAOqd,YAAc/S,EAAQsmB,mBAG1B5wB,CACX,EA2BA,oCAAyCA,G,MACrC,OAAOA,EAAO22C,aACR,GACGgiB,EAAgB,IAAIE,GAAsC,QAAjB,EAAA74D,EAAO0d,kBAAU,QAAI,IAAE,KAC/D1d,EAAOod,GAAK,GAAG07C,EAAmB94D,EAAOod,GAAE,IAAM,IAClD27C,GAAyB/4D,EAAOqd,WAAa,IAAM,IAChE,EAQA,6BAAkC2M,EAAsBwkB,GACpD,IAAMgrB,OAA2Bx/D,IAAbw0C,GAA0BA,EACxCirB,OAA0Bz/D,IAAbw0C,IAA2BA,EAE9C,OACI,IAAA7d,iBAAgB3G,EAAS,UACvByvC,GAAczvC,EAAQ8uB,UAAUjuC,SAASouD,IACtCO,GAAexvC,EAAQ8uB,UAAUjuC,SAASmuD,KAlH9B,MAmHjBhvC,EAAQkI,WAEhB,EAOA,kCAAuClI,GACnC,OAAO,IAAA2G,iBAAgB3G,EAAS,QAAUA,EAAQ8uB,UAAUjuC,SAASquD,EACzE,EAQA,yBACIn5C,EACAiK,EACAhqB,EACA0D,GAEI,IAmBe+1B,EACbnnC,EACE2lD,EAAoBD,EArBxB,gBAoBE1lD,EAAsC,GACpC2lD,GAFWxe,EAnBmCzP,GAqBc,mBAAxCguB,EAA2Bve,EAAa,uBACpEnnC,EAAO4D,KACHkjE,EAAYnhB,EAAoBghB,GAChCG,EAAYphB,EAAwBghB,IAGjC1mE,GA3BuD,GAAzDonE,EAAc,KAAEC,EAAe,KAgBpC,OAdKD,IACDA,EAAiBL,EAAgBt5C,EAAKiK,GAAS,GAC3CtmB,GAAW1D,IACX,IAAA45D,aAAYF,EAAgBh2D,EAAQm2D,eAAe72D,QAAShD,EAAQ0D,IAIvEi2D,IACDA,EAAkBN,EAAgBt5C,EAAKiK,GAAS,GAC5CtmB,GAAW1D,IACX,IAAA45D,aAAYD,EAAiBj2D,EAAQm2D,eAAe72D,QAAShD,EAAQ0D,IAItE,CAACg2D,EAAgBC,EAC5B,C,yGCpKA,6BACI3oC,EACApmC,EACAkvE,GAEA,IAAMxnE,EACF0+B,EAAM+oC,gBAAkB/oC,EAAM+oC,eAAelvE,eAAeD,GACnDomC,EAAM+oC,eAAenvE,GACxBkvE,EAAO9oC,GAIjB,OAHAA,EAAM+oC,eAAiB/oC,EAAM+oC,gBAAkB,CAAC,EAChD/oC,EAAM+oC,eAAenvE,GAAO0H,EAErBA,CACX,C,4ICtBA,IAIM0nE,EAAmB,IAAI3qB,IAAY,CACrC,UACA,YACA,YACA,aACA,OACA,MACA,SACA,aAOJ,SAAgB4Q,EAAcjvB,GAC1B,IAAMipC,EAAYjpC,EAAMupB,SApBL,YAoBgBvpB,EAAMpmC,IACnCsvE,EAAWlpC,EAAMspB,QApBL,QAoBetpB,EAAMpmC,IACjCuvE,EAAYnpC,EAAMwpB,SApBL,SAoBgBxpB,EAAMpmC,IAEzC,OAAOqvE,GAAaC,GAAYC,CACpC,CANA,kBAeA,4BAAiCnpC,GAC7B,OAAQivB,EAAcjvB,MAAYA,EAAMpmC,KAA2B,GAApBomC,EAAMpmC,IAAIwB,MAC7D,EAOA,6BAAkC4kC,GAC9B,OAAOgpC,EAAiBzqB,IAAIve,EAAMpmC,IACtC,C,qHC7CA,eAGMwvE,IAAe,MAGhB,aAAc,SAAC56B,EAAMjzC,GAAU,OAACizC,EAAKnI,QAAU9qC,CAAhB,EAChC,EAAC,cAAe,SAACizC,EAAMjzC,GAAU,OAACizC,EAAKp9B,KAAO7V,CAAb,EACjC,EAAC,UAAW,SAACizC,EAAMjzC,EAAOsd,GAAU,QAAEA,IAAS21B,EAAK66B,aAAaxwD,GAAQtd,EAArC,EACpC,EAAC,qBAoEL,SAA6BizC,EAAqBjzC,GAC9C,IACIizC,EAAK66B,aAAa,gBAAkB9tE,EACpCizC,EAAK86B,YAActkE,KAAKukE,MAAMhuE,E,CAChC,SAAM,CACZ,EAxEI,EAAC,iBAAkB,SAACizC,EAAMjzC,GAAU,OAACizC,EAAKp9B,KAAO7V,CAAb,E,GASxC,iCACIgmB,EACAo/B,GAEA,IAAMnS,EAAsB,CACxBg7B,MAAO,GACPp4D,KAAM,GACNwL,MAAO,KACP6sD,MAAO,GACPpjC,QAAS,KACTgjC,aAAc,CAAC,EACfK,kBAAkB,GAGtB,OAAOC,QAAQC,KACVroD,GAAS,IAAIxhB,KAAI,SAAA4R,GACd,IAAMkH,EAAOlH,EAAKkH,KAElB,GAA8B,GAA1BA,EAAK/T,QAAQ,WAAmB0pC,EAAK5xB,OAAsB,QAAbjL,EAAK8vC,KAahD,IAAiB,QAAb9vC,EAAK8vC,KACZ,OAAO,IAAIkoB,SAAc,SAAAE,GACrB,IAAMxqD,EAAO1N,EAAKm4D,YACZzqD,IACFmvB,EAAKg7B,MAAMtkE,KAAK2T,GAChB21B,EAAKi7B,MAAOvkE,KAAKma,IAErBwqD,GACJ,IAEA,IAAM,EAwBtB,SAA8BhxD,EAAc8nC,GACxC,IAAMopB,EAAoC,GAAzBlxD,EAAK/T,QAAQ,SAAgB+T,EAAKlZ,UAAU,GAAkB,KACzEoU,EACF4sC,GAA0BopB,EAAWppB,EAAuB77C,QAAQilE,IAAa,EACrF,OAAOA,GAAYh2D,GAAS,EAAIg2D,OAAW/gE,CAC/C,CA7BmCghE,CAAqBnxD,EAAM8nC,GACxC,EACFyoB,EAAgBvwD,KAAU,EAAauwD,EAAgB,UAAY,MACvE,OAAO,IAAIO,SAAc,SAAAE,GACrB,SACMl4D,EAAKs4D,aAAY,SAAA1uE,GACbizC,EAAKg7B,MAAMtkE,KAAK2T,GAChB,EAAQ21B,EAAMjzC,EAAO,GACrBsuE,GACJ,IACAA,GANN,G,CAxBJ,OAFAr7B,EAAKg7B,MAAMtkE,KAAK2T,GAChB21B,EAAK5xB,MAAQjL,EAAKm4D,YACX,IAAIH,SAAc,SAAAE,GACjBr7B,EAAK5xB,OACL,IAAAsR,UAASsgB,EAAK5xB,OAAO,SAAAuR,GACjBqgB,EAAKtL,aAAe/U,EACpB07C,GACJ,IAEAA,GAER,GAwBR,KACFjpB,MAAK,WAAM,OAAApS,CAAA,GACjB,C,qGCtEA,yBACIhqC,GAEA,OAAOnJ,OAAOsF,KAAK6D,EACvB,C,yGCTA,eACA,WACA,WAEM0lE,EAA0B,CAAC,KAAM,KAAM,OAgD7C,SAASC,EAAmBnxC,GACxB,OAAO,IAAAiO,gBAAejO,IAAYkxC,EAAcplE,QAAQk0B,EAAQpkB,UAAY,CAChF,CAEA,SAASw1D,EAAiBzwD,EAAmBjH,GAGzC,IAFA,IAAM23D,GAAiB33D,EAAQ43D,cAAgB3wD,EAAKimB,kBAE3Ch9B,EAAO+W,EAAKW,WAAY1X,EAAMA,EAAOA,EAAK2X,YAC/C,IAAI,IAAAT,cAAalX,EAAM,cAAgBynE,EAAe,CAClD,IAAME,EAAW73D,EAAQ2iD,UACnBzyD,EAAK+0B,WAAa,IACjB/0B,EAAK+0B,WAAa,IAAIn0B,cAEzB+mE,IACA73D,EAAQ83D,eAAiBD,EACzB73D,EAAQ8hC,QAAQtvC,KAAK,CAAEtC,KAAI,EAAExH,OAAQmvE,EAASnvE,S,MAE3C,IAAA0e,cAAalX,EAAM,kBACtB8P,EAAQ83D,eAAiBL,EAAmBvnE,IAC5CmtB,EAAOpW,EAAKslB,cAAevsB,GAG/B03D,EAAiBxnE,EAAM8P,IAI3BA,EAAQ83D,eAAiBL,EAAmBxwD,IAC5CoW,EAAOpW,EAAKslB,cAAevsB,EAEnC,CAEA,SAASqd,EAAOhB,EAAerc,GAI3B,IAHA,IAAIoS,EACA0d,EAAa,GAET1d,EAASpS,EAAQ83D,cAAc1lE,QAAQ4N,EAAQtB,KAAMoxB,KAAgB,GAAG,CAC5E,IACK9vB,EAAQ4iD,YACG,GAAVxwC,GAAe2lD,EAAqB/3D,EAAQ83D,cAAc1lD,EAAS,OAChEA,EAASpS,EAAQtB,KAAKhW,QAAUsX,EAAQ83D,cAAcpvE,QACnDqvE,EAAqB/3D,EAAQ83D,cAAc1lD,EAASpS,EAAQtB,KAAKhW,UAC3E,CACE,IAAM42B,EAAQ04C,EAAkBh4D,EAAQ8hC,QAAS1vB,GAAQ,GACnDmN,EAAMy4C,EACRh4D,EAAQ8hC,QACR1vB,EAASpS,EAAQtB,KAAKhW,QACtB,GAGJ,GAAI42B,GAASC,EAAK,CACd,IAAMkC,EAAQpF,EAAI6R,cAElBzM,EAAMwV,SAAS3X,EAAMpvB,KAAMovB,EAAMlN,QACjCqP,EAAMyV,OAAO3X,EAAIrvB,KAAMqvB,EAAInN,QAC3BpS,EAAQpR,OAAO4D,KAAKivB,E,EAI5BqO,EAAa1d,EAASpS,EAAQtB,KAAKhW,M,CAGvCsX,EAAQ83D,cAAgB,GACxB93D,EAAQ8hC,QAAU,EACtB,CAEA,SAASi2B,EAAqBzqE,GAC1B,OAAO,IAAAglB,SAAQhlB,KAAS,IAAA+kB,eAAc/kB,EAC1C,CAEA,SAAS0qE,EACLC,EACA7lD,EACA8lD,GAIA,IAFA,IAAI5pD,EAAe,EAEVzjB,EAAI,EAAGA,EAAIotE,EAAQvvE,OAAQmC,IAAK,CACrC,IAAMstE,EAAgBF,EAAQptE,GAAGnC,OAEjC,GACIwvE,EAAQ5pD,EAAe6pD,GAAiB/lD,EAAS9D,EAAe6pD,EAAgB/lD,EAEhF,MAAO,CAAEliB,KAAM+nE,EAAQptE,GAAGqF,KAAMkiB,OAAQA,EAAS9D,GAGrDA,GAAgB6pD,C,CAGpB,OAAO,IACX,CAjHA,2BACIlxD,EACAvI,EACAikD,EACAC,EACAgV,GAEA,IAAM53D,EAAyB,CAC3BtB,KAAMikD,EAAYjkD,EAAOA,EAAK5N,cAC9B6xD,UAAS,EACTC,UAAS,EACTh0D,OAAQ,GACRkpE,cAAe,GACfh2B,QAAS,GACT81B,eAAgBA,GAOpB,OAJI53D,EAAQtB,MACRg5D,EAAiBzwD,EAAMjH,GAGpBA,EAAQpR,MACnB,C,yGClDA,IAAMwpE,EAAiC,eASvC,6BAAkC1+C,GAC9B,OAAKA,EAIDA,EAAGxsB,MAAMkrE,GACF,QAAQ1+C,EAAE,KAEV,IAAIA,EANJA,CAQf,C,6HCSA,6BACIxpB,EACAhJ,GAEA,IACMmxE,EADyBnoE,EACeooE,0BAE9C,OAAOD,EAAiBA,EAAenxE,QAAOoP,CAClD,EAKA,6BACIpG,EACAhJ,EACA2B,GAEA,IAAM0vE,EAAyBroE,EACzBmoE,EAAiBE,EAAuBD,2BAA6B,CAAC,EAE5ED,EAAenxE,GAAO2B,EACtB0vE,EAAuBD,0BAA4BD,CACvD,C,sHCnDA,eAKA,yBAA8B/xC,GAC1B,OAAO,IAAAkyC,mBAAkBlyC,EAAS,aACtC,EAKA,yBAA8BA,EAAsB9iB,IAChD,IAAAi1D,mBAAkBnyC,EAAS,aAAc9iB,EAC7C,C,iICdA,eAKA,8BAAmC8iB,GAC/B,OAAO,IAAAkyC,mBAAkBlyC,EAAS,kBACtC,EAKA,8BAAmCA,EAAsB9iB,IACrD,IAAAi1D,mBAAkBnyC,EAAS,kBAAmB9iB,EAClD,C,gICdA,eAGMk1D,EAA2C,cAQjD,8BAAmC1sE,EAAsB2sE,IACrD,IAAAF,mBAAkBzsE,EAAG0sE,EAAoBC,EAC7C,EAQA,6BAAkC3sE,GAC9B,SAAS,IAAAwsE,mBAAkBxsE,EAAG0sE,EAClC,C,uGCjBA,2BACIpyC,EACA1O,G,MAEA,OAAuB,QAAhB,EAAA0O,aAAO,EAAPA,EAASpkB,eAAO,eAAEqJ,sBAAuBqM,CACpD,C,4GCVA,IAAMghD,EAAsB,IAAIjtB,IAAI,CAChC,MACA,OACA,IACA,UACA,UACA,QACA,SACA,SACA,OACA,MACA,UACA,aACA,MACA,SACA,aACA,WAMJ,gCAAqCrlB,GACjC,IAAKA,EACD,OAAO,EAGX,IAAMpkB,EAAUokB,EAAQpkB,QAAQpR,cAEhC,OAAO8nE,EAAoB/sB,IAAI3pC,EACnC,C,oGCxBA,wBACIhS,EACA2oE,GAEA,QAAS3oE,GAAQA,EAAK4oE,UAAYle,KAAKie,EAC3C,C,6GCXA,IAAME,EAAwB,CAAC,MAAO,WAAY,gBAMlD,iCAAsCpvC,GAClC,QAASA,GAAcovC,EAAsB3mE,QAAQu3B,IAAe,CACxE,C,6BCHA,SAAgBkH,EAAenuB,EAAck5B,EAAeo9B,GACxD,GAAKt2D,EAAL,CAIA,MAAQs2D,GAAwBt2D,EAAOkF,YACnClF,EAAO0lB,YAAY1lB,EAAOkF,YAG9B,KAAOg0B,aAAM,EAANA,EAAQh0B,YACXlF,EAAOwW,YAAY0iB,EAAOh0B,W,CAElC,C,6FAZA,mBAoBA,6BACIpY,EACA0S,GAEA,IAAM+2D,EAAazpE,EAAO+8B,cAAcvT,cAAc9W,GAKtD,OAHA2uB,EAAeooC,EAAYzpE,GAC3BA,EAAO0pB,YAAY+/C,GAEZA,CACX,C,qGC7BA,yBAA8BC,GACpB,MACFA,GAAuB,CAAE39D,KAAM,EAAGI,MAAO,EAAG2hC,IAAK,EAAGC,OAAQ,GADxDhiC,EAAI,OAAEI,EAAK,QAAE2hC,EAAG,MAAEC,EAAM,SAEhC,OAAgB,IAAThiC,GAAwB,IAAVI,GAAuB,IAAR2hC,GAAwB,IAAXC,EAC3C,KACA,CACIhiC,KAAMnS,KAAKqD,MAAM8O,GACjBI,MAAOvS,KAAKqD,MAAMkP,GAClB2hC,IAAKl0C,KAAKqD,MAAM6wC,GAChBC,OAAQn0C,KAAKqD,MAAM8wC,GAEjC,C,gGCZA,oBAAyB5wB,EAAY+G,GACjC,IACI,GAAI/G,EAAM,CACN,IAAM,EAAS,IAAIwsD,WACnB,EAAOC,OAAS,WACZ1lD,EAAS,EAAO9kB,OACpB,EACA,EAAOyqE,QAAU,WACb3lD,EAAS,KACb,EACA,EAAO4lD,cAAc3sD,E,EAE3B,SACE+G,EAAS,K,CAEjB,C,kHCrBA,aAOA,oCAAyC2I,G,MAC/BztB,EAAiC,CAAC,EAClC28B,EAAsC,QAAzB,EAAAlP,EAAIsa,cAAc,eAAO,eAAEpL,WAU9C,OARCA,GAAa,IAAA9D,SAAQ8D,GAAc,IAAIr9B,SAAQ,SAAAqiE,GAC5C3hE,EAAO2hE,EAAKhgE,MAAQggE,EAAK1nE,KAC7B,KAEA,IAAA4+B,SAAQpL,EAAIqL,iBAAiB,SAASx5B,SAAQ,SAAAqrE,GAC1C3qE,EAAO2qE,EAAKhpE,MAAQgpE,EAAKC,OAC7B,IAEO5qE,CACX,C,4GCpBA,eACA,WAYA,8BACIY,EACA82B,EACA4X,EACAl+B,G,MAEA,GAAIsmB,EAAQjf,YAAc7X,EAAQ,CAM9B,IALA,IAAMomE,GAAW,IAAAh4B,iBAAgBtX,GAK1B4X,GAAWA,GAAW5X,IAAYsvC,KAAa,IAAAh4B,iBAAgBM,KAAW,CAC7E,IAAME,EAAOF,EAAQr2B,YAEH,QAAlB,EAAAq2B,EAAQ72B,kBAAU,SAAE+gB,YAAY8V,IAE5B,IAAA92B,cAAa82B,EAAS,kBACtBl+B,SAAAA,EAAS25C,qBAAqBnnD,KAAK0rC,IAGvCA,EAAUE,C,CAGVF,GAAWA,GAAW5X,EACtB4X,EAAUA,EAAQr2B,YAElBrY,EAAOgnC,aAAalQ,EAAS4X,E,MAGjC1uC,EAAOgnC,aAAalQ,EAAS4X,GAGjC,OAAOA,CACX,C,6BC6BA,SAASu7B,EAAal2C,EAAsBm2C,GACxC,YAAuBpjE,IAAnBojE,EACOn2C,EAAUO,qBAEV41C,CAEf,C,6EAvEA,8BACIl9B,EACAD,EACAhZ,EACAo2C,EACAC,EACAC,GAEA,IAAIh2C,OAHJ,IAAA+1C,IAAAA,EAAA,QACA,IAAAC,IAAAA,GAAA,GAGA,IAAIh9C,EAAS,EAEO,GAAhB+8C,IACA/1C,EAAY41C,EAAal2C,EAAWM,GAEpChH,EAASzzB,KAAKC,IACV,EACAD,KAAKD,IACDywE,EAAe/1C,GACd0Y,EAAYgB,OAAShB,EAAYe,IAAMq8B,EAAWp8B,OAASo8B,EAAWr8B,KAAO,KAK1F,IAAMA,EAAMq8B,EAAWr8B,IAAMzgB,EACvB0gB,EAASo8B,EAAWp8B,OAAS1gB,EAC7B1G,EAASonB,EAASD,EAGlBw8B,EAAW,WACbj2C,EAAY41C,EAAal2C,EAAWM,GACpC2Y,EAAgBif,YAAclf,EAAYe,IAAMA,GAAOzZ,CAC3D,EAEMk2C,EAAa,WACfl2C,EAAY41C,EAAal2C,EAAWM,GACpC2Y,EAAgBif,YAAcle,EAAShB,EAAYgB,QAAU1Z,CACjE,EAGMm2C,EAAgB18B,EAAMf,EAAYe,IAClC28B,EAAkB18B,EAAShB,EAAYgB,OAEzCpnB,EAASomB,EAAYgB,OAAShB,EAAYe,IAEtCu8B,EACAC,IAEAC,IAEGF,EACHG,EACAF,IACOG,GACPF,IAGAE,EACAF,IACOC,GACPF,GAGZ,C,+GCzEA,eACA,WAkCA,SAASI,EAAkB/5C,EAAqBsB,GACpC,IAAAvxB,EAAiBiwB,EAAG,KAAd/N,EAAW+N,EAAG,OAE5BsB,EAAMwV,SAAS/mC,EAAMkiB,GACrBqP,EAAMyV,OAAOhnC,EAAMkiB,GAEnB,IAAMiqB,GAAO,IAAAe,eAAc3b,EAAM4b,yBAEjC,GAAIhB,EACA,OAAOA,EAEP,IAAMc,EAAQ1b,EAAM04C,gBAAkB14C,EAAM04C,iBAE5C,OAAOh9B,GAAyB,GAAhBA,EAAMz0C,QAAc,IAAA00C,eAAcD,EAAM,IAAM,IAEtE,CAzCA,iCAAsC9gB,EAAe8D,G,QA2CzBjwB,EA1ClBuxB,EAAQpF,EAAI6R,cAElB,OAE+D,QAD3D,EAA6B,QAA7B,EAAAgsC,EAAkB/5C,EAAKsB,UAAM,QAC7By4C,EAAmB/5C,EAK3B,SAA8BA,GAG1B,IAFM,IAAAjwB,EAAiBiwB,EAAG,KAAd/N,EAAW+N,EAAG,OAEnBjwB,EAAKi6C,WACJ/3B,GAAUliB,EAAKqnC,WAAW7uC,OAE1B0pB,GADAliB,EAAOA,EAAKi6C,WACE5S,WAAW7uC,QAEzBwH,EAAOA,EAAKqnC,WAAWnlB,GACvBA,EAAS,GAIjB,MAAO,CAAEliB,KAAI,EAAEkiB,OAAM,EACzB,CAnBiCgoD,CAAqBj6C,GAAOsB,UAAM,SAsCvCvxB,EArCDiwB,EAAIjwB,MAsCpB,IAAAkX,cAAalX,EAAM,iBAAmBA,EAAKmtC,uBAC5C,IAAAD,eAAcltC,EAAKmtC,yBACnB,KAtCV,C,4GCRA,gCAAqCr2B,GACjC,OAAQA,EAEgB,SAAlBA,EAAUb,KACVa,EAAUya,MAAMqb,wBACE,SAAlB91B,EAAUb,KACVa,EAAU1D,MACQ,SAAlB0D,EAAUb,KACVa,EAAUkD,WACV5T,OAPAA,CAQV,C,+HCnBA,IAAM+jE,EAAe,4DAOrB,yBAA8B/sE,GAC1B,MAPiB,gBAOG8E,QAAQ9E,IAAS,CACzC,EAOA,mBAAwBA,G,MACduY,EAA0B,QAAnB,EAAAvY,aAAI,EAAJA,EAAMgtE,WAAW,UAAE,QAAI,EACpC,OAAe,KAARz0D,GAAuB,IAARA,GAAcw0D,EAAa9tD,KAAKjf,EAC1D,EAQA,yBAA8B03B,EAAau1C,GACvC,OAAOv1C,EAAIpmB,QAAQ27D,EAAY,WAAa,WAAY,IAC5D,C,gIC3BA,IAAMC,EAAe,CACjB,OACA,SACA,SACA,SACA,QACA,SACA,SACA,QACA,QACA,UAEEC,EAAkB,mCAOxB,+BAAoCC,GAChC,IAAM9rE,EAAiB,CAAC,EAaxB,OAZgB8rE,GAAkB,IAAI97D,QAAQ,MAAO,KAAKxR,MAAM,KAEzDc,SAAQ,SAAAvE,GACP6wE,EAAapoE,QAAQzI,IAAM,IAAMiF,EAAO0b,MACxC1b,EAAO0b,MAAQ3gB,EACR8wE,EAAgBluD,KAAK5iB,KAAOiF,EAAOyb,MAC1Czb,EAAOyb,MAAQ1gB,EACRA,IAAMiF,EAAOjC,QACpBiC,EAAOjC,MAAQhD,EAEvB,IAEOiF,CACX,EAOA,8BAAmC/F,GAC/B,MAAO,CAACA,EAAMwhB,OAAS,GAAIxhB,EAAMyhB,OAAS,GAAIzhB,EAAM8D,OAAS,IAAIY,KAAK,KAAKqW,QAAU,MACzF,C,8FCzCA,kBAAuB+2D,GACnB,QACMA,IAA2B,QAAbA,GAAoC,UAAbA,GAAyBltE,SAASktE,IAAc,IAE/F,C,6BCkBA,SAASC,EAAQpqD,EAAoB5hB,EAAkB0wB,EAAeC,GACjD/O,EAAWvjB,UAAUqyB,EAAOC,GAAKnyB,MAAM,KAE/Cc,SAAQ,SAAA2sE,IACbA,EAASA,EAAOj3D,UAIR,iBAAiB2I,KAAKsuD,GACtBjsE,EAAO4D,KAAK,IAAIqoE,EAAM,KAEtBjsE,EAAO4D,KAAKqoE,GAGxB,GACJ,C,8EAnCA,+BAAoCrqD,GAMhC,IALA,IAAMsqD,EAA2B,mBAC7B5tE,EAAQ4tE,EAAyB/uC,KAAKvb,GACtC8O,EAAQ,EACN1wB,EAAmB,GAElB1B,GACH0tE,EAAQpqD,EAAY5hB,EAAQ0wB,EAAOpyB,EAAMmU,OAEzCie,EAAQpyB,EAAMmU,MAAQnU,EAAM,GAAGxE,OAC/BkG,EAAO4D,KAAKtF,EAAM,IAElBA,EAAQ4tE,EAAyB/uC,KAAKvb,GAK1C,OAFAoqD,EAAQpqD,EAAY5hB,EAAQ0wB,EAAO9O,EAAW9nB,QAEvCkG,EAAOrB,KAAK,KACvB,C,wGCxBA,eACA,WACA,WA6EA,SAASwtE,EACL9zD,EACA+zD,EACAC,GAEIA,GAAeC,EAAcj0D,IAC7B+zD,EAAY/zD,GAGhB,IAAK,IAAIU,EAAQV,EAAKW,WAAYD,EAAOA,EAAQA,EAAME,YAC/CqzD,EAAcvzD,IACdqzD,EAAYrzD,GAGhBozD,EAAgBpzD,EAAOqzD,EAE/B,CAKA,SAASE,EAAchrE,GACnB,IAAMirE,EAA2BjrE,EACjC,OAAOA,EAAK4oE,UAAYle,KAAKwgB,gBAAkBD,EAAY7wD,KAC/D,CA5EA,0BACI+sB,EACA4jC,EACA1+D,EACAknB,EACA43C,GAEA,IAAMC,EAA0B,eAAb/+D,EACbizB,GAAe6rC,aAAqB,EAArBA,EAAuB7rC,gBAAgB,EAa5DurC,EAAgB1jC,GAZI,SAAC/Q,GACjB,IAAM1gB,GAAY,IAAA08C,UAASh8B,GAAS,GAAyBg1C,EAAY73C,GACnE83C,GAAY,IAAAjZ,UAASh8B,GAAS,GAAwBg1C,EAAY73C,IAExE,IAAAq2B,UAASxzB,EAAS1gB,GAAW,EAAwB01D,EAAY73C,IACjE,IAAAq2B,UAASxzB,EAASi1C,GAAW,EAAuBD,EAAY73C,GAE5D+L,GAQZ,SACIlJ,EACAg1C,EACA73C,KAEI,IAAAwJ,iBAAgB3G,EAAS,QAAS,IAAA2G,iBAAgB3G,EAAS,QAC3D,EAAAk1C,WAAWttE,SAAQ,SAAAhH,GACf,IAAMu0E,EAAsB,EAAAC,kBAAkBx0E,GACxCojB,EAAQgc,EAAQhc,MAAMqmD,iBAAiB8K,GAC7C,GAAInxD,EAAO,CACP,IAAMqxD,GAAa,IAAAC,mBAAkBtxD,GAAQgxD,EAAY73C,GACzD,GAAIk4C,EAAY,CACZ,IAAME,GAAmB,IAAAC,YACrBx1C,EACAq1C,EACA,SACAL,EACA73C,GAEAo4C,GACAv1C,EAAQhc,MAAMnN,YAAYs+D,EAAqBI,E,EAI/D,GAER,CAjCYE,CAAqBz1C,EAASg1C,EAAY73C,EAElD,GAEuCw3C,EAC3C,C,yGCjDA,aAQA,2BAAgC33D,GAC5B,IAAM04D,GAAM,IAAAv0C,SAAQnkB,EAAMhG,MACpBE,EAAqBw+D,EAAI3uE,KAAI,SAAAkQ,GAAO,YA8B1C,OA5BAy+D,EAAI9tE,SAAQ,SAACmkE,EAAIptD,GACb,IAAK,IAAIutD,EAAY,EAAGC,EAAY,EAAGD,EAAYH,EAAG70D,MAAM9U,OAAQ8pE,IAAa,CAE7E,UAAsCl8D,IAA/BkH,EAAMyH,GAAUwtD,GAA0BA,KAIjD,IAFA,IAAMrV,EAAKiV,EAAG70D,MAAMg1D,GAEXI,EAAU,EAAGA,EAAUxV,EAAGwV,QAASA,IAAWH,IACnD,IAAK,IAAIK,EAAU,EAAGA,EAAU1V,EAAG0V,QAASA,IACpCt1D,EAAMyH,EAAW6tD,KACjBt1D,EAAMyH,EAAW6tD,GAASL,GACX,GAAXG,EACiB,GAAXE,EACI1V,EACA,UACO,GAAX0V,EACA,WACA,W,CAM1B,IAAK,IAAIl+C,EAAM,EAAGA,EAAMpX,EAAMyH,GAAUvc,OAAQksB,IAC5CpX,EAAMyH,GAAU2P,GAAOpX,EAAMyH,GAAU2P,IAAQ,IAEvD,IAEOpX,CACX,C,6FCTA,mBAAwBy+D,GACpB,MAAO,GAAGvtE,MAAMC,KAAKstE,EACzB,C,8FC9BA,kBAAuB/rE,GAEnB,IAAMmX,EAAanX,EAAOA,EAAKmX,WAAa,KAE5C,IAAKA,EACD,OAAO,KAGX,KAAOnX,EAAK0X,YACRP,EAAWmvB,aAAatmC,EAAK0X,WAAY1X,GAI7C,OADAmX,EAAW+gB,YAAYl4B,GAChBmX,CACX,C,4FCVA,gBACIgV,EACAnsB,EACAgsE,G,MAEMt1D,EAAUyV,EAAIrD,cAAckjD,GAIlC,OAHe,QAAf,EAAAhsE,EAAKmX,kBAAU,SAAEmvB,aAAa5vB,EAAS1W,GACvC0W,EAAQsS,YAAYhpB,GAEb0W,CACX,C,gHClBA,eAOa,EAAAu1D,uBAAyD,CAClEtF,MAAO,SAACv6D,EAAQgqB,EAASxU,EAAG20C,GACxB,IAAM2V,EAAM91C,EAAQhc,MAAM/N,WAAa+pB,EAAQ81C,KAAO3V,EAAalqD,UAE/D6/D,IACA9/D,EAAOC,UAAmB,OAAP6/D,EAAe,MAAQ,MAElD,EACAC,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOC,YACP+pB,EAAQhc,MAAM/N,UAAYD,EAAOC,WAGb,OAApBD,EAAOC,YAAsB,IAAA0wB,iBAAgB3G,EAAS,WACtDA,EAAQhc,MAAMgyD,YAAc,WAEpC,E,4GCjBS,EAAAC,qBAAqD,CAC9D1F,MAAO,SAACv6D,EAAQgqB,GACZ,IAAMrN,EAAUqN,EAAQhc,MAAM2O,QAE1BA,IACA3c,EAAO2c,QAAUA,EAEzB,EACAojD,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO2c,UACPqN,EAAQhc,MAAM2O,QAAU3c,EAAO2c,QAEvC,E,gHClBJ,eACA,WAWa,EAAAujD,uBAET,CACA3F,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAE9B,IAAKngC,EAAQhc,MAAM1N,UAAW,CAC1B,EAAAu/D,uBAAuBtF,MAAMv6D,EAAQgqB,EAAStmB,EAASymD,GAEvD,IAAMgW,EAAYn2C,EAAQiC,aAAa,SAEnCk0C,IACAngE,EAAOmgE,WAAY,IAAAC,WAAUD,EAAWngE,EAAOC,kBACxCD,EAAOM,iBACPoD,EAAQwlB,YAAY5oB,U,CAGvC,EACAy/D,MAAO,SAAC//D,EAAQgqB,GACZ,IAAM81C,EAAyC,OAApB9/D,EAAOC,UAAqB,MAAQ,MAE3DD,EAAOmgE,WACPn2C,EAAQgC,aAAa,QAAS,EAAAhtB,UAAUgB,EAAOmgE,WAAWL,GAElE,E,+GC7BS,EAAAO,wBAA2D,CACpE9F,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAMxuC,EAAaqO,EAAQhc,MAAM2N,YAAcwuC,EAAaxuC,WAExDA,GAA4B,WAAdA,IACd3b,EAAO2b,WAAaA,EAE5B,EACAokD,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO2b,aACPqO,EAAQhc,MAAM2N,WAAa3b,EAAO2b,WAE1C,E,6GClBJ,eAIM2kD,EAAiE,CACnE,YACA,cACA,eACA,cAGEC,EAGF,CACArhE,IAAK,CACD4B,YAAa,kBACbH,WAAY,qBAEhBxB,IAAK,CACD2B,YAAa,oBACbH,WAAY,oBAId6/D,EAAsD,CACxD7/D,WAAY,cACZG,YAAa,aACbmT,UAAW,YACXD,aAAc,gBAML,EAAAysD,oBAAqE,CAC9ElG,MAAO,SAACv6D,EAAQgqB,EAASxU,EAAG20C,GACxBmW,EAAW1uE,SAAQ,SAAAhH,G,QACT81E,EAAiBH,EAAiC,QAAhB,EAAAvgE,EAAOC,iBAAS,QAAI,OAAOrV,GAC7D2B,EACFy9B,EAAQhc,MAAMpjB,IACdu/D,EAAav/D,KACZ81E,EAA6C,QAA5B,EAAAvW,EAAauW,UAAe,eAAEjwE,WAAa,IAEjE,GAAIlE,EACA,OAAQ3B,GACJ,IAAK,YACL,IAAK,eACDoV,EAAOpV,GAAO2B,EACd,MAEJ,IAAK,aACL,IAAK,cACDyT,EAAOpV,GAAOoV,EAAOpV,IACf,IAAA0Y,oBAAmBtD,EAAOpV,IAAQ,GAAIo/B,IACtC,IAAA1mB,oBAAmB/W,EAAOy9B,GAC1B,KACAz9B,EAItB,GACJ,EACAwzE,MAAO,SAAC//D,EAAQgqB,EAAStmB,GACrB48D,EAAW1uE,SAAQ,SAAAhH,GACf,IAAM2B,EAAQyT,EAAOpV,GACf+1E,EAA6B,OAApB3gE,EAAOC,UAAqBugE,EAAI51E,GAAOA,EAElD2B,GAASmX,EAAQk9D,eAAeD,KAChC32C,EAAQhc,MAAMpjB,GAAO2B,GAAS,IAEtC,GACJ,E,8GCxEJ,eAIMs0E,EAAmE,CACrE,aACA,eACA,gBACA,eAGEC,EAGD,CACDlgE,YAAa,sBAGXmgE,EAGD,CACDhgE,aAAc,sBAML,EAAAigE,qBAAuE,CAChFzG,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,EAAA0V,uBAAuBtF,MAAMv6D,EAAQgqB,EAAStmB,EAASymD,GAEvD0W,EAAYjvE,SAAQ,SAAAhH,G,QACZ2B,EAAQy9B,EAAQhc,MAAMpjB,GACpBq2E,GAAqC,OAApBjhE,EAAOC,UACxB8gE,EACAD,GAAmBl2E,GACnBs2E,GAE2D,QAD5D,EAAiB,QAAjB,EAAA/W,EAAav/D,UAAI,QACbq2E,EAAgB9W,EAAa8W,QAAiBjnE,SAAU,QACzD,OAAS,GAEZzN,IACDA,EAAQ20E,GAGP30E,GAAkB,KAATA,IACVA,EAAQ,OAGRA,GAASA,GAAS20E,IAClBlhE,EAAOpV,GAAO2B,EAEtB,GACJ,EACAwzE,MAAO,SAAC//D,EAAQgqB,EAAStmB,GACrBm9D,EAAYjvE,SAAQ,SAAAhH,GAChB,IAAM2B,EAAQyT,EAAOpV,GACjBs2E,OAAmClnE,EAEhB,MAAnBgwB,EAAQpkB,SAAsC,MAAnBokB,EAAQpkB,UAEV,OAApB5F,EAAOC,WAA6B,gBAAPrV,GACT,OAApBoV,EAAOC,WAA6B,eAAPrV,KAE9Bs2E,EAAe,QAInB30E,GAASA,GAAS20E,IAClBl3C,EAAQhc,MAAMpjB,GAAO2B,EAE7B,GACJ,E,+GCzEJ,eACA,WAOa,EAAA40E,uBAA2E,CACpF5G,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,G,MAC9B,EAAA0V,uBAAuBtF,MAAMv6D,EAAQgqB,EAAStmB,EAASymD,GAEvD,IAAM7pD,EAAY0pB,EAAQhc,MAAM1N,WAAa6pD,EAAa7pD,UAEtDA,GAAsD,UAApB,QAArB,EAAA0pB,EAAQ0H,qBAAa,eAAE1jB,MAAM2O,WAC1C3c,EAAOM,WAAY,IAAA8/D,WAAU9/D,EAAWN,EAAOC,WAEvD,EACA8/D,MAAO,SAAC//D,EAAQgqB,GACZ,IAAM81C,EAAyC,OAApB9/D,EAAOC,UAAqB,MAAQ,MAE3DD,EAAOM,YACP0pB,EAAQhc,MAAM1N,UAAY,EAAAtB,UAAUgB,EAAOM,WAAWw/D,GAE9D,E,+GClBS,EAAAsB,wBAA2D,CACpE7G,MAAO,SAACv6D,EAAQgqB,GACZ,IAAMouC,EAAapuC,EAAQhc,MAAMoqD,WAE7BA,IACAp4D,EAAOo4D,WAAaA,EAE5B,EACA2H,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOo4D,aACPpuC,EAAQhc,MAAMoqD,WAAap4D,EAAOo4D,WAE1C,E,gHClBJ,aAOa,EAAAiJ,wBAA2D,CACpE9G,MAAO,SAACv6D,EAAQgqB,EAASxU,EAAG20C,GACxB,IAAM98B,EAAarD,EAAQhc,MAAMqf,YAAc88B,EAAa98B,YAExD,IAAAi0C,gBAAej0C,EAAY,SAAUrtB,EAAOqtB,WAAY88B,EAAa98B,cACrErtB,EAAOqtB,WAAaA,EAE5B,EACA0yC,MAAO,SAAC//D,EAAQgqB,EAAStmB,GACrB,IAAM2pB,EAAa3pB,EAAQk9D,eAAevzC,WACtCrtB,EAAOqtB,YAAcA,IACrBrD,EAAQhc,MAAMqf,WAAartB,EAAOqtB,YAAc,SAExD,E,yGCdS,EAAAk0C,kBAA+C,CACxDhH,MAAO,SAACv6D,EAAQgqB,GACZ,IAAMw3C,EAAkBx3C,EAAQiC,aAAa,oBACvC0nC,EAAQ3pC,EAAQiC,aAAa,SAC/Bu1C,IACAxhE,EAAOwhE,gBAAkBA,GAEzB7N,IACA3zD,EAAO2zD,MAAQA,EAEvB,EACAoM,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOwhE,iBACPx3C,EAAQgC,aAAa,mBAAoBhsB,EAAOwhE,iBAEhDxhE,EAAO2zD,OACP3pC,EAAQgC,aAAa,QAAShsB,EAAO2zD,MAE7C,E,sHCxBJ,eACA,SAOa,EAAA8N,6BAAqE,CAC9ElH,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAMrqC,GACF,IAAAkmC,UACIh8B,GACA,IACEtmB,EAAQ8a,WACV9a,EAAQyjB,mBACPgjC,EAAarqC,iBAGlB,IAAAwhD,gBACIxhD,EACA,mBACA9lB,EACAmwD,EAAarqC,mBAGjB9f,EAAO8f,gBAAkBA,EAEjC,EACAigD,MAAO,SAAC//D,EAAQgqB,EAAStmB,GACjB1D,EAAO8f,kBACP,IAAA09B,UACIxzB,EACAhqB,EAAO8f,iBACP,IACEpc,EAAQ8a,WACV9a,EAAQyjB,iBAGpB,E,8GCjCS,EAAAu6C,uBAAyD,CAClEnH,MAAO,SAACv6D,EAAQgqB,G,MACoB,eAAf,QAAb,EAAAA,EAAQhc,aAAK,eAAEy+C,aACfzsD,EAAO+I,cAAe,EAE9B,EACAg3D,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO+I,eACPihB,EAAQhc,MAAMy+C,UAAY,aAElC,E,iHChBJ,eACA,WACA,WAOMkV,EAEF,CACApzD,UAAW,mBACX9M,YAAa,qBACb+M,aAAc,sBACdhN,WAAY,qBAMVogE,EAEF,CACArzD,UAAW,mBACX9M,YAAa,qBACb+M,aAAc,sBACdhN,WAAY,qBAMH,EAAAqgE,yBAAwD,CACjEtH,MAAO,SAACv6D,EAAQgqB,EAAStmB,GAEjBA,EAAQ+jB,sBACR/jB,EAAQ+jB,qBAAqB3xB,QAAQ,+BAAiC,GAEtE,EAAAopE,WAAWttE,SAAQ,SAAAhH,GACf,IAAMmjB,EAAQic,EAAQhc,MAAMqmD,iBAAiBsN,EAAkB/2E,IACzDojB,EAAQgc,EAAQhc,MAAMqmD,iBAAiBuN,EAAkBh3E,IACzDujB,GAAc,IAAA2zD,sBAAqB93C,EAASp/B,GAElD,GAAIujB,EAAa,CACb,IAAM4zD,GAAiB,IAAAzC,mBACnBnxD,IACEzK,EAAQ8a,WACV9a,EAAQyjB,kBAGZnnB,EAAOpV,IAAO,IAAAo3E,oBAAmB,CAC7Bj0D,MAAK,EACLC,MAAK,EACL3d,MAAO0xE,G,CAGnB,GAER,EACAhC,MAAO,SAAC//D,EAAQgqB,EAAStmB,GAEjBA,EAAQ+jB,sBACR/jB,EAAQ+jB,qBAAqB3xB,QAAQ,+BAAiC,GAEtE,EAAAopE,WAAWttE,SAAQ,SAAAhH,GACf,IAAM2B,EAAQyT,EAAOpV,GACrB,GAAI2B,EAAO,CACP,IAAM01E,GAAe,IAAA/zD,qBAAoB3hB,GACzC,GAAI01E,EAAa5xE,MAAO,CACpB,IAAMkvE,GAAmB,IAAAC,YACrBx1C,EACAi4C,EAAa5xE,MACb,WACEqT,EAAQ8a,WACV9a,EAAQyjB,kBAEZ,GAAIo4C,EAAkB,CAClB,IAAMJ,EAAsB,EAAAC,kBAAkBx0E,GAC9Co/B,EAAQhc,MAAMnN,YAAYs+D,EAAqBI,E,GAI/D,GAER,E,4HCrFJ,WAKM2C,EAAiD,CACnD,iBACA,mBACA,oBACA,mBAGEC,EAAuE,CACzE,sBACA,uBACA,yBACA,2BAGEC,GAAU,EAAH,qDAAO,EAAAlD,aAAU,gBAAKiD,IAAgB,GAKtC,EAAAE,oBAAmD,CAC5D9H,MAAO,SAACv6D,EAAQgqB,EAASxU,EAAG20C,GACxB,EAAA+U,WAAWttE,SAAQ,SAAChH,EAAK2D,G,MACfhC,EAAQy9B,EAAQhc,MAAMpjB,GACtB03E,EAA+C,QAAhC,EAAAnY,EAAa+X,EAAgB3zE,WAAG,QAAI,MACrDwf,EAAQic,EAAQhc,MAAMk0D,EAAgB3zE,IAE7B,KAATwf,IACAA,EAAQ,OAGRxhB,GAASwhB,GAASu0D,IAClBtiE,EAAOpV,GAAgB,QAAT2B,EAAkB,GAAKA,EAE7C,IAEA,IAAMuhB,EAAekc,EAAQhc,MAAMF,aAE/BA,EACA9N,EAAO8N,aAAeA,EAEtBq0D,EAAiBvwE,SAAQ,SAAAhH,GACrB,IAAM2B,EAAQy9B,EAAQhc,MAAMpjB,GAExB2B,IACAyT,EAAOpV,GAAO2B,EAEtB,GAER,EACAwzE,MAAO,SAAC//D,EAAQgqB,GACZo4C,EAAQxwE,SAAQ,SAAAhH,GACZ,IAAM2B,EAAQyT,EAAOpV,GAEjB2B,IACAy9B,EAAQhc,MAAMpjB,GAAO2B,EAE7B,IAEIyT,EAAO8N,eACPkc,EAAQhc,MAAMF,aAAe9N,EAAO8N,aAE5C,E,8GC5DS,EAAAy0D,uBAAyD,CAClEhI,MAAO,SAACv6D,EAAQgqB,G,OACK,QAAb,EAAAA,EAAQhc,aAAK,eAAEsS,aACftgB,EAAOsgB,UAAY0J,EAAQhc,MAAMsS,UAEzC,EACAy/C,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOsgB,YACP0J,EAAQhc,MAAMsS,UAAYtgB,EAAOsgB,UAEzC,E,8GChBJ,eAOa,EAAAkiD,qBAAqD,CAC9DjI,MAAO,SAACv6D,EAAQgqB,GACZ,IAAMxlB,EAAUwlB,EAAQxlB,SAExB,IAAAoM,eAAcpM,GAAS5S,SAAQ,SAAAhH,GAC3BoV,EAAOpV,GAAO4Z,EAAQ5Z,IAAQ,EAClC,GACJ,EAEAm1E,MAAO,SAAC//D,EAAQgqB,IACZ,IAAApZ,eAAc5Q,GAAQpO,SAAQ,SAAAhH,GAC1Bo/B,EAAQxlB,QAAQ5Z,GAAOoV,EAAOpV,EAClC,GACJ,E,0GCdS,EAAA63E,mBAAiD,CAC1DlI,MAAO,SAACv6D,EAAQgqB,GACZ,IAAM6E,EAAQ7E,EAAQhc,MAAM6gB,OAAS7E,EAAQiC,aAAa,SAEtD4C,IACA7uB,EAAO6uB,MAAQA,EAEvB,EACAkxC,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO6uB,QACP7E,EAAQhc,MAAM6gB,MAAQ7uB,EAAO6uB,MAErC,E,uGCZS,EAAA6zC,gBAA2C,CACpDnI,MAAO,SAACv6D,EAAQgqB,GACRA,EAAQ5M,KACRpd,EAAOod,GAAK4M,EAAQ5M,GAE5B,EACA2iD,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOod,KACP4M,EAAQ5M,GAAKpd,EAAOod,GAE5B,E,yGCVS,EAAAulD,kBAA+C,CACxDpI,MAAO,SAACv6D,EAAQgqB,GACZ,IAAM44C,EAAO54C,EAAQiC,aAAa,QAE9B22C,IACA5iE,EAAO4iE,KAAOA,EAEtB,EACA7C,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO4iE,MACP54C,EAAQgC,aAAa,OAAQhsB,EAAO4iE,KAE5C,E,yGCfJ,IAAMC,EAAkB,WAuDxB,SAASC,EAAa94C,EAAsB+4C,GACxC,IAAMC,EAAYh5C,EAAQiC,aAAa82C,GACjCx2E,EAAQ4E,SAAS6xE,GAAa,IAEpC,OAAOA,GAAaH,EAAgB5yD,KAAK+yD,GACnCA,EACA5rE,OAAOvC,MAAMtI,IAAmB,GAATA,OACvByN,EACAzN,EAAQ,IAClB,CA3Da,EAAA02E,kBAA+C,CACxD1I,MAAO,SAACv6D,EAAQgqB,EAAStmB,GACrB,IAAMqK,EAAQic,EAAQhc,MAAMD,OAAS+0D,EAAa94C,EAAS,SACrDnQ,EAASmQ,EAAQhc,MAAM6L,QAAUipD,EAAa94C,EAAS,UACvDsK,EAAWtK,EAAQhc,MAAMsmB,SACzB4uC,EAAYl5C,EAAQhc,MAAMk1D,UAC1BC,EAAWn5C,EAAQhc,MAAMm1D,SACzBC,EAAYp5C,EAAQhc,MAAMo1D,UAE5Br1D,IACA/N,EAAO+N,MAAQA,GAEf8L,IACA7Z,EAAO6Z,OAASA,GAEhBya,IACAt0B,EAAOs0B,SAAWA,GAElB4uC,IACAljE,EAAOkjE,UAAYA,GAEnBC,IACAnjE,EAAOmjE,SAAWA,GAElBC,IACApjE,EAAOojE,UAAYA,EAE3B,EACArD,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO+N,QACPic,EAAQhc,MAAMD,MAAQ/N,EAAO+N,OAE7B/N,EAAO6Z,SACPmQ,EAAQhc,MAAM6L,OAAS7Z,EAAO6Z,QAE9B7Z,EAAOs0B,WACPtK,EAAQhc,MAAMsmB,SAAWt0B,EAAOs0B,UAEhCt0B,EAAOkjE,YACPl5C,EAAQhc,MAAMk1D,UAAYljE,EAAOkjE,WAEjCljE,EAAOmjE,WACPn5C,EAAQhc,MAAMm1D,SAAWnjE,EAAOmjE,UAEhCnjE,EAAOojE,YACPp5C,EAAQhc,MAAMo1D,UAAYpjE,EAAOojE,UAEzC,E,kHCjDS,EAAAC,2BAAiE,CAC1E9I,MAAO,SAACv6D,EAAQgqB,GAGZ,OAFcA,EAAQhc,MAAM0J,eAAiBsS,EAAQiC,aAAa,WAG9D,IAAK,WACL,IAAK,UACL,IAAK,QACL,IAAK,MACL,IAAK,WACL,IAAK,cACL,IAAK,MACDjsB,EAAO0X,cAAgB,MACvB,MAEJ,IAAK,SACD1X,EAAO0X,cAAgB,SACvB,MAEJ,IAAK,SACD1X,EAAO0X,cAAgB,SAGnC,EACAqoD,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO0X,gBACPsS,EAAQhc,MAAM0J,cAAgB1X,EAAO0X,cAE7C,E,8GC5BS,EAAA4rD,uBAAyD,CAClE/I,MAAO,SAACv6D,EAAQgqB,EAASxU,EAAG20C,GACxB,IAAMoZ,EAAYv5C,EAAQhc,MAAMu1D,WAAapZ,EAAaoZ,UAEtDA,IACAvjE,EAAOujE,UAAYA,EAE3B,EACAxD,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOujE,YACPv5C,EAAQhc,MAAMu1D,UAAYvjE,EAAOujE,UAEzC,E,mLClBJ,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WAgBMC,EAA0C,CAC5CC,KAAM,EAAAlC,kBACNzhD,gBAAiB,EAAA2hD,6BACjBiC,KAAM,EAAAC,kBACN91D,OAAQ,EAAAw0D,oBACRuB,UAAW,EAAAlC,uBACXvzD,YAAa,EAAA0zD,yBACbvhD,UAAW,EAAAiiD,uBACX/9D,QAAS,EAAAg+D,qBACTviE,UAAW,EAAA4/D,uBACXljD,QAAS,EAAAsjD,qBACTpxC,MAAO,EAAA4zC,mBACPvuD,WAAY,EAAA2vD,wBACZ1vD,SAAU,EAAA2vD,sBACV98C,OAAQ,EAAA+8C,oBACR5D,UAAW,EAAAD,uBACX9iD,GAAI,EAAAslD,gBACJsB,WAAY,EAAAC,wBACZviD,OAAQ,EAAAwiD,oBACRC,kBAAmB,EAAAC,+BACnBle,cAAe,EAAAme,2BACf1oD,WAAY,EAAA0kD,wBACZztE,KAAM,EAAA0xE,kBACNC,cAAe,EAAAC,2BACf7P,eAAgB,EAAA8P,4BAChB3P,gBAAiB,EAAA4P,6BACjB5xD,UAAW,EAAA6xD,uBACXpkD,OAAQ,EAAAkgD,oBACR7xC,QAAS,EAAAoyC,qBACT4B,KAAM,EAAAD,kBACN7mB,KAAM,EAAAmnB,kBACN3W,OAAQ,EAAAsY,oBACRC,iBAAkB,EAAAC,8BAClBC,YAAa,EAAAC,yBACbC,aAAc,EAAAC,0BACd5kE,UAAW,EAAA6gE,uBACX73D,UAAW,EAAA67D,uBACXC,qBAAsB,EAAAC,kCACtBjN,WAAY,EAAAgJ,wBACZkE,gBAAiB,EAAAC,6BACjB7zD,UAAW,EAAA8zD,uBACX9tD,cAAe,EAAA2rD,2BACfh2C,WAAY,EAAAg0C,wBACZkC,UAAW,EAAAD,wBAGTmC,EAA2D,CAC7D,gBACA,aACA,YAGEC,EAA6D,CAC/D,SACA,YACA,mBACA,SACA,QAEEC,EAAqD,CACvD,YACA,YACA,aACA,aACA,cAEEC,EAAyD,CAC3D,kBACA,SACA,UACA,UAMS,EAAArV,6BAET,CACA1wD,MAAO8lE,EACPhR,eAAgB,CAAC,kBACjBG,gBAAiB,CAAC,mBAClBJ,iBAAiB,EAAF,qDAAMiR,IAAkB,IAAE,gBAAiB,SAAU,cAAW,GAC/Etd,UAAW,CAAC,YAAa,YAAa,SAAU,UAAW,YAAa,mBACxEwd,mBAAmB,EAAF,qDAAMJ,IAAwB,IAAE,YAAa,kBAAmB,eAAY,GAC7FK,oBAAqBJ,EACrB1iE,SAAS,EAAF,yEACAyiE,IAAwB,gBACxBC,IAA0B,IAC7B,YACA,kBACA,e,GAEJv3C,gBAAgB,EAAF,yEAAMs3C,IAAwB,gBAAKC,IAA0B,IAAE,cAAW,GACxF/O,oBAAoB,EAAF,yEACX8O,IAAwB,gBACxBC,IAA0B,IAC7B,yB,GAEJ9O,UAAW,CACP,SACA,cACA,kBACA,UACA,gBACA,YACA,YACA,YACA,QAEJZ,SAAU,CAAC,mBACXJ,YAAa,CAAC,QACd5uD,MAAO,CACH,OACA,KACA,SACA,kBACA,UACA,YACA,SACA,OACA,cACA,YACA,YACA,QAEJwuD,YAAa,CAAC,YAAa,eAAgB,qBAC3CuQ,gBAAiB,CAAC,aAClBn4D,MAAO,CACH,KACA,OACA,SACA,UACA,YACA,SACA,YACA,UACA,QACA,gBACA,cAEJhb,KAAM,CACF,OACA,YACA,YACA,UACA,SACA,UACA,kBACA,SACA,OACA,YACA,mBAEJ2hE,iBAAkB,CAAC,aACnBhrD,KAAM,CAAC,aAAc,WACrB/E,QAAS,CAAC,WACVgvD,SAAS,EAAF,yEAAMmS,IAAkB,gBAAKC,IAAsB,IAAE,UAAW,OAAQ,cAAW,GAC1Fj+D,WAAW,EAAF,qDAAMi+D,IAAsB,IAAE,YAAa,OAAQ,UAAW,OAAI,GAC3E5+C,OAAQ,CAAC,UACTmsC,QAAS,CAAC,YAAa,oBAMd,EAAA/I,sBAAsC,IAAAx5C,eAAc4yD,GAAyBthE,QACtF,SAAC5P,EAAQ1H,GAEL,OADA0H,EAAO1H,GAAO44E,EAAwB54E,GAAK2vE,MACpCjoE,CACX,GACe,CAAC,GAMP,EAAA0zE,uBAAwC,IAAAp1D,eAAc4yD,GAAyBthE,QACxF,SAAC5P,EAAQ1H,GAEL,OADA0H,EAAO1H,GAAO44E,EAAwB54E,GAAKm1E,MACpCztE,CACX,GACgB,CAAC,E,6GCjPrB,eAOa,EAAAyxE,oBAAkE,CAC3ExJ,MAAO,SAACv6D,EAAQgqB,GACZ39B,OAAO0gB,OAAO/M,GAAQ,IAAAyd,mBAAkBuM,GAC5C,EAEA+1C,MAAO,SAAC//D,EAAQgqB,GACPhqB,EAAO22C,eACR3sB,EAAQ4sB,WAAY,IAAAC,0BAAyB72C,IAG7CA,EAAOqd,WACP2M,EAAQud,gBAAkB,QAE1Bvd,EAAQ6G,gBAAgB,kBAEhC,E,oHCtBJ,eAOa,EAAA2zC,2BAA+E,CACxFjK,MAAO,SAACv6D,EAAQgqB,EAAStmB,G,MAErB,GAAIsmB,EAAQhc,MAAMi4D,UACdjmE,EAAOM,WAAY,IAAA8/D,WAAUp2C,EAAQhc,MAAMi4D,UAAWviE,EAAQwlB,YAAYjpB,gBACvE,GAAI+pB,EAAQhc,MAAM1N,WAAsD,UAApB,QAArB,EAAA0pB,EAAQ0H,qBAAa,eAAE1jB,MAAM2O,SAAoB,CACnF,IAAIupD,EAAQl8C,EAAQhc,MAAM1N,UAGY,QAAlCoD,EAAQwlB,YAAYjpB,WAAiC,SAATimE,GAA6B,OAATA,IAChEA,EAAiB,SAATA,EAAmB,MAAQ,SAGvClmE,EAAOM,WAAY,IAAA8/D,WAAU8F,EAAOxiE,EAAQwlB,YAAYjpB,U,CAEhE,EACA8/D,MAAO,SAAC//D,EAAQgqB,GACZ,GAAIhqB,EAAOM,UAAW,CAClB,IAAM,EAAS0pB,EAAQ0H,cAEvB1H,EAAQhc,MAAMi4D,UAAYjmE,EAAOM,UAGjC0pB,EAAQhc,MAAM44C,eAAe,cAEzB,IACA,EAAO54C,MAAMm4D,cAAgB,SAC7B,EAAOn4D,MAAM2O,QAAU,O,CAGnC,E,qHCrCJ,eACA,WAyCA,SAASypD,EAAYp8C,GACjB,OACI,IAAA2G,iBAAgB3G,EAAS,QACzB,IAAAlf,cAAakf,EAAQjf,WAAY,kBACjC,IAAA4lB,iBAAgB3G,EAAQjf,WAAY,KAE5C,CAxCa,EAAA05D,4BAA+D,CACxElK,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAAS2iE,GACtB,IAAA9c,EAAe7lD,EAAO,WACxB4lD,EAAQC,EAAW3mD,OAAOxW,OAC1BuwB,EAAUqN,EAAQhc,MAAM2O,SAAW0pD,EAAc1pD,QAEnDA,GAAsB,aAAXA,EACX3c,EAAO0S,oBAAsBiK,EACtBypD,EAAYp8C,IAAYs/B,EAAQ,IACvCC,EAAWC,iBAAiBF,EAAQ,KACpCC,EAAWC,iBAAiB3zD,OAAOyzD,GACnCC,EAAW3mD,OAAOhR,SAAQ,SAAAgH,UAGfA,EAAMoH,OAAO2E,mBACxB,IAER,EACAo7D,MAAO,SAAC//D,EAAQgqB,EAAStmB,G,MACrB,GAAI1D,EAAO0S,oBACPsX,EAAQhc,MAAM2O,QAAU3c,EAAO0S,yBAC5B,GAAI0zD,EAAYp8C,GAAU,CACrB,IAAAu/B,EAAe7lD,EAAO,WACtB8lD,EAAqBD,EAAU,iBACjCxkD,EAAQwkD,EAAWh/C,UAAUne,OAAS,EAExC2Y,GAAS,IACTykD,EAAiB3zD,OAAOkP,EAAQ,GAChCykD,EAAiBzkD,IAAiC,QAAvB,EAAAykD,EAAiBzkD,UAAM,QAAI,GAAK,E,CAGvE,E,qHCvCJ,eAOa,EAAA2/D,6BAAgE,CACzEnK,MAAO,SAACv6D,EAAQgqB,EAAStmB,GACrB,IAAI,IAAAitB,iBAAgB3G,EAAS,MAAO,CACxB,IAAAu/B,EAAe7lD,EAAO,WACtB8lD,EAA6BD,EAAU,iBACzCD,EAD+BC,EAAU,OAC1Bn9D,OAGA,GAAjB49B,EAAQhH,OAC2B,iBAA5BwmC,EAAiBF,IACxBt/B,EAAQhH,OAASwmC,EAAiBF,GAAS,IAE3CtpD,EAAO2E,oBAAsBqlB,EAAQhH,OAGzCwmC,EAAiBF,GAASt/B,EAAQhH,MAAQ,C,CAElD,EACA+8C,MAAO,SAAC//D,EAAQgqB,EAAStmB,GAEjB,MACAA,EAAO,WADO8lD,EAAgB,mBAK5BF,EALuC,YAKrBl9D,OAAS,EAEjC,GAAIk9D,GAAS,IAAK,IAAA34B,iBAAgB3G,EAAS,MAAO,CAC9C,IAAMs8C,EAActmE,EAAO2E,oBAEA,iBAAhB2hE,EACP9c,EAAiBF,GAASgd,EAAc,EACC,iBAA3B9c,EAAiBF,KAC/BE,EAAiBF,GAAS,GAG9BE,EAAiB3zD,OAAOyzD,EAAQ,GAChCt/B,EAAQhH,MAAQwmC,EAAiBF,GAAS,C,CAElD,E,8GCxCS,EAAAqb,uBAAyD,CAClEpK,MAAO,SAACv6D,EAAQgqB,GACZ,IAAMu8C,EAAoBv8C,EAAQhc,MAAMu4D,kBAClCvzD,EAAgBgX,EAAQhc,MAAMgF,cAEhCuzD,IACAvmE,EAAOumE,kBAAoBA,GAG3BvzD,IACAhT,EAAOgT,cAAgBA,EAE/B,EACA+sD,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOumE,oBACPv8C,EAAQhc,MAAMu4D,kBAAoBvmE,EAAOumE,mBAGzCvmE,EAAOgT,gBACPgX,EAAQhc,MAAMgF,cAAgBhT,EAAOgT,cAE7C,E,2GC3BJ,aACA,WAOa,EAAA2wD,kBAA+C,CACxDpJ,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAM5uC,EAAayO,EAAQhc,MAAMuN,YAAc4uC,EAAa5uC,YAExD,IAAA+lD,gBAAe/lD,EAAY,MAAOvb,EAAOub,WAAY4uC,EAAa5uC,cAClEvb,EAAOub,WAAaA,EAE5B,EACAwkD,MAAO,SAAC//D,EAAQgqB,EAAStmB,GACrB,QAAiC,IAAtB1D,EAAOub,WAAlB,CAIA,IAAMirD,EAAkB9iE,EAAQk9D,eAAerlD,YAG1CirD,GAAmBA,GAAmBxmE,EAAOub,aAC5CirD,GAAmBxmE,EAAOub,YAAmC,UAArBvb,EAAOub,cAExB,QAArBvb,EAAOub,YACP,IAAAkrD,mBAAkBz8C,EAAS,KAE3BA,EAAQhc,MAAMuN,WAAavb,EAAOub,YAAc,S,CAG5D,E,+GC3BS,EAAAsoD,wBAA2D,CACpEtJ,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAMj2C,EAAa8V,EAAQhc,MAAMkG,YAAci2C,EAAaj2C,WAExDA,GAA4B,WAAdA,IACdlU,EAAOkU,WAAaA,EAE5B,EACA6rD,MAAO,SAAC//D,EAAQgqB,EAAStmB,GACjB1D,EAAOkU,YAAclU,EAAOkU,YAAcxQ,EAAQk9D,eAAe1sD,aACjE8V,EAAQhc,MAAMkG,WAAalU,EAAOkU,WAE1C,E,+GClBJ,eACA,WAOa,EAAA4vD,sBAAuD,CAChEvJ,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAMh2C,EAAW6V,EAAQhc,MAAMmG,UAAYg2C,EAAah2C,SAClDuD,EAAgBsS,EAAQhc,MAAM0J,eAAiByyC,EAAazyC,cAI9DvD,KAAa,IAAAuyD,oBAAmBvyD,EAAUuD,IAA8B,WAAZvD,IACxD6V,EAAQhc,MAAMmG,SACdnU,EAAOmU,SA6BvB,SACIA,EACAwyD,EACAjjE,GAEA,IAAMkjE,EAAgBC,EAAe1yD,GAC/B2yD,EAAY3yD,EAAS4yD,SAAS,OAEpC,GAAIH,EACA,OAAOA,EACJ,KACS,WAAZzyD,GACY,UAAZA,GACAA,EAAS4yD,SAAS,OAClB5yD,EAAS4yD,SAAS,MAClBD,GAoBG,MAAgB,WAAZ3yD,GAAqC,UAAZA,GAAoC,SAAZA,OACxD,EAEOA,EArBP,GAAKwyD,GAAgBG,EAArB,CAGI,IAAME,EAAmBF,EACnBpjE,EAAQs6B,cACR,IAAA16B,oBAAmBqjE,GAEzB,GAAIK,EACA,OAAQ7yD,GACJ,IAAK,UACD,OAAOrnB,KAAKqD,MAA0B,IAAnB62E,EAA0B,GAAK,IAAM,KAC5D,IAAK,SACD,OAAOl6E,KAAKqD,MAA0B,IAAnB62E,EAA0B,GAAK,IAAM,KAC5D,QACI,OAAO,IAAA1jE,oBAAmB6Q,EAAU6yD,EAAkB,MAAQ,K,CAStF,CArEkCC,CACd9yD,EACAzQ,EAAQ0B,cAAc+O,SACtBzQ,GAEGymD,EAAah2C,WACpBnU,EAAOmU,SAAWA,GAG9B,EACA4rD,MAAO,SAAC//D,EAAQgqB,EAAStmB,GACjB1D,EAAOmU,UAAYnU,EAAOmU,UAAYzQ,EAAQk9D,eAAezsD,WAC7D6V,EAAQhc,MAAMmG,SAAWnU,EAAOmU,SAExC,GAIJ,IAAM0yD,EAAyC,CAC3C,WAAY,SACZ,UAAW,QACXK,MAAO,SACPC,OAAQ,OACRC,MAAO,SACP,UAAW,OACX,WAAY,OACZ,YAAa,O,gHC3CjB,cAOa,EAAAnD,wBAA2D,CACpE1J,MAAO,SAACv6D,EAAQgqB,GACZ,IAAM9iB,GAAS,IAAAmgE,eAAcr9C,GACzB9iB,IACAlH,EAAOgkE,WAAa98D,EAE5B,EACA64D,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOgkE,aACP,IAAAsD,eAAct9C,EAAShqB,EAAOgkE,WAEtC,E,6GClBJ,eAOa,EAAAE,oBAAmD,CAC5D3J,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAMlE,EAAYj8B,EAAQhc,MAAMi4C,WAAakE,EAAalE,UAEzC,UAAbA,GAAsC,WAAbA,EACzBjmD,EAAO0hB,QAAS,EACI,WAAbukC,GAAuC,UAAbA,IACjCjmD,EAAO0hB,QAAS,EAExB,EACAq+C,MAAO,SAAC//D,EAAQgqB,EAAStmB,QACQ,IAAlB1D,EAAO0hB,UAIKhe,EAAQk9D,eAAel/C,UAEpB1hB,EAAO0hB,SACzB1hB,EAAO0hB,QACP,IAAA+kD,mBAAkBz8C,EAAS,KAE3BA,EAAQhc,MAAMi4C,UAAY,SAGtC,E,oHC/BJ,aAOa,EAAAoe,2BAAiE,CAC1E9J,MAAO,SAACv6D,EAAQgqB,EAASxU,EAAG20C,GACxB,IAAMjE,EAAgBl8B,EAAQhc,MAAMk4C,eAAiBiE,EAAajE,eAG9D,IAAAob,gBACIpb,EACA,SACAlmD,EAAOkmD,cACPiE,EAAajE,iBAGjBlmD,EAAOkmD,cAAgBA,EAE/B,EACA6Z,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOkmD,gBACPl8B,EAAQhc,MAAMk4C,cAAgBlmD,EAAOkmD,cAE7C,E,2GC1BJ,eAOa,EAAAoe,kBAA+C,CACxD/J,MAAO,SAACv6D,EAAQgqB,GACZ,IAAI,IAAA2G,iBAAgB3G,EAAS,KAAM,CAC/B,IAAM,EAAOA,EAAQ/1B,KACfod,EAAO2Y,EAAQiC,aAAa,QAC5B7lB,EAAS4jB,EAAQ5jB,OACjBmhE,EAAMv9C,EAAQu9C,IACdnqD,EAAK4M,EAAQ5M,GACbw5B,EAAY5sB,EAAQ4sB,UACpB+c,EAAQ3pC,EAAQ2pC,MAElB,IACA3zD,EAAO/L,KAAO,GAGdod,IACArR,EAAOqR,KAAOA,GAGdjL,IACApG,EAAOoG,OAASA,GAGhBgX,IACApd,EAAOwnE,SAAWpqD,GAGlBmqD,IACAvnE,EAAOynE,aAAeF,GAGtB5T,IACA3zD,EAAO2gB,YAAcgzC,GAGrB/c,IACA52C,EAAO0nE,YAAc9wB,E,CAGjC,EACAmpB,MAAO,SAAC//D,EAAQgqB,IACR,IAAA2G,iBAAgB3G,EAAS,OAAShqB,EAAOqR,MAAQrR,EAAO/L,QACpD+L,EAAOqR,OACP2Y,EAAQ3Y,KAAOrR,EAAOqR,MAGtBrR,EAAO/L,OACP+1B,EAAQ/1B,KAAO+L,EAAO/L,MAGtB+L,EAAOoG,SACP4jB,EAAQ5jB,OAASpG,EAAOoG,QAGxBpG,EAAOwnE,WACPx9C,EAAQ5M,GAAKpd,EAAOwnE,UAGpBxnE,EAAO0nE,cACP19C,EAAQ4sB,UAAY52C,EAAO0nE,aAG3B1nE,EAAO2gB,cACPqJ,EAAQ2pC,MAAQ3zD,EAAO2gB,aAGvB3gB,EAAOynE,eACPz9C,EAAQu9C,IAAMvnE,EAAOynE,cAGjC,E,6GC7EJ,eAOa,EAAA7C,oBAAmD,CAC5DrK,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAMhE,EAAiBn8B,EAAQhc,MAAMm4C,gBAAkBgE,EAAahE,gBAEhEA,aAAc,EAAdA,EAAgBrwD,QAAQ,kBAAoB,IAC5CkK,EAAO2hB,eAAgB,EAE/B,EACAo+C,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO2hB,gBACP,IAAA8kD,mBAAkBz8C,EAAS,IAEnC,E,4ICnBJ,eAuCA,SAAgB08C,EACZvyD,EACAuD,GAEA,MAAmB,WAAZvD,IAA2C,OAAjBuD,GAA2C,SAAjBA,EAC/D,CArCa,EAAAotD,8BAAuE,CAChFvK,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAMzyC,EAAgBsS,EAAQhc,MAAM0J,eAAiByyC,EAAazyC,cAG9DgvD,EAFa18C,EAAQhc,MAAMmG,UAAYg2C,EAAah2C,SAEvBuD,KAC7B1X,EAAO4hB,0BAA4B5hB,EAAO4hB,0BAA4B,IACjE9wB,MAAM,KACNgG,OAAO4gB,GACPzmB,KAAK,KACLqW,OAEb,EACAy4D,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO4hB,0BACP5hB,EAAO4hB,yBACF9wB,MAAM,KACN4vD,UACA9uD,SAAQ,SAAArF,GACL,IAAMqZ,EAAmB,SAATrZ,EAAmB,MAAiB,OAATA,EAAiB,MAAQ,KAEhEqZ,IACA,IAAA6gE,mBAAkBz8C,EAASpkB,EAEnC,GAEZ,GAMJ,sB,gHCvCA,eAOa,EAAAu/D,uBAAyD,CAClE5K,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAM7gD,GACF,IAAA08C,UACIh8B,GACA,IACEtmB,EAAQ8a,WACV9a,EAAQyjB,mBACPgjC,EAAa95D,MAElBiZ,GAA0B,WAAbA,IACbtJ,EAAOsJ,UAAYA,EAE3B,EACAy2D,MAAO,SAAC//D,EAAQgqB,EAAStmB,GACrB,IAAMikE,EAAgBjkE,EAAQk9D,eAAet3D,UAEzCtJ,EAAOsJ,WAAatJ,EAAOsJ,WAAaq+D,IACxC,IAAAnqB,UACIxzB,EACAhqB,EAAOsJ,WACP,IACE5F,EAAQ8a,WACV9a,EAAQyjB,iBAGpB,E,sHCjCJ,eACA,WAUa,EAAAo+C,6BAAiE,CAC1EhL,MAAO,SAACv6D,EAAQgqB,IACR,IAAA2G,iBAAgB3G,EAAS,OAAQ,IAAA49C,mBAAkB59C,KACnDhqB,EAAOq8D,aAAc,EAE7B,EAEA0D,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOq8D,cAAe,IAAA1rC,iBAAgB3G,EAAS,OAC/C,IAAA69C,oBAAmB79C,GAAS,EAEpC,E,gHCtBJ,eAOa,EAAAw7C,uBAAyD,CAClEjL,MAAO,SAACv6D,EAAQgqB,EAAStmB,EAASymD,GAC9B,IAAMhE,EAAiBn8B,EAAQhc,MAAMm4C,gBAAkBgE,EAAahE,gBAEhEA,aAAc,EAAdA,EAAgBrwD,QAAQ,eAAiB,EACzCkK,EAAO0R,WAAY,EACO,KAAnBsY,EAAQpkB,SAAoC,QAAlBugD,IACjCnmD,EAAO0R,WAAY,EAE3B,EACAquD,MAAO,SAAC//D,EAAQgqB,EAAStmB,QACW,IAArB1D,EAAO0R,aAIKhO,EAAQk9D,eAAelvD,aAEpB1R,EAAO0R,YACzB1R,EAAO0R,WACP,IAAA+0D,mBAAkBz8C,EAAS,KAE3BA,EAAQhc,MAAMm4C,eAAiB,OAG3C,E,sHCzBS,EAAAie,+BAAyE,CAClF7J,MAAO,SAACv6D,EAAQgqB,GACZ,IAAMnc,EAASmc,EAAQiC,aAAa,UAC9B67C,EAAc99C,EAAQiC,aAAa,eACnC87C,EAAc/9C,EAAQiC,aAAa,eAErCpe,IACA7N,EAAOmkE,kBAAoBt2D,GAG3Bi6D,IACA9nE,EAAO8nE,YAAcA,GAGrBC,IACA/nE,EAAOgoE,YAAcD,EAE7B,EAEAhI,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOmkE,mBACPn6C,EAAQgC,aAAa,SAAUhsB,EAAOmkE,mBAGtCnkE,EAAO8nE,aACP99C,EAAQgC,aAAa,cAAehsB,EAAO8nE,aAG3C9nE,EAAOgoE,aACPh+C,EAAQgC,aAAa,cAAehsB,EAAOgoE,YAEnD,E,gHC/BS,EAAAhD,yBAA6D,CACtEzK,MAAO,SAACv6D,EAAQgqB,GACZ,IAAM+6C,EAAc/6C,EAAQhc,MAAM+2D,YAC9BA,GAA8B,WAAfA,IACf/kE,EAAO+kE,YAAcA,EAE7B,EACAhF,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAO+kE,cACP/6C,EAAQhc,MAAM+2D,YAAc/kE,EAAO+kE,YAE3C,E,iHCdJ,IAAMkD,EAAkB,WAClBC,EAAiB,WAKV,EAAAhD,0BAA0D,CACnE3K,MAAO,SAACv6D,EAAQgqB,GACRA,EAAQhc,MAAMvE,gBAAkBw+D,IAChCjoE,EAAOyJ,gBAAiB,GAGxBugB,EAAQhc,MAAMvE,gBAAkBy+D,IAChCloE,EAAOmoE,gBAAiB,EAEhC,EACApI,MAAO,SAAC//D,EAAQgqB,GACRhqB,EAAOyJ,gBACPugB,EAAQhc,MAAMvE,eAAiBw+D,EAC/Bj+C,EAAQhc,MAAMo6D,cAAgB,IAC9Bp+C,EAAQhc,MAAMy+C,UAAY,cACnBzsD,EAAOmoE,iBACdn+C,EAAQhc,MAAMvE,eAAiBy+D,EAC/Bl+C,EAAQhc,MAAMo6D,cAAgB,IAC9Bp+C,EAAQhc,MAAMy+C,UAAY,aAElC,E,yHCvBS,EAAA4Y,kCAAoE,CAC7E9K,MAAO,SAACv6D,EAAQgqB,GACRA,EAAQhc,MAAM3d,cAIP2P,EAAOsJ,SAEtB,EACAy2D,MAAO,WAAO,E,sHCVL,EAAAb,WAA6E,CACtF,YACA,cACA,eACA,cAMS,EAAAE,kBAET,CACA7wD,UAAW,mBACX9M,YAAa,qBACb+M,aAAc,sBACdhN,WAAY,oB,8OCrBhB,WACA,WAWa,EAAA6mE,iBAA6B,CACtC,iBACA,eACA,sBACA,kBACA,gBACA,eACA,iBACA,aACA,kBACA,eACA,cACA,WACA,WACA,OACA,YACA,mBACA,aACA,kBACA,oBACA,eACA,aACA,cACA,UAGJ,IACMC,EAAa,6CACbC,EAAa,sDACbC,EAAY,6EACZC,EAAa,oGACbl6C,EAAiB,0DACjBC,EAAkB,OAkCxB,SAAgB8wC,EACZjvE,EACAmuB,EACA2I,EACAuhD,GAEA,GAAI,EAAAL,iBAAiBvyE,QAAQzF,IAAU,EACnC,OAAOq4E,EACJ,GAAIvhD,EAAkB,CACzB,IAAMv2B,EAAQP,EAAMu/B,WAAWpB,GAAmBD,EAAekB,KAAKp/B,GAAS,KAE/E,GAAIO,EACAP,EAAQO,EAAM,IAAM,QACjB,GAAI4tB,EAIP,OA2HZ,SACImqD,EACAniB,GAEA,IAAMoiB,EAAYC,EAAWF,GAE7B,GAAIC,GAAapiB,EAAa,CAC1B,IAAM57D,GAAM,IAAAgmB,eAAc41C,GAAax9C,MAAK,SAAApe,GACxC,IAAMk+E,EAAaD,EAAWriB,EAAY57D,GAAK+7D,eAE/C,OACImiB,GACAA,EAAW,IAAMF,EAAU,IAC3BE,EAAW,IAAMF,EAAU,IAC3BE,EAAW,IAAMF,EAAU,EAEnC,IAEA,GAAIh+E,EACA,OAAO47D,EAAY57D,GAAKm3E,c,CAIhC,OAAO,IACX,CAnJmBgH,CAA4B14E,EAAO82B,EAAiBq/B,cAAgB,E,CAGnF,OAAOn2D,CACX,CAKA,SAAgByxE,EACZ93C,EACAsV,EACAopC,GAEA,OAAQppC,GACJ,IAAK,OACD,OAAOtV,EAAQhc,MAAM3d,OAAS25B,EAAQiC,aAAa,UAAYy8C,EAEnE,IAAK,aACD,OAAO1+C,EAAQhc,MAAM8R,iBAAmBkK,EAAQiC,aAAa,YAAcy8C,EAE/E,QACI,OAAO1+C,EAAQhc,MAAMqmD,iBAAiB,EAAA+K,kBAAkB9/B,KAAYopC,EAEhF,CAgCA,SAAgBlJ,EACZx1C,EACA35B,EACA24E,EACAxqD,EACA2I,G,QAEMv2B,EAAQP,GAASA,EAAMu/B,WAAWpB,GAAmBD,EAAekB,KAAKp/B,GAAS,KAClF,eAAkCO,QAAAA,EAAS,GAAE,GAAzCq4E,GAAF,KAAa,MAAEC,EAAa,KAIpC,GAFA74E,EAAQ64E,QAAAA,EAAiB74E,EAErB82B,GAAoB92B,EAAO,CAC3B,IAAMzF,EACFq+E,GACA9hD,EAAiBs/B,iBAAiBp2D,OAAO2J,EAA0BgvE,EAAWh/C,GAC5E28B,GACiC,QAAnC,EAA4B,QAA5B,EAAAx/B,EAAiBq/B,mBAAW,eAAG57D,UAAI,eAAE+7D,gBACrCx/B,EAAiBq4B,aAAanvD,OAAO2J,EAA0BgvE,EAAWh/C,GAE9E7C,EAAiBga,iBAAiB3iB,EAAY5zB,EAAK,CAC/Cm3E,eAAgB1xE,EAChBs2D,cAAa,IAGjBt2D,EAAQmuB,EAAa,GAAGgQ,EAAkB5jC,EAAG,KAAKyF,EAnIjC,IAmI8DA,C,CAGnF,OAAOA,CACX,CAiBA,SAAgBw4E,EAAWx4E,GAGvB,IAAIO,EACJ,OAAKA,GAHLP,GAASA,GAAS,IAAIiX,QAGH1W,MAAM03E,IACd,CACHn3E,SAASP,EAAM,GAAKA,EAAM,GAAI,IAC9BO,SAASP,EAAM,GAAKA,EAAM,GAAI,IAC9BO,SAASP,EAAM,GAAKA,EAAM,GAAI,MAE1BA,EAAQP,EAAMO,MAAM23E,IACrB,CAACp3E,SAASP,EAAM,GAAI,IAAKO,SAASP,EAAM,GAAI,IAAKO,SAASP,EAAM,GAAI,MACnEA,EAAQP,EAAMO,MAAM43E,IAAcn4E,EAAMO,MAAM63E,IAC/C,CAACt3E,SAASP,EAAM,IAAKO,SAASP,EAAM,IAAKO,SAASP,EAAM,KAIxD,IAEf,CAhKA,oBACIo5B,EACAm/C,EACA3qD,EACA2I,EACAuhD,GAEA,IAAMr4E,EAAQyxE,EAAqB93C,EAASm/C,EAAe,aAAe,OAAQT,GAElF,OAAOr4E,EACDivE,EACIjvE,EACAmuB,EACA2I,EACAgiD,OAAenvE,EAhCV,qBAkCTA,CACV,EAKA,sBA0BA,yBAyBA,oBACIgwB,EACA35B,EACA84E,EACA3qD,EACA2I,GAEA,IAAMiiD,EAAW5J,EACbx1C,EACA35B,EACA84E,EAAe,aAAe,OAC9B3qD,EACA2I,GAGJ6C,EAAQ6G,gBAAgBs4C,EAAe,UAAY,SACnDn/C,EAAQhc,MAAMnN,YAAYsoE,EAAe,mBAAqB,QAASC,GAAY,KACvF,EAKA,eAoCa,EAAAviB,wBAAkD,SAAAwY,GAC3D,MAAUgK,eAAoBhK,EAAW/8D,QAAQ,WAAY,IACjE,EAQA,c,6GClMa,EAAAtD,UAAY,CACrBgkB,MAAO,CACH9jB,IAAK,OACLC,IAAK,SAETC,OAAQ,CACJF,IAAK,SACLC,IAAK,UAET8jB,IAAK,CACD/jB,IAAK,QACLC,IAAK,QAETmqE,QAAS,CACLpqE,IAAK,UACLC,IAAK,WAETG,QAAS,CACLJ,IAAK,UACLC,IAAK,YAOb,qBAA0B+mE,EAAepG,GACrC,OAAQoG,GACJ,IAAK,SACD,MAAO,SAEX,IAAK,OACD,MAAc,OAAPpG,EAAe,MAAQ,QAElC,IAAK,QACD,MAAc,OAAPA,EAAe,QAAU,MAEpC,IAAK,QACL,IAAK,MAGL,IAAK,UACL,IAAK,UACD,OAAOoG,EAEX,QACI,OAEZ,C,2HCnDMqD,EAAmB,4BAyDzB,SAASC,EAAYC,G,QACjB,QAAoC,IAAzBA,EACP,OAAO,EACJ,GAAoC,iBAAzBA,EACd,OAAOA,EAEP,IAAMC,EAEW,QADb,EAA8C,QAA9C,EAAAD,EAAqBx5C,cAAcvI,mBAAW,eAAEC,iBAAiB8hD,GAC5Dt1D,gBAAQ,QAAI,GAIrB,OAFkBw1D,EADAh1E,WAAW+0E,GAKrC,CAEA,SAASC,EAAOnnD,GACZ,OAAO11B,KAAKqD,MAAY,IAALqyB,EAAa,GAAK,GACzC,CA9DA,8BACIj2B,EACAq9E,EACAC,QAFA,IAAAt9E,IAAAA,EAAA,SAEA,IAAAs9E,IAAAA,EAAA,MAEA,IA2DYC,EA3DNl5E,EAAQ24E,EAAiB95C,KAAKljC,GAChC+F,EAAS,EAEb,GAAI1B,EAAO,CACD,mBAAwBA,EAAK,GAAzBm5E,GAAF,KAAQ,MAAMC,GAAF,KAAM,MACpB31E,EAAMM,WAAWo1E,GAEvB,OAAQC,GACJ,IAAK,KACD13E,EAAS+B,EACT,MACJ,IAAK,KACD/B,EAASq3E,EAAOt1E,GAChB,MACJ,IAAK,KACD/B,EAASk3E,EAAYI,GAA0Bv1E,EAC/C,MACJ,IAAK,KACD/B,EAAUk3E,EAAYI,GAA0Bv1E,EAAO,EACvD,MACJ,IAAK,IACD/B,EAAUk3E,EAAYI,GAA0Bv1E,EAAO,IACvD,MACJ,IAAK,KACD/B,EAvCK,GAuCI+B,EACT,MACJ,IAAK,MACD/B,GAAUk3E,EAAYI,IAxCV,IAwC4Dv1E,E,CASpF,OAJI/B,EAAS,GAAmB,MAAdu3E,IA2BNC,EA1BQx3E,EAAhBA,EA2BGxF,KAAKqD,MAAY,IAAL25E,EAAa,GAAK,KAxB9Bx3E,CACX,C,oGCpDA,0BACI/F,EACA09E,EACAC,EACAhJ,GAEA,QACM30E,GACO,WAATA,MACGA,GAAS09E,GAAeC,GAAkBhJ,GAAgB30E,GAAS20E,EAE9E,C,szGCdA,eAAS,mFAAA72D,iBAAiB,IAC1B,eAAS,mFAAAkgB,iBAAiB,IAC1B,eAAS,oFAAA4H,kBAAkB,IAE3B,eACI,gFAAA2/B,cAAc,IACd,wFAAArmD,sBAAsB,IACtB,kFAAAC,gBAAgB,IAEpB,eAAS,iFAAAmmD,eAAe,IACxB,eAAS,gFAAAL,cAAc,IACvB,eAAS,0FAAAV,wBAAwB,IACjC,eAAS,oEAAA38D,IAAA,oBAAA+W,0BAA0B,IACnC,eAAS,6EAAA+iB,WAAW,IACpB,eAAS,gFAAA5nB,cAAc,IACvB,eAAS,gFAAA4xB,cAAc,IACvB,eAAS,sFAAAhP,oBAAoB,IAE7B,eAAS,gFAAAkhD,cAAc,IAAE,qDAAAh2E,IAAA,oBAAAi2E,WAAW,IAAE,6EAAAv/C,WAAW,IACjD,eAAS,8EAAA/f,YAAY,IACrB,eAAS,iFAAA6lB,eAAe,IACxB,eAAS,uDAAAx8B,IAAA,oBAAAyc,aAAa,IACtB,eAAS,2DAAAzc,IAAA,oBAAAyuC,iBAAiB,IAC1B,aAAS,yEAAAzX,OAAO,IAChB,eAAS,gFAAAoJ,cAAc,IAAE,mFAAAkyC,iBAAiB,IAC1C,eAAS,sEAAA/rE,IAAI,IACb,eAAS,wEAAA63B,MAAM,IACf,eACI,iFAAA+O,eAAe,IACf,0FAAA5H,wBAAwB,IACxB,8DAAAvlC,IAAA,oBAAAguC,oBAAoB,IACpB,mFAAA1kB,iBAAiB,IACjB,0FAAAo5B,wBAAwB,IACxB,+EAAAsD,aAAa,IACb,mFAAAnY,iBAAiB,IACjB,wFAAAR,sBAAsB,IACtB,iGAAAgO,+BAA+B,IAEnC,eAAS,oFAAAtN,kBAAkB,IAC3B,eAAS,uFAAAgoB,qBAAqB,IAC9B,eAAS,+EAAAppB,aAAa,IACtB,eAAS,oFAAAV,kBAAkB,IAE3B,eAAS,oFAAAynC,kBAAkB,IAAE,mFAAAD,iBAAiB,IAE9C,eAAS,0EAAAn6D,QAAQ,IACjB,eAAS,gFAAAsG,cAAc,IACvB,eAAS,uFAAA5N,qBAAqB,IAC9B,eAAS,iFAAAhB,eAAe,IACxB,cAAS,uFAAAuI,qBAAqB,IAC9B,eAAS,6EAAAqL,WAAW,IACpB,eAAS,iFAAAC,eAAe,IACxB,eAAS,4EAAA3D,UAAU,IACnB,eAAS,6EAAAwK,WAAW,IACpB,eAAS,4FAAAG,0BAA0B,IACnC,eAAS,0FAAAvE,wBAAwB,IACjC,eAAS,sFAAA43C,oBAAoB,IAC7B,eAAS,oFAAAJ,kBAAkB,IAC3B,cAAS,8EAAAp2C,YAAY,IACrB,eAAS,+EAAA42C,aAAa,IACtB,eAAS,iFAAAnvD,eAAe,IACxB,eAAS,kFAAA8pB,gBAAgB,IACzB,eAAS,gFAAAi8C,cAAc,IAEvB,eAAS,6EAAAvqE,WAAW,IAAE,gFAAA0I,cAAc,IAAE,+EAAA3B,aAAa,IACnD,eAAS,0EAAAyF,QAAQ,IACjB,eAAS,yEAAAoX,OAAO,IAChB,eAAS,yEAAAvC,OAAO,IAChB,eAAS,gFAAA6H,cAAc,IACvB,eAAS,oFAAAshD,kBAAkB,IAE3B,gBAAS,wFAAAtlE,qBAAqB,IAC9B,gBAAS,mFAAAulE,gBAAgB,IACzB,gBAAS,8EAAArkE,WAAW,IACpB,gBAAS,6EAAAuQ,UAAU,IACnB,gBAAS,0EAAA+zD,OAAO,IAChB,gBAAS,yFAAAC,sBAAsB,IAC/B,gBAAS,oFAAAtgD,iBAAiB,IAC1B,gBAAS,yFAAAuxB,sBAAsB,IAE/B,gBAAS,0FAAArvC,uBAAuB,IAChC,gBACI,6EAAAsH,UAAU,IACV,8EAAAC,WAAW,IACX,oFAAAU,iBAAiB,IACjB,oFAAAD,iBAAiB,IACjB,mFAAAq2D,gBAAgB,IAEpB,gBAAS,iEAAAv2E,IAAA,qBAAAgf,uBAAuB,IAChC,gBAAS,8DAAAhf,IAAA,qBAAA4e,oBAAoB,IAE7B,gBAAS,qFAAAzP,kBAAkB,IAC3B,gBAAS,6EAAA47D,UAAU,IACnB,gBACI,mFAAAmJ,gBAAgB,IAChB,kDAAAl0E,IAAA,qBAAA6xD,QAAQ,IACR,2EAAAxI,QAAQ,IACR,6EAAAqrB,UAAU,IACV,0FAAAhiB,uBAAuB,IAG3B,gBACI,0FAAAz8C,uBAAuB,IACvB,oGAAAozB,iCAAiC,IACjC,yFAAA0qB,sBAAsB,IAE1B,gBACI,0FAAA79B,uBAAuB,IACvB,oGAAAiZ,iCAAiC,IACjC,yFAAAklB,sBAAsB,IAG1B,gBAAS,yEAAAnlC,MAAM,IACf,gBAAS,8DAAAlvB,IAAA,qBAAAsW,oBAAoB,IAC7B,gBAAS,+DAAAtW,IAAA,qBAAA6rC,qBAAqB,IAC9B,gBAAS,mFAAAsU,gBAAgB,IAAE,gFAAA2L,aAAa,IAAE,oFAAA1L,iBAAiB,IAC3D,gBAAS,qFAAAytB,kBAAkB,IAAE,sFAAA9zD,mBAAmB,IAChD,gBAAS,gFAAA6H,aAAa,IAAE,0EAAAC,OAAO,IAAE,gFAAA20D,aAAa,IAC9C,gBAAS,kFAAA3lC,eAAe,IACxB,gBAAS,2EAAA9lB,QAAQ,IACjB,gBAAS,2FAAAmZ,wBAAwB,IACjC,gBAAS,iFAAApF,cAAc,IACvB,gBAAS,sFAAAuoB,mBAAmB,IAC5B,gBAAS,wFAAA9J,qBAAqB,IAC9B,gBAAS,oFAAAk5B,iBAAiB,IAC1B,gBACI,qFAAAvgC,kBAAkB,IAClB,4DAAAl2C,IAAA,qBAAA61C,kBAAkB,IAEtB,eAAS,gFAAAs9B,aAAa,IAAE,uDAAAnzE,IAAA,qBAAAkzE,aAAa,IACrC,gBAAS,yDAAAlzE,IAAA,qBAAAiyD,eAAe,IAExB,gBAAS,qFAAA3jD,kBAAkB,IAE3B,eAAS,oFAAA4F,iBAAiB,IAC1B,gBACI,kEAAAlU,IAAA,qBAAAqgB,wBAAwB,IACxB,+DAAArgB,IAAA,qBAAA4vB,qBAAqB,IACrB,8DAAA5vB,IAAA,qBAAAwL,oBAAoB,IACpB,+DAAAxL,IAAA,qBAAA0gB,qBAAqB,IACrB,6DAAA1gB,IAAA,qBAAAqsB,mBAAmB,IACnB,0EAAArsB,IAAA,qBAAAoR,gCAAgC,IAEpC,gBAAS,0DAAApR,IAAA,qBAAAmjB,gBAAgB,IACzB,gBAAS,sFAAAqT,mBAAmB,IAC5B,gBAAS,wFAAAkgD,qBAAqB,IAC9B,gBAAS,2FAAA/jD,wBAAwB,IACjC,eAAS,+EAAAnZ,YAAY,IAErB,gBAAS,6EAAAmoB,UAAU,IACnB,gBAAS,6EAAA7V,UAAU,IACnB,gBAAS,kFAAA/S,eAAe,IACxB,gBAAS,gFAAA49D,aAAa,IACtB,gBAAS,8EAAAC,WAAW,IACpB,gBAAS,mFAAArpE,gBAAgB,IAAE,8FAAAsjB,2BAA2B,IACtD,gBACI,iFAAAyB,cAAc,IACd,+FAAAC,4BAA4B,IAC5B,gGAAAskD,6BAA6B,IAEjC,cAAS,8FAAAjkD,2BAA2B,IACpC,gBAAS,2FAAAtI,wBAAwB,IACjC,gBAAS,oEAAAtqB,IAAA,qBAAA82E,0BAA0B,IACnC,gBAAS,8DAAA92E,IAAA,qBAAAoiC,oBAAoB,IAC7B,gBAAS,2EAAApiC,IAAA,qBAAAuT,iCAAiC,IAC1C,gBAAS,+EAAAwjE,YAAY,IAErB,eAAS,sFAAAC,mBAAmB,IAAE,0DAAAh3E,IAAA,qBAAAmrB,gBAAgB,IAC9C,gBACI,0FAAAle,uBAAuB,IACvB,8DAAAjN,IAAA,qBAAAi3E,oBAAoB,IAExB,gBAAS,sFAAA1hE,mBAAmB,IAAE,0DAAAvV,IAAA,qBAAA4wB,gBAAgB,IAC9C,gBACI,qFAAAtgB,kBAAkB,IAClB,yDAAAtQ,IAAA,qBAAA0e,eAAe,IACf,yFAAAu2C,sBAAsB,IAG1B,gBAAS,+EAAAnsC,YAAY,IACrB,gBAAS,iFAAA2vC,cAAc,IACvB,gBAAS,oFAAAoB,iBAAiB,IAC1B,eAAS,oFAAAqB,iBAAiB,IAC1B,gBAAS,sFAAArG,mBAAmB,IAC5B,gBAAS,wFAAAC,qBAAqB,IAC9B,gBAAS,qFAAAryB,kBAAkB,G,4LCjLd,EAAAviB,kBAAuD,CAChE,cACA,aACA,eACA,eAMS,EAAAC,kBAAuD,CAChE,YACA,YACA,aAMS,EAAAV,YAAiD,EAAAS,kBAAkBvd,OAC5E,EAAAwd,mBAMS,EAAAo2D,iBAAsD,CAC/D,kBACA,YACA,YACA,YACA,aACA,aACA,YACA,cACA,eACA,aACA,aACA,eACA,gBACA,eAUJ,sBACIW,EACAC,EACAC,EACAC,G,cAEA,IAAkB,qBAAAD,GAAU,8BAAE,CAAzB,IAAM3gF,EAAG,aACgBoP,IAAtBsxE,EAAa1gF,KACbyB,OAAO0gB,OAAOs+D,IAAY,MACrBzgF,GAAM0gF,EAAa1gF,G,IAGpB4gF,UACOF,EAAa1gF,G,mGAIpC,C,iHC3EA,eAOA,mCAAwCiV,GACb,aAAnBA,EAAMK,WAA4BL,EAAMwyB,cACxC,IAAAvyB,aAAYD,GAAOwyB,YAAa,EAExC,C,gGCDA,oBACItoB,EACAlK,GAEAkK,EAAM1J,OAAOnK,KAAK2J,EACtB,C,0ICLA,SAAgBshB,EACZne,EACApQ,IAEIA,EAAKoN,OAAOqR,MAAQze,EAAKoN,OAAO/L,QAChC+O,EAAQpQ,KAAO,CACXoN,QAAQ,EAAF,eAAOpN,EAAKoN,QAClBwE,SAAS,EAAF,eAAO5R,EAAK4R,UAG/B,CAOA,SAAgBkf,EACZ1gB,EACAuG,GAEIA,EAAKvJ,OAAOkU,aACZlR,EAAQuG,KAAO,CACXvJ,QAAQ,EAAF,eAAOuJ,EAAKvJ,SAG9B,CA1BA,YAiBA,YAcA,yBACIgD,EACAU,GAEAyd,EAAQne,EAASU,EAAQ9Q,MACzB8wB,EAAQ1gB,EAASU,EAAQ6F,KAC7B,C,oGC/CA,eAuCA,sBACIQ,EACA0hE,EACAviD,EACA9jB,GAEA,IAAM6B,GAAY,IAAAiwD,iBAAgBntD,EAAOmf,EAAa9jB,GAChDsmE,EAAczkE,EAAUpF,SAASoF,EAAUpF,SAASzV,OAAS,GA8BnE,OA5BI88B,aAAW,EAAXA,EAAakvC,cAGTlvC,EAAYmvC,qBAAoD,GAA7BpxD,EAAUpF,SAASzV,cAC/C6a,EAAUjH,OAAOo4D,WAExBlvC,EAAYmvC,qBAAsB,SAG/BpxD,EAAUjH,OAAOq4D,qBAGE,mBAA1BoT,EAAWzpE,YACN0pE,GAAgBA,EAAY7oE,YAAe4oE,EAAW5oE,YACvDoE,EAAUpF,SAAS3L,KAAKu1E,IAIxBA,EAAW5oE,YACiB,oBAA5B6oE,aAAW,EAAXA,EAAa1pE,cACb0pE,EAAY7oE,YAEZoE,EAAUpF,SAASpO,MAGvBwT,EAAUpF,SAAS3L,KAAKu1E,IAGrBxkE,CACX,C,wGC7EA,eACA,WACA,WACA,WACA,UACA,WAcA,0BACI8C,EACA3H,EACAsB,G,MAEIioE,EAEJ,GAAIvpE,EAAM,CACN,IAAM6E,GAAY,IAAAiwD,iBAAgBntD,EAAOrG,EAAQwlB,gBAG5C,IAAA0iD,eAAcxpE,KACY,QAA1B,EAAA6E,aAAS,EAATA,EAAWpF,SAASzV,cAAM,QAAI,GAAK,IACpC,IAAA89D,uBAAsBjjD,aAAS,EAATA,EAAWjH,OAAOqtB,eAExCs+C,GAAY,IAAAt2D,YAAWjT,EAAMsB,EAAQ0B,eAEjC1B,EAAQ2kB,gBACRsjD,EAAU9oE,YAAa,IAG3B,IAAAywD,eAAcqY,EAAWjoE,IAEzB,IAAA+S,YAAW1M,EAAO4hE,EAAWjoE,EAAQwlB,a,CAI7C,OAAOyiD,CACX,C,yGC/CA,eACA,WACA,WAkCA,2BACI5hE,EACAmf,EACA9jB,GAEA,IAAMymE,EAAY9hE,EAAM1J,OAAO0J,EAAM1J,OAAOjU,OAAS,GAErD,GAA4B,cAAxBy/E,aAAS,EAATA,EAAW3rE,WACX,OAAO,IAAAJ,aAAY+rE,GAEnB,IAAM5kE,GAAY,IAAA9B,kBAAgB,EAAM+jB,EAAa9jB,GAGrD,OAFA,IAAAkH,UAASvC,EAAO9C,GAETA,CAEf,C,oGCjDA,IAAM6kE,EAAmB,eAOzB,yBAA8BpjD,GAC1B,OAAOojD,EAAiB77D,KAAKyY,EACjC,C,6BCFA,SAAgBqjD,EAAalsE,GACzB,OAAQA,EAAMK,WACV,IAAK,YACD,OAAgC,GAAzBL,EAAMgC,SAASzV,OAE1B,IAAK,QACD,OAAOyT,EAAMmB,KAAKgF,OAAM,SAAA/E,GAAO,OAAoB,GAApBA,EAAIC,MAAM9U,MAAV,IAEnC,IAAK,aACD,OAAO4/E,EAAkBnsE,GAK7B,QACI,OAAO,EAEnB,CAKA,SAAgBmsE,EAAkBjiE,GAC9B,OAAQA,EAAM3J,gBACV,IAAK,kBAED,MAAwB,OAAjB2J,EAAMnE,SAA2BmE,EAAM1J,OAAO2F,MAAM+lE,GAE/D,IAAK,WACD,OAAOhiE,EAAM1J,OAAO2F,MAAM+lE,GAE9B,IAAK,WACL,IAAK,UACL,IAAK,YACD,OAAO,EAEX,QACI,OAAO,EAEnB,CAKA,SAAgBE,EACZjpE,EACAkpE,G,MAEA,MACS,SADDlpE,EAAQhB,eAEAgB,EAAQZ,MAAU8pE,IAAsC,QAAZ,EAAAlpE,EAAQpQ,YAAI,eAAEoN,OAAO/L,MAKrF,C,sHAvDA,iBAsBA,sBAsBA,mBAiBA,mBACI/H,GAEA,OAuBJ,SACIA,GAEA,MAAyE,iBAA1BA,EAAOkU,cAC1D,CA3BQ+rE,CAAajgF,GACN8/E,EAAkB9/E,GAgBjC,SACIA,GAEA,MAA+D,iBAArBA,EAAOgU,SACrD,CAnBeyM,CAAQzgB,GACR6/E,EAAa7/E,KAQ5B,SACIA,GAEA,MAAmE,iBAAvBA,EAAO8V,WACvD,CAXeoqE,CAAUlgF,IACV+/E,EAAe//E,EAI9B,C,2GClFA,eAaA,6BAAkC2T,GAG9B,IAFA,IA2CAwsE,EACAC,EAdAC,EACAC,EAbAC,EACAC,EAnBIC,EAAoC,KAE/Bp+E,EAAI,EAAGA,EAAIsR,EAAMgC,SAASzV,OAAQmC,IAAK,CAC5C,IAAMyU,EAAUnD,EAAMgC,SAAStT,GAEJ,QAAvByU,EAAQhB,YACR2qE,EAAW,KACHA,IAYhBD,EAZ8D1pE,KAW9DypE,EAXoDE,GAezC9pE,cAAgB6pE,EAAK7pE,aAC5B,IAAAwD,gBAAeomE,EAAKzsE,OAAQ0sE,EAAK1sE,UAOrCusE,EANiBE,EAAK75E,KAOtB45E,EAP4BE,EAAK95E,MAU3B25E,IAAUC,GACXD,GACGC,IACA,IAAAnmE,gBAAekmE,EAAMvsE,OAAQwsE,EAAMxsE,UACnC,IAAAqG,gBAAekmE,EAAM/nE,QAASgoE,EAAMhoE,YAK5C6nE,EAlBiBI,EAAKljE,KAmBtB+iE,EAnB4BI,EAAKnjE,MAqBxB8iE,IAAUC,GAAWD,GAASC,IAAS,IAAAjmE,gBAAegmE,EAAMrsE,OAAQssE,EAAMtsE,WApC3E2sE,EAASvqE,MAAQY,EAAQZ,KACzBvC,EAAMgC,SAAShM,OAAOtH,EAAG,GACzBA,KAJAo+E,EAAW3pE,C,CAOvB,C,qJCZA,SAAgBlD,EACZD,GAgBA,OAdIA,EAAM01D,sBACC11D,EAAM01D,cA8EsC,SA3E3C11D,EA2E8BK,UA1EtCL,EAAMmB,KAAKpP,SAAQ,SAAAqP,UACRA,EAAIs0D,aACf,IA8E2D,YA7EzC11D,EA6EuBO,gBA5EzCP,EAAM+C,OAAOhR,SAAQ,SAAAgH,GAAS,cAAOA,EAAM28D,aAAb,IAGlB11D,CAGpB,CAQA,SAAgB2I,EACZvB,EACApF,GAEA,IAAM+qE,EAAc9sE,EAAYmH,GAC1B3U,EAIF,CAACs6E,EAAa,GAAI,IAatB,OAXI/qE,GACAA,EAASjQ,SAAQ,SAAAoR,GACb,IAAM+B,EAAQkC,EAAUpF,SAAS/L,QAAQkN,GAErC+B,GAAS,IACTzS,EAAO,GAAG4D,KAAK02E,EAAY/qE,SAASkD,IACpCzS,EAAO,GAAG4D,KAAK6O,GAEvB,IAGGzS,CACX,CAjDA,gBA0BA,mBA+BA,yBACI2U,EACAjE,EACAoU,G,MAMM,eAA0C5O,EAAevB,EAAW,CAACjE,IAAS,GAA7E4pE,EAAW,KAAErkE,EAAe,KAAEi9B,EAAO,KACtCqnC,EACDtkE,EAAgB,IAAsCvF,EAChDuF,EAAgB,GACjB,KAMV,OAJI6O,GAAYy1D,GACZz1D,EAAS7O,EAAgB,GAAsBqkE,EAAapnC,EAAQ,IAGjE,CAAConC,EAAaC,EAA0B,QAAV,EAAArnC,EAAQ,UAAE,SAAK,EACxD,C,+GC9FA,eACA,WACA,WACA,WACA,WAYA,iCAAgBxgC,EAAsB+E,GAClC,IAAK,IAAIxb,EAAIwb,EAAM1J,OAAOjU,OAAS,EAAGmC,GAAK,EAAGA,IAAK,CAC/C,IAAMsR,EAAQkK,EAAM1J,OAAO9R,GAE3B,OAAQsR,EAAMK,WACV,IAAK,aAC2B,YAAxBL,EAAMO,gBAAuD,GAAvBP,EAAM+C,OAAOxW,QACnDmC,GAAKsR,EAAMQ,OAAOjU,QAClB,IAAA8Z,aAAY6D,EAAOlK,EAAO,EAAA+T,cAE1B5O,EAAsBnF,GAE1B,MACJ,IAAK,aACD,IAAAyqE,oBAAmBzqE,GACnB,MACJ,IAAK,QACD,IAAK,IAAInT,EAAI,EAAGA,EAAImT,EAAMmB,KAAK5U,OAAQM,IACnC,IAAK,IAAIc,EAAI,EAAGA,EAAIqS,EAAMmB,KAAKtU,GAAGwU,MAAM9U,OAAQoB,IACxCqS,EAAMmB,KAAKtU,GAAGwU,MAAM1T,IACpBwX,EAAsBnF,EAAMmB,KAAKtU,GAAGwU,MAAM1T,KAO1D,IAAAu+E,cAAalsE,KACb,IAAAC,aAAYiK,GAAO1J,OAAOxK,OAAOtH,EAAG,E,CAGhD,C,4GC/CA,eACA,WACA,WACA,WACA,WACA,WAWA,8BAAmC0Y,GAC/B,IAAMpF,EAAWoF,EAAUpF,SAE3B,IAAKoF,EAAUorB,YAAcxwB,EAASzV,OAAS,EAAG,CAC9C,IAAMylB,EAAOhQ,EAASA,EAASzV,OAAS,GAClC0gF,EAAajrE,EAASA,EAASzV,OAAS,GAE9C,GACwB,mBAApBylB,EAAK7P,aACH8qE,GAAwC,MAA1BA,EAAW9qE,aAGxB,GAAIH,EAASzV,OAAS,GAAkD,MAA7CyV,EAASA,EAASzV,OAAS,GAAG4V,YAAqB,CACjF,IAAM+qE,EAAmBlrE,EAASC,QAAO,SAAAlU,GAAK,MAAiB,mBAAjBA,EAAEoU,WAAF,IAK1C+qE,EAAiB3gF,OAAS,GACmC,MAA7D2gF,EAAiBA,EAAiB3gF,OAAS,GAAG4V,cAE9C,IAAAlC,aAAYmH,GAAWpF,SAASpO,K,OAVpC,IAAAqM,aAAYmH,GAAWpF,SAAS3L,MAAK,IAAAuX,UAASoE,EAAK7R,UA0B/D,SAAiCiH,GAGzBA,EAAUjH,OAAOqtB,YACjBpmB,EAAUpF,SAASmE,OACf,SAAAjE,GAAO,MAAmB,MAAnBA,EAAIC,aAA0C,mBAAnBD,EAAIC,WAA/B,YAGJ,IAAAlC,aAAYmH,GAAWjH,OAAOqtB,UAE7C,CAtBQ2/C,CAAwB/lE,E,EAGvB,IAAAijD,uBAAsBjjD,EAAUjH,OAAOqtB,cACxC,IAAA4/C,sBAAqBhmE,GA4B7B,SAA0BA,GACtB,IAAMC,EAASD,EAAUpF,SAASmH,MAAK,SAAApb,GAAK,MAAiB,mBAAjBA,EAAEoU,WAAF,IAC5C,GAAIkF,EAAQ,CACR,IAAM+jB,EAAchkB,EAAUpF,SAAS/L,QAAQoR,GACzC/E,EAAO8E,EAAUpF,SAASopB,EAAc,GACxC6W,EAAO76B,EAAUpF,SAASopB,EAAc,IAGzC9oB,IACIA,EAAKvP,OACN,IAAAyT,gBAAelE,EAAKnC,OAAQkH,EAAOlH,WACjC8hC,IAAUA,EAAKlvC,OAAQ,IAAAyT,gBAAey7B,EAAK9hC,OAAQkH,EAAOlH,UAC5DkH,EAAOtU,OACTuP,GACE+E,EAAOtU,MACPkvC,IACCA,EAAKlvC,OACN,IAAAyT,gBAAey7B,EAAK9hC,OAAQkH,EAAOlH,WAEvC,IAAA6G,eAAcI,EAAWC,GAAQ,SAAAgmE,UACtBA,EAAct6E,IACzB,G,CAGZ,CAjDIu6E,CAAiBlmE,GAiBrB,SAA6BpH,GACzB,IAAK,IAAI2Y,EAAI3Y,EAAMgC,SAASzV,OAAS,EAAGosB,GAAK,EAAGA,KACxC,IAAAyzD,gBAAepsE,EAAMgC,SAAS2W,IAAI,KAClC,IAAA1Y,aAAYD,GAAOgC,SAAShM,OAAO2iB,EAAG,EAGlD,CAtBI40D,CAAoBnmE,GAsDxB,SAA6BA,GACzB,IAAKA,EAAU5B,UAAW,CACtB,IAAM,EAAW4B,EAAUpF,SAASC,QAAO,SAAAlU,GAAK,MAAiB,mBAAjBA,EAAEoU,WAAF,IAC1C,EAASiF,EAAU7B,eAAiB,CAAC,EACvC,GAAU,EAEdioE,EAAgBz7E,SAAQ,SAAAhH,GACpB,EASZ,SACIiX,EACAuE,EACAoqD,G,MAEM8c,EAAyB,QAAX,EAAAzrE,EAAS,UAAE,eAAE7B,OAEjC,UACIstE,aAAW,EAAXA,EAAc9c,MACd3uD,EAASmE,OAAM,SAAAhD,GAAW,OAAAA,EAAQhD,OAAOwwD,IAAc8c,EAAY9c,EAAzC,KAC1BpqD,EAAOoqD,IAAc8c,EAAY9c,KAEjCpqD,EAAOoqD,GAAa8c,EAAY9c,GACzB,GAIf,CA1BsB+c,CAA4B,EAAU,EAAQ3iF,IAAQ,CACpE,IAEI,KACA,IAAAkV,aAAYmH,GAAW7B,cAAgB,E,CAGnD,CAnEIooE,CAAoBvmE,EACxB,EAiDA,IAAMomE,EAAqC,CAAC,aAAc,WAAY,Y,0LCpGtE,cACA,WAOMI,EAAQ,IACRC,EAAmB,IACnBC,EAAsB,WACtBC,EAAuB,WAkD7B,SAASC,EACLnqE,GAEA,OAAOrX,OAAO0gB,OAAOrJ,QAAAA,EAAW,CAAC,EAAG,CAChCwqC,aAAc,GACd4/B,qBAAqB,EACrBC,sBAAsB,EACtBC,uBAAmBh0E,EACnB0b,qBAAiB1b,GAEzB,CAKA,SAAgBi0E,EACZhnE,EACAjE,EACAU,GAEA,OAAQV,EAAQhB,aACZ,IAAK,KACDksE,EAAsBjnE,EAAWvD,EAAQwqC,aAAcxqC,EAAQsqE,mBAC/DG,EAAyBlnE,EAAWvD,EAAQgS,gBAAiBhS,EAAQsqE,mBAGrEH,EAA6BnqE,GAC7B,MAEJ,IAAK,SACL,IAAK,UACL,IAAK,QAIDA,EAAQsqE,kBAAoBhrE,EAC5BU,EAAQoqE,qBAAsB,EAC9B,MAEJ,IAAK,OACDpqE,EAAQwqC,aAAah4C,KAAK8M,GAC1BU,EAAQsqE,kBAAoBhrE,EAC5BU,EAAQgS,gBAAkB1S,EAE1B,IAAM2R,EAAQ3R,EAAQZ,KAAKzR,UAAU,EAAG,GAClCkhB,EAAO7O,EAAQZ,KAAKg1C,QAAQ,IAE7B,IAAAw0B,eAAc5oE,EAAQZ,QACnBuS,GAAS84D,IAET,IAAA5mE,eAAcI,EAAWjE,GAAS,SAAA8D,GAC9BA,EAAY1E,KAAO0E,EAAY1E,KAAKE,QAChCqrE,EACAjqE,EAAQoqE,oBAAsB,GAAKJ,EAE3C,IAGA77D,GAAQ47D,IAER,IAAA5mE,eAAcI,EAAWjE,GAAS,SAAA8D,GAC9BA,EAAY1E,KAAO0E,EAAY1E,KAAKE,QAChCsrE,EACAlqE,EAAQqqE,qBAAuBN,EAAQC,EAE/C,KAIRhqE,EAAQoqE,oBAAsBj8D,GAAQ47D,EAIlD,CAEA,SAASS,EACLjnE,EACApF,EACAmsE,GAEAnsE,EAASjQ,SAAQ,SAAAoR,GAGb,GAAIA,GAAWgrE,EAAmB,CAC9B,IAAM,EAAOhrE,EAAQZ,KAGjB,EAAKg1C,QAAQ,IAAMs2B,GACnB,EAAKthF,OAAS,GACd,EAAKgrD,QAAQ,EAAG,IAAMq2B,IAEtB,IAAA5mE,eAAcI,EAAWjE,GAAS,SAAA8D,GAC9BA,EAAY1E,KAAO,EAAKzR,UAAU,EAAG,EAAKvE,OAAS,GAAKqhF,CAC5D,G,CAGZ,GACJ,CAEA,SAASU,EACLlnE,EACAjE,EACAgrE,GAEIhrE,GAAWA,GAAWgrE,IAAqBhrE,aAAO,EAAPA,EAASZ,KAAKg1C,QAAQ,KAAMq2B,IAEvE,IAAA5mE,eAAcI,EAAWjE,GAAS,SAAA8D,GAC9BA,EAAY1E,KAAO0E,EAAY1E,KAAKE,QAAQsrE,EAAsB,GACtE,GAER,CA3JA,gCAAqC3mE,GACjC,IAAMvD,EAAUmqE,IAEhB5mE,EAAUpF,SAASjQ,SAAQ,SAAAoR,GACvBirE,EAAiBhnE,EAAWjE,EAASU,EACzC,IAEAwqE,EAAsBjnE,EAAWvD,EAAQwqC,aAAcxqC,EAAQsqE,mBAC/DG,EAAyBlnE,EAAWvD,EAAQgS,gBAAiBhS,EAAQsqE,kBACzE,EAOA,kCACI/mE,EACAjE,EACA+qE,QAAA,IAAAA,IAAAA,GAAA,GAEA,IAAMrqE,EAAUmqE,IAEhBnqE,EAAQqqE,qBAAuBA,EAC/BE,EAAiBhnE,EAAWjE,EAASU,EACzC,EAgBA,2CACI,OAAOmqE,GACX,EAiBA,oB,gHC5EA,eACA,WACA,WACA,WACA,WAcA,kCACI7tE,EACAs9B,G,QAEM2sB,EAAO3sB,EAAY5Q,SAAShQ,cAAc,QAC1C1Z,GAAU,IAAAqS,YAAW,OAAQrV,GAE7Bq2B,GAAuC,IAAAmH,mCACzCF,EAAYlI,mBAAmBqI,YAE7BrT,GAAuC,IAAAkZ,mCACzChG,EAAY+F,mBAAmB5F,YAE7BvxC,GAAQ,IAAA8zB,8BAcd,OAZAoK,EAAkBgkD,cAAcprE,QAC5BinD,EAAKh6B,cACLg6B,EACAjnD,EACAonB,EACA,IAGJiM,EAAkB45B,kBAAkBjmC,QAAQ99B,EAAO+9D,EAAM5zB,GAIrB,QAA7B,EAAqB,QAArB,GAFW,IAAA6gC,iBAAgBhrE,GAEjB2V,SAAS,UAAE,eAAE7B,cAAM,QAAIA,CAC5C,C,oHC9CA,WACA,WACA,WAYA,uBACI9M,EACAm7E,EACAC,G,UAEMvpE,EAA6C,QAArC,EAAA7R,aAAM,EAANA,EAAQmN,OAAOvK,QAAQu4E,UAAc,SAAK,EAEpDtpE,GAAS,IACTspE,EAAchuE,OAAOzO,QAAQ,EAAAya,yBAEzBnZ,IACmB,QAAnB,OAAA4M,aAAY5M,UAAO,YAAEmN,QAAOxK,OAAM,6BAC9BkP,EACA,IAAC,YACEspE,EAAchuE,OAAOtP,KAAI,SAAAnD,GACxB,IAAM8lB,GAAe,IAAA5T,aAAYlS,GAUjC,OARI0gF,IACA,IAAA36D,YACID,EAAa1T,OACbquE,EAAcruE,OACdsuE,GAID56D,CACX,MAAE,KAIlB,C,iHCtCA,oBAAyB1T,GACrB,MAAO,CACHgC,YAAa,KACbhC,QAAQ,EAAF,eAAOA,GAErB,C,kHCFA,sCACIknB,GAEA,IAAM50B,EAA+B,CACjC8N,eAAgB,WAChBC,OAAQ,IAOZ,OAJI6mB,IACA50B,EAAO0N,OAASknB,GAGb50B,CACX,C,sHCfA,yBACIsT,EACA5F,GAEA,MAAO,CACHE,UAAW,UACX0F,QAAO,EACP5F,QAAQ,EAAF,eAAOA,GAErB,C,0GChBA,eACA,WACA,WACA,UAUA,4BACIA,GAEA,IAAM9T,GAAQ,IAAA8zB,4BAA2BhgB,GACnCiH,GAAY,IAAA9B,kBAAgB,OAAsBnL,EAA2BgG,GAKnF,OAHAiH,EAAUpF,SAAS3L,MAAK,IAAAwX,uBAAsB1N,IAAS,IAAAyN,UAASzN,IAChE9T,EAAMmU,OAAOnK,KAAK+Q,GAEX/a,CACX,C,oHCbA,wBACIoe,EACA+S,EACAjY,EACAyE,EACAuT,GAEA,YALA,IAAAC,IAAAA,GAAA,GAKO,CACHrb,YAAa,SACb9B,UAAW,SACXF,QAAQ,EAAF,eAAOoF,GACbykB,aAAc,CACVzM,GAAE,EACFM,WAAY7T,EACZwT,WAAU,GAEd/S,QAAO,EAEf,C,8HClBA,iCACIgR,EACAtb,GAEA,MAAO,CACHE,UAAW,aACXE,eAAgB,kBAChBwF,QAAS0V,EACTjb,OAAQ,GACRL,QAAQ,EAAF,eAAOA,GAErB,C,0GCfA,8BAAmCgqB,GAC/B,MAAO,CACH9pB,UAAW,aACXE,eAAgB,UAChB4pB,QAASA,EACT3pB,OAAQ,GACRL,OAAQ,CAAC,EAEjB,C,6HCJA,gCACIgqB,EACAhqB,GAEA,MAAO,CACHE,UAAW,aACXE,eAAgB,UAChB4B,YAAa,UACbhC,QAAQ,EAAF,eAAOA,GACbK,OAAQ,GACR2pB,QAASA,EAEjB,C,oHCfA,uBACIzK,EACAvf,GAEA,MAAO,CACHgC,YAAa,QACbud,IAAKA,EACLvf,QAAQ,EAAF,eAAOA,GACbwE,QAAS,CAAC,EAElB,C,wGCjBA,eACA,UAYA,0BACI5B,EACA5C,GAEA,IAAMyI,GAAe,IAAAiF,uBAAsB1N,GAI3C,OAFAyI,EAAa5F,YAAa,EAEnB,CACH3C,UAAW,aACXE,eAAgB,WAChBC,OAAQ,GACRuC,OAAQA,EACFA,EAAO7R,KAAI,SAAA6H,GAAS,WAAA0L,iBAAgB1L,EAAM2L,SAAU3L,EAAMoH,OAAQpH,EAAM4L,QAApD,IACpB,GACNiE,aAAY,EACZzI,OAAQ,CAAC,EAEjB,C,wHCnBA,2BACIuE,EACAvE,EACAwE,GAEA,MAAO,CACHD,SAAQ,EACRvE,QAAQ,EAAF,eAAOA,GACbwE,SAAS,EAAF,eAAOA,GAEtB,C,wHCRA,2BACI6tB,EACAnJ,EACA9jB,EACAC,GAEA,IAAM/S,EAAgC,CAClC4N,UAAW,YACX2B,SAAU,GACV7B,QAAQ,EAAF,eAAOkpB,IAkBjB,OAfI9jB,GAAiB/Y,OAAOsF,KAAKyT,GAAehZ,OAAS,IACrDkG,EAAO8S,eAAgB,EAAH,eAAQA,IAG5BitB,IACA//B,EAAO+/B,YAAa,GAGpBhtB,IACA/S,EAAO+S,UAAY,CACfO,QAASP,EAAUO,QACnB5F,QAAQ,EAAF,eAAOqF,EAAUrF,UAIxB1N,CACX,C,iIChCA,oCACIsT,EACA5F,GAEA,MAAO,CACH4F,QAASA,EAAQqJ,oBACjBjP,QAAQ,EAAF,eAAOA,GAErB,C,6HCTA,iCACIA,GAEA,MAAO,CACHgC,YAAa,kBACba,YAAY,EACZ7C,QAAQ,EAAF,eAAOA,GAErB,C,oHCjBA,WAYA,uBACIuuE,EACAvuE,GAIA,IAFA,IAAMgB,EAA+B,GAE5BzS,EAAI,EAAGA,EAAIggF,EAAUhgF,IAC1ByS,EAAK9K,MAAK,IAAAm0E,mBAGd,MAAO,CACHnqE,UAAW,QACXc,KAAI,EACJhB,QAAQ,EAAF,eAAOA,GACbkZ,OAAQ,GACR1U,QAAS,CAAC,EAElB,C,wHChBA,2BACIgqE,EACAC,EACA3lE,EACA9I,EACAwE,GAEA,IAAMyT,EAC2B,iBAAtBu2D,EAAiCA,EAAoB,IAAMA,EAChEz2D,EAC4B,iBAAvB02D,EAAkCA,EAAqB,IAAMA,EACxE,MAAO,CACHruE,eAAgB,YAChBC,OAAQ,GACRL,QAAQ,EAAF,eAAOA,GACbiY,SAAQ,EACRF,UAAS,EACTjP,WAAYA,EACZtE,SAAS,EAAF,eAAOA,GAEtB,C,uHC3BA,0BACIxE,EACA6Z,GAEA,YAFA,IAAAA,IAAAA,EAAA,GAEO,CACHA,OAAQA,EACR7Z,QAAQ,EAAF,eAAOA,GACbkB,MAAO,GAEf,C,mHCfA,WAeA,sBACIkB,EACApC,EACApN,EACA2W,GAEA,IAAMjX,EAA2B,CAC7B0P,YAAa,OACbI,KAAMA,EACNpC,QAAQ,EAAF,eAAOA,IAWjB,OARIpN,IACA,IAAAuuB,SAAQ7uB,EAAQM,GAGhB2W,IACA,IAAAma,SAAQpxB,EAAQiX,GAGbjX,CACX,C,6JCpCA,WACA,WACA,WACA,SACA,UACA,WACA,WAQMo8E,EAAgD,CAClDC,eAAgB,UAChBC,kBAAmB,UACnBC,oBAAqB,UACrBC,cAAc,EACdC,gBAAgB,EAChBC,eAAe,EACfC,kBAAkB,EAClBC,YAAa,KACbC,WAAY,YACZC,eAAgB,UAChBC,kBAAmB,EAAAhgB,kBAAkBC,QACrC53C,cAAe,MAenB,4BACI1Q,EACAya,EACA0E,GAEA,IAAMmpD,GAAe,IAAAxvE,aAAYkH,GACzBhG,EAASsuE,EAAY,MAE7B,IAAA5lE,qBAAoB4lE,GAAc,SAAAtvE,GAC9B,IAAMuvE,GAAoB,EAAH,6CAChBb,GACA1uE,GACAyhB,GAGD+tD,EAUd,SACIxuE,EACAyuE,GAEA,IAAMrf,EAA2B,CAC7Bsf,iBAAkB,GAClBC,gBAAiB,GACjBC,gBAAiB,IA4BrB,OAzBA5uE,EAAKpP,SAAQ,SAAAqP,GACT,IAAMyuE,EAA8B,GAC9BC,EAA6B,GAC7BC,EAA6B,GAEnCxf,EAAUsf,iBAAiBx5E,KAAKw5E,GAChCtf,EAAUuf,gBAAgBz5E,KAAKy5E,GAC/Bvf,EAAUwf,gBAAgB15E,KAAK05E,GAE/B3uE,EAAIC,MAAMtP,SAAQ,SAAAuP,IACd,IAAAC,0BAAwB,IAAAtB,aAAYqB,IAAO,SAAAE,GAUvC,OATIA,GAAYouE,GACZC,EAAiBx5E,MAAK,UACfmL,EAASwuE,iBAEhBH,EAAiBx5E,QAAOmL,aAAQ,EAARA,EAAUwuE,kBAEtCF,EAAgBz5E,QAAOmL,aAAQ,EAARA,EAAUsW,iBACjCi4D,EAAgB15E,QAAOmL,aAAQ,EAARA,EAAUC,iBAE1BD,CACX,GACJ,GACJ,IAEO+uD,CACX,CA9C6C0f,CAAgB9uE,GAAOmlB,GAM5D,OAwGR,SACInlB,EACAhB,EACAwvE,GAEQ,IAAAR,EAA6EhvE,EAAM,cAApEivE,EAA8DjvE,EAAM,iBAAlDmvE,EAA4CnvE,EAAM,WAAtCkvE,EAAgClvE,EAAM,YAAzB+uE,EAAmB/uE,EAAM,eAE3FgB,EAAKpP,SAAQ,SAACqP,EAAK0H,GACf1H,EAAIC,MAAMtP,SAAQ,SAACm+E,EAAcrnE,G,MACvBvH,GAAO,IAAArB,aAAYiwE,GAGzB,IACKP,EAAcI,gBAAgBjnE,GAAUD,IACN,iBAA5B1I,EAAOqvE,kBAChB,CACE,IAAMW,EAAoE,QAA1C,EAAAC,EAAiBjwE,EAAOqvE,0BAAkB,oBAA1CY,EAA6C,CACzE14D,SAAuB,IAAb5O,EACV6O,QAAS7O,IAAa3H,EAAK5U,OAAS,EACpCoqB,YAA0B,IAAb9N,EACb+O,WAAY/O,IAAazH,EAAIC,MAAM9U,OAAS,IAG1C,EAAc,CAChB4T,EAAO2uE,eACP3uE,EAAO6uE,oBACP7uE,EAAO4uE,kBACP5uE,EAAO6uE,qBAGXmB,SAAAA,EAAyBp+E,SAAQ,SAACs+E,EAAsB3hF,GACpD,IAAM4f,GAAgB+hE,GAAwB,EAAY3hF,IAAO,GAEjE4S,EAAKnB,OAAO,EAAAk/D,WAAW3wE,KAAM,IAAAyzE,oBAAmB,CAC5Ch0D,MAAOmiE,EAAwBhiE,GAC/BJ,MAAO,MACP1d,MAAO8d,GAEf,G,CAIJ,IAAKqhE,EAAcE,iBAAiB/mE,GAAUD,GAAW,CACrD,IAAIrY,EAEAA,EADA0+E,GAA8B,GAAZrmE,GAAiBC,EAAW,EACtC,MAGJqmE,GAAiBC,KACVA,GAAoBvmE,EAAW,GAAK,GACpCsmE,GAAiBrmE,EAAW,GAAK,GAC9BwmE,EAEJD,GAEd,IAAAnoD,6BACI5lB,EACA9Q,GACA,GACA,E,CAKJ2P,EAAO0X,gBAAkB83D,EAAcG,gBAAgBhnE,GAAUD,KACjEvH,EAAKnB,OAAO0X,cAAgB1X,EAAO0X,eAIvCvW,EAAK2H,UAAW,CACpB,GACJ,GACJ,CApLQsnE,CAAYpvE,EAAMuuE,EAAmBC,GACrCxqD,EAA4BhkB,EAAMuuE,GA8N1C,SACIvuE,EACAhB,EACAwvE,G,MAGA,GAAKxvE,EAAO8uE,aAAZ,CAMc,QAAd,EAAA9tE,EAFiB,UAEH,SAAEE,MAAMtP,SAAQ,SAACm+E,EAAcjqC,GACzC,IAAM3kC,GAAO,IAAArB,aAAYiwE,GAEzB5uE,EAAK2H,UAAW,EAChB3H,EAAKnB,OAAOub,WAAa,OAErBvb,EAAOovE,iBACFI,EAAcE,iBATV,GASqC5pC,KAC1C,IAAA/e,6BACI5lB,EACAnB,EAAOovE,gBACP,GACA,GAIRiB,EAAelvE,EAAKnB,OAAQ,YAAaA,EAAOovE,gBAChDiB,EAAelvE,EAAKnB,OAAQ,cAAeA,EAAOovE,gBAClDiB,EAAelvE,EAAKnB,OAAQ,aAAcA,EAAOovE,gBAEzD,G,CACJ,CA9PQkB,CAAmBtvE,EAAMuuE,EAAmBC,GAErCD,CACX,GACJ,EA+CA,IAAMU,IAAgB,MACjB,EAAA5gB,kBAAkBC,SAAU,SAAA95C,GAAK,QAAC,GAAO,GAAO,GAAO,EAAtB,EAClC,EAAC,EAAA65C,kBAAkBE,qBAAsB,SAAC,GAAgC,QACtE,GADkD,cAGlD,GAH+D,cAAO,EAM1E,EAAC,EAAAF,kBAAkBK,2BAA4B,SAAC,G,IAC5Cl5C,EAAW,cACXe,EAAQ,WAGN,QACDA,GAHS,eAIOf,GAAiBA,GAAee,GAH1C,YAIMA,GACZf,EAJC,EAMN,EAAC,EAAA64C,kBAAkBG,iBAAkB,SAAC,G,IAAEj4C,EAAQ,WAAEf,EAAW,cAAEiB,EAAU,aAAO,OAC5EF,EACAA,GAAYE,GACZ,EACAF,GAAYf,EAJgE,EAMhF,EAAC,EAAA64C,kBAAkBI,eAAgB,SAAC,G,IAAEj5C,EAAW,cAAmB,QAChE,EADyD,cAGzD,EACAA,EAJgE,EAMpE,EAAC,EAAA64C,kBAAkBM,eAAgB,SAAC,G,IAAEp4C,EAAQ,WAAEf,EAAW,cAAO,OAC9DA,IAAgBe,EAChBA,EACAf,IAAgBe,EAChBA,IAAaf,EAJiD,EAMlE,EAAC,EAAA64C,kBAAkBO,eAAgB,SAAC,G,IAAEr4C,EAAQ,WAAEf,EAAW,cAAO,QAC7De,EACDA,IAAaf,GACZe,GACAf,EAJ6D,EAMlE,EAAC,EAAA64C,kBAAkBQ,eAAgB,SAAC,G,IAAEr5C,EAAW,cAAEe,EAAQ,WAAO,QAC9D,EACAA,IAAaf,GACZe,GACD,EAJ8D,EAMlE,EAAC,EAAA83C,kBAAkBS,OAAQ,WAAM,QAAC,GAAM,GAAM,GAAM,EAAnB,E,GAqFrC,SAAgB9qC,EACZhkB,EACAhB,GAEAgB,EAAKpP,SAAQ,SAACqP,EAAK0H,GACf1H,EAAIC,MAAMtP,SAAQ,SAACm+E,EAAcjqC,G,YACvB3kC,GAAO,IAAArB,aAAYiwE,GAEzB,GAAkB,IAAdjqC,EAAiB,CACD,GAAZn9B,IACAxH,EAAK2H,WAAa9I,EAAO8uE,c,IAG7B,IAAoB,qBAAA3tE,EAAKd,QAAM,8BAAE,CAA5B,IAAMR,EAAK,QACZ,GAAuB,aAAnBA,EAAMK,U,IACN,IAAsB,+BAAAL,EAAMgC,WAAQ,8BAAE,CAAjC,IAAMmB,EAAO,SACd,IAAA6D,eAAchH,EAAOmD,GAAS,SAAAutE,GACtBvwE,EAAO+uE,gBACPwB,EAAYvwE,OAAOub,WAAa,OAChCpa,EAAKnB,OAAOub,WAAa,QAEQ,QAAjCg1D,EAAYvwE,OAAOub,YACO,QAA1Bpa,EAAKnB,OAAOub,oBAELg1D,EAAYvwE,OAAOub,kBACnBpa,EAAKnB,OAAOub,WAE3B,G,uMAKpB,GACJ,GACJ,CA0CA,SAAS80D,EAAerwE,EAAsBpV,EAAyB2B,GACnE,IAAMshB,GAAS,IAAAK,qBAAoBlO,EAAOpV,IAC1CijB,EAAOxd,MAAQ9D,GAAS,GACxBshB,EAAOG,MAAQmiE,EAAwBtiE,EAAOxd,OAC9C2P,EAAOpV,IAAO,IAAAo3E,oBAAmBn0D,EACrC,CAEA,SAASsiE,EAAwB9/E,GAC7B,OAAQA,GAAkB,eAATA,EAAkC,QAAT,MAC9C,CArFA,+B,mHCnIA,SAASmgF,EACLtkF,GAEA,MAAO,CACH8T,OAAQ3T,OAAO0gB,OAAO,CAAC,EAAG7gB,EAAM8T,QAExC,CAEA,SAASywE,EACLvkF,GAEA,MAAO,CACHsY,QAASnY,OAAO0gB,OAAO,CAAC,EAAG7gB,EAAMsY,SAEzC,CAEA,SAASksE,EACL7wE,GAEQ,IAAAK,EAAcL,EAAK,UAE3B,OAAOxT,OAAO0gB,OACV,CACI7M,UAAS,GAEbswE,EAAqB3wE,GAE7B,CAEA,SAAS8wE,EACL5mE,EACAqS,GAIA,MAAO,CACHhc,eAH+B2J,EAAK,eAIpC1J,OAJ+B0J,EAAK,OAIrBhZ,KAAI,SAAA8O,GAAS,OAnFpC,SACIA,EACAuc,GAEA,OAAQvc,EAAMK,WACV,IAAK,aACD,OAAQL,EAAMO,gBACV,IAAK,kBACD,OAqMpB,SACIuH,EACAyU,GAEQ,IAAAxW,EAA2B+B,EAAS,QAA3B4tD,EAAkB5tD,EAAS,cACtCG,EAA4Czb,OAAO0gB,OACrD,CAAEnH,QAAO,EAAE2vD,cAAeqb,EAAoBrb,EAAe,QAASn5C,IACtEs0D,EAAe/oE,GACfgpE,EAAoBhpE,EAAWyU,IAOnC,OAJIzU,EAAUmrD,eACVhrD,EAAagrD,cAAe,GAGzBhrD,CACX,CArN2B+oE,CAAqBhxE,EAAOuc,GACvC,IAAK,UACD,OAAO00D,EAAkBjxE,EAAOuc,GACpC,IAAK,WACD,OAmNpB,SACIzZ,EACAyZ,GAEQ,IAAA3T,EAAwC9F,EAAI,aAA9BC,EAA0BD,EAAI,OAAtB4yD,EAAkB5yD,EAAI,cAEpD,OAAOtW,OAAO0gB,OACV,CACItE,aAAcsoE,EAAqBtoE,GACnC7F,OAAQA,EAAO7R,IAAIigF,GACnBzb,cAAeqb,EAAoBrb,EAAe,QAASn5C,IAE/Ds0D,EAAe/tE,GACfguE,EAAoBhuE,EAAMyZ,GAElC,CAlO2B60D,CAAcpxE,EAAOuc,GAEpC,MACJ,IAAK,UACD,OAqOZ,SACIo3C,EACAp3C,GAEQ,IAAAxW,EAAuC4tD,EAAO,QAArC3wD,EAA8B2wD,EAAO,WAAzB+B,EAAkB/B,EAAO,cAEtD,OAAOnnE,OAAO0gB,OACV,CACIlK,WAAU,EACV+C,QAAO,EACP2vD,cAAeqb,EAAoBrb,EAAe,QAASn5C,IAE/Ds0D,EAAeld,GAEvB,CAnPmB0d,CAAarxE,EAAOuc,GAC/B,IAAK,SACD,OAAO+0D,EAAYtxE,EAAOuc,GAC9B,IAAK,YACD,OAuGZ,SACInV,EACAmV,GAEQ,IAAAm5C,EAAkEtuD,EAAS,cAA5DpF,EAAmDoF,EAAS,SAAlDorB,EAAyCprB,EAAS,WAAtC5B,EAA6B4B,EAAS,UAA3B7B,EAAkB6B,EAAS,cAE7EmqE,EAAsC/kF,OAAO0gB,OAC/C,CACIwoD,cAAeqb,EAAoBrb,EAAe,QAASn5C,GAC3DiW,WAAU,EACVxwB,SAAUA,EAAS9Q,KAAI,SAAAiS,GAAW,OA3G9C,SACIA,EACAoZ,GAEA,OAAQpZ,EAAQhB,aACZ,IAAK,KACD,OAAOqvE,EAAiBruE,GAC5B,IAAK,SACD,OAAOmuE,EAAYnuE,EAASoZ,GAChC,IAAK,UACD,OAgQZ,SACI+2C,EACA/2C,GAEA,OAAO/vB,OAAO0gB,OAAO+jE,EAAkB3d,EAAS/2C,GAAUi1D,EAAiBle,GAC/E,CArQmBme,CAAoBtuE,EAASoZ,GACxC,IAAK,QACD,OAqPAmD,GADQ3R,EApPU5K,GAqPmC,IAAhDyc,EAA2C7R,EAAK,IAA3C+lD,EAAsC/lD,EAAK,MAApCgmD,EAA+BhmD,EAAK,2BAEtDvhB,OAAO0gB,OACV,CAAEwS,IAAG,EAAEE,IAAG,EAAEk0C,MAAK,EAAEC,2BAA0B,GAC7Cyd,EAAiBzjE,GACjB6iE,EAAsB7iE,IAzPtB,IAAK,kBACD,OAAOmjE,EAAqB/tE,GAChC,IAAK,OACD,OAkQAZ,GADO0E,EAjQU9D,GAkQG,KACrB3W,OAAO0gB,OAAO,CAAE3K,KAAI,GAAIivE,EAAiBvqE,IAFpD,IAAmBA,EACP1E,EAlBQwL,EACR2R,EAAKE,EAAKk0C,EAAOC,CA/O7B,CAyF8C2d,CAAavuE,EAASoZ,EAAtB,IAClChX,cAAeA,GAAgB,EAAD,eAAMA,QAAkBpL,GAE1D02E,EAAezpE,GACfupE,EAAqBvpE,IAYzB,OATI5B,IACA+rE,EAAa/rE,UAAYhZ,OAAO0gB,OAC5B,CACInH,QAASP,EAAUO,SAEvB4qE,EAAqBnrE,KAItB+rE,CACX,CAlImBI,CAAe3xE,EAAOuc,GACjC,IAAK,QACD,OAkIZ,SACIpV,EACAoV,GAEQ,IAAAm5C,EAAgCvuD,EAAK,cAAtBkS,EAAiBlS,EAAK,OAAdhG,EAASgG,EAAK,KAE7C,OAAO3a,OAAO0gB,OACV,CACIwoD,cAAeqb,EAAoBrb,EAAe,QAASn5C,GAC3DlD,OAAQhnB,MAAMW,KAAKqmB,GACnBlY,KAAMA,EAAKjQ,KAAI,SAAAkQ,GAAO,OAOlC,SACIA,EACAmb,GAEQ,IAAAvC,EAAiC5Y,EAAG,OAA5BC,EAAyBD,EAAG,MAArBs0D,EAAkBt0D,EAAG,cAE5C,OAAO5U,OAAO0gB,OACV,CACI8M,OAAM,EACN07C,cAAeqb,EAAoBrb,EAAe,QAASn5C,GAC3Dlb,MAAOA,EAAMnQ,KAAI,SAAAoQ,GAAQ,OAMrC,SACIA,EACAib,GAEQ,IAAAm5C,EAA6Dp0D,EAAI,cAAlD0B,EAA8C1B,EAAI,WAAtC4W,EAAkC5W,EAAI,UAA3B8W,EAAuB9W,EAAI,SAAjB2H,EAAa3H,EAAI,SAEzE,OAAO9U,OAAO0gB,OACV,CACIwoD,cAAeqb,EAAoBrb,EAAe,QAASn5C,GAC3DvZ,WAAU,EACVkV,UAAS,EACTE,SAAQ,EACRnP,SAAQ,GAEZ6nE,EAAoBxvE,EAAMib,GAC1Bo0D,EAAqBrvE,GACrBsvE,EAAsBtvE,GAE9B,CAxBqCswE,CAAetwE,EAAMib,EAArB,KAE7Bo0D,EAAqBvvE,GAE7B,CArBkCywE,CAAczwE,EAAKmb,EAAnB,KAE1Bs0D,EAAe1pE,GACfypE,EAAsBzpE,GAE9B,CAjJmB2qE,CAAW9xE,EAAOuc,GAErC,CA2DoCw1D,CAAW/xE,EAAOuc,EAAlB,IAEpC,CAEA,SAASi1D,EACLruE,GAEQ,IAAAhB,EAAwCgB,EAAO,YAAlCH,EAA2BG,EAAO,WAAtBuG,EAAevG,EAAO,KAAhBpQ,EAASoQ,EAAO,KAEjDyoE,EAAyCp/E,OAAO0gB,OAClD,CACI/K,YAAW,EACXa,WAAU,GAEd2tE,EAAqBxtE,IAUzB,OAPIuG,IACAkiE,EAAWliE,KAAOinE,EAAqBjnE,IAEvC3W,IACA64E,EAAW74E,KAAOvG,OAAO0gB,OAAOyjE,EAAqB59E,GAAO69E,EAAsB79E,KAG/E64E,CACX,CAEA,SAAS0F,EAAYnqD,EAA4B5K,GACrC,IAAA9R,EAA0B0c,EAAM,QAAvB6C,EAAiB7C,EAAM,aAExC,OAAO36B,OAAO0gB,OACV,CACIzC,QAASsmE,EAAoBtmE,EAAS,SAAU8R,GAChDyN,cAAc,EAAF,eAAOA,IAEvB6mD,EAAe1pD,GACfqqD,EAAiBrqD,GAEzB,CAuHA,SAASgqD,EAAep4E,GACZ,IAAA2L,EAAa3L,EAAK,SAE1B,OAAOvM,OAAO0gB,OAAO,CAAExI,SAAQ,GAAIisE,EAAqB53E,GAAQ63E,EAAsB73E,GAC1F,CAiBA,SAASk4E,EACL3d,EACA/2C,GAEQ,IAAA4N,EAAYmpC,EAAO,QAE3B,OAAO9mE,OAAO0gB,OACV,CACIid,QAAS4mD,EAAoB5mD,EAAS,UAAW5N,IAErDs0D,EAAevd,GACfwd,EAAoBxd,EAAS/2C,GAErC,CAEA,SAAS20D,EACL7pE,GAEA,OAAO7a,OAAO0gB,OAAO,CAAElK,WAAYqE,EAAOrE,YAAcwuE,EAAiBnqE,GAC7E,CAoCA,SAAS0pE,EACLh9E,EACAiW,EACAuS,GAEQ,IAAAwZ,EAAyBxZ,EAAO,qBAExC,GAAKxoB,EAEE,IAAKgiC,EAEL,KAA6B,IAAzBA,EACP,OAAOhiC,EAEP,IAAMtB,EAASsjC,EAAqBhiC,EAAMiW,GAE1C,IAAa,WAARA,GAA6B,UAARA,KAAsBvX,EAC5C,MAAM,IAAInG,MAAM,qDAGpB,OAAOmG,C,CAVP,MAAe,SAARuX,OAAkB7P,EAAapG,EAAKu8B,WAAU,E,CAY7D,CA/VA,sBACIjkC,EACAkwB,GAEA,IAAMy1D,EAAiClB,EAAoBzkF,EAAOkwB,GAAW,CAAC,GAM9E,OAJIlwB,EAAM8T,SACN6xE,EAAS7xE,OAAS3T,OAAO0gB,OAAO,CAAC,EAAG7gB,EAAM8T,SAGvC6xE,CACX,C,mGCnDA,uBACIxxE,EACAyxE,EACAC,EACAruE,EACAzD,GAEA,IAAM8E,EAAQ1E,EAAOvK,QAAQg8E,GAE7B,OAAQA,EAAc5xE,WAClB,IAAK,QACL,IAAK,UAED,OADA6xE,EAAc1xE,EAAOxK,OAAOkP,EAAO,EAAGgtE,GAAe1xE,EAAOxK,OAAOkP,EAAO,IACnE,EAEX,IAAK,SACD,IAAM2R,EAAgDo7D,EAAcjvE,WAC9D,YACa,WAAb5C,EACA,kBACa,YAAbA,EACA,qBACAjG,EAUN,YARkBA,IAAd0c,IACAq7D,EAAc1xE,EAAOxK,OAAOkP,EAAO,EAAGgtE,GAAe1xE,EAAOxK,OAAOkP,EAAO,GAC1ErB,SAAAA,EAAS86B,gBAAgBtoC,KAAK,CAC1B8wB,OAAQ8qD,EACRp7D,UAAS,MAIV,EAEX,IAAK,aACD,OAAQo7D,EAAc1xE,gBAClB,IAAK,UACD,QAAI2xE,IACA1xE,EAAOxK,OAAOkP,EAAO,EAAGgtE,IACjB,GAMf,IAAK,WACL,IAAK,kBAED,OADA1xE,EAAOxK,OAAOkP,EAAO,IACd,GAIvB,OAAO,CACX,C,gICpEA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WAaMitE,EAA2D,CAC7DC,8BAA+B,uBAC/BC,mCAAoC,qBACpChpE,wBAAyB,SAsH7B,SAASipE,EACLjrE,EACAD,EACAhU,EACAqV,GAEA,MAAO,CACHpB,OAAM,EACND,UAAS,EACThU,KAAI,EACJqV,aAAY,EAEpB,CA1HA,mCACIpc,EACAkmF,GAEA,IAAM1uE,EAAkC,CACpCuJ,aAAc,aACdlG,YAAa,KACbqrE,cAAa,EACbC,oBAAqB,IAmGzB,OAhGA,IAAAhqE,mBACInc,GACA,SAAC+G,EAAMqV,EAAc1I,EAAe0yE,GAGhC,IAAIrrE,GAAiD,IAAA9B,kBACjD,OACAnL,EACA9N,EAAM8T,QAENs8C,EAAepwD,EAAM8T,OACrBuyE,EAAoB,EAExB,GAAID,GAAgD,cAA5B1yE,aAAa,EAAbA,EAAeM,WAA0B,CACvD,oBAA6B,IAAAsI,gBAAe5I,EAAe0yE,GAAiB,GAA3E,EAAK,KAAEzwE,EAAQ,KAAE2jC,EAAO,KAG/B,GAAI3jC,EAAS,GAAI,CAGboF,EAAY,EACZsrE,EAAoB/sC,EAAQ,GAC5B8W,GAAe,IAAA/lB,sBAAqB10B,EAAS,IAAI,GAEjD,IAAM,GAA4B6B,EAAQmf,cAE1Cnf,EAAQmf,cAAgB5b,EACxBvD,EAAQ8uE,iBAAmBlqE,EAE3BzG,EAASjQ,SAAQ,SAACoR,EAASzU,GAEd,GAALA,GACCmV,EAAQqD,aACc,mBAAvB/D,EAAQhB,aAWR,IAAA8oE,eACI,EACA9nE,EACAU,EAAQ0uE,mBACRp4E,EACA,OAA2BA,EAAY0J,EAAQ2uE,uBAGnD3uE,EAAQuJ,aAAe,SAfvBvJ,EAAQqD,YAAcorE,EAClBnvE,EACA,EACA/P,EACAqV,EAaZ,IAK4B,SAAxB5E,EAAQuJ,eACR,IAAAZ,yBAAwB,E,OAG7B,GAAIzM,EAAe,CAEtB,IAAMS,GAAS,IAAAP,aAAY7M,EAAK,IAAIoN,QAEhC,IAAA0qE,aAAY1qE,EAAQT,EAAeqH,EAAWvD,EAAQ0uE,iBACtD1uE,EAAQuJ,aAAe,Q,MAExB,GAAI3E,EAAc,CAEb,IAAAtB,EAA8BsB,EAAY,MAAnCI,EAAuBJ,EAAY,SAAzBK,EAAaL,EAAY,SAE5CrH,GADe,IAAAnB,aAAYkH,GACRhG,KAAK2H,GACxBxH,GAAO,IAAArB,aAAYmB,EAAIC,MAAMwH,IAEnCzV,GAAO,EAAH,kBAAIkO,IAAI,YAAKlO,IAAI,GACrBgU,EAAUpF,SAAS3L,MAAK,IAAAuX,UAASvhB,EAAM8T,SACvCmB,EAAKd,OAAS,CAAC4G,GAEfvD,EAAQuJ,aAAe,O,CAG3B,IAAKvJ,EAAQqD,YAAa,CAEtB,IAAMG,GAAS,IAAAwG,uBAAsB4uC,IAErC,IAAAjwC,yBAAwBpF,GACxBA,EAAUpF,SAAShM,OAAO08E,EAAmB,EAAGrrE,GAChDxD,EAAQqD,YAAcorE,EAAkBjrE,EAAQD,EAAWhU,EAAMqV,E,CAEzE,GACA0pE,GAGGtuE,CACX,C,sHC5IA,WACA,WACA,WACA,WACA,WAkGA,SAAS+uE,EACL5wE,EACAkD,EACA9E,EACAoyE,G,MAEMrvE,EAAUnB,EAAShM,OAAOkP,EAAO,GAAG,GAE1C,GAAgB,QAAZ,EAAA/B,EAAQpQ,YAAI,eAAEoN,OAAOq8D,YAIrB,UAFOr5D,EAAQH,WAEXwvE,EAIAA,EAAoBn8E,KAAK8M,OACtB,CAGH,IAAI0vE,OAAW,EAEf,OAAQzyE,GACJ,IAAK,UACDyyE,EACI3tE,EAAQ,GAAwC,mBAAnClD,EAASkD,EAAQ,GAAG/C,YAC3B+C,EAAQ,EACRA,EACV,MAEJ,IAAK,WACD2tE,EACI3tE,EAAQlD,EAASzV,QAAyC,mBAA/ByV,EAASkD,GAAO/C,YACrC+C,EAAQ,EACRA,EACV,MAEJ,QACI2tE,EAAc3tE,EAGtBlD,EAAShM,OAAO68E,EAAa,EAAG1vE,E,CAG5C,CA5HA,yBACI2vE,EACAC,EACAlvE,EACAzD,EACAoyE,GAEM,oBAAsC,IAAAxrE,eACxC8rE,EACAC,GACH,GAHM3rE,EAAS,KAAE4rE,EAAe,KAAE9tE,EAAK,KAIlClD,EAAWoF,EAAUpF,SACrBixE,GAAqB,IAAA5oB,uBAAsBjjD,EAAUjH,OAAOqtB,YAC5D4wC,EAAyB,WAAbh+D,EACZ8yE,EAA0B,YAAb9yE,EAMnB,OAJK6yE,GA8GT,SACI7rE,EACApF,EACAmQ,GAIA,I,MAFIjN,EAAQiN,EAAe,EAEY,oBAAjB,QAAf,EAAAnQ,EAASkD,UAAM,eAAE/C,cACpB+C,IAGJ,IAAM/B,EAAUnB,EAASkD,GAErB/B,IACA,IAAAynE,wBAAuBxjE,EAAWjE,EAE1C,CA7HQgwE,CAAyB/rE,EAAWpF,EAAUkD,GAG1C8tE,aAAe,EAAfA,EAAiB7wE,aACrB,IAAK,KACL,IAAK,QACL,IAAK,kBAED,OADAywE,EAAc5wE,EAAUkD,EAAO9E,EAAWoyE,IACnC,EAEX,IAAK,SACD,IAAM37D,EAAgDm8D,EAAgBhwE,WAChE,YACAo7D,EACA,kBACA8U,EACA,qBACA/4E,EASN,YARkBA,IAAd0c,IACA+7D,EAAc5wE,EAAUkD,EAAO9E,EAAWoyE,GAC1C3uE,SAAAA,EAAS86B,gBAAgBtoC,KAAK,CAC1B8wB,OAAQ6rD,EACRn8D,UAAS,MAIV,EAEX,IAAK,OACD,GAAmC,GAA/Bm8D,EAAgBzwE,KAAKhW,QAAeymF,EAAgBhwE,WACpDgwE,EAAgBzwE,KAAO,GACvBqwE,EAAc5wE,EAAUkD,EAAO9E,EAAWoyE,QACvC,GAAIpyE,EAAW,CAClB,IAAImC,EAAOywE,EAAgBzwE,KAE3BA,GAAO,IAAA6wE,kBAAiB7wE,EAAM67D,GAEzB6U,IACD1wE,GAAO,IAAAuoE,eAAcvoE,EAAM67D,IAG/B4U,EAAgBzwE,KAAOA,EAEX,IAARA,GACAqwE,EAAc5wE,EAAUkD,EAAO9E,EAAWoyE,E,CAIlD,OAAO,EAEX,IAAK,UACD,QAAIQ,EAAgBhwE,aAChB4vE,EAAc5wE,EAAUkD,EAAO9E,EAAWoyE,IACnC,GAKf,QACI,OAAO,EAEnB,C,wHCpGA,WACA,WACA,WAgBA,2BACInmF,EACAgnF,EACAd,QADA,IAAAc,IAAAA,EAAA,IAGA,IAAMxvE,GAAU,IAAAyvE,yBAAwBjnF,EAAOkmF,GACzCgB,EAAQF,EAAgBpxE,QAC1B,SAAClU,GAA4D,QAAEA,CAAF,IAMjE,OAHA,IAAAs9E,cAAakI,EAAO1vE,GAOxB,SAAmCA,G,QAE3BqD,EAKArD,EAAO,YAJPuJ,EAIAvJ,EAAO,aAHPmf,EAGAnf,EAAO,cAFP8uE,EAEA9uE,EAAO,iBADP2uE,EACA3uE,EAAO,oBAEX,GACIqD,GACgB,cAAhBkG,GACgB,mBAAhBA,GACA4V,GACAA,GAAiB9b,EAAYE,WAC7BurE,GAAoBzrE,EAAYuB,aAClC,CACE,IAAM+qE,GAAuB,IAAAvzE,aAAY+iB,GACnCywD,GAA4B,IAAAxzE,aAAYiH,EAAYE,WAEtDorE,IACA,EAAAgB,EAAqBxxE,UAASzO,QAAO,4CAAIi/E,IAAmB,KAGhE,EAAAiB,EAA0BzxE,UAAS3L,KAAI,4CAAIm9E,EAAqBxxE,WAAQ,IACxEwxE,EAAqBxxE,SAAW,E,CAExC,CAhCI0xE,CAA0B7vE,GACnBA,CACX,C,yHC7BA,4BAAiCtB,EAAc67D,GAK3C,IAHA,IAAMjnE,GAAQ,EAAH,iCAAOoL,IAAI,GAClBoxE,EAAe,EAGXjlF,EAAI0vE,EAAY,EAAIjnE,EAAM5K,OAAS,EACnCqnF,EAAiD,aACrDllF,GAAK,GAAKA,EAAIyI,EAAM5K,QAAyB,QAAfqnF,EAC9BllF,GAAK0vE,EAAY,GAAK,EAEtB,OAAQjnE,EAAMzI,IACV,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACDklF,EAAc,aACdD,IACA,MAEJ,QACuB,cAAfC,GACAA,EAAc,UACdD,KACsB,WAAfC,IACPA,EAAc,QAQ9B,OAFAz8E,EAAMnB,OAAOooE,EAAY,EAAIjnE,EAAM5K,OAASonF,EAAcA,GAEnDx8E,EAAM/F,KAAK,GACtB,C,yHCvBA,6CACIgC,EACAygF,EACAC,EACAC,QADA,IAAAD,IAAAA,EAAA,IAGA,IAAK,IAAIplF,EAAI,EAAGA,EAAI0E,EAAK7G,OAAQmC,IAAK,CAClC,IAAMwb,EAAQ9W,EAAK1E,GAEnB,GACKmlF,EAA6B59E,QAAQiU,EAAM3J,iBAAmB,KAC7DwzE,GAAiBA,EAAc7pE,IAEjC,OAAOxb,EACJ,GAAIolF,EAAU79E,QAAQiU,EAAM3J,iBAAmB,EAKlD,OAAQ,C,CAIhB,OAAQ,CACZ,C,oHCtCA,eACA,WACA,WAQA,sCAA2CmE,EAAuBsvE,GAC9D,IAAM9iF,EAAkB,MAAZwT,EAAmB,EAAAykD,oBAAsB,EAAAC,sBAE/C32D,GADO,IAAAse,eAAc7f,GACPiY,MAAK,SAAApe,GAAO,OAAAmG,EAAInG,IAAQipF,CAAZ,IAChC,OAAIvhF,GACwB,iBAAVA,EAAqBnB,SAASmB,GAEzCA,CACX,C,4GCPA,gCACI0Q,EACA8wE,G,MAEM9zE,EAAuB,QAAd,EAAAgD,EAAQhD,cAAM,QAAI,CAAC,EAC5B+zE,EAAwC,CAC1C7/D,WAAYlU,EAAOkU,WACnBC,SAAUnU,EAAOmU,SACjB7K,UAAWtJ,EAAOsJ,UAClBwW,gBAAiB9f,EAAO8f,gBACxBomC,cAAelmD,EAAOkmD,cACtBvqC,WAAY3b,EAAO2b,WACnBJ,WAAYu4D,EAAe9zE,EAAOub,gBAAavhB,EAC/C0nB,OAAQoyD,EAAe9zE,EAAO0hB,YAAS1nB,EACvC0X,UAAWoiE,EAAe9zE,EAAO0R,eAAY1X,GAGjD,OAAOg6E,EAAsBD,EACjC,EAEA,IAAMC,EAAwB,SAACh0E,GAC3B,IAAM+zE,EAAqE,CAAC,EAQ5E,OAPA1nF,OAAOsF,KAAKqO,GAAQ8B,QAAO,SAAAlX,GACvB,IAAM2B,EAAQyT,EAAOpV,QAEPoP,IAAVzN,IACAwnF,EAAWnpF,GAAO2B,EAE1B,IACOwnF,CACX,C,mHCzCA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WAmBME,EAAc,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAC7CC,GAAsB,IAAAtjE,eAAc,EAAAgmB,oBAoF1C,SAASu9C,EACLC,EACA96D,EACA+6D,EACA3wE,EACAq5B,GAEQ,IAAA91B,EAAsBmtE,EAAc,UAAzBltE,EAAWktE,EAAc,OACtChD,EAAeiD,EACfptE,EACAqtE,EAAeF,EAAgB96D,EAAQtZ,QACvCu0E,EAAenD,EAAavvE,SAAS/L,QAAQoR,GAQnD,GAN2B,SAAvB61B,aAAM,EAANA,EAAQ7c,cAAyBm0D,IACjCjD,EAAavvE,SAASjQ,SAAQ,SAAAoR,GAC1BA,EAAQhD,QAAS,EAAH,8BAASoxE,EAAahsE,eAAiB,CAAC,GAAOpC,EAAQhD,OACzE,WACOoxE,EAAahsE,eAEpBmvE,GAAgB,EAChB,IAAK,IAAIhmF,EAAI,EAAGA,EAAI+qB,EAAQzX,SAASzV,OAAQmC,IAAK,CAC9C,IAAMyU,EAAUsW,EAAQzX,SAAStT,GAEjC6iF,EAAavvE,SAAShM,OAAO0+E,EAAehmF,EAAG,EAAGyU,GAE9CU,IAC2B,UAAvBV,EAAQhB,aACR0B,EAAQ6Z,YAAYrnB,KAAK8M,GAGF,SAAvBA,EAAQhB,aACR0B,EAAQk7B,UAAU1oC,KAAK8M,G,CAMvC,GAAIsW,EAAQjU,YACR+rE,EAAa/rE,WAAY,EAAH,eAAQiU,EAAQjU,WAClC4uE,EAAYn+E,QAAQs7E,EAAa/rE,UAAUO,UAAY,GAAG,CAC1D,IAAM4uE,GAAkD,IAAA5jE,eACpDwgE,EAAa/rE,UAAUrF,QAErB,GAA4D,IAAA4Q,eAC9DwgE,EAAahsE,eAAiB,CAAC,GAGnCovE,EAAW5iF,SAAQ,SAAAhH,G,MACX,EAAqBkL,QAAQlL,IAAQ,IACJ,QAA1B,EAAAwmF,EAAahsE,qBAAa,gBAAGxa,GAE5C,G,CAOJwmF,EAAapxE,OAHZq0E,GAGqB,EAAH,8BACZjD,EAAapxE,QACbsZ,EAAQtZ,QAJOsZ,EAAQtZ,MAOtC,CAEA,SAASy0E,EACLL,EACAM,EACAp1C,G,QAEQh3B,EAAyB8rE,EAAc,aAAzBltE,EAAWktE,EAAc,OAE/C,GAAI9rE,GAAwC,GAAxBg3B,EAAOj/B,OAAOjU,QAAekzC,EAAOj/B,OAAO,IAAMq0E,EAAU,CAI3E,IAHQ,IAAOC,EAAsCrsE,EAAY,MAAnCI,EAAuBJ,EAAY,SAAzBK,EAAaL,EAAY,SAC3DtB,GAAQ,IAAAlH,aAAY60E,GAEjBpmF,EAAI,EAAGA,EAAImmF,EAAS1zE,KAAK5U,OAAQmC,IACtC,IAAK,IAAIiqB,EAAI,EAAGA,EAAIk8D,EAAS1zE,KAAKzS,GAAG2S,MAAM9U,OAAQosB,IAAK,CACpD,IAAMC,EAAUi8D,EAAS1zE,KAAKzS,GAAG2S,MAAMsX,GAEvC,GAAS,GAALjqB,GAAUma,EAAW8P,GAAKxR,EAAMhG,KAAK,GAAGE,MAAM9U,OAC9C,IAAK,IAAIqB,EAAI,EAAGA,EAAIuZ,EAAMhG,KAAK5U,OAAQqB,IAAK,CACxC,IAAMmnF,EAAwB,QAAb,EAAA5tE,EAAMhG,KAAKvT,UAAE,eAAEyT,MAAMwH,EAAW8P,EAAI,GACrDxR,EAAMhG,KAAKvT,GAAGyT,MAAMwH,EAAW8P,IAAK,IAAAQ,kBAChC,GACA,EACA47D,aAAQ,EAARA,EAAU9rE,SACV8rE,aAAQ,EAARA,EAAU50E,O,CAKtB,GAAS,GAALwY,GAAU7P,EAAWpa,GAAKyY,EAAMhG,KAAK5U,OASrC,IARK4a,EAAMhG,KAAK2H,EAAWpa,KACvByY,EAAMhG,KAAK2H,EAAWpa,GAAK,CACvB2S,MAAO,GACPlB,OAAQ,CAAC,EACT6Z,OAAQ,IAIPpsB,EAAI,EAAGA,EAAIuZ,EAAMhG,KAAK2H,GAAUzH,MAAM9U,OAAQqB,IAAK,CACxD,IAAMonF,EAAwC,QAA5B,EAAA7tE,EAAMhG,KAAK2H,EAAWpa,EAAI,UAAE,eAAE2S,MAAMzT,GACtDuZ,EAAMhG,KAAK2H,EAAWpa,GAAG2S,MAAMzT,IAAK,IAAAurB,kBAChC,GACA,GACA,EACA67D,aAAS,EAATA,EAAW70E,O,CAKvB,IAAM80E,EAAU9tE,EAAMhG,KAAK2H,EAAWpa,GAAG2S,MAAMwH,EAAW8P,GAG1D,GAFAxR,EAAMhG,KAAK2H,EAAWpa,GAAG2S,MAAMwH,EAAW8P,GAAKC,EAEtC,GAALlqB,GAAe,GAALiqB,EAAQ,CAClB,IAAMu8D,GAAY,IAAArnE,uBAAsBxG,EAAOlH,QACzCsZ,GAAU,IAAA7C,YAAWgC,EAASs8D,GAEhCX,EAAenhF,KAAK,IAAM6hF,IAE1BV,EAAenhF,KAAK,GAAKwlB,EACzB27D,EAAeltE,OAAS6tE,EACxBX,EAAentE,UAAYqS,E,GAM3C,IAAAmN,gBAAezf,EAAOotE,EAAeltE,OAAOlH,SAC5C,IAAA0B,kBAAiBsF,OAAOhN,GAAyB,E,MAEjDg7E,EAAYZ,EAAgBM,EAEpC,CAEA,SAASO,EAAUb,EAA6Bc,GAC5CZ,EAAeF,EAAgBc,EAAQl1E,QAE/B,IAAA/M,EAAoBmhF,EAAc,KAA5BntE,EAAcmtE,EAAc,UAEpCvhC,GAAgB,IAAAnrC,mCAAkCzU,EAAM,CAAC,YAAa,CAAC,cACvE6P,EAAW7P,EAAK4/C,GAChB4hB,EAAaxhE,EAAK4/C,EAAgB,GAClChrC,EAAa4sD,EAAWp0D,OAAOvK,QAAQgN,GAAYmE,GAErDY,GAAc,IACd,IAAA/H,aAAY20D,GAAYp0D,OAAOxK,OAAOgS,EAAY,EAAGqtE,GAGrDpyE,IACAA,SAAAA,EAAUF,OAAOhR,SAAQ,SAACgH,EAAOrK,GAC7B2mF,EAAQtyE,OAAOrU,IAAK,EAAH,eAAQqK,EAC7B,IAER,CAEA,SAAS07E,EAAeF,EAA6Be,GACzC,IAAAluE,EAA4BmtE,EAAc,UAA/BltE,EAAiBktE,EAAc,OAAvBnhF,EAASmhF,EAAc,KAC5CG,EAAettE,EAAUpF,SAAS/L,QAAQoR,GAC1C4wC,EAAY7kD,EAAK,GAAGoN,OAAOvK,QAAQmR,GACnCmqE,GAAoD,IAAAjsE,kBACtD,GAAoB,gCACf8B,EAAUjH,QAAWm1E,GAC1BluE,EAAU7B,eAGVmvE,GAAgB,IAChBnD,EAAavvE,SAAWoF,EAAUpF,SAAShM,OAAO0+E,IAGlDz8B,GAAa,IACb,IAAAh4C,aAAY7M,EAAK,IAAIoN,OAAOxK,OAAOiiD,EAAY,EAAG,EAAGs5B,GAGzD,IAAMv+B,GAAgB,IAAAnrC,mCAClBzU,EACA,CAAC,YACD,CAAC,kBAAmB,cAElB6P,EAAW7P,EAAK4/C,GAEtB,GAAI/vC,EAAU,CACV,IAAM2xD,EAAa5hB,GAAiB,EAAI5/C,EAAK4/C,EAAgB,GAAK,KAC5DhrC,EAAa4sD,EAAaA,EAAWp0D,OAAOvK,QAAQgN,IAAa,EAEvE,GAAI+E,GAAc,GAAK4sD,EAAY,CAC/B,IAAM3gD,GAAc,IAAAC,gBAAejR,EAASF,OAAQE,EAAS2F,aAAazI,QAEtE83C,GAAa,IACbhkC,EAAYzT,OAASyC,EAASzC,OAAOxK,OAAOiiD,EAAY,IAGxDjwC,GAAc,IACd,IAAA/H,aAAY20D,GAAYp0D,OAAOxK,OAAOgS,EAAa,EAAG,EAAGiM,GAG7D7gB,EAAK4/C,GAAiB/+B,C,EAM9B,OAFAsgE,EAAentE,UAAYmqE,EAEpBA,CACX,CAEA,SAAS4D,EAAYZ,EAA6Bv0E,GACtC,IAAA5M,EAASmhF,EAAc,KAEzB96D,EAAUg7D,EAAeF,EADW,cAApBv0E,EAAMK,UAA4B,CAAC,EAAIL,EAAMG,QAE7D6H,EAAa5U,EAAK,GAAGoN,OAAOvK,QAAQwjB,GAEtCzR,GAAc,IACd,IAAA/H,aAAY7M,EAAK,IAAIoN,OAAOxK,OAAOgS,EAAY,EAAGhI,EAE1D,CAEA,SAASm8C,EACLjyC,EACA/J,EACAo1E,GAEArrE,EAAM1J,OAAOzO,SAAQ,SAAAiO,G,MAGjB,OAmDR,SAA0Bu1E,EAAkCv1E,GACxB,4BAA5Bu1E,GAA0Dv1E,EAAMG,OAAO8f,wBAChE,IAAAhgB,aAAYD,GAAOG,OAAO8f,eAEzC,CAzDQu1D,CAAiBD,EAA0Bv1E,GAEnCA,EAAMK,WACV,IAAK,aAC2B,YAAxBL,EAAMO,kBACN,IAAAN,aAAYD,GAAO4I,aAAazI,OAASs1E,EACrCF,EACAp1E,EACAH,EAAM4I,aAAazI,SAG3Bg8C,EAAmBn8C,EAAOG,EAAQo1E,GAClC,MAEJ,IAAK,QACDv1E,EAAMmB,KAAKpP,SAAQ,SAAAqP,GACf,OAAAA,EAAIC,MAAMtP,SAAQ,SAAAuP,GACd66C,EAAmB76C,EAAMnB,EAAQo1E,EACrC,GAFA,IAIJ,MAEJ,IAAK,YACD,IAAM,GAAiC,QAAf,EAAAv1E,EAAMwF,iBAAS,eAAErF,SAAU,CAAC,EAC9CiH,GAAY,IAAAnH,aAAYD,GAE9BoH,EAAUpF,SAASjQ,SAAQ,SAAAoR,GACI,WAAvBA,EAAQhB,aACRg6C,EAAmBh5C,EAAShD,EAAQo1E,GAGxCpyE,EAAQhD,OAASs1E,EAAmBF,EAA0Bp1E,GAAQ,EAAF,8BAC7D,GACAgD,EAAQhD,SAGXgD,EAAQpQ,OACRoQ,EAAQpQ,KAAKoN,OAwCrC,SACIo1E,EACA/J,EACAC,GAEA,OAAQ8J,GACJ,IAAK,WACL,IAAK,eACD,OAAO,EAAP,8BAAYG,EAA6BlK,IAAkBC,GAC/D,IAAK,2BACD,OAAO,EAAP,4DAGOkK,EAA8BlK,IAG9BiK,EAA6BlK,IAE7BoK,EAAkBnK,IA6DrC,SAA+BA,GAC3B,IAAMh5E,EAAsC,CAAC,EAK7C,OAJIg5E,EAAahiE,YACbhX,EAAOgX,UAAYgiE,EAAahiE,WAG7BhX,CACX,CAjEmBojF,CAAsBpK,IAEjC,IAAK,eACD,OAAO,EAAP,8BAAYA,GAAiBiK,EAA6BlK,IAEtE,CAlE8CsK,CAClBP,EACAp1E,EACAgD,EAAQpQ,KAAKoN,QAGzB,IAEiC,6BAA7Bo1E,UACOnuE,EAAU5B,UAIjC,GACJ,CAYA,SAASkwE,EACLlK,GAEA,IAAM/4E,EAAsC,CAAC,EAQ7C,OAPI+4E,EAAavrD,kBACbxtB,EAAOwtB,gBAAkBurD,EAAavrD,iBAEtCurD,EAAa35D,YACbpf,EAAOof,UAAY25D,EAAa35D,WAG7Bpf,CACX,CA8BA,SAASgjF,EACLF,EACA/J,EACAC,GAEA,OAAQ8J,GACJ,IAAK,WACL,IAAK,eACD,OAAO,EAAP,8BAAY/J,GAAiBC,GACjC,IAAK,eACD,OAAO,EAAP,8BAAYA,GAAiBD,GACjC,IAAK,2BACD,OAAO,EAAP,6CACOmK,EAA8BlK,IAC9BD,GACAoK,EAAkBnK,IAGrC,CAEA,SAASmK,EAAkBrwE,GACvB,IAAM9S,EAAoC,CAAC,EAEnCipB,EAAkCnW,EAAa,WAAnCsc,EAAsBtc,EAAa,OAA3BsM,EAActM,EAAa,UAYvD,OAVImW,GAA4B,UAAdA,IACdjpB,EAAOipB,WAAaA,GAEpBmG,IACApvB,EAAOovB,OAASA,GAEhBhQ,IACApf,EAAOof,UAAYA,GAGhBpf,CACX,CAMA,SAASkjF,EACLlK,GAEA,IAAMsK,GAAe,EAAH,eACXtK,GAGP,OADA4I,EAAoBtiF,SAAQ,SAAAhH,GAAO,cAAOgrF,EAAahrF,EAApB,IAC5BgrF,CACX,CAlcA,sBACIxvE,EACAk5B,EACA57B,EACA0Y,G,MAEMmK,EACqB,QAAvB,EAAAnK,aAAO,EAAPA,EAASmK,sBAAc,SAAI,IAAArZ,iBAAgB9G,EAAQ,GAAI1C,GAASqD,YAE9D,EAA8DqV,GAAW,CAAC,EAAxEua,EAA8B,iCAAEzW,EAAW,cAAEwW,EAAU,aAE/D,GAAIC,IAAmCD,EAAY,CACzC,MAAwBnQ,GAAkB,CAAC,EAAzCtf,EAAS,YAAEC,EAAM,SACnBoS,GAAU,IAAAnU,kBAAgB,EAAwB8B,aAAS,EAATA,EAAWjH,OAAQkH,aAAM,EAANA,EAAQlH,SACnF,IAAAsM,UAASgzB,EAAQhmB,E,CAGrB,GAAIiN,EAAgB,CACZrG,GAA8B,QAAfA,GAMf87B,EAAmB1c,GALJ,gCACPl5B,EAAOpG,QAAU,CAAC,GACnBumB,EAAerf,OAAOlH,QAGSkgB,GAG1C,IAAK,IAAI3xB,EAAI,EAAGA,EAAI+wC,EAAOj/B,OAAOjU,OAAQmC,IAAK,CAC3C,IAAMsR,EAAQy/B,EAAOj/B,OAAO9R,GAE5B,OAAQsR,EAAMK,WACV,IAAK,YACDi0E,EAAe5tD,EAAgB1mB,EAAY,GAALtR,EAAQmV,EAAS0Y,GACvD,MAEJ,IAAK,UACD44D,EAAYzuD,EAAgB1mB,GAC5B,MAEJ,IAAK,SACDm1E,EAAYzuD,EAAgB1mB,GAC5B6D,SAAAA,EAAS6Z,YAAYrnB,KAAK2J,GAC1B,MAEJ,IAAK,QAC2B,GAAxBy/B,EAAOj/B,OAAOjU,QAAesqC,EAC7B+9C,EAAYluD,EAAgB1mB,EAAOy/B,GAEnC01C,EAAYzuD,EAAgB1mB,GAEhC,MAEJ,IAAK,aACD,OAAQA,EAAMO,gBACV,IAAK,UACL,IAAK,kBACD40E,EAAYzuD,EAAgB1mB,GAC5B,MACJ,IAAK,WACDo1E,EAAU1uD,EAAgB1mB,I,EAUlD,OAFA,IAAAmF,uBAAsBoB,GAEfmgB,CACX,C,sLCnHA,WACA,WACA,WACA,WACA,WAmIA,SAASsvD,EACLC,EACAC,G,MAEyBA,EAAW11E,OAAO2F,OACvC,SAAAnG,GAAS,MAAmB,aAAnBA,EAAMK,YAYO,IAF1B2B,GADsBA,EAT0ChC,EAAMgC,UAUlDC,QAAO,SAAA1U,GAAK,MAAiB,mBAAjBA,EAAE4U,WAAF,KAEhB5V,QAAmC,GAAnByV,EAASzV,QAA0C,MAA3ByV,EAAS,GAAGG,aAHxE,IAA0BH,CATT,OAIT,OAAA/B,aAAYg2E,GAAYz1E,QAAOnK,KAAI,4CAAI6/E,EAAW11E,SAAM,KACxD,IAAAP,aAAYi2E,GAAY11E,OAAS,GAEzC,CApIa,EAAAqmB,6BAAuC,GAIvC,EAAAskD,8BAAwC,GAarD,0BACI2J,EACAtrE,G,MAEMrC,GAAQ,IAAAlH,aAAY60E,GAIpB30E,EAASgH,EAAMhH,OAEhBA,EAAO8nE,aAAgB9nE,EAAOgoE,aAAgBhoE,EAAOmkE,oBACtDnkE,EAAOyJ,gBAAiB,EACxBzJ,EAAO+I,cAAe,GAM1B/B,EAAMhG,KAAKpP,SAAQ,SAACqP,EAAK0H,GACrB1H,EAAIC,MAAMtP,SAAQ,SAACm+E,EAAcrnE,GAC7B,IAAMvH,GAAO,IAAArB,aAAYiwE,GAEzB,GAA0B,GAAtB5uE,EAAKd,OAAOjU,OAAa,CACzB,IAAM,EAAS+U,EAAKnB,OAAOsJ,WACrB,EAAD,8BACQD,GAAoB,CACvBC,UAAWnI,EAAKnB,OAAOsJ,YAE3BD,GACN,IAAAiD,UACInL,GACA,IAAAgE,sBAAgBnL,OAA0BA,EAA2B,KAEzE,IAAAyc,YAAWtV,GAAM,IAAAsM,UAAS,G,CAGd,GAAZ9E,EACAxH,EAAK4W,WAAY,EACVpP,EAAW,GAAKD,EAAW,GAAKvH,EAAK2H,WAC5C3H,EAAK2H,UAAW,GAGJ,GAAZJ,IACAvH,EAAK8W,UAAW,GAGpB9W,EAAKnB,OAAO+I,cAAe,CAC/B,IAGI9H,EAAI4Y,OAAS,EAAAmxD,gCACb/pE,EAAI4Y,OAAS,EAAAmxD,8BAErB,IAMA,IAFA,I,WAEStiE,GACL1B,EAAMhG,KAAKpP,SAAQ,SAAAqP,GACf,IAAME,EAAOF,EAAIC,MAAMwH,GACjBksE,EAAW3zE,EAAIC,MAAMwH,EAAW,GAClCvH,GAAQyzE,GAAYzzE,EAAK8W,UACzB49D,EAAcjB,EAAUzzE,EAEhC,IAEI6F,EAAMhG,KAAKgF,OAAM,SAAA/E,GAAG,MAAI,OAAmB,QAAnB,EAAAA,EAAIC,MAAMwH,UAAS,eAAEuP,QAAQ,MACrDjR,EAAMhG,KAAKpP,SAAQ,SAAAqP,GAAO,OAAAA,EAAIC,MAAMrL,OAAO6S,EAAU,EAA3B,IAGY,iBAA3B1B,EAAMkS,OAAOxQ,IACkB,iBAA/B1B,EAAMkS,OAAOxQ,EAAW,GAE/B1B,EAAMkS,OAAOrjB,OACT6S,EAAW,EACX,EACA1B,EAAMkS,OAAOxQ,EAAW,GAAK1B,EAAMkS,OAAOxQ,IAG9C1B,EAAMkS,OAAOrjB,OAAO6S,EAAU,G,EAtBjCA,IAFqB,QAAb,EAAA1B,EAAMhG,KAAK,UAAE,eAAEE,MAAM9U,SAAU,GAEjB,EAAGsc,EAAW,EAAGA,I,EAAvCA,GA2BT,I,eAASC,GACL,IAAM1H,EAAM+F,EAAMhG,KAAK2H,GAEvB1H,EAAIC,MAAMtP,SAAQ,SAACuP,EAAMuH,G,MACfmsE,EAAoC,QAAxB,EAAA7tE,EAAMhG,KAAK2H,EAAW,UAAE,eAAEzH,MAAMwH,GAC9CmsE,GAAa1zE,EAAK4W,WAClB89D,EAAchB,EAAW1zE,EAEjC,IAEIF,EAAIC,MAAM8E,OAAM,SAAA7E,GAAQ,OAAAA,EAAK4W,SAAL,MACxB/Q,EAAMhG,KAAK2H,EAAW,GAAGkR,QAAU5Y,EAAI4Y,OACvC7S,EAAMhG,KAAKnL,OAAO8S,EAAU,G,EAZ3BA,EAAW3B,EAAMhG,KAAK5U,OAAS,EAAGuc,EAAW,EAAGA,I,EAAhDA,EAeb,C,iICrIA,WACA,WACA,UACA,WACA,WACA,UACA,WAmRA,SAASqtE,EACLh2E,EACApV,EACA2Y,EACA0yE,EACAl4D,EACAm4D,GAEA,QAHA,IAAAn4D,IAAAA,EAAA,eACA,IAAAm4D,IAAAA,EAAA,SAA2E5nF,GAAO,OAAAA,CAAA,GAE9E2nF,OACiBj8E,IAAbuJ,IACAvD,EAAOpV,GAAO2Y,QAEf,GAAI2yE,EAAQ3yE,KAAc2yE,EAAQl2E,EAAOpV,IAC5C,OAAQmzB,GACJ,IAAK,gBACM/d,EAAOpV,GACd,MACJ,IAAK,YACD,MACJ,IAAK,iBAC0B,iBAAhBoV,EAAOpV,GACboV,EAAOpV,GAAkB,kBAEnBoV,EAAOpV,GAKlC,CAnRA,oCACIsB,EACA8xB,EACAm4D,EACAp4D,EACAkJ,EACA6+B,EACA9B,GAEA,IAAIoyB,EACAvvD,OANJ,IAAA9I,IAAAA,EAAA,UAOA,IAAIk4D,GAAU,EACVI,GAAe,EACfC,GAAiB,EACjB75B,OAAyDziD,EAEvDu8E,GAAc,EAAH,eAAQrqF,EAAM8T,eAExBu2E,EAAY70D,cACZ60D,EAAY7kE,iBACZ6kE,EAAYh7D,YAEnB,IAAAlT,mBACInc,GACA,SAAC+G,EAAMqV,EAAczI,EAAOgC,GAsFxB,GA4EZ,SACIvP,EACAW,EACAgjF,EACAl4D,G,aAAA,IAAAA,IAAAA,EAAA,UAEA,IAAM80B,GAAgB,IAAAnrC,mCAAkCzU,EAAM,CAAC,YAAa,IACtE2U,GAAiB,IAAAF,mCAAkCzU,EAAM,CAAC,mBAAoB,IAEpF,GAAI4/C,GAAiB,EAAG,CACpB,IAAM/vC,EAAW7P,EAAK4/C,GAChBtuC,EAAuD,QAA5C,EAAAzB,aAAQ,EAARA,EAAUF,OAAOE,EAASF,OAAOxW,OAAS,UAAE,eAAEmY,SAE/DyxE,EAAW1jF,EAAQ,WAAwB,MAAZiS,EAAkB0xE,EAASl4D,GAC1Di4D,EAAW1jF,EAAQ,cAA2B,MAAZiS,EAAkB0xE,EAASl4D,E,CAGjEi4D,EACI1jF,EACA,eACAsV,GAAkB,GAC4D,eAAb,QAA7D,EAAC3U,EAAK2U,UAAuD,eAAEhC,SACnEqwE,EACAl4D,EAER,CAzLYy4D,CAAwBL,EAAaljF,EAAMgjF,EAASl4D,GAGhDle,IACIgnB,EACAsvD,EAAYM,sBAAuB,EAEnC5vD,EAAahnB,GAIG,cAApBA,aAAK,EAALA,EAAOK,aAqIvB,SACI5N,EACA2U,EACAgvE,EACAl4D,G,WAAA,IAAAA,IAAAA,EAAA,UAEA,IAAM1C,EAAelqB,WAA6B,QAAnB,EAAA8V,EAAU5B,iBAAS,eAAEO,UAAW,IAAIjV,UAAU,IACvE+lF,EAAoBr7D,GAAgB,GAAKA,GAAgB,EAAIA,OAAerhB,EAElFg8E,EAAW1jF,EAAQ,eAAgB2U,EAAUjH,OAAOgU,aAAciiE,EAASl4D,GAC3Ei4D,EAAW1jF,EAAQ,YAAa2U,EAAUjH,OAAOiU,UAAWgiE,EAASl4D,GACrEi4D,EAAW1jF,EAAQ,eAAgBokF,EAAmBT,EAASl4D,GAC/Di4D,EAAW1jF,EAAQ,YAAa2U,EAAUjH,OAAOM,UAAW21E,EAASl4D,GACrEi4D,EAAW1jF,EAAQ,YAAa2U,EAAUjH,OAAOC,UAAWg2E,EAASl4D,EACzE,CAjJgB44D,CAAwBR,EAAat2E,EAAOo2E,EAASl4D,GAGrDlc,SAAAA,EAAUjQ,SAAQ,SAAAoR,G,YAuPJhD,EAtPV,GAAIs2E,GAAyC,mBAAvBtzE,EAAQhB,YAAkC,CAC5D,IAAI40E,EAAgBvqF,OAAO0gB,OACvB,CAAC,EACDlN,EAAMG,OACS,QAAf,EAAAH,EAAMwF,iBAAS,eAAErF,OACjBgD,EAAQhD,OACI,QAAZ,EAAAgD,EAAQuG,YAAI,eAAEvJ,OACF,QAAZ,EAAAgD,EAAQpQ,YAAI,eAAEoN,OACdge,IA8OEhe,EAxOoB42E,GAyO9B1iE,YAAgBlU,EAAOmU,UAAcnU,EAAOsJ,YAxO/BmzC,IACDA,EAC6D,QAAzD,EAAAx1B,aAAS,EAATA,EAAW4+B,mBAAmBC,EAAc9B,UAAa,QACzDuyB,GAGRK,EAAgBvqF,OAAO0gB,OAAO,CAAC,EAAG0vC,EAAiBm6B,IA2E/E,SACItkF,EACA2jF,EACAY,EACA94D,G,aAAA,IAAAA,IAAAA,EAAA,UAEA,IAAM+4D,EAAoE,QAAjD,EAAqC,QAArC,EAAAD,EAAaj1D,gCAAwB,eAAE9wB,MAAM,YAAI,eAAE2C,MAE5EuiF,EAAW1jF,EAAQ,UAAU,IAAA+wB,QAAOwzD,EAAat7D,YAAa06D,EAASl4D,GACvEi4D,EAAW1jF,EAAQ,WAAYukF,EAAan1D,OAAQu0D,EAASl4D,GAC7Di4D,EAAW1jF,EAAQ,cAAeukF,EAAanlE,UAAWukE,EAASl4D,GACnEi4D,EAAW1jF,EAAQ,kBAAmBukF,EAAal1D,cAAes0D,EAASl4D,GAC3Ei4D,EAAW1jF,EAAQ,gBAAqC,SAApBwkF,EAA6Bb,EAASl4D,GAC1Ei4D,EAAW1jF,EAAQ,cAAmC,OAApBwkF,EAA2Bb,EAASl4D,GACtEi4D,EAAW1jF,EAAQ,gBAAiBukF,EAAa3wB,cAAe+vB,EAASl4D,GAEzEi4D,EAAW1jF,EAAQ,WAAYukF,EAAa3iE,WAAY+hE,EAASl4D,GACjEi4D,EACI1jF,EACA,WACAukF,EAAa1iE,SACb8hE,EACAl4D,GACA,SAAAzvB,GAAO,WAAAgV,oBAAmBhV,OAAK0L,EAAW,MAAQ,IAA3C,IAEXg8E,EAAW1jF,EAAQ,kBAAmBukF,EAAa/2D,gBAAiBm2D,EAASl4D,GAC7Ei4D,EAAW1jF,EAAQ,YAAaukF,EAAavtE,UAAW2sE,EAASl4D,GACjEi4D,EAAW1jF,EAAQ,aAAcukF,EAAat7D,WAAY06D,EAASl4D,GACnEi4D,EAAW1jF,EAAQ,aAAcukF,EAAal7D,WAAYs6D,EAASl4D,EACvE,CArGwBg5D,CACIZ,EACAF,EACAW,EACA74D,GAGJi4D,EACIG,EACA,kBACEnzE,aAAO,EAAPA,EAASuG,MACX0sE,EACAl4D,E,CAQRu4D,GAAiB,EAEjBH,EAAYa,UAAYb,EAAYa,aAAeh0E,EAAQpQ,KAC3DujF,EAAYc,mBACRd,EAAYc,oBACZp1E,EAASkB,MAAK,SAAAC,GAAW,MAAuB,SAAvBA,EAAQhB,WAAR,IAE7Bi0E,GAAU,EAEkB,UAAxBjzE,EAAQhB,cACJq0E,GAoI5B,SAA6BzoE,EAAkCtb,GACnD,IAAA0N,EAAW4N,EAAK,OAElBK,GAAkB,IAAAC,qBAAoBlO,EAAgB,WACtDmO,EAAcF,EAAgB5d,MAC9B+d,EAAcH,EAAgBF,MAC9BM,EAAcJ,EAAgBD,MAEpC1b,EAAOohE,YAAc,CACjBvlD,YAAW,EACXC,YAAW,EACXC,YAAW,EACXiS,UAAWtgB,EAAOsgB,UAClBxS,aAAc9N,EAAO8N,cAEzBxb,EAAO4kF,sBAAuB,IAAA53D,kBAAiB1R,EACnD,CAnJ4BupE,CAAoBn0E,EAASmzE,GAC7BE,GAAe,IAEfF,EAAYziB,iBAAc15D,EAC1Bm8E,EAAYe,0BAAuBl9E,GAG/C,IAEAi8E,GAAU,GAGV3tE,EACA,GAAI8tE,EAAmB,CACX,IAAApvE,EAA8BovE,EAAiB,MAAxC1tE,EAAuB0tE,EAAiB,SAA9BztE,EAAaytE,EAAiB,SAInD9tE,EAAatB,OAASA,GACrBsB,EAAaI,UAAYA,GAAYJ,EAAaK,UAAYA,IAE/DwtE,EAAYiB,mBAAoB,EAChCjB,EAAYM,sBAAuB,E,MA6F3D,SACInuE,EACAhW,GAEA,IAAM+kF,GAAc,IAAAtyD,kBAAiBzc,EAAatB,OAElD1U,EAAOglF,WAAY,EACnBhlF,EAAOilF,eAAiBjvE,EAAatB,MAAMhG,KAAK+B,MAAK,SAAA9B,GACjD,OAAAA,EAAIC,MAAM6B,MAAK,SAAA5B,GAAQ,OAAAA,EAAK2H,QAAL,GAAvB,IAGAuuE,IACA/kF,EAAO+kF,YAAcA,EAE7B,CAvGoBG,CAAoBlvE,EAAc6tE,GAClCC,EAAoB9tE,CAGhC,GACA,CACIY,wBAAyB,UAI7BitE,EAAYhiE,WACZgiE,EAAYhiE,SA8IpB,SAAe21D,GACX,GAAIA,EAAI,CACJ,IAAM/kE,EAAQ+kE,EAAGh0E,QAAQ,MACzB,IAAe,IAAXiP,GAAgBA,IAAU+kE,EAAG19E,OAAS,EAGtC,OAAOU,KAAKqD,MAAuB,GAAjBwE,WAAWm1E,GAAW,KAAQ,IAAM,I,CAG9D,OAAOA,CACX,CAxJ+B2N,CAAMtB,EAAYhiE,UAEjD,C,oGC/JA,wBAA6Bi/D,EAA8B1vE,GACvD0vE,EAAMxhF,SAAQ,SAAA+uD,GACNA,GAMZ,SACIj9C,GAEA,QAASA,EAAQqD,WACrB,CAVoB2wE,CAA8Bh0E,IACtCi9C,EAAKj9C,EAEb,GACJ,C,kIClBA,WACA,WACA,WAQMi0E,EAAQ,UACRC,EAAQ,UA4Hd,SAASC,EAAa99E,EAAgBtB,GAClC,IAAMq/E,GAAO,IAAAjP,YAAW9uE,GAClBg+E,GAAO,IAAAlP,YAAWpwE,GAExB,SAAIq/E,IAAQC,IACDD,EAAK,KAAOC,EAAK,IAAMD,EAAK,KAAOC,EAAK,IAAMD,EAAK,KAAOC,EAAK,EAG9E,CA3HA,uCACI52E,EACA9Q,EACA2nF,EACAC,GAEA,GAAI5nF,EAAO,CACP8Q,EAAKnB,OAAO8f,gBAAkBzvB,EAE1B2nF,IACA,IAAA52E,yBAAwBD,GAAM,SAAAE,GAG1B,OAFAA,EAAWA,GAAY,CAAC,GACfwuE,iBAAkB,EACpBxuE,CACX,IAGJ,IAAMzJ,EA8Ed,SAA4BvH,GACxB,IAAM6nF,GAAc,IAAArP,YAAWx4E,GAI/B,GAAI6nF,EAAa,CACb,IAAM1gF,EAAM0gF,EAAY,GAAK,IACvBzgF,EAAQygF,EAAY,GAAK,IACzBxgF,EAAOwgF,EAAY,GAAK,IAG9B,OAAmE,IAA3DprF,KAAKC,IAAIyK,EAAKC,EAAOC,GAAQ5K,KAAKD,IAAI2K,EAAKC,EAAOC,G,CAE1D,OAAO,GAEf,CA7F0BygF,CAAmB9nF,GAEjCuH,EA/BkB,GAgClBuJ,EAAKnB,OAAOsJ,UAAYquE,EACjB//E,EAhCa,GAiCpBuJ,EAAKnB,OAAOsJ,UAAYsuE,SAEjBz2E,EAAKnB,OAAOsJ,UAGnB2uE,GAqCZ,SAA8B92E,EAA2C2e,GACjE3e,EAAKnB,OAAOsJ,WACZnI,EAAKd,OAAOzO,SAAQ,SAAAgO,G,MAChB,GAA+B,aAA3BA,EAAcM,UAA0B,CACxC,IAAML,GAAQ,IAAAC,aAAYF,IAGF,QAAnB,EAAAC,EAAMuF,qBAAa,eAAEkE,aACtBuuE,EAAa/3D,EAAiBjgB,EAAMuF,cAAckE,aAElDzJ,EAAMuF,eAAgB,EAAH,8BACZvF,EAAMuF,eAAa,CACtBkE,UAAWnI,EAAKnB,OAAOsJ,aAG/BzJ,EAAMgC,SAASjQ,SAAQ,SAAAoR,G,OAEA,QAAd,EAAAA,EAAQhD,cAAM,eAAEsJ,aACjBuuE,EAAa/3D,EAAiB9c,EAAQhD,OAAOsJ,aAE7CtG,EAAQhD,QAAS,EAAH,8BACPgD,EAAQhD,QAAM,CACjBsJ,UAAWnI,EAAKnB,OAAOsJ,YAGnC,G,CAER,GAER,CAjEY8uE,CAAqBj3E,EAAM9Q,E,aAGxB8Q,EAAKnB,OAAO8f,uBACZ3e,EAAKnB,OAAOsJ,UACf2uE,GAMZ,SAAiC92E,GAC7BA,EAAKd,OAAOzO,SAAQ,SAAAgO,G,MAChB,GAA+B,aAA3BA,EAAcM,UAA0B,CACxC,IAAML,GAAQ,IAAAC,aAAYF,IAGH,QAAnB,EAAAC,EAAMuF,qBAAa,eAAEkE,aACpBuuE,EAAah4E,EAAMuF,cAAckE,UAAWquE,IACzCE,EAAah4E,EAAMuF,cAAckE,UAAWsuE,YAEzC/3E,EAAMuF,cAAckE,UAE/BzJ,EAAMgC,SAASjQ,SAAQ,SAAAoR,GAEfA,EAAQhD,OAAOsJ,YACduuE,EAAa70E,EAAQhD,OAAOsJ,UAAWquE,IACpCE,EAAa70E,EAAQhD,OAAOsJ,UAAWsuE,YAEpC50E,EAAQhD,OAAOsJ,SAE9B,G,CAER,GACJ,CA5BY+uE,CAAwBl3E,EAGpC,C,8GCzDA,eACA,WAGMm3E,EAA2B,CAC7B,EAAAtqB,kBAAkBC,QAClB,EAAAD,kBAAkBK,WAClB,EAAAL,kBAAkBa,YAEhB0pB,EAA6B,CAC/B,EAAA3rB,eAAeE,KACf,EAAAF,eAAeU,OACf,EAAAV,eAAeI,QAEbwrB,EAAoD,CACtD,cAAe,EAAAxqB,kBAAkBK,WACjC,cAAe,EAAAL,kBAAkBK,WACjC,cAAe,EAAAL,kBAAkBS,WACjC,cAAe,EAAAT,kBAAkBS,WACjC,cAAe,EAAAT,kBAAkBa,WACjC,cAAe,EAAAb,kBAAkBiB,YAE/BwpB,EAAsD,CACxDC,KAAM,EAAA9rB,eAAeE,KACrB6rB,OAAQ,EAAA/rB,eAAeU,OACvBsrB,OAAQ,EAAAhsB,eAAeI,QAgB3B,gCACIzoD,EACAlD,EACAioD,EACAuvB,GAEQ,IAAAC,EAAkEz3E,EAAQ,iBAAxD03E,EAAgD13E,EAAQ,mBAApCqD,EAA4BrD,EAAQ,wBAElF,MAAgB,MAAZkD,EACkC,iBAApBu0E,EACRA,EACAp0E,EACA4zE,EAAyBhvB,EAAQgvB,EAAyBlsF,QAC1DysF,EACAL,EAA0BK,QAC1B7+E,EAE8B,iBAAtB++E,EACRA,EACAr0E,EACA6zE,EAA2BjvB,EAAQivB,EAA2BnsF,QAC9DysF,EACAJ,EAA4BI,QAC5B7+E,CAEd,C,gIClEA,WACA,WAGMg/E,EAAsC,CACxCC,EAAG,IACHC,GAAI,IACJC,EAAG,IACHC,GAAI,IACJC,EAAG,IACHC,GAAI,GACJC,EAAG,GACHC,GAAI,GACJC,EAAG,GACHC,GAAI,EACJC,EAAG,EACHC,GAAI,EACJC,EAAG,GAwCP,SAASC,EAAuBC,EAAiBC,GAC7C,IAAIplF,EAAQ,GAGZ,IAFAmlF,IAEOA,GAAW,GACdnlF,EAAQqlF,OAAOC,aAAcH,EAAU,GA3D3B,IA2DgDnlF,EAC5DmlF,EAAUjtF,KAAK6B,MAAMorF,EAAU,IAAM,EAEzC,OAAOC,EAAcplF,EAAMJ,cAAgBI,CAC/C,CAEA,SAASulF,EAAuBJ,EAAiBC,G,QACzCI,EAAa,G,IAEjB,IAAgB,0BAAAxpE,eAAcooE,IAAY,8BAAE,CAAvC,IAAMzqF,EAAC,QACF8rF,EAAuBvtF,KAAK6B,MAAMorF,EAAUf,EAAYzqF,IAC9DwrF,GAAoBM,EAAuBrB,EAAYzqF,GACvD6rF,GAA0B7rF,EAAE+rF,OAAOD,E,mGAEvC,OAAOL,EAAcI,EAAWnrE,oBAAsBmrE,CAC1D,CAnDA,mCAAwCG,EAAmB5nE,GACvD,OAAQ4nE,GACJ,KAAK,EAAAvsB,kBAAkBK,WACvB,KAAK,EAAAL,kBAAkBQ,eACvB,KAAK,EAAAR,kBAAkBO,4BACvB,KAAK,EAAAP,kBAAkBM,sBACnB,OAAOwrB,EAAuBnnE,GAAY,GAE9C,KAAK,EAAAq7C,kBAAkBS,WACvB,KAAK,EAAAT,kBAAkBY,eACvB,KAAK,EAAAZ,kBAAkBW,4BACvB,KAAK,EAAAX,kBAAkBU,sBACnB,OAAOorB,EAAuBnnE,GAAY,GAE9C,KAAK,EAAAq7C,kBAAkBa,WACvB,KAAK,EAAAb,kBAAkBgB,eACvB,KAAK,EAAAhB,kBAAkBe,4BACvB,KAAK,EAAAf,kBAAkBc,sBACnB,OAAOqrB,EAAuBxnE,GAAY,GAE9C,KAAK,EAAAq7C,kBAAkBiB,WACvB,KAAK,EAAAjB,kBAAkBoB,eACvB,KAAK,EAAApB,kBAAkBmB,4BACvB,KAAK,EAAAnB,kBAAkBkB,sBACnB,OAAOirB,EAAuBxnE,GAAY,GAE9C,QACI,OAAOA,EAAa,GAEhC,C,kNCnCA,kCACI6nE,EACAjuF,EACAkuF,EACAC,EACAC,GAEA,MAAO,CACH9wE,KAAM,SACN2wE,WAAU,EACVjuF,MAAK,EACLmuF,SAAQ,EACRD,SAAQ,EACRE,UAAS,EAEjB,EAUA,mCACIH,EACAjuF,EACAouF,GAEA,MAAO,CACH9wE,KAAM,UACN2wE,WAAU,EACVjuF,MAAK,EACLouF,UAAS,EAEjB,EAUA,kCACIH,EACAjuF,EACAouF,GAEA,MAAO,CACH9wE,KAAM,SACN2wE,WAAU,EACVjuF,MAAK,EACLouF,UAAS,EAEjB,EAUA,iCACIC,EACAJ,EACAK,EACAC,EACAH,GAEA,MAAO,CACH9wE,KAAM,QACN2wE,WAAU,EACVI,QAAO,EACPC,UAAS,EACTC,UAAS,EACTH,UAAS,EAEjB,EAUA,kCACII,EACAP,EACAG,GAEA,MAAO,CACH9wE,KAAM,SACN2wE,WAAU,EACVO,YAAW,EACXJ,UAAS,EAEjB,C,+HC3HA,eACA,WAYMK,GAAmB,IAAAC,yBAAuB,GAC1CC,GAAoB,IAAAC,0BAAwB,GAM5CC,GAAgC,IAAAC,wBAAsD,CACxFC,QAASN,EACTO,SAAUP,EACVQ,YAAaR,EACbS,aAAcT,EACdU,WAAYV,EACZW,cAAeX,EACfY,SAAUZ,EACVz7D,KAAK,IAAAs8D,0BACLC,cAAed,EACfe,aAAcf,EACdgB,kBAAmBd,EACnBe,gBAAiBf,IAOrB,4BAAiCttE,GAC7B,OAAO,IAAAw8D,aAAYx8D,EAAOwtE,EAC9B,EAOA,+BACIxtE,EACAwJ,GAEA,OAAO,IAAA+yD,gBAAev8D,EAAOwJ,EAAUgkE,EAC3C,C,uJCrDA,eACA,WACA,WACA,WAea,EAAAhyB,wBAA+D,IAAAiyB,wBAGxE,CACIvC,kBAAkB,IAAAmC,yBACd,OACAjhF,EACA,EAAAg0D,kBAAkBnB,IAClB,EAAAmB,kBAAkBN,KAEtBqrB,oBAAoB,IAAAkC,yBAChB,OACAjhF,EACA,EAAA4yD,eAAeC,IACf,EAAAD,eAAec,KAEnBhpD,yBAAyB,IAAAy2E,0BAAwB,KAErD,GACA,GAOJ,2BACIe,GAEA,OAAO,IAAA9R,aAAY8R,EAAM,EAAA9yB,uBAC7B,EAOA,8BACI8yB,EACA9kE,GAEA,OAAO,IAAA+yD,gBAAe+R,EAAM9kE,EAAU,EAAAgyC,uBAC1C,C,oIC5DA,eAOM+yB,EAAyB,cAQ/B,SAAgB/R,EACZl+E,EACAkwF,GAEA,IAAMC,EAAiBnwF,EAAMsY,QAAQ23E,GACjC3mF,EAAqB,KAEzB,IACIA,EAAMQ,KAAKukE,MAAM8hB,E,CACnB,SAAM,CAER,OAAQD,IAAc,IAAAE,UAAS9mF,EAAK4mF,GAAe5mF,EAAY,IACnE,CAZA,gBAqBA,0BACItJ,EACAkrB,EACAglE,GAEA,IAAI5mF,EAAM40E,EAAYl+E,EAAOkwF,GAY7B,OAVIhlE,KACA5hB,EAAM4hB,EAAS5hB,IAIH4mF,KAAc,IAAAE,UAAS9mF,EAAK4mF,KACpClwF,EAAMsY,QAAQ23E,GAA0BnmF,KAAKC,UAAUT,WAFhDtJ,EAAMsY,QAAQ23E,IAMtB3mF,CACX,EAMA,uBAA+BtJ,GAC3B,QAASA,EAAMsY,QAAQ23E,EAC3B,C,wIC9DA,eACA,WAOMI,GAAoC,IAAAlB,wBACtC,CACIxL,iBAAiB,IAAAsL,0BAAwB,GACzCxjE,gBAAgB,IAAAwjE,0BAAwB,GACxC75E,gBAAgB,IAAA65E,0BAAwB,KAE5C,GACA,GAOJ,gCACIh6E,GAEA,OAAO,IAAAipE,aAAYjpE,EAAMo7E,EAC7B,EAOA,mCACIp7E,EACAiW,GAEA,OAAO,IAAA+yD,gBAAehpE,EAAMiW,EAAUmlE,EAC1C,C,gICtCA,eACA,UACA,WAYMC,GAAuB,IAAAX,yBACzB,OACA7hF,GACA,GAGEkhF,GAAoB,IAAAC,0BAAwB,GAE5CsB,GAAwB,IAAApB,wBAC1B,CACI1M,eAAgB6N,EAChB5N,kBAAmB4N,EACnB3N,oBAAqB2N,EACrB1N,aAAcoM,EACd9L,eAAgBoN,EAChBzN,eAAgBmM,EAChBjM,iBAAkBiM,EAClBlM,cAAekM,EACfhM,YAAasN,EACbrN,WAAYqN,EACZnN,mBAAmB,IAAA4L,yBACf,OACAjhF,EACA,EAAAq1D,kBAAkBxC,IAClB,EAAAwC,kBAAkB3B,KAEtBh2C,cAAe8kE,IAEnB,GACA,GAOJ,4BAAiCx1E,GAC7B,OAAO,IAAAojE,aAAYpjE,EAAOy1E,EAC9B,EAOA,+BACIz1E,EACAoQ,GAEA,OAAO,IAAA+yD,gBAAenjE,EAAOoQ,EAAUqlE,EAC3C,C,kGChEA,eAUA,oBAAgBH,EAAYh0D,EAAYo0D,GACpC,IAmDoBC,EAAYC,EAnD5BtqF,GAAS,EACb,GAAKoqF,EAAIlC,iBAA+B,IAAVlyD,GAA2Bo0D,EAAI/B,WAAuB,OAAVryD,EACtEh2B,GAAS,MACN,KACDoqF,EAAIlC,iBAA+B,IAAVlyD,IACzBo0D,EAAI/B,WAAuB,OAAVryD,EAEnB,OAAO,EAEP,OAAQo0D,EAAI7yE,MACR,IAAK,SACDvX,EACqB,iBAAVg2B,SACe,IAAdo0D,EAAInwF,OAAyB+7B,IAAUo0D,EAAInwF,OACvD,MAEJ,IAAK,SACD+F,EACqB,iBAAVg2B,SACe,IAAdo0D,EAAInwF,QAgCRowF,EAhCgDD,EAAInwF,MAgCxCqwF,EAhC+Ct0D,EAiCxEx7B,KAAK+vF,IAAIF,EAAKC,GAAM,cAhCc,IAAjBF,EAAIjC,UAA4BnyD,GAASo0D,EAAIjC,iBAC5B,IAAjBiC,EAAIhC,UAA4BpyD,GAASo0D,EAAIhC,UACzD,MAEJ,IAAK,UACDpoF,EACqB,kBAAVg2B,SACe,IAAdo0D,EAAInwF,OAAyB+7B,IAAUo0D,EAAInwF,OACvD,MAEJ,IAAK,QACD+F,EACIJ,MAAMsE,QAAQ8xB,UACY,IAAlBo0D,EAAI7B,WAA6BvyD,EAAMl8B,QAAUswF,EAAI7B,kBACnC,IAAlB6B,EAAI5B,WAA6BxyD,EAAMl8B,QAAUswF,EAAI5B,YAC7DxyD,EAAMtiB,OAAM,SAAApY,GAAK,OAAA0uF,EAAS1uF,EAAG8uF,EAAI9B,QAAhB,IACrB,MAEJ,IAAK,SACDtoF,EACqB,iBAAVg2B,IACP,IAAA1X,eAAc8rE,EAAI3B,aAAa/0E,OAAM,SAAApY,GACjC,OAAA0uF,EAASh0D,EAAM16B,GAAI8uF,EAAI3B,YAAYntF,GAAnC,I,CAMpB,OAAO0E,CACX,C,iQC5DA,WACA,WACA,UACA,WA0EA,SAAgBiT,EACZrZ,EACAq9B,EACAuzD,EACAC,GAMA,IAAMz3E,EAAa03E,EAAkB9wF,EAAO,CACxCgd,wBAAyBqgB,EAAwB,cAAgB,UAE/Dj3B,EAIA,GAuCN,OArCAgT,EAAW1T,SAAQ,SAAC,G,IAAEiQ,EAAQ,WAAEhC,EAAK,QAAE5M,EAAI,OACvC,GAAI4O,EACA,GACI0nB,IACC1pB,GACkB,GAAnBgC,EAASzV,QACiB,YAA1B6G,EAAK,GAAGmN,gBACRyB,EAAS,IAAM5O,EAAK,GAAGwV,aACzB,CACE,IAAMyzE,EAAOjpF,EAAK,GAEd8pF,IACA,IAAAj9E,aAAYo8E,GAGhB5pF,EAAO4D,KAAK,CAACgmF,EAAKzzE,aAAc,KAAMxV,G,KACX,cAApB4M,aAAK,EAALA,EAAOK,aACV68E,IACA,IAAAj9E,aAAYD,GAGhBgC,EAASjQ,SAAQ,SAAAoR,IAET85E,GACuB,UAAvB95E,EAAQhB,aACPgB,EAAQ6mB,aAAaxM,YAEtB/qB,EAAO4D,KAAK,CAAC8M,EAASnD,EAAO5M,GAErC,SAEuB,WAApB4M,aAAK,EAALA,EAAOK,YAAyB48E,GAEvCxqF,EAAO4D,KAAK,CAAC2J,EAAO,KAAoB5M,GAEhD,IAEOX,CACX,CAmIA,SAAgBqN,EACZoK,EACA2pE,EACAC,EACAsJ,EACArJ,GAEA,IAAMthF,EAAyC,GACzC4qF,EAAeD,EAAYvJ,EAAgB3iF,KAAI,SAAA8Y,GAAQ,OAACA,EAAD,IAAU,CAAC6pE,GAClEpuE,EAAa03E,EAAkBjzE,EAAO,CACxCb,wBAAyB,QACzB+oE,8BAA+B,mBAkCnC,OA/BAkL,EAA6B73E,GAE7BA,EAAW1T,SAAQ,SAAC,GAChB,I,IADkBqB,EAAI,OAAE4M,EAAK,Q,WACpBtR,GACL,IAAM6uF,GAAa,IAAA11E,mCACfzU,EACAiqF,EAAa3uF,GACbolF,EACAC,GAGJ,OAAIwJ,GAAc,GACV9qF,EAAOwP,QAAO,SAAAlU,GAAK,OAAAA,EAAEiS,OAAS5M,EAAKmqF,EAAhB,IAA6BhxF,QAAU,GAC1DkG,EAAO4D,KAAK,CACRhD,OAAQD,EAAKmqF,EAAa,GAC1Bv9E,MAAO5M,EAAKmqF,GACZnqF,KAAMA,EAAKb,MAAMgrF,EAAa,K,SAI/B7uF,GAAK2uF,EAAa9wF,OAAS,GAAKyT,GACvCvN,EAAO4D,KAAK,CACRhD,OAAQD,EAAK,GACb4M,MAAOA,EACP5M,KAAI,I,cAJL,C,EAjBF1E,EAAI,EAAGA,EAAI2uF,EAAa9wF,Q,YAAxBmC,GAAgCA,KA0B7C,IAEO+D,CACX,CA2GA,SAAS0qF,EACLjzE,EACAgzB,GAEA,IAAMz3B,EAAsC,GAe5C,OAbA,IAAA+C,mBACI0B,GACA,SAAC9W,EAAMqV,EAAczI,EAAOgC,GACxByD,EAAWpP,KAAK,CACZjD,KAAI,EACJqV,aAAY,EACZzI,MAAK,EACLgC,SAAQ,GAEhB,GACAk7B,GAGGz3B,CACX,CAIA,SAAS63E,EAA6B73E,GAE9BA,EAAWlZ,OAAS,GACpB+c,EAA8B7D,GAAY,IAE1CA,EAAW7R,MAKX6R,EAAWlZ,OAAS,GACpB+c,EAA8B7D,GAAY,IAE1CA,EAAWkU,OAEnB,CAEA,SAASrQ,EACL7D,EACA+3E,G,MAEM3yE,EAAYpF,EAAW+3E,EAAsB,EAAI/3E,EAAWlZ,OAAS,GAE3E,GACkC,cAAf,QAAf,EAAAse,EAAU7K,aAAK,eAAEK,YACjBwK,EAAU7I,UACV6I,EAAU7I,SAASzV,OAAS,EAC9B,CACE,IAAMkxF,EAAc5yE,EAAU7K,MAAMgC,SAC9BmB,EAAU0H,EAAU7I,SAAS,GAEnC,OACiC,GAA7B6I,EAAU7I,SAASzV,QACI,mBAAvB4W,EAAQhB,aACRgB,GAAWs6E,EAAYD,EAAsBC,EAAYlxF,OAAS,EAAI,E,CAG1E,OAAO,CAEf,CApZA,qCA6FA,+BACIF,EACAq9B,EACAwzD,GAWA,OATiBA,EACXx3E,EACIrZ,EACAq9B,GACA,GACA,GAEJhkB,EAAiCrZ,EAAOq9B,IAE9Bx4B,KAAI,SAAAnD,GAAK,OAAAA,EAAE,EAAF,GAC7B,EA4BA,iCACI1B,EACA6wF,GAEA,IAAMz3E,EAAa03E,EAAkB9wF,EAAO,CAAEgd,wBAAyB,UACjE5W,EAA0C,GAUhD,OARA6qF,EAA6B73E,GAE7BA,EAAW1T,SAAQ,SAAC,G,IAAEiO,EAAK,QACC,cAApBA,aAAK,EAALA,EAAOK,YACP5N,EAAO4D,KAAK6mF,GAAS,IAAAj9E,aAAYD,GAASA,EAElD,IAEOvN,CACX,EAoCA,yBAkEA,iCACIpG,GAEA,IACI8a,EADE1B,EAAa03E,EAAkB9wF,EAAO,CAAEgd,wBAAyB,UAEnEq0E,EAA+C,GAqBnD,OAnBAJ,EAA6B73E,GAE7BA,EAAW1T,SAAQ,SAAC,G,IAAEiO,EAAK,QAAEyI,EAAY,eAAErV,EAAI,OAC3C,IAAK+T,EACD,GAAwB,UAApBnH,aAAK,EAALA,EAAOK,WACP8G,EAAQnH,EACR09E,GAAa,EAAH,iCAAOtqF,IAAI,QAClB,GAAIqV,aAAY,EAAZA,EAActB,MAAO,CAC5BA,EAAQsB,EAAatB,MAErB,IAAM,EAAS/T,EAAK6O,QAChB,SAAAiI,GAAS,OAAAA,EAAM1J,OAAOvK,QAAQwS,EAAatB,QAAU,CAA5C,IACX,GACIjC,EAAQ9R,EAAK6C,QAAQ,GAC3BynF,EAAax4E,GAAS,EAAI9R,EAAKb,MAAM2S,GAAS,E,CAG1D,IAEO,CAACiC,EAAOu2E,EACnB,EAoBA,oCACIrxF,GAEA,IAAI4W,EAQJ,OANAnD,EAAqBzT,EAAO,CAAC,YAAa,CAAC,cAAc0F,SAAQ,SAAAlF,IACxDoW,IAAY,IAAAL,oBAAyC/V,EAAEmT,MAAO,cAC/DiD,EAAWpW,EAAEmT,MAErB,IAEOiD,CACX,C,0GCtYA,eAUA,4BACIkE,GAEA,IAAIuQ,GAAY,EACZf,GAAe,EACfgB,GAAW,EACXC,GAAc,EACd+lE,GAAe,EAqBnB,OAnBAx2E,EAAMhG,KAAKpP,SAAQ,SAACqP,EAAK0H,GACrB,OAAA1H,EAAIC,MAAMtP,SAAQ,SAACuP,EAAMuH,IACjB,IAAAoe,0BAAyB3lB,KACzBq8E,GAAe,EAEXjmE,EAAW,IACXA,EAAW5O,GAGX6N,EAAc,IACdA,EAAc9N,GAGlB8O,EAAU1qB,KAAKC,IAAIyqB,EAAS7O,GAC5B8O,EAAa3qB,KAAKC,IAAI0qB,EAAY/O,GAE1C,GAfA,IAkBG80E,EAAe,CAAEjmE,SAAQ,EAAEf,YAAW,EAAEgB,QAAO,EAAEC,WAAU,GAAK,IAC3E,C,6GCvCA,eACA,WAOA,+BAAoC5X,GAChC,OAAQA,EAAMK,WACV,IAAK,YACD,OAAOL,EAAMgC,SAASkB,KAAK,EAAA8nE,uBAE/B,IAAK,QACD,OAAOhrE,EAAMmB,KAAK+B,MAAK,SAAA9B,GAAO,OAAAA,EAAIC,MAAM6B,KAAK,EAAA+jB,yBAAf,IAElC,IAAK,aACD,OAAO,IAAAA,0BAAyBjnB,GAEpC,IAAK,UACL,IAAK,SACD,QAASA,EAAMgD,WAEnB,QACI,OAAO,EAEnB,C,kHC1BA,eAOA,oCAAyCkH,GACrC,QAA4B,aAAxBA,EAAM3J,iBAAiC2J,EAAMlH,eAI7CkH,EAAM1J,OAAO0C,KAAK,EAAA4nB,oBAK1B,C,+GCjBA,eAOA,iCAAsC3nB,GAClC,OACIA,EAAQH,YACgB,WAAvBG,EAAQhB,aAA4BgB,EAAQ3C,OAAO0C,KAAK,EAAA4nB,oBAEjE,C,yHC8BA,SAAS8yD,EACLxqF,EACAmkB,EACA2lB,EACA/1B,EACA02E,GAWA,IATA,IAAMxqF,EAASD,EAAK,GACdiW,GAA0B6zB,aAAM,EAANA,EAAQ7zB,0BAA2B,cAC7D+oE,GAAgCl1C,aAAM,EAANA,EAAQk1C,gCAAiC,UACzEC,GACFn1C,aAAM,EAANA,EAAQm1C,qCAAsC,cAE9CyL,GAAqB,EACrBC,GAAuB,EAElBrvF,EAAI,EAAGA,EAAI2E,EAAOmN,OAAOjU,OAAQmC,IAAK,CAC3C,IAAMsR,EAAQ3M,EAAOmN,OAAO9R,GAE5B,OAAQsR,EAAMK,WACV,IAAK,aACD,IAAM29E,GAAU,EAAH,kBAAIh+E,IAAK,YAAK5M,IAAI,GAE/B,GAA4B,WAAxB4M,EAAMO,eAA6B,CACnC,IACM09E,IADAj7E,EAAa66E,GAAoB79E,EAAMgD,aAGH,QAAtCqvE,GACsC,eAAtCA,EACE6L,EACFl7E,IACuC,QAAtCqvE,GACyC,sBAAtCA,GACuB,GAAvBryE,EAAMQ,OAAOjU,QAErB,GACK0xF,GACGL,EACII,EACAzmE,EACA2lB,EACA/1B,EACAnE,IAEPk7E,GAAwB3mE,EAASnkB,EAAM+T,EAAOnH,GAE/C,OAAO,C,MAER,GACH49E,EAA0BI,EAASzmE,EAAU2lB,EAAQ/1B,EAAO02E,GAE5D,OAAO,EAEX,MAEJ,IAAK,QACD,IAAM18E,EAAOnB,EAAMmB,KACb4H,EAAuB5H,EAAKgF,OAAM,SAAA/E,GACpC,OAAAA,EAAIC,MAAM8E,OAAM,SAAA7E,GAAQ,OAAAA,EAAK0B,UAAL,GAAxB,IAGJ,GAAqC,WAAjCovE,GAA8CrpE,GAC9C,GAAIwO,EAASnkB,EAAM+T,EAAOnH,GACtB,OAAO,OAGX,IAAK,IAAI8I,EAAW,EAAGA,EAAW3H,EAAK5U,OAAQuc,IAG3C,IAFA,IAAM1H,EAAMD,EAAK2H,GAERD,EAAW,EAAGA,EAAWzH,EAAIC,MAAM9U,OAAQsc,IAAY,CAC5D,IAAMvH,EAAOF,EAAIC,MAAMwH,GACvB,GAAKvH,EAAL,CAIA,IAAMuzE,EAA0C,CAC5C1tE,MAAOnH,EACP8I,SAAQ,EACRD,SAAQ,EACRE,qBAAoB,GAGxB,GAAIzH,EAAK0B,YAAcuU,EAASnkB,EAAMyhF,GAClC,OAAO,EAGX,KACKvzE,EAAK0B,YAC2B,wBAAjCovE,IAMIwL,GAJY,EAAH,kBAAIt8E,IAAI,YAAKlO,IAAI,GAMtBmkB,EACA2lB,EACA23C,EAPF7xE,EAAa66E,GAAoBv8E,EAAK0B,YAWxC,OAAO,C,EAO3B,MAEJ,IAAK,YAGD,IAFA,IAAMhB,EAA0C,GAEvC,EAAI,EAAG,EAAIhC,EAAMgC,SAASzV,OAAQ,IAAK,CAC5C,IAAM4W,EAAUnD,EAAMgC,SAAS,GACzBgB,EAAa66E,GAAoB16E,EAAQH,WAE/C,GAA2B,WAAvBG,EAAQhB,YAA0B,CAWlC,GAVM87E,GACDj7E,GACqC,QAAtCqvE,GACsC,eAAtCA,EACE6L,EACFl7E,IACuC,QAAtCqvE,GACyC,sBAAtCA,GACyB,GAAzBlvE,EAAQ3C,OAAOjU,QAGnB0xF,GACAL,GAA0B,EAAD,kBACpBz6E,IAAO,YAAK/P,IAAI,GACjBmkB,EACA2lB,EACA/1B,EACAnE,GAGJ,OAAO,EAGPk7E,GACAl8E,EAAS3L,KAAK8M,E,MAEXH,GACPhB,EAAS3L,KAAK8M,GAGdH,EACA86E,GAAqB,EAErBC,GAAuB,C,CAI/B,GAAI/7E,EAASzV,OAAS,GAAKgrB,EAASnkB,EAAM+T,EAAOnH,EAAOgC,GACpD,OAAO,EAEX,MAEJ,IAAK,UACL,IAAK,SACD,IAAK67E,GAAoB79E,EAAMgD,aAAeuU,EAASnkB,EAAM+T,EAAOnH,GAChE,OAAO,E,CAOvB,QAC+B,SAA3BqJ,GACyB,YAAzBhW,EAAOkN,iBACPu9E,GACEC,GAAmD,cAA3B10E,IAE1BkO,EAASnkB,EAAM+T,OAAOhN,EAAqB,CAAC9G,EAAOuV,eAM3D,CA/LA,6BACIsB,EACAqN,EACA2lB,GAEA0gD,EAA0B,CAAC1zE,GAAQqN,EAA+C2lB,EACtF,C,qGCxCA,eACA,WA2BA,SAASihD,EACLj0E,EACAse,EACArF,EACAC,GAEA,OAAOg7D,EAAgB51D,EAAete,EAAOiZ,EAAOC,GAAK,SAAAoF,IACjD,IAAAkiD,kBAAiBxgE,IAAUm0E,EAAmBn0E,EAAOse,IACrD81D,GAAc,IAAAr+E,aAAYiK,GAAQse,GAGtC,IAUItjB,EAVEq5E,EAA2B,GAYjC,GAVAr0E,EAAM1J,OAAOzO,SAAQ,SAACiO,EAAOtR,GACzB85B,EAuBZ,SACIxoB,EACAwoB,EACArF,EACAC,GAEA,OAAQpjB,EAAMK,WACV,IAAK,aACD,OAAO89E,EAAyBn+E,EAAOwoB,EAAerF,EAAOC,GAEjE,IAAK,QACD,OA4DZ,SACIjc,EACAqhB,EACArF,EACAC,GAEA,IAAMtO,EAAQ0pE,EAASr3E,EAAOgc,GACxBnR,EAAOoR,EAAMo7D,EAASr3E,EAAOic,GAAOtO,EAE1C,GAAK0T,EAkBDrhB,EAAMhG,KAAKpP,SAAQ,SAAAqP,GACf,OAAAA,EAAIC,MAAMtP,SAAQ,SAAAuP,GACd,IAAMm9E,EAAiBj2D,EAEvBA,EAAgB21D,EAAyB78E,EAAMknB,EAAerF,EAAOC,GAEjEq7D,GAAkBj2D,KAClB,IAAAvoB,aAAYqB,GAAM0B,YAAa,EAEvC,GARA,SAlBJ,IAAK,IAAI5B,EAAM,EAAGA,EAAM+F,EAAMhG,KAAK5U,OAAQ6U,IAEvC,IADA,IAAM4kC,EAAa7+B,EAAMhG,KAAKC,GACrBqX,EAAM,EAAGA,EAAMutB,EAAW3kC,MAAM9U,OAAQksB,IAAO,CACpD,IAAMimE,EAAcv3E,EAAMhG,KAAKC,GAAKC,MAAMoX,GACpCzV,EACF5B,GAAO0T,EAAM1T,KAAOA,GAAO4Q,EAAK5Q,KAAOqX,GAAO3D,EAAM2D,KAAOA,GAAOzG,EAAKyG,IAEvE4lE,EAAmBK,EAAa17E,IAChCs7E,GAAc,IAAAr+E,aAAYy+E,GAAc17E,GAGvCA,GACDm7E,EAAyBO,GAAa,EAAyBv7D,EAAOC,E,CAkBtF,OAAOoF,CACX,CArGmBm2D,CAAoB3+E,EAAOwoB,EAAerF,EAAOC,GAE5D,IAAK,UACL,IAAK,SACD,OAAOg7D,EAAgB51D,EAAexoB,EAAOmjB,EAAOC,GAAK,SAAAoF,GACrD,GAAI61D,EAAmBr+E,EAAOwoB,GAAgB,CAC1C,IAAM3U,GAAe,IAAA5T,aAAYD,GAE7BwoB,EACA3U,EAAa7Q,YAAa,SAEnB6Q,EAAa7Q,U,CAI5B,OAAOwlB,CACX,IAEJ,IAAK,YACD,IAAM,EAA6B,GAsBnC,GApBAxoB,EAAMgC,SAASjQ,SAAQ,SAACoR,EAASzU,GAC7B85B,EAAgB41D,EACZ51D,EACArlB,EACAggB,EACAC,GACA,SAAAoF,GACI,OAyFxB,SACIphB,EACAjE,EACAqlB,EACAo2D,EACAz7D,EACAC,EACA10B,GAEA,OAAQyU,EAAQhB,aACZ,IAAK,kBAOD,QANKqmB,GAAkBrlB,GAAWggB,GAAShgB,GAAWigB,IAIlDw7D,EAAiBvoF,KAAK3H,GAEnB85B,EAEX,IAAK,UAGD,OAFAq2D,EAA8Bz3E,EAAWjE,EAASqlB,GAE3CrlB,GAAWggB,GAAShgB,GAAWigB,EAChC+6D,EAAyBh7E,EAASqlB,EAAerF,EAAOC,GACxDoF,EAEV,IAAK,QACD,IAAM,EAA6BrF,GAAShgB,KAAaigB,GAAOA,GAAOjgB,GAWvE,OATA07E,EACIz3E,EACAjE,EACAqlB,GACCrlB,EAAQ4wD,6BAA+B,EAClC,SAAAhmD,GAAS,OAACA,EAAMgmD,2BAA6B,CAApC,OACT55D,GAGHquB,EACX,QAEI,OADAq2D,EAA8Bz3E,EAAWjE,EAASqlB,GAC3CA,EAEnB,CApI+Bs2D,CACH9+E,EACAmD,EACAqlB,EACA,EACArF,EACAC,EACA10B,EAER,GAER,IAEI,EAAiBnC,OAAS,EAK1B,IAJA,IAAMwgF,GAAc,IAAA9sE,aAAYD,GAE5BkF,OAAK,OAEmC/K,KAApC+K,EAAQ,EAAiBtR,QACzBsR,GAAS,GACT6nE,EAAY/qE,SAAShM,OAAOkP,EAAO,GAK/C,OAAOsjB,EAEX,QACI,OAAOA,EAEnB,CA5F4Bu2D,CAAoB/+E,EAAOwoB,EAAerF,EAAOC,GAE1C,aAAnBpjB,EAAMK,WAAqD,GAAzBL,EAAMgC,SAASzV,QAAeyT,EAAMwyB,YACtE+rD,EAAeloF,KAAK3H,EAE5B,IAII6vF,EAAehyF,OAAS,EAGxB,IAFA,IAAMyyF,GAAe,IAAA/+E,aAAYiK,QAES/P,KAAlC+K,EAAQq5E,EAAe3qF,QACvBsR,GAAS,GACT85E,EAAax+E,OAAOxK,OAAOkP,EAAO,GAK9C,OAAOsjB,CACX,GACJ,CAoHA,SAASg2D,EACLr3E,EACA7F,GAEA,IAAImX,GAAO,EAOX,MAAO,CAAErX,IANGE,EACN6F,EAAMhG,KAAK+T,WACP,SAAA9T,GAAO,OAACqX,EAAOrX,EAAIC,MAA4CpL,QAAQqL,KAAU,CAA1E,KAEV,EAEOmX,IAAG,EACrB,CA+CA,SAASomE,EACLz3E,EACAjE,EACAqlB,EACAy2D,IAEIA,GAAkBZ,EAAmBl7E,EAASqlB,MAC9C,IAAAxhB,eAAcI,EAAWjE,GAAS,SAAA6pE,GAC9BsR,EAActR,EAAgBxkD,GAC9By2D,SAAAA,EAAiBjS,EACrB,GAER,CAEA,SAASqR,EAAmBjwC,EAAgCprC,GACxD,OAAQorC,EAAWprC,aAAeA,CACtC,CAEA,SAASs7E,EAAclwC,EAAsC1hD,GAOzD,OANIA,EACA0hD,EAAWprC,YAAa,SAEjBorC,EAAWprC,WAGftW,CACX,CAEA,SAAS0xF,EACL51D,EACAn8B,EACA82B,EACAC,EACA7L,GAIA,OADAiR,EAAgBjR,EADhBiR,EAAgBA,GAAiBn8B,GAAS82B,OAEhBC,GAAO/2B,GAAS+2B,CAC9C,CAhQA,wBACIlZ,EACAiZ,EACAC,GAEA+6D,EAAyBj0E,GAAO,EAAyBiZ,GAAS,KAAMC,GAAO,KACnF,C,0GCEA,8BAGIqF,EAOAze,GAIA,OAAOlH,MAF4B2lB,OAExB,EAFwBA,EAEtBloB,iBAAkByJ,CACnC,C,wGCVA,4BACIE,GAEA,MAC4B,WAAxBA,EAAM3J,gBAC6C,WAAtB2J,EAAO/H,WAE5C,C,2GCxCA,eACA,SAsEA,SAAS+8E,EACLl7D,G,cAEIvxB,EAqBJ,GAnBIuxB,EAAIhkB,QACCgkB,EAAI7gB,SAEE,IAAA8H,cAAa+Y,EAAI7gB,QAAS,aACjC1Q,EAAS,CACLqV,UAAWkc,EAAI7gB,QACf8S,OAAmD,QAA3C,EAAU,QAAV,EAAA+N,EAAI/N,cAAM,QAAyB,QAArB,EAAA+N,EAAI7gB,QAAQ2lB,iBAAS,eAAEv8B,cAAM,QAAI,GAEpDy3B,EAAI7gB,QAAQ+H,aACnBzY,EAAS,CACLqV,UAAWkc,EAAI7gB,QAAQ+H,WACvB+K,QACI,IAAAqV,SAAQtH,EAAI7gB,QAAQ+H,WAAWkwB,YAAgCnlC,QAC3D+tB,EAAI7gB,SACJ,IAZZ1Q,EAAS,CAAEqV,UAAWkc,EAAIhkB,MAAOiW,OAAQ,IAiB7CxjB,IAAU,IAAAwY,cAAaxY,EAAOqV,UAAW,0BAA2B,CACpE,IAAMszB,EAAa3oC,EAAOqV,UAAUszB,WAEpC,GAAIA,EAAW7uC,OAASkG,EAAOwjB,OAC3BxjB,EAAS,CAAEqV,UAAWszB,EAAW3oC,EAAOwjB,QAASA,OAAQ,QACtD,GAAIxjB,EAAOqV,UAAUkmC,UAAW,CACnC,IAAMlmC,EAAYrV,EAAOqV,UAAUkmC,UACnCv7C,EAAS,CACLqV,UAAS,EACTmO,QAAQ,IAAAhL,cAAanD,EAAW,aACC,QAA3B,EAAmB,QAAnB,EAAAA,EAAUghB,iBAAS,eAAEv8B,cAAM,QAAI,EAC/Bub,EAAUszB,WAAW7uC,O,MAG/BkG,OAAS0H,C,CAIjB,OAAO1H,CACX,CA/FA,6BACIytB,EACApV,EACAze,EACAwX,GAEAA,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAKpV,EAAMze,EAAOwX,GAE3D,IAAMyhB,EAWV,SAA+BpF,EAAerc,GAEtC,IAKAu7E,EACAC,EANA,EAGAx7E,EAAO,iBAHasf,EAAK,QAAEC,EAAG,MAC9Bi7B,EAEAx6C,EAAO,eADPy7E,EACAz7E,EAAO,eAKX,GAAIy7E,EACA,OAAOA,EACJ,IACFF,EAAgBj8D,GAAS+7D,EAAa/7D,MACtCk8D,EAAcj8D,GAAO87D,EAAa97D,IACrC,CACE,IAAMkC,EAAQpF,EAAI6R,cAKlB,OAHAzM,EAAMwV,SAASskD,EAAct3E,UAAWs3E,EAAcnpE,QACtDqP,EAAMyV,OAAOskD,EAAYv3E,UAAWu3E,EAAYppE,QAEzC,CACHjM,KAAM,QACNsb,MAAK,EACLI,YAAY,E,CAEb,OAAI24B,GAGA,IAEf,CA1CkBkhC,CAAsBr/D,EAAKrc,GAQzC,OANIxX,EAAM4gD,2BAA4C,UAAf3nB,aAAK,EAALA,EAAOtb,QAC1Csb,EAAMI,YAAa,GAGvB5a,EAAK4uC,YAEEp0B,CACX,C,mNCpCA,WACA,WACA,WACA,UAmCA,SAAgBme,EACZysB,EACA5lD,GAEA,OAAO9d,OAAO0gB,OACV,CAAC,EACD5C,EASG,CACHk1E,iBAAkB,CACd7rF,QAAS,CACLqM,MAAO,KACPmD,QAAS,QAOd,CACHumD,WAAY,CACRC,iBAAkB,GAClBj/C,UAAW,IAEfq2D,eAAgB,CAAC,GAKd,CACHp9B,iBAAkB,CACd4Z,mBAAoB,GACpBC,qBAAsB,KA7B1B0S,EAER,CAoCA,SAAgBvH,EACZpsC,GAEA,MAAO,CACHgyD,cAAe/hF,OAAO0gB,OAAM,MAAb1gB,QAAM,oBACjB,CAAC,EACD,EAAAizF,8BAA2B,YACxBljE,EAAQrrB,KAAI,SAAAnD,GAAK,OAAAA,aAAC,EAADA,EAAG2xF,oBAAH,MAAwB,IAEhD1lB,eAAgB2lB,EACZpjE,EAAQrrB,KAAI,SAAAnD,GAAK,OAAAA,aAAC,EAADA,EAAG6xF,qBAAH,IACjBrjE,EAAQrrB,KAAI,SAAAnD,GAAK,OAAAA,aAAC,EAADA,EAAG8xF,wBAAH,KAErBC,qBAAsB,EAAAL,4BACtBtZ,sBAAqB,wBACrB7d,iBAAkB97D,OAAO0gB,OAAM,MAAb1gB,QAAM,oBAAQ,CAAC,IAAC,YAAK+vB,EAAQrrB,KAAI,SAAAnD,GAAK,OAAAA,aAAC,EAADA,EAAGu6D,gBAAH,MAAoB,IAC5EyC,6BAA8Bv+D,OAAO0gB,OAAM,MAAb1gB,QAAM,oBAChC,CAAC,EACD,EAAAu+D,+BAA4B,YACzBxuC,EAAQrrB,KAAI,SAAAnD,GAAK,OAAAA,aAAC,EAADA,EAAGgyF,iCAAH,MAAqC,IAGrE,CAMA,SAAgBJ,EACZpvB,EACAyvB,QADA,IAAAzvB,IAAAA,EAAA,SACA,IAAAyvB,IAAAA,EAAA,IAEA,IAAMvvB,EAAoBjkE,OAAO0gB,OAAM,MAAb1gB,QAAM,oBAAQ,CAAC,IAAC,YAAK+jE,IAAS,IAElD99D,GAAS,IAAAse,eAAc,EAAA2/C,8BAA8BruD,QACvD,SAAC5P,EAAQ1H,G,MACC2B,GAAQ,IAAAgkE,6BAA6B3lE,GACtCmG,KACG,SAAAy/D,GACI,YAAkCx2D,IAAjCs2D,EAAkBE,GACb,EAAAwV,sBAAsBxV,GACtBF,EAAkBE,EAFxB,KAIP15D,OAAM,4CACA+oF,EAAwB9uF,KACvB,SAAA+uF,GAAQ,MAAI,OAAgB,QAAf,EAAAA,aAAQ,EAARA,EAAWl1F,UAAI,QAAI,EAA2B,MAC9D,IAKT,OAFA0H,EAAO1H,GAAO2B,EAEP+F,CACX,GACA,CACI8P,KAAM,KAUd,OANAy9E,EAAwBjuF,SAAQ,SAAAkuF,IACxBA,aAAQ,EAARA,EAAU19E,QACV9P,EAAO8P,KAAO9P,EAAO8P,KAAKtL,OAAOgpF,EAAS19E,MAElD,IAEO9P,CACX,CA7HA,mCACI6X,G,IACA,wDAEA,OAAOm5B,EAAkCklB,EAAuBpsC,GAAUjS,EAC9E,EAOA,sCAgDA,2BA4BA,uB,qHClHA,eACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WAMa,EAAAm1E,4BAAsD,CAC/Dz/E,MAAO,EAAAkgF,YACPf,mBAAoB,EAAAgB,yBACpBpnE,GAAI,EAAAqnE,SACJloC,YAAa,EAAAmoC,kBACbroC,cAAe,EAAAsoC,oBACfC,aAAc,EAAAC,mBACdC,eAAgB,EAAAC,qBAChB/sB,QAAS,EAAAgtB,cACT5yE,MAAO,EAAA6yE,YACPvE,KAAM,EAAAwE,WACN59E,SAAU,EAAA69E,eACV15E,UAAW,EAAA25E,gBACX/tB,gBAAiB,EAAAguB,sBACjB79E,QAAS,EAAA89E,cACTC,iBAAkB,EAAAC,uBAClBh6E,MAAO,EAAAi6E,YACP7+E,KAAM,EAAA8+E,W,mGC5BG,EAAAnB,YAA2D,SACpEhgE,EACA7sB,EACA2M,EACA6D,EACAk+B,GAEA,IAAMu/C,EAAWz9E,EAAQ0qE,cAEzB,OAAQvuE,EAAMK,WACV,IAAK,QACD0hC,EAAUu/C,EAASn6E,MAAM+Y,EAAK7sB,EAAQ2M,EAAO6D,EAASk+B,GACtD,MACJ,IAAK,YACDA,EAAUu/C,EAASl6E,UAAU8Y,EAAK7sB,EAAQ2M,EAAO6D,EAASk+B,GAC1D,MACJ,IAAK,SACDA,EAAUu/C,EAASppC,YAAYh4B,EAAK7sB,EAAQ2M,EAAO6D,EAASk+B,GAC5D,MACJ,IAAK,UACDA,EAAUu/C,EAAS3tB,QAAQzzC,EAAK7sB,EAAQ2M,EAAO6D,EAASk+B,GACxD,MACJ,IAAK,aACD,OAAQ/hC,EAAMO,gBACV,IAAK,UACDwhC,EAAUu/C,EAASf,aAAargE,EAAK7sB,EAAQ2M,EAAO6D,EAASk+B,GAC7D,MAEJ,IAAK,kBACDA,EAAUu/C,EAAStuB,gBAAgB9yC,EAAK7sB,EAAQ2M,EAAO6D,EAASk+B,GAChE,MAEJ,IAAK,WACDA,EAAUu/C,EAASr+E,SAASid,EAAK7sB,EAAQ2M,EAAO6D,EAASk+B,IAOzE,OAAOA,CACX,C,kHClDA,eAuDA,SAASw/C,EAAiB72E,EAAsC7G,G,QAC5D,GAAIA,EAAQi6B,oBAAsBpzB,EAAUne,OAAS,EAEjD,IAAK,IAAImC,EAAIgc,EAAUne,OAAS,EAAGmC,EAAI,EAAGA,IAAK,CAC3C,IAAMqF,EAA+B,QAAxB,EAAe,QAAf,EAAA2W,EAAU9W,aAAK,eAAEmuC,eAAO,QAAI,MAEzC,IAAAy/C,kBAAiBztF,EAAM8P,EAAQ8/B,iB,CAG3C,CArDa,EAAAw8C,yBAAwE,SACjFjgE,EACA7sB,EACA6W,EACArG,GAEQ,IAAA6lD,EAAe7lD,EAAO,WACxB6G,EAAYg/C,EAAWh/C,UACzBq3B,EAAuB1uC,EAAOoY,WAElC,IACIvB,EAAM1J,OAAOzO,SAAQ,SAAC0vF,EAAYv8E,G,MAMjB,GAATA,GACwB,cAAxBu8E,EAAWphF,WACkB,YAA7BohF,EAAWlhF,iBAEXghF,EAAiB73B,EAAWh/C,UAAW7G,GAEnC6lD,EAAWh/C,UAAUne,OAAS,IAC9Bm9D,EAAWh/C,UAAY,KAI/Bq3B,EAAUl+B,EAAQ0qE,cAAcvuE,MAAMkgB,EAAK7sB,EAAQouF,EAAY59E,EAASk+B,GAE5C,UAAxB0/C,EAAWphF,YACO,QAAlB,EAAAwD,EAAQ4jB,kBAAU,SAAE4kB,cAAco1C,EAAYv3E,GAEtD,IAEAq3E,EAAiB73B,EAAWh/C,UAAW7G,IAGvC,IAAA29E,kBAAiBz/C,EAASl+B,EAAQ8/B,iB,SAElC+lB,EAAWh/C,UAAYA,C,CAE/B,C,kGCrDA,eAMa,EAAA01E,SAAuD,SAChElgE,EACA7sB,EACA8P,EACAU,EACA69E,GAEA,IAAM3oE,EAAKmH,EAAIrD,cAAc,MACvBsN,EAAUjK,EAAIrD,cAAc,QAClCsN,EAAQpN,YAAYhE,GACpB1lB,EAAO0pB,YAAYoN,IAEnB,IAAAw3D,qBAAoBzhE,EAAKnH,EAAIoR,EAAShnB,EAASU,EAAS69E,EAC5D,C,uGCnBA,eACA,WAUa,EAAAf,cAA+D,SACxEzgE,EACA7sB,EACAsgE,EACA9vD,EACAk+B,G,MAEI5X,EAAUtmB,EAAQ2jB,kBAAoBmsC,EAAQ+B,mBAAgBv7D,EAuBlE,OArBIgwB,IAAYwpC,EAAQ3wD,WACpB++B,GAAU,IAAAM,oBAAmBhvC,EAAQ82B,EAAS4X,EAASl+B,EAAQ8/B,mBAE/DxZ,EAAUjK,EAAIrD,cAAc82C,EAAQ5tD,SAEhClC,EAAQ2jB,oBACRmsC,EAAQ+B,cAAgBvrC,GAG5B92B,EAAOgnC,aAAalQ,EAAS4X,GAC7Bl+B,EAAQ8/B,iBAAiB4Z,mBAAmBlnD,KAAK8zB,IAEjD,IAAA4vC,aAAY5vC,EAAStmB,EAAQm2D,eAAerG,QAASA,EAAQxzD,OAAQ0D,GAEjE8vD,EAAQ1X,MACR9xB,EAAQgC,aAAa,OAAQwnC,EAAQ1X,OAIxB,QAArB,EAAAp4C,EAAQ4d,qBAAa,cAArB5d,EAAwB8vD,EAASxpC,GAE1B4X,CACX,C,gJC1CA,WACA,WACA,WACA,WACA,WASM6/C,EAAuB,2BAmF7B,SAASC,EACLh+E,G,MAEA,OAAO,EAAP,8BAC4B,QAArB,EAAAA,EAAQsa,qBAAa,eAAEhe,QACvB0D,EAAQwjB,cAEnB,CArFa,EAAAg5D,kBAAkE,SAC3EngE,EACA7sB,EACAuZ,EACA/I,EACAk+B,G,QAEQ/X,EAA0Bpd,EAAW,aAAvBnC,EAAYmC,EAAW,SAE7C,IAAAmtD,aAAYtvD,EAAS5G,EAAQm2D,eAAe7yC,OAAQ6C,EAAcnmB,GAElE,IAAMi+E,EACFj+E,EAAQ0jB,uBACiB,gBAAzB9c,EAAQ0D,MAAM2O,SACS,QAAvBrS,EAAQ0D,MAAMD,MACZ6zE,EAAmC,QAArB,EAAAt3E,EAAQonB,qBAAa,eAAEonB,UAAUjuC,SAAS42E,GACxDI,EAAiBD,GAAeD,EAAuBr3E,EAAQonB,cAAiBpnB,EActF,OAZAs3B,GAAU,IAAAM,oBAAmBhvC,EAAQ2uF,EAAgBjgD,EAASl+B,EAAQ8/B,kBAElEm+C,IACKC,IACe,IAAAlnF,MAAKqlB,EAAKzV,EAAS,OAC3BwuC,UAAUrJ,IAAIgyC,IAE1B,IAAAtnC,eAAcp6B,EAAKzV,EAASo3E,EAAiBh+E,GAAUA,IAGtC,QAArB,EAAAA,EAAQ4d,qBAAa,cAArB5d,EAAwB+I,EAAanC,GAE9Bs3B,CACX,EAKa,EAAAu+C,oBAAsE,SAC/EpgE,EACA7sB,EACAuZ,EACA/I,EACAyf,G,MAEQ0G,EAAkCpd,EAAW,aAA/BnC,EAAoBmC,EAAW,QAAtBzM,EAAWyM,EAAW,OAKrD,GAHAvZ,EAAO0pB,YAAYtS,GACnB6Y,SAAAA,EAAajtB,KAAKoU,IAEd,IAAAsG,eAAc5Q,GAAQ5T,OAAS,EAAG,CAClC,IAAM69D,GAAO,IAAAvvD,MAAKqlB,EAAKzV,EAAS,SAEhC,IAAAsvD,aAAY3P,EAAMvmD,EAAQm2D,eAAe72D,QAAShD,EAAQ0D,E,CAK9D,IAFA,IAAAk2D,aAAYtvD,EAAS5G,EAAQm2D,eAAe7yC,OAAQ6C,EAAcnmB,GAE9DA,EAAQ0jB,uBAAyByC,EAAaxM,WAAY,CACpD,oBAAkB,IAAA88B,eAAcp6B,EAAKzV,EAASo3E,EAAiBh+E,GAAUA,GAAQ,GAAhF69C,EAAK,KAAEugC,EAAM,KAEhB3+D,IACAA,EAAYjtB,KAAKqrD,EAAOugC,GAEpBvgC,EAAMj2C,YACN6X,EAAYjtB,KAAKqrD,EAAMj2C,YAGvBw2E,EAAOx2E,YACP6X,EAAYjtB,KAAK4rF,EAAOx2E,aAIhC5H,EAAQ27E,iBAAiB7rF,QAAQwP,QAAUu+C,C,MAE3C79C,EAAQ27E,iBAAiB7rF,QAAQwP,QAAUsH,EAG1B,QAArB,EAAA5G,EAAQ4d,qBAAa,cAArB5d,EAAwB+I,EAAanC,EACzC,C,+GC/FA,eACA,WACA,WACA,WASMy3E,EAAsE,CACxE7tE,WAAY,YACZmZ,WAAY,OAMH,EAAAwzD,sBAA+E,SACxF9gE,EACA7sB,EACAyU,EACAjE,EACAk+B,G,MAEI5X,EAAUtmB,EAAQ2jB,kBAAoB1f,EAAU4tD,mBAAgBv7D,EAEpE,GAAIgwB,EACA4X,GAAU,IAAAM,oBAAmBhvC,EAAQ82B,EAAS4X,EAASl+B,EAAQ8/B,kBAE/D9/B,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAKiK,EAASriB,EAAWjE,QAC/D,KAAK,IAAAsoE,mBAAkBrkE,GAAY,CACtC,IAAM,EAAgBoY,EAAIrD,cAAc/U,EAAU/B,SAE9ClC,EAAQ2jB,oBACR1f,EAAU4tD,cAAgB,GAG9BriE,EAAOgnC,aAAa,EAAe0H,GACnCl+B,EAAQ8/B,iBAAiB4Z,mBAAmBlnD,KAAK,IAEjD,IAAAi8D,aAAYzuD,EAASiE,EAAU/B,SAAS,YACpC,IAAAg0D,aAAY,EAAel2D,EAAQm2D,eAAelyD,UAAWA,EAAU3H,OAAQ0D,IAC/E,IAAAk2D,aACI,EACAl2D,EAAQm2D,eAAe1rC,eACvBxmB,EAAU3H,OACV0D,IAGJ,IAAAk2D,aAAY,EAAel2D,EAAQm2D,eAAelyD,UAAWA,EAAU3H,OAAQ0D,EACnF,IAEyB,OAArBiE,EAAU/B,SACV,IAAAusD,aAAYzuD,EAASq+E,GAAgB,WACjCr+E,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAK,EAAepY,EAAWjE,EAC5E,IAEAA,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAK,EAAepY,EAAWjE,GAG5EsmB,EAAU,C,CAOd,OAJIA,IACqB,QAArB,EAAAtmB,EAAQ4d,qBAAa,cAArB5d,EAAwBiE,EAAWqiB,IAGhC4X,CACX,C,mICvEA,eACA,WACA,WACA,WACA,WAWa,EAAAy+C,mBAAyE,SAClFtgE,EACA7sB,EACA6W,EACArG,EACAk+B,G,MAEIhuC,EAAoBmW,EAAMigB,QAiB9B,OAfI4X,GAAWhuC,EAAKmX,YAAc7X,EAC9B0uC,GAAU,IAAAM,oBAAmBhvC,EAAQU,EAAMguC,EAASl+B,EAAQ8/B,mBAE5D5vC,EAAOA,EAAKu8B,YACZpmB,EAAMigB,QAAUp2B,GAEhB,IAAAgmE,aAAYhmE,EAAM8P,EAAQm2D,eAAe1G,QAASppD,EAAM/J,OAAQ0D,GAEhExQ,EAAOgnC,aAAatmC,EAAMguC,GAC1Bl+B,EAAQ8/B,iBAAiB4Z,mBAAmBlnD,KAAKtC,IAGhC,QAArB,EAAA8P,EAAQ4d,qBAAa,cAArB5d,EAAwBqG,EAAOnW,GAC/B8P,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAKnsB,EAAMmW,EAAOrG,GAEpDk+B,CACX,EAKa,EAAA2+C,qBAA+E,SACxFxgE,EACA7sB,EACA6W,EACArG,EACA69E,G,MAEM3tF,EAAOmW,EAAMigB,QAAQmG,YAI3B,GAHApmB,EAAMigB,QAAUp2B,EAChBV,EAAO0pB,YAAYhpB,IAEf,IAAAkX,cAAalX,EAAM,gBAAiB,CACpC,IAAMo2B,GAAU,IAAAtvB,MAAKqlB,EAAKnsB,EAAM,SAEhC,IAAA4tF,qBAAoBzhE,EAAKnsB,EAAMo2B,EAASjgB,EAAOrG,EAAS69E,IACxD,IAAA3nB,aAAYhmE,EAAM8P,EAAQm2D,eAAe1G,QAASppD,EAAM/J,OAAQ0D,GAE3C,QAArB,EAAAA,EAAQ4d,qBAAa,cAArB5d,EAAwBqG,EAAOnW,E,CAGnC8P,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAKnsB,EAAMmW,EAAOrG,EAC/D,C,qGClEA,eACA,WACA,WAMa,EAAA+8E,YAA6D,SACtE1gE,EACA7sB,EACA8uF,EACAt+E,EACA69E,GAEA,IAAMltD,EAAMtU,EAAIrD,cAAc,OACxBsN,EAAUjK,EAAIrD,cAAc,QAElCxpB,EAAO0pB,YAAYoN,GACnBA,EAAQpN,YAAYyX,GAEpBA,EAAI9U,IAAMyiE,EAAWziE,IAEjByiE,EAAWviE,MACX4U,EAAI5U,IAAMuiE,EAAWviE,KAGrBuiE,EAAWruB,QACXt/B,EAAIs/B,MAAQquB,EAAWruB,QAG3B,IAAAiG,aAAYvlC,EAAK3wB,EAAQm2D,eAAejsD,MAAOo0E,EAAWhiF,OAAQ0D,IAClE,IAAAk2D,aAAYvlC,EAAK3wB,EAAQm2D,eAAer1D,QAASw9E,EAAWx9E,QAASd,GAE/D,MAAoBs+E,EAAWhiF,OAA7B+N,EAAK,QAAE8L,EAAM,SACfooE,EAAWl0E,GAAQ,IAAAzK,oBAAmByK,GAAS,EAC/Cm0E,EAAYroE,GAAS,IAAAvW,oBAAmBuW,GAAU,EAEpDooE,EAAW,IACX5tD,EAAItmB,MAAQk0E,GAGZC,EAAY,IACZ7tD,EAAIxa,OAASqoE,GAGbF,EAAWpuB,6BACXlwD,EAAQy7E,eAAiB,CACrBt1E,KAAM,QACN+D,MAAOymB,KAIf,IAAAmtD,qBAAoBzhE,EAAKsU,EAAKrK,EAASg4D,EAAYt+E,EAAS69E,EAChE,C,mHCtDA,WACA,WACA,WACA,WAUa,EAAAb,WAA6D,SACtE3gE,EACA7sB,EACA4P,EACAY,EACAk+B,G,YAEIugD,EAAQ,EACJ53E,EAAc7G,EAAQ6lD,WAAU,UAUxC,IARwB,GAApBh/C,EAAUne,QACVme,EAAUrU,KAAK,CACXtC,KAAMV,EACN0uC,QAAO,IAKRugD,EAAQr/E,EAASF,OAAOxW,QAAU+1F,EAAQ,EAAI53E,EAAUne,OAAQ+1F,IAAS,CAC5E,IAAMC,EAAc73E,EAAU43E,GACxBE,EAAa93E,EAAU43E,EAAQ,GAC/BG,EAAYx/E,EAASF,OAAOu/E,GAElC,GACIE,EAAW99E,UAAY+9E,EAAU/9E,WACf,QAAlB,EAAA89E,EAAW79E,eAAO,eAAE+9E,cAAeD,EAAU99E,QAAQ+9E,aAC9B,MAAtBD,EAAU/9E,UACyC,iBAAzC+9E,EAAUtiF,OAAO2E,qBACL,MAAtB29E,EAAU/9E,UACP+9E,EAAUtiF,OAAOgT,gBAAkC,QAAjB,EAAAqvE,EAAWriF,cAAM,eAAEgT,eAEzD,MAIAtP,EAAQi6B,oBACRykD,EAAYxgD,SACZ0gD,EAAU/sB,eAAiB6sB,EAAYxgD,UAGvCwgD,EAAYxgD,QAAUwgD,EAAYxgD,QAAQr2B,Y,CAKlD,GAAI7H,EAAQi6B,mBAER,IAAK,IAAIpvC,EAAI4zF,EAAQ,EAAG5zF,EAAIgc,EAAUne,OAAQmC,IACpC8zF,EAAa93E,EAAUhc,IAE7B,IAAA8yF,kBAAiBgB,EAAWzgD,QAASl+B,EAAQ8/B,kBAOrD,IAHAj5B,EAAU1U,OAAOssF,EAAQ,GAGlBA,EAAQr/E,EAASF,OAAOxW,OAAQ+1F,IAAS,CAC5C,IAAMvpF,EAAQkK,EAASF,OAAOu/E,GACxBK,EAAaj4E,EAAUA,EAAUne,OAAS,GAAGwH,KAE/CshF,OAAO,EACPuN,GAAiB,EACfC,EAAuC,QAAxB,EAAAn4E,EAAU43E,GAAOvgD,eAAO,QAAI,KAE7Cl+B,EAAQi6B,oBAAsB/kC,EAAM28D,eACpC2f,EAAUt8E,EAAM28D,cAEhBhrD,EAAU43E,GAAOvgD,SAAU,IAAAM,oBACvBsgD,EACA5pF,EAAM28D,cACNmtB,EACAh/E,EAAQ8/B,kBAEZj5B,EAAUrU,KAAK,CACXtC,KAAMshF,EACNtzC,QAASszC,EAAQ5pE,WACjB/G,SAAU3L,EAAM2L,SAChBvE,QAAQ,EAAF,eAAOpH,EAAMoH,QACnBwE,SAAS,EAAF,eAAO5L,EAAM4L,aAGxB0wE,EAAUn1D,EAAIrD,cAAgC,MAAlB9jB,EAAM2L,SAAmB,KAAO,MAC5Dk+E,GAAiB,EAEjBD,EAAWtoD,aAAag7C,EAASwN,GACjCn4E,EAAUrU,KAAK,CACXtC,KAAMshF,EACNtzC,QAAS,KACTr9B,SAAU3L,EAAM2L,SAChBvE,QAAQ,EAAF,eAAOpH,EAAMoH,QACnBwE,SAAS,EAAF,eAAO5L,EAAM4L,WAGpBd,EAAQi6B,qBACR/kC,EAAM28D,cAAgB2f,KAI9B,IAAAtb,aAAYsb,EAASxxE,EAAQm2D,eAAe/E,gBAAiBl8D,EAAMoH,OAAQ0D,IAG3E,IAAAi/E,eAAc/pF,EAAO8K,EAAQykD,iBAAiBE,UAAWzvD,EAAMoH,OAAQ0D,IAGvE,IAAAk2D,aAAYsb,EAASxxE,EAAQm2D,eAAexR,UAAWzvD,EAAMoH,OAAQ0D,IACrE,IAAAk2D,aAAYsb,EAASxxE,EAAQm2D,eAAer1D,QAAS5L,EAAM4L,QAASd,GAEhE++E,IACqB,QAArB,EAAA/+E,EAAQ4d,qBAAa,cAArB5d,EAAwB9K,EAAOs8E,G,CAIvC,OAAO3qE,EAAU,GAAGq3B,OACxB,C,wGC/HA,eACA,WACA,WACA,WACA,WACA,WACA,WAca,EAAA++C,eAAiE,SAC1E5gE,EACA7sB,EACA4P,EACAY,EACAk+B,G,QAEAA,EAAUl+B,EAAQ0qE,cAAc8N,KAAKn8D,EAAK7sB,EAAQ4P,EAAUY,EAASk+B,GAE7D,IAMJoqB,EANIzhD,EAAc7G,EAAQ6lD,WAAU,UAClCq5B,EAA+E,QAAjC,EAAAr4E,aAAS,EAATA,EAAYA,EAAUne,OAAS,UAAE,QAAI,CAAC,EACpFy2F,EAAcD,EAAUhhD,SAAW,KACnC6yB,EAAamuB,EAAUhvF,MAAQV,EAC/B0F,EAAQkK,EAASF,OAAOE,EAASF,OAAOxW,OAAS,GAGnDq2F,GAAiB,EAErB,GAAI/+E,EAAQi6B,oBAAsB76B,EAASyyD,cAAe,CACtDvJ,EAAKlpD,EAASyyD,cAKd,IAAK,IAAIhnE,EAAI,EAAGA,EAAIgc,EAAUne,OAAS,EAAGmC,IAClCgc,EAAUhc,GAAGqzC,UAAYoqB,IACzBzhD,EAAUhc,GAAGqzC,QAAUoqB,EAAGzgD,aAIlCq3E,EAAUhhD,SAAU,IAAAM,oBAChBuyB,EACAzI,EACA62B,EACAn/E,EAAQ8/B,iB,MAGZwoB,EAAKjsC,EAAIrD,cAAc,MACvB+lE,GAAiB,EAIjBhuB,EAAWv6B,aAAa8xB,GAAI62B,aAAW,EAAXA,EAAa93E,aAAc0pD,EAAaouB,EAAc,MAClFn/E,EAAQ8/B,iBAAiB4Z,mBAAmBlnD,KAAK81D,GAE7CtoD,EAAQi6B,qBACR76B,EAASyyD,cAAgBvJ,GAI7BpzD,IACA,IAAAghE,aAAY5N,EAAItoD,EAAQm2D,eAAe72D,QAASF,EAAS2F,aAAazI,OAAQ0D,IAC9E,IAAAk2D,aAAY5N,EAAItoD,EAAQm2D,eAAelF,eAAgB/7D,EAAMoH,OAAQ0D,IAGrE,IAAAi/E,eAAc/pF,EAAO8K,EAAQykD,iBAAiBrlD,SAAUA,EAAS9C,OAAQ0D,IAGzE,IAAAk2D,aAAY5N,EAAItoD,EAAQm2D,eAAenF,gBAAiB5xD,EAAS9C,OAAQ0D,IAEzE,IAAAyuD,aAAYzuD,EAASZ,EAAS2F,aAAazI,QAAQ,WAC/C0D,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAKisC,EAAIlpD,EAAUY,EAChE,MAIAZ,EAASzC,OAAOzO,QAAQ,EAAAya,yBAExB3I,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAKisC,EAAIlpD,EAAUY,IAE5D,IAAA6uB,QAAOy5B,IAMX,IAAK,IAAIjnD,EAAQ,EAAGA,EAAQinD,EAAG82B,SAAS12F,OAAQ2Y,IAAS,CACrD,IAAMilB,EAAUgiC,EAAG82B,SAASngF,KAAKoC,IAC7B,IAAAg+E,sBAAqB/4D,IACrBA,EAAQgC,aArFM,OACI,e,CA4F1B,OAJIy2D,IACqB,QAArB,EAAA/+E,EAAQ4d,qBAAa,cAArB5d,EAAwBZ,EAAUkpD,IAG/BpqB,CACX,C,wHC5GA,WACA,WACA,UACA,WACA,WACA,WAYa,EAAAg/C,gBAAmE,SAC5E7gE,EACA7sB,EACA+T,EACAvD,EACAk+B,G,MAEIj6B,EAAYjE,EAAQ2jB,kBAAoBpgB,EAAUsuD,mBAAgBv7D,EA0GtE,OAxGI2N,GAAaV,EAAUpF,SAASmE,OAAM,SAAApY,GAAK,MAAiB,WAAjBA,EAAEoU,cAA6BpU,EAAEiV,UAAjC,IAC3C++B,GAAU,IAAAM,oBAAmBhvC,EAAQyU,EAAWi6B,EAASl+B,EAAQ8/B,mBAEjE,IAAA2uB,aAAYzuD,GAA4B,QAAnB,EAAAuD,EAAU5B,iBAAS,eAAEO,UAAW,MAAM,W,cACjDo9E,GACD/7E,EAAUorB,cACTprB,EAAU5B,YACX,IAAAuL,eAAc3J,EAAUjH,QAAQ5T,OAAS,GACtC6a,EAAUpF,SAASkB,MAAK,SAAAC,GAAW,MAAuB,mBAAvBA,EAAQhB,WAAR,IACrCihF,EAAkBD,GAClB,EAAD,+BAC4B,QAAnB,EAAA/7E,EAAU5B,iBAAS,eAAErF,SAAU,CAAC,GACjCiH,EAAU7B,eAEjB,CAAC,EAEPuC,EAAYoY,EAAIrD,eAAiC,QAAnB,EAAAzV,EAAU5B,iBAAS,eAAEO,UA9BnC,OAgChB1S,EAAOgnC,aAAavyB,EAAWi6B,GAE/Bl+B,EAAQ27E,iBAAiB7rF,QAAU,CAC/BqM,MAAOmjF,EAAuBr7E,EAAYA,EAAUoD,WACpD/H,QAAS,MAGb,IAAMkgF,EAAiB,WACnB,IAAMhwF,EAASyU,EAEf,GAAIzU,EAAQ,CACR,IAAMwlB,EAAezR,EAAUpF,SAAS,GAEP,oBAA7B6W,aAAY,EAAZA,EAAc1W,cAId0B,EAAQ0qE,cAAchsE,KAClB2d,EACA7sB,GAAM,gCAECwlB,GAAY,CACf1W,YAAa,OACbI,KAAM,KAEVsB,EACA,IAIRuD,EAAUpF,SAASjQ,SAAQ,SAAAoR,GACvB,IAAMmgB,EAAsB,GAC5Bzf,EAAQ0qE,cAAcprE,QAAQ+c,EAAK7sB,EAAQ8P,EAASU,EAASyf,GAE7DA,EAAYvxB,SAAQ,SAAAgC,G,MACE,QAAlB,EAAA8P,EAAQ4jB,kBAAU,SAAEqkB,UAAU/3C,EAAMqT,EAAW,CAACjE,GACpD,GACJ,G,CAER,EAEIggF,IACA,IAAA7wB,aAAYzuD,EAASu/E,EAAiBC,IAEtC,IAAAtpB,aAAYjyD,EAAWjE,EAAQm2D,eAAeh6D,MAAOoH,EAAUjH,OAAQ0D,IACvE,IAAAk2D,aAAYjyD,EAAWjE,EAAQm2D,eAAelyD,UAAWV,EAAUjH,OAAQ0D,IAC3E,IAAAk2D,aACIjyD,EACAjE,EAAQm2D,eAAe1rC,eACvB80D,EACAv/E,GAGgB,QAApB,EAAAA,EAAQk6B,oBAAY,SAAEwM,iBAAiBziC,EAAWV,IAElDi8E,KAGJ,IAAAC,UAASx7E,EAAWjE,GAQpBk+B,EAAUj6B,EAAU4D,YAEhB5D,IACqB,QAArB,EAAAjE,EAAQ4d,qBAAa,cAArB5d,EAAwBuD,EAAWU,GACjB,QAAlB,EAAAjE,EAAQ4jB,kBAAU,SAAEukB,YAAYlkC,IAGhCq7E,GACIt/E,EAAQ2jB,oBACRpgB,EAAUsuD,cAAgB5tD,GAG9BjE,EAAQ8/B,iBAAiB4Z,mBAAmBlnD,KAAKyR,MAEjD,IAAA4qB,QAAO5qB,GACPA,OAAY3N,EAEpB,IAGG4nC,CACX,C,sHC3Ha,EAAAk/C,cAAiE,SAC1E/gE,EACA7sB,EACA8P,EACAU,EACA69E,GAEA,IAAMlC,EAAmB37E,EAAQ27E,iBASjC,OANIr8E,EAAQH,aAAew8E,EAAiBr8D,QACxCq8D,EAAiBr8D,OAAQ,EAAH,eACfq8D,EAAiB7rF,UAIpBwP,EAAQhB,aACZ,IAAK,OACD0B,EAAQ0qE,cAAchsE,KAAK2d,EAAK7sB,EAAQ8P,EAASU,EAAS69E,GAC1D,MAEJ,IAAK,KACD79E,EAAQ0qE,cAAcx1D,GAAGmH,EAAK7sB,EAAQ8P,EAASU,EAAS69E,GACxD,MAEJ,IAAK,QACD79E,EAAQ0qE,cAAcxgE,MAAMmS,EAAK7sB,EAAQ8P,EAASU,EAAS69E,GAC3D,MAEJ,IAAK,UACD79E,EAAQ0qE,cAAckS,eAAevgE,EAAK7sB,EAAQ8P,EAASU,EAAS69E,GACpE,MAEJ,IAAK,SACD79E,EAAQ0qE,cAAcv2B,cAAc93B,EAAK7sB,EAAQ8P,EAASU,EAAS69E,GAMvEv+E,EAAQH,YAAcw8E,EAAiBr8D,QACvCq8D,EAAiBp8D,KAAM,EAAH,eACbo8D,EAAiB7rF,SAGhC,C,gHCrDA,eACA,WACA,WACA,WASa,EAAAwtF,uBAA0E,SACnFxrE,EACAtiB,EACA8P,EACAU,GAEQ,IAAA6F,EAAevG,EAAO,KAAhBpQ,EAASoQ,EAAO,MAE1B,IAAA8H,cAAa5X,EAAQ,kBACjBN,IACA,IAAAu/D,aAAYzuD,EAAS,KAAK,W,MAChBhU,GAAI,IAAA+2E,mBAAkBvzE,EAAQ,MAEpC,IAAA0mE,aAAYlqE,EAAGgU,EAAQm2D,eAAejnE,KAAMA,EAAKoN,OAAQ0D,IACzD,IAAAk2D,aAAYlqE,EAAGgU,EAAQm2D,eAAer1D,QAAS5R,EAAK4R,QAASd,GAExC,QAArB,EAAAA,EAAQ4d,qBAAa,cAArB5d,EAAwB9Q,EAAMlD,EAClC,IAGA6Z,IACA,IAAA4oD,aAAYzuD,EAAS,QAAQ,W,MACnB0/E,GAAW,IAAA3c,mBAAkBvzE,EAAQ,SAE3C,IAAA0mE,aAAYwpB,EAAU1/E,EAAQm2D,eAAetwD,KAAMA,EAAKvJ,OAAQ0D,GAE3C,QAArB,EAAAA,EAAQ4d,qBAAa,cAArB5d,EAAwB6F,EAAM65E,EAClC,IAGZ,C,qGC1CA,eACA,WACA,WACA,WACA,WACA,WAWa,EAAAnC,YAA2D,SACpElhE,EACA7sB,EACA8T,EACAtD,EACAk+B,G,kBAEA,IAAI,IAAAmqC,cAAa/kE,GAEb,OAAO46B,EAGX,IAAIyhD,EAAY3/E,EAAQ2jB,kBAAoBrgB,EAAMuuD,mBAAgBv7D,EAE9DqpF,GACAzhD,GAAU,IAAAM,oBAAmBhvC,EAAQmwF,EAAWzhD,EAASl+B,EAAQ8/B,mBAEjE,IAAAjP,gBAAe8uD,KAEfA,EAAYtjE,EAAIrD,cAAc,SAE1BhZ,EAAQ2jB,oBACRrgB,EAAMuuD,cAAgB8tB,GAG1BnwF,EAAOgnC,aAAampD,EAAWzhD,GAC/Bl+B,EAAQ8/B,iBAAiB4Z,mBAAmBlnD,KAAKmtF,IAEjD,IAAAzpB,aAAYypB,EAAW3/E,EAAQm2D,eAAeh6D,MAAOmH,EAAMhH,OAAQ0D,IACnE,IAAAk2D,aAAYypB,EAAW3/E,EAAQm2D,eAAe7yD,MAAOA,EAAMhH,OAAQ0D,IACnE,IAAAk2D,aAAYypB,EAAW3/E,EAAQm2D,eAAerE,YAAaxuD,EAAMhH,OAAQ0D,IACzE,IAAAk2D,aAAYypB,EAAW3/E,EAAQm2D,eAAer1D,QAASwC,EAAMxC,QAASd,IAGrD,QAArB,EAAAA,EAAQ4d,qBAAa,cAArB5d,EAAwBsD,EAAOq8E,GAE/B,IAAMppD,EAAQla,EAAIrD,cAAc,SAChC2mE,EAAUzmE,YAAYqd,GAEtB,IAAK,IAAIh5B,EAAM,EAAGA,EAAM+F,EAAMhG,KAAK5U,OAAQ6U,IAAO,CAC9C,IAAM+0D,EAAWhvD,EAAMhG,KAAKC,GAE5B,GAA6B,GAAzB+0D,EAAS90D,MAAM9U,OAAnB,CAKA,IAAM2pE,EAAMryD,EAAQ2jB,mBAAqB2uC,EAAST,eAAkBx1C,EAAIrD,cAAc,MACtFud,EAAMrd,YAAYm5C,IAClB,IAAAxhC,gBAAewhC,GAEVC,EAAST,gBACN7xD,EAAQ2jB,oBACR2uC,EAAST,cAAgBQ,IAG7B,IAAA6D,aAAY7D,EAAIryD,EAAQm2D,eAAe7D,SAAUA,EAASh2D,OAAQ0D,IAGjD,QAArB,EAAAA,EAAQ4d,qBAAa,cAArB5d,EAAwBsyD,EAAUD,GAElC,I,eAASz9C,GACL,IAAMnX,EAAO60D,EAAS90D,MAAMoX,GAE5B,GAAInX,EAAK0B,WAAY,CACjB,IAAMq7C,EAAiCx6C,EAAQw6C,gBAAkB,CAC7Dr0C,KAAM,QACN7C,MAAOq8E,EACP7sE,YAAa8B,EACbb,WAAYa,EACZf,SAAUtW,EACVuW,QAASvW,GAGTi9C,EAAel3C,OAASq8E,IACxBnlC,EAAezmC,WAAa3qB,KAAKC,IAAImxD,EAAezmC,WAAYa,GAChE4lC,EAAe1mC,QAAU1qB,KAAKC,IAAImxD,EAAe1mC,QAASvW,IAG9DyC,EAAQw6C,eAAiBA,C,CAG7B,IAAK/8C,EAAK4W,YAAc5W,EAAK8W,SAAU,CACnC,IAAMqD,EAAMna,EAAK2H,SAAW,KAAO,KAC7B,EACDpF,EAAQ2jB,mBAAqBlmB,EAAKo0D,eAAkBx1C,EAAIrD,cAAcpB,GAE3Ey6C,EAAGn5C,YAAY,GAOf,IALA,IAAI45C,EAAU,EACVF,EAAU,EACVvoD,EAAQ/G,EAAMkS,OAAOZ,GACrBuB,EAASm8C,EAASn8C,OAEsB,QAArC,EAAyB,QAAzB,EAAA7S,EAAMhG,KAAKC,EAAMu1D,UAAQ,eAAEt1D,MAAMoX,UAAI,eAAEP,UAAWy+C,IACrD38C,GAAU7S,EAAMhG,KAAKC,EAAMu1D,GAAS38C,OAExC,KAAoC,QAA7B,EAAAm8C,EAAS90D,MAAMoX,EAAMg+C,UAAQ,eAAEr+C,SAAUq+C,IAC5CvoD,GAAS/G,EAAMkS,OAAOZ,EAAMg+C,GAG5BE,EAAU,IACV,EAAGA,QAAUA,GAGbF,EAAU,IACV,EAAGA,QAAUA,KAGZn1D,EAAKo0D,eAAkBp0D,EAAKnB,OAAO+I,eAAgB,IAAA8hB,aAAY7jB,MAC5D+G,EAAQ,IAAM,EAAGC,MAAMD,QACvB,EAAGC,MAAMD,MAAQA,EAAQ,MAGzB8L,EAAS,IAAM,EAAG7L,MAAM6L,SACxB,EAAG7L,MAAM6L,OAASA,EAAS,QAInC,IAAAs4C,aAAYzuD,EAAS4X,GAAK,WACjBna,EAAKo0D,gBACF7xD,EAAQ2jB,oBACRlmB,EAAKo0D,cAAgB,IAGzB,IAAAqE,aAAY,EAAIl2D,EAAQm2D,eAAeh6D,MAAOsB,EAAKnB,OAAQ0D,IAC3D,IAAAk2D,aAAY,EAAIl2D,EAAQm2D,eAAejD,UAAWz1D,EAAKnB,OAAQ0D,IAC/D,IAAAk2D,aACI,EACAl2D,EAAQm2D,eAAekM,gBACvB5kE,EAAKnB,OACL0D,IAEJ,IAAAk2D,aAAY,EAAIl2D,EAAQm2D,eAAer1D,QAASrD,EAAKqD,QAASd,IAGlEA,EAAQ0qE,cAAc4Q,mBAAmBj/D,EAAK,EAAI5e,EAAMuC,EAC5D,IAEqB,QAArB,EAAAA,EAAQ4d,qBAAa,cAArB5d,EAAwBvC,EAAM,E,GA9E7BmX,EAAM,EAAGA,EAAM09C,EAAS90D,MAAM9U,OAAQksB,I,EAAtCA,E,EAqFb,OAFkB,QAAlB,EAAA5U,EAAQ4jB,kBAAU,SAAE0kB,QAAQq3C,EAAWr8E,GAEhC46B,CACX,C,oGCnKA,eAMa,EAAAs/C,WAA2D,SACpEnhE,EACA7sB,EACA8P,EACAU,EACA69E,GAEA,IAAM74D,EAAM3I,EAAIkV,eAAejyB,EAAQZ,MACjC4nB,EAAUjK,EAAIrD,cAAc,QAElCxpB,EAAO0pB,YAAYoN,GACnBA,EAAQpN,YAAY8L,GAEpBhlB,EAAQm2D,eAAez3D,KAAKxQ,SAAQ,SAAA0xF,GAAW,OAAAA,EAAQtgF,EAAQhD,OAAQ0oB,EAAKhlB,EAA7B,KAE/C,IAAA89E,qBAAoBzhE,EAAK2I,EAAKsB,EAAShnB,EAASU,EAAS69E,EAC7D,C,mGCtBA,eAEMgC,EAAe,CAAC,OAAQ,IAAK,KAAM,IAAK,IAAK,MAAO,MAAO,SAAU,IAAK,IAAK,QA4BrF,SAASC,EAAkBC,EAAuBC,GAC9C,IAAMC,EAAQF,EAASx0D,WACjB20D,EAAQF,EAASz0D,WAEvB,GAAI00D,EAAMv3F,QAAUw3F,EAAMx3F,OACtB,OAAO,EAGX,IAAK,IAAImC,EAAI,EAAGA,EAAIo1F,EAAMv3F,OAAQmC,IAC9B,GAAIo1F,EAAMp1F,GAAG0F,MAAQ2vF,EAAMr1F,GAAG0F,MAAQ0vF,EAAMp1F,GAAGhC,OAASq3F,EAAMr1F,GAAGhC,MAC7D,OAAO,EAIf,OAAO,CACX,CAtCA,qBAA0Boe,GACtB,IAAK,IAAIU,EAAQV,EAAKW,WAAYD,GAAS,CACvC,IAAMy2B,EAAOz2B,EAAME,YAEnB,GACIu2B,IACA,IAAAh3B,cAAaO,EAAO,kBACpB,IAAAP,cAAag3B,EAAM,iBACnBz2B,EAAMzF,SAAWk8B,EAAKl8B,SACtB29E,EAAaztF,QAAQuV,EAAMzF,UAAY,GACvC49E,EAAkBn4E,EAAOy2B,GAC3B,CACE,KAAOA,EAAKx2B,YACRD,EAAMuR,YAAYklB,EAAKx2B,YAG3Bw2B,EAAK/2B,WAAY+gB,YAAYgW,E,MAE7Bz2B,EAAQy2B,C,CAGpB,C,iGC5BA,eACA,WACA,WACA,WA4DA,SAAS+hD,EACLC,EACAnX,EACAoX,EACAC,GAEIF,GAAuB9pF,MAAf8pF,EAAKhuE,SACTguE,EAAK9gF,SAAW2pE,EAChBmX,EAAKhuE,OAASkuE,EACPF,EAAK9gF,SAAW+gF,IACvBD,EAAK9gF,QAAU2pE,GAG3B,CAhEA,oBAAgBwW,EAASx4E,EAAYjH,GAIjC,KAAI,IAAA49B,iBAAgB32B,GAApB,EAIA,IAAAs5E,uBAAsBt5E,IACtB,IAAAu5E,WAAUv5E,GAEV,IAAK,IAAIU,EAAQV,EAAKW,WAAYD,EAAOA,EAAQA,EAAME,YACnD43E,EAAS93E,EAAO3H,IAQxB,SAA2BiH,EAAYjH,G,YAE/B2H,EACAy2B,EAFA6qC,EAAwB,KAGtBjiE,EAAYhH,EAAQ27E,iBAE1B,IAC6Bv9C,GAAzBz2B,EAAQV,EAAKW,YAA2BD,EAAME,YAAc,KAC5DF,EACcy2B,GAAdz2B,EAAQy2B,GAAqBz2B,EAAME,YAAc,KAEjD,IAAK,IAAAT,cAAaO,EAAO,aAElB,GAAKshE,EAEL,CACH,IAAMwX,EAA2C,QAA1B,EAAkB,QAAlB,EAAAxX,EAAShkD,iBAAS,eAAEv8B,cAAM,QAAI,EAEnC,QAAlB,EAAAsX,EAAQ4jB,kBAAU,SAAE8kB,YAAYugC,EAAUthE,GAC1CshE,EAAShkD,WAA4B,QAAf,EAAAtd,EAAMsd,iBAAS,QAAI,GAErCje,IACAm5E,EAAgBn5E,EAAUsY,MAAO2pD,EAAUthE,EAAO84E,GAClDN,EAAgBn5E,EAAUuY,IAAK0pD,EAAUthE,EAAO84E,IAGpDx5E,EAAKmhB,YAAYzgB,E,MAZjBshE,EAAWthE,OAFXshE,EAAW,IAiBvB,CAlCIyX,CAAkBz5E,EAAMjH,E,CAC5B,C,+GC5BA,eAKA,iCAAsCiH,GAClC,IAAK,IAAIU,EAAQV,EAAKW,WAAYD,GAC9B,IACI,IAAAP,cAAaO,EAAO,iBACH,QAAjBA,EAAMzF,SACqB,GAA3ByF,EAAM4jB,WAAW7iC,OACnB,CACE,IAAMwH,EAAOyX,EACTu2B,EAAUv2B,EAAME,YAGpB,IAFAF,EAAQA,EAAME,YAEP3X,EAAKi6C,WAAW,CACnB,IAAMw2C,EAAUzwF,EAAKi6C,UACrBljC,EAAKuvB,aAAamqD,EAASziD,GAC3BA,EAAUyiD,C,CAGd15E,EAAKmhB,YAAYl4B,E,MAEjByX,EAAQA,EAAME,WAG1B,C,mGCbA,uBACIye,EACA81D,EACA9/E,EACA0D,GAEAo8E,EAASluF,SAAQ,SAAA0xF,GACbA,SAAAA,EAAUtjF,EAAQgqB,EAAStmB,EAC/B,GACJ,C,uGCvBA,eAWA,yBACIxX,EACAo3F,EACAtjF,EACA0D,GAEI4/E,IACA,IAAAnZ,gBACIj+E,GACA,SAAAmV,GAEI,OADAiiF,EAAQj6B,gBAAgBhoD,EAAUrB,EAAQ0D,GACnCrC,CACX,GACAiiF,EAAQn6B,mBAGpB,C,0GC3BA,eASA,4BAAiCvnB,EAAsB0iD,GACnD,KAAO1iD,GAAS,CACZ,IAAME,EAAOF,EAAQr2B,YAEjBq2B,EAAQ72B,cACJ,IAAAD,cAAa82B,EAAS,iBACtB0iD,EAAejnC,qBAAqBnnD,KAAK0rC,GAG7CA,EAAQ72B,WAAW+gB,YAAY8V,IAGnCA,EAAUE,C,CAElB,C,6GCvBA,eAMA,+BACI/hB,EACA6rB,EACA24C,EACAvhF,EACAU,EACA69E,G,MAEK31C,EAAYtgC,aACb5H,EAAQ27E,iBAAiB7rF,QAAQwP,QAAU4oC,IAG/C,IAAAguB,aAAY2qB,EAAe7gF,EAAQm2D,eAAegM,kBAAmB7iE,EAAQhD,OAAQ0D,GAErF69E,SAAAA,EAAcrrF,KAAK01C,GACnBloC,EAAQ0qE,cAAc2S,iBAAiBhhE,EAAKwkE,EAAevhF,EAASU,EAAS69E,IAE7E,IAAA3nB,aAAY2qB,EAAe7gF,EAAQm2D,eAAeiM,oBAAqB9iE,EAAQhD,OAAQ0D,GAElE,QAArB,EAAAA,EAAQ4d,qBAAa,cAArB5d,EAAwBV,EAAS4oC,EACrC,C,oHCjBA,uBACIloC,EACA8gF,EACAptE,GAEA,IAAMqK,EACyB,iBAApB+iE,EACD9gF,EAAQknD,6BAA6B45B,GACrCA,EAEV,GAAI/iE,EAAW,CACX,IAAMm/C,EAAiBl9D,EAAQk9D,eACzBr2D,EAAY7G,EAAQ6lD,WAAWh/C,UAErC,IACI7G,EAAQk9D,gBAAiB,EAAH,8BACfA,GACAn/C,GAEP/d,EAAQ6lD,WAAWh/C,UAAY,GAE/B6M,G,SAEA1T,EAAQk9D,eAAiBA,EACzBl9D,EAAQ6lD,WAAWh/C,UAAYA,C,OAGnC6M,GAER,C,0GChCA,IACMqtE,EAAmD,CACrDC,UAAW,SAAAlxB,GAAW,MAAoB,MAAnBA,EAAQ5tD,QAFjB,2CAE+C,EAAvC,EACtB++E,cAAe,WAAM,UACrBC,gBAAiB,SAAA59D,GAAM,MAAI,OAA0B,QAA1B,EAAAA,EAAO1c,QAAQ4nB,mBAAW,QAAI,EAAE,EAC3D2yD,iBAAkB,SAAA7hF,GAAO,MAAI,OAA2B,QAA3B,EAAAA,EAAQgnB,QAAQkI,mBAAW,QAAI,EAAE,EAC9D4yD,QAAS,WAAM,WACfC,OAAQ,SAAA3iF,GAAQ,OAAAA,EAAKA,IAAL,EAChBypC,YAAa,WAAM,UACnBG,QAAS,WAAM,UACfg5C,aAAc,WAAM,WAsBxB,SAASC,EACLl7E,EACAm7E,EACAC,GAEIA,EAAUH,aAAaj7E,IACvBA,EAAM1J,OAAOzO,SAAQ,SAAAiO,GACjB,OAAQA,EAAMK,WACV,IAAK,YACD,GAAIilF,EAAUt5C,YAAYhsC,GAAQ,CAC9B,IAAI,EAAO,GAEXA,EAAMgC,SAASjQ,SAAQ,SAAAoR,GACnB,OAAQA,EAAQhB,aACZ,IAAK,KACDkjF,EAAUhvF,KAAK,GACf,EAAO,GACP,MAEJ,IAAK,SACD,GAAQivF,EAAUP,gBAAgB5hF,GAClC,MAEJ,IAAK,UACD,GAAQmiF,EAAUN,iBAAiB7hF,GACnC,MAEJ,IAAK,OACD,GAAQmiF,EAAUJ,OAAO/hF,GACzB,MAEJ,IAAK,QACD,GAAQmiF,EAAUL,QAAQ9hF,GAGtC,IAEI,GACAkiF,EAAUhvF,KAAK,E,CAIvB,MAEJ,IAAK,UACDgvF,EAAUhvF,KAAKivF,EAAUT,UAAU7kF,IACnC,MACJ,IAAK,SACDqlF,EAAUhvF,KAAKivF,EAAUR,cAAc9kF,IACvC,MAEJ,IAAK,QACGslF,EAAUn5C,QAAQnsC,IAClBA,EAAMmB,KAAKpP,SAAQ,SAAAqP,GACf,OAAAA,EAAIC,MAAMtP,SAAQ,SAAAuP,GACd8jF,EAAwB9jF,EAAM+jF,EAAWC,EAC7C,GAFA,IAKR,MAEJ,IAAK,aACDF,EAAwBplF,EAAOqlF,EAAWC,GAGtD,GAER,CAhFA,8BACIj5F,EACAk5F,EACAD,QADA,IAAAC,IAAAA,EAAA,QAGA,IAAMF,EAAsB,GAK5B,OAFAD,EAAwB/4F,EAAOg5F,EAFT74F,OAAO0gB,OAAO,CAAC,EAAG03E,EAAkBU,IAInDD,EAAUj0F,KAAKm0F,EAC1B,C,wHCtBa,EAAAC,cAAgB,CACzB,CAAEvkE,OAAQ,KAAMlb,QAAS,KAAMuO,SAZ3B,OAaJ,CAAE2M,OAAQ,MAAOlb,QAAS,KAAMuO,SAZ5B,SAaJ,CAAE2M,OAAQ,OAAQlb,QAAS,KAAMuO,SAZ7B,UAaJ,CAAE2M,OAAQ,QAASlb,QAAS,KAAMuO,SAZ9B,OAaJ,CAAE2M,OAAQ,SAAUlb,QAAS,KAAMuO,SAZ/B,UAaJ,CAAE2M,OAAQ,UAAWlb,QAAS,KAAMuO,SAZhC,WAkBK,EAAAmxE,iBAA2C,CACpDvqE,GAAI,KACJC,GAAI,MACJC,GAAI,OACJC,GAAI,QACJC,GAAI,SACJC,GAAI,U,uJChCR,eAAS,+FAAAmqE,6BAA6B,IACtC,cAAS,+FAAAC,6BAA6B,G,iGCItC,qBACI1+E,EACA1E,EACA4N,GAWA,OATAlJ,EAAY1E,KAAOA,EACnB0E,EAAYlU,KAAO,CACf4R,QAAS,CAAC,EACVxE,OAAQ,CACJqR,KAAMrB,EACN0B,WAAW,IAIZ5K,CACX,C,+HCpBA,WACA,WACA,WACA,WACA,WACA,WAUA,kCACI1E,EACA6E,EACA5B,G,UAEA,GAAoB,IAAhBjD,EAAKhW,OAAc,CACnB,IAAMwsB,GAAK,IAAAnL,YACXxG,EAAUpF,SAAS3L,KAAK0iB,E,KACrB,CACH,IAAMs1B,GAAe,IAAAu3C,wBAAuBrjF,G,IAC5C,IAAsB,qBAAA8rC,GAAY,8BAAE,CAA/B,IAAMlrC,EAAO,QACR0iF,GAAmB,IAAArwE,YAAWrS,EAAQZ,MAC5C,GAAqB,UAAjBY,EAAQ6G,KAAkB,CAC1B,IAAM+D,GAAQ,IAAA+3E,oBAAmB3iF,EAAQZ,KAAMY,EAAQgN,KACvD/I,EAAUpF,SAAS3L,KAAK0X,E,MAMxB,GAJqB,SAAjB5K,EAAQ6G,OACR,IAAA+7E,WAAUF,EAAkB1iF,EAAQZ,KAAMY,EAAQgN,MAEnB,IAAA61E,eAAcH,EAAkBrgF,GACnC,CAC5B,IAAMygF,GAAoB,IAAAC,qBAAoBL,IAC9C,EAAAz+E,EAAUpF,UAAS3L,KAAI,4CAAI4vF,IAAiB,G,qGAM5D,OAAO7+E,CACX,C,4HC5CA,WAoGA,SAAS++E,EAAc5jF,EAAc2C,GACjC,IAAMkhF,EAAY7jF,EAAKzR,UAAUoU,GAEjC,OAAIkhF,EAAUr2D,WAAW,MACd,CAAE/lB,KAAM,gBAAiBzd,OAAQ,GAGxC65F,EAAUr2D,WAAW,MACd,CAAE/lB,KAAM,OAAQzd,OAAQ,GAG/B65F,EAAUr2D,WAAW,KACd,CAAE/lB,KAAM,SAAUzd,OAAQ,GAG9B,IACX,CAEA,SAAS85F,EACL9jF,EACA2C,EACAmC,EACAi/E,GAEA,IAAMxyD,EAAW5uB,EAAQmC,EAAO9a,OAASgW,EAAKhW,OAASgW,EAAK6f,OAAOld,EAAQmC,EAAO9a,QAAU,GAI5F,QA4BJ,SACIuxB,EACA9T,GAEA,OAAQA,GACJ,IAAK,OACD,OAAO8T,EAAM+lD,KACjB,IAAK,SACD,OAAO/lD,EAAM+D,OACjB,IAAK,gBACD,OAAO/D,EAAMgE,cAEzB,CA1C8BykE,CAAsBD,EAAcj/E,EAAO2C,OAQ1D8pB,EAASvnC,OAAS,IAKtB,KAAK6jB,KALoC0jB,EAEpD,CAMA,SAAS0yD,EAAiB1oE,EAAwB9T,GAC9C,OAAQA,GACJ,IAAK,OACD8T,EAAM+lD,MAAQ/lD,EAAM+lD,KACpB,MACJ,IAAK,SACD/lD,EAAM+D,QAAU/D,EAAM+D,OACtB,MACJ,IAAK,gBACD/D,EAAMgE,eAAiBhE,EAAMgE,cAGzC,CAgBA,SAAS2kE,EACLlkF,EACAmkF,EACA5oE,EACA/qB,GAEA,IAAMoN,GAAM,iBAAmCumF,GAc/C,OAZI5oE,EAAM+lD,OACN1jE,EAAOub,WAAa,QAGpBoC,EAAM+D,SACN1hB,EAAO0hB,QAAS,GAGhB/D,EAAMgE,gBACN3hB,EAAO2hB,eAAgB,IAGpB,IAAAtM,YAAWjT,EAAMpC,EAAQpN,EACpC,CA1KA,+BAAoCkU,GAChC,IAAM1E,EAAO0E,EAAY1E,KAGzB,GAgEJ,SAAiCA,GAQ7B,OAA4B,IANZA,EACME,QAAQ,QAAS,IACjBA,QAAQ,MAAO,IACfA,QAAQ,MAAO,IAGpBlW,MACrB,CAzEQo6F,CAAwBpkF,GACxB,MAAO,CAAC0E,GASZ,IANA,IAAMonC,EAAmC,GACnCi4C,EAAgC,CAAEziB,MAAM,EAAOhiD,QAAQ,EAAOC,eAAe,GAE/E8kE,EAAc,GACdl4F,EAAI,EAEDA,EAAI6T,EAAKhW,QAAQ,CACpB,IAAM8a,EAAS8+E,EAAc5jF,EAAM7T,GAE/B2Y,GAEIg/E,EAAuB9jF,EAAM7T,EAAG2Y,EAAQi/E,IAEpCM,EAAYr6F,OAAS,IACrB8hD,EAAah4C,KACTowF,EACIG,EACA3/E,EAAY9G,OACZmmF,EACAr/E,EAAYlU,OAGpB6zF,EAAc,IAIlBJ,EAAiBF,EAAcj/E,EAAO2C,MAGtCtb,GAAK2Y,EAAO9a,SAQhBq6F,GAAerkF,EAAK7T,GACpBA,I,CAYR,OAPIk4F,EAAYr6F,OAAS,GACrB8hD,EAAah4C,KACTowF,EAAuBG,EAAa3/E,EAAY9G,OAAQmmF,EAAcr/E,EAAYlU,OAM9D,IAAxBs7C,EAAa9hD,QACY,IAAxB8hD,EAAa9hD,QAAgB8hD,EAAa,GAAG9rC,OAAS0E,EAAY1E,KAE5D,CAAC0E,GAGLonC,CACX,C,uHCvFA,eA0BA,yCACI9rC,EACAskF,G,MAEMtqE,EAK+B,QAJhC,EAAsC,iBAA/BsqE,EACF,CACIC,kBAAmBD,GAEvBA,SAA2B,QAAI,CAAC,EAE1C,OAAO,IAAAE,mBAAkBxkF,EAAMga,EACnC,C,sHCtCA,eACA,UAQMyqE,EAAqE,CACvEC,eAAgB,WAChBC,aAAc,WACdl8B,WAAY,mBAMhB,wCACIzoD,EACA4kF,EACA5qE,EACArS,GAEA,MAA4C,aAAxC88E,EAAuBG,IAChB,IAAAC,wBAAuB7kF,EAAsB,iBAAhB4kF,EAAiC,KAAO,KAAM5qE,IAE3E,IAAA8qE,8BAA6B9kF,EAAMga,EAASrS,EAE3D,C,qIC7BA,WACA,WAOMo9E,EAAiD,CACnD3lF,WAAY,+BACZ8H,UAAW,qBACX2K,UAAW,MACXD,aAAc,MACdrT,WAAY,OACZG,YAAa,OACbF,YAAa,QAMjB,wCACIwB,EACAga,EACAyuC,GAEAzoD,EAAOA,EAAKE,QAAQ,IAAK,IACzB,IAAM2E,GAAY,IAAAmgF,6BAA4BhlF,EAAMga,GAC9CirE,EACFx8B,IACA,IAAA1kD,uBACI,aACAiW,EAAQnc,WAAY,EAAD,8BAAMknF,GAAW,CAAElnF,UAAWmc,EAAQnc,YAAcknF,GAI/E,OADAE,EAAMhnF,OAAOnK,KAAK+Q,GACXogF,CACX,C,4GCrCA,eAMA,8BAAmCjlF,EAAc4N,GAC7C,IAAMpC,GAAQ,IAAAiS,aAAY7P,GAE1B,OADApC,EAAM6R,IAAMrd,EACLwL,CACX,C,+GCVA,eACA,WAOA,kCACIxL,EACAmC,EACA6X,GAEA,IAAMlV,EAAS9E,EAAKkF,OAAOxW,MAAM,KAAK,GAChCw2F,EAAUC,EAAgBrgF,GAC1BsgF,EAAWF,EAAUllF,EAAOA,EAAKkF,OAAO3W,UAAUuW,EAAO9a,QACzD6a,GAAY,IAAAmgF,6BAA4BI,EAASlgF,OAAQ8U,GACzDxZ,EAUV,SACIR,EACAmC,EACA+iF,EACAlrE,GAEA,IAAMxjB,GAAQ,IAAA0L,iBACVC,EACA6X,EAAQnc,UAAY,CAAEA,UAAWmc,EAAQnc,gBAAcjG,GAEvDstF,IACA1uF,EAAMoH,OAAO0S,oBAAsB,SAEvC,IAAM9P,EAAS,CAAChK,GAIhB,OAHkBwJ,EAONwtB,WAAW,MANnBhtB,EAAO1M,KAAK0C,GAETgK,CACX,CA5BmB6kF,CAAarlF,EAAMmC,EAAU+iF,EAASlrE,GAC/CsrE,GAAY,IAAA3zE,gBAAenR,GAMjC,OALIwZ,EAAQnc,YACRynF,EAAU1nF,OAAOC,UAAYmc,EAAQnc,WAGzCynF,EAAUrnF,OAAOnK,KAAK+Q,GACfygF,CACX,EA0BA,IAAMH,EAAkB,SAAC5kF,GACrB,MAAe,KAARA,GAAuB,KAARA,GAAuB,KAARA,IAAgBA,EAAKokE,SAAS,IACvE,C,qHCrDA,eACA,WACA,WAOA,uCACI3kE,EACAga,GAEA,IAAMnV,GAAY,IAAA9B,sBACdnL,EACAoiB,EAAQnc,UAAY,CAAEA,UAAWmc,EAAQnc,gBAAcjG,GAGrD2tF,GAAc,IAAAC,qBAAoBxlF,GAKxC,OAJIulF,IACA1gF,EAAU5B,UAAYsiF,IAE1B,IAAAE,wBAAuBzlF,EAAM6E,EAAW0gF,GACjC1gF,CACX,C,gICxBA,WAEA,WAiCA,SAAS6gF,EACLC,EACA/gF,EACAghF,EACA5rE,GAEA,IAAM6rE,EAAWF,EAASj3F,MAAM,KACL,KAAvBm3F,EAAS,GAAG3gF,QACZ2gF,EAASzuE,QAEgC,KAAzCyuE,EAASA,EAAS77F,OAAS,GAAGkb,QAC9B2gF,EAASx0F,MAMjB,SACIuT,EACAihF,EACAD,EACA5rE,G,QAEMnb,GAAM,IAAAopE,gBAAejuD,EAAQnc,UAAY,CAAEA,UAAWmc,EAAQnc,gBAAcjG,GAE9E+K,EAAQ,E,IACZ,IAAsB,qBAAAkjF,GAAQ,8BAAE,CAA3B,IAAM/qB,EAAO,QACRj2D,GAAY,IAAAmgF,6BAA4BlqB,EAAS9gD,GACjDjb,GAAO,IAAA6X,sBACThf,OACAA,OACAA,EACAoiB,EAAQnc,UAAY,CAAEA,UAAWmc,EAAQnc,gBAAcjG,GAG3DmH,EAAKd,OAAOnK,KAAK+Q,GACb+gF,EAAajjF,KACb5D,EAAKnB,OAAOM,UAAY4nF,EAAiBF,EAAajjF,KAE1D9D,EAAIC,MAAMhL,KAAKiL,GACf4D,G,mGAEJiC,EAAMhG,KAAK9K,KAAK+K,EACpB,CA7BIknF,CAAYnhF,EAAOihF,EAAUD,EAAc5rE,EAC/C,CA8BA,SAAS8rE,EAAiBhrB,GACtB,OAAIA,EAAQttC,WAAW,MAAQstC,EAAQ6J,SAAS,KACrC,SAEP7J,EAAQ6J,SAAS,KACV,MAEJ,OACX,CA3EA,mCACIqhB,EACAhsE,G,QAEM4rE,EAAeI,EAAW,GAAGt3F,MAAM,KAAKgR,QAAO,SAAAo7D,GAAW,MAAmB,KAAnBA,EAAQ51D,MAAR,IAChE8gF,EAAWvyF,OAAO,EAAG,GACrB,IAAMmR,GAAQ,IAAA+R,aACV,EACAqD,EAAQnc,UACF,CAAEwJ,gBAAgB,EAAMxJ,UAAWmc,EAAQnc,WAC3C,CAAEwJ,gBAAgB,I,IAG5B,IAAmB,qBAAA2+E,GAAU,8BACzBN,EADW,QACY9gF,EAAOghF,EAAc5rE,E,kGAKhD,OAHA,IAAA1a,kBAAiBsF,EAAO,CACpB8nE,cAAc,IAEX9nE,CACX,C,0HCjCA,WACA,WACA,WACA,WACA,WAkBMqhF,EAA0C,CAC5CC,QAAS,aACTC,gBAAiB,QACjBvhF,MAAO,cACP6jD,WAAY,UACZi8B,eAAgB,kBAChBC,aAAc,eACdyB,MAAO,QACPvhF,UAAW,mBAGTwhF,EAA2D,CAC7DH,QAAS,YACTC,gBAAiB,UACjBthF,UAAW,YACX6/E,eAAgB,aAChBC,aAAc,aACd//E,MAAO,QACP6jD,WAAY,aACZ29B,MAAO,aAqCX,SAASE,EACLx8F,EACAgU,EACA6nF,EACAf,EACA2B,EACAvsE,G,QAEA,GACkB,UAAdlc,GACAyoF,EAAgBP,YAChBO,EAAgBP,WAAWh8F,OAAS,EACtC,CACE,GACIu8F,EAAgBP,WAAWh8F,OAAS,GACpCu8F,EAAgBP,WAAW,GAAG9gF,OAAOlb,OAAS,IAC9C,IAAAw8F,iBAAgBD,EAAgBP,WAAW,KAC3CO,EAAgBP,WAAWh8F,OAAS,EACtC,CACE,IAAM03B,GAAa,IAAA+kE,yBAAwBF,EAAgBP,WAAYhsE,GACvElwB,EAAMmU,OAAOnK,KAAK4tB,E,UAElB,IAAmB,qBAAA6kE,EAAgBP,YAAU,8BAAE,CAA1C,IAAM5zD,EAAI,QACLvtB,GAAY,IAAAmgF,6BAA4B5yD,EAAMpY,GACpDlwB,EAAMmU,OAAOnK,KAAK+Q,E,mGAG1B0hF,EAAgBP,WAAWh8F,OAAS,C,CAGxC,GAAmB,SAAf46F,EAAwB,CACxB,GACI2B,EAAgBP,WAAWh8F,OAAS,GACpCu8F,EAAgBG,WAChBH,EAAgBI,SAMhB,OAJAJ,EAAgBP,WAAa,GAC7BO,EAAgBG,eAAY9uF,OAC5B2uF,EAAgBI,cAAW/uF,GAK/B,OAAQoiB,EAAQ4sE,WACZ,IAAK,SAED,OACJ,IAAK,QACD,OAAQL,EAAgBM,gBACpB,IAAK,WACL,QAGI,YADAN,EAAgBM,eAAiB,aAGrC,IAAK,YAEDN,EAAgBM,eAAiB,QAGjC,MAEJ,IAAK,QAED,Q,MAShBN,EAAgBM,eAAiB,WAYrC,OATiB,aAAb/oF,IAA6ByoF,EAAgBI,UAAYJ,EAAgBG,aACzE5oF,EAAY,aACZ8mF,EAAc2B,EAAgBI,SACuB,MAA/CJ,EAAgBI,SAASnmF,OAAO,GAAG2B,SAC/B,eACA,iBACJ,cAGFrE,GACJ,IAAK,YACK+G,GAAY,IAAAmgF,6BAA4BW,EAAU3rE,GACxDlwB,EAAMmU,OAAOnK,KAAK+Q,GAClB,MACJ,IAAK,UACD,IAAMusD,GAAU,IAAAC,eAAc,MAC9BvnE,EAAMmU,OAAOnK,KAAKs9D,GAClB,MACJ,IAAK,aACD,IAAM01B,GAAa,IAAAC,8BACfpB,EACAf,EACA5qE,EACAusE,EAAgBG,WAEfH,EAAgBG,WACjB58F,EAAMmU,OAAOnK,KAAKgzF,GAEtBP,EAAgBG,UACiB,mBAA7BI,EAAW9oF,eAAsC8oF,OAAalvF,EAClE2uF,EAAgBI,SACiB,YAA7BG,EAAW9oF,eAA+B8oF,OAAalvF,EAC3D,MACJ,IAAK,QACD2uF,EAAgBP,WAAaO,EAAgBP,YAAc,GAC3DO,EAAgBP,WAAWlyF,KAAK6xF,GAItB,eAAd7nF,IACAyoF,EAAgBG,eAAY9uF,EAC5B2uF,EAAgBI,cAAW/uF,EAEnC,CAjJA,6BACIoI,EACAga,G,MAEMuqE,EAAoBvqE,EAAQuqE,mBAAqB,iBACjDqC,EAA6B,QAAjB,EAAA5sE,EAAQ4sE,iBAAS,QAAI,QACjCI,EAAehnF,EAAKtR,MAAM61F,GAEhCyC,EAAalzF,KAAK,IAElB,IACMhK,EAwIV,SACIA,EACAuoC,EACArY,G,QAEMusE,EAAmC,CACrCG,eAAW9uF,EACX+uF,cAAU/uF,EACVouF,WAAY,I,IAEhB,IAAmB,qBAAA3zD,GAAK,8BAAE,CAArB,IAAMD,EAAI,QACP60D,GAAU,EACd,IAAK,IAAMrC,KAAeqB,EACtB,GAAIA,EAAgBx9F,eAAem8F,IACfqB,EAAgBrB,GACpB/2E,KAAKukB,GAAO,CACpBk0D,EACIx8F,EACAu8F,EAAkBzB,GAClBxyD,EACAwyD,EACA2B,EACAvsE,GAEJitE,GAAU,EACV,K,CAKPA,GACDX,EACIx8F,EACA,YACAsoC,EACA,YACAm0D,EACAvsE,E,mGAIZ,OAAOlwB,CACX,CAlLkBo9F,EADF,IAAAtpE,8BAC2BopE,EAAchtE,GAC/CyvD,EAAY3/E,EAAMmU,OAAOnU,EAAMmU,OAAOjU,OAAS,GAWrD,MARiB,UAAb48F,GACAnd,GACuB,aAAvBA,EAAU3rE,WACV2rE,EAAUhqE,SAASmE,OAAM,SAAApY,GAAK,MAAiB,MAAjBA,EAAEoU,WAAF,KAE9B9V,EAAMmU,OAAO5M,MAGVvH,CACX,C,uGC5EA,eASA,yBACI4a,EACAzB,GAEA,IAAMkkF,EAAsB,EAAAjE,kBAAiBjgF,aAAS,EAATA,EAAWO,UAAW,IACnE,OAAI2jF,IACAziF,EAAY1E,KAAO0E,EAAY1E,KAAKE,QAAQinF,EAAqB,IACjC,IAA5BziF,EAAY1E,KAAKhW,QAEV,KAGR0a,CACX,C,4HCtBA,WAMA,+BAAoC1E,G,YAChC,IAAoB,uBAAAijF,eAAa,8BAAE,CAA9B,IAAMzsF,EAAK,QACZ,GAAIwJ,EAAKwtB,WAAWh3B,EAAMkoB,QACtB,MAAO,CACHlb,QAAShN,EAAMgN,QACf5F,OAAQ,CACJub,WAAY,OACZpH,SAAUvb,EAAMub,U,mGAOpC,C,uGCjBA,2BAAgC/R,GAC5B,IAAMyW,EAAUzW,EAAKtR,MAAM,KAAKgR,QAAO,SAAA1U,GAAK,MAAM,KAANA,CAAA,IACtCo8F,EAAU,WAEhB,OAAO3wE,EAAQzsB,OAAS,GAAKysB,EAAQ7S,OAAM,SAAAxY,GAAK,OAAAg8F,EAAQv5E,KAAKziB,EAAE8Z,OAAf,GACpD,C,8GCRA,IAAMmiF,EAAY,iFAWZC,EAAa,SAAC15E,GAChB,IAEI,OADA,IAAI25E,IAAI35E,IACD,C,CACT,MAAOwF,GACL,OAAO,C,CAEf,EAKA,kCAAuCpT,GAKnC,IAJA,IAAM9P,EAA4B,GAC9Bg8C,EAAY,EACZ19C,EAAgC,KAEM,QAAlCA,EAAQ64F,EAAUh6D,KAAKrtB,KACvBxR,EAAMmU,MAAQupC,GACdh8C,EAAO4D,KAAK,CAAE2T,KAAM,OAAQzH,KAAMA,EAAKhQ,MAAMk8C,EAAW19C,EAAMmU,OAAQiL,IAAK,KAG3Epf,EAAM,IAAMA,EAAM,GAClB0B,EAAO4D,KACHwzF,EAAW94F,EAAM,IACX,CAAEiZ,KAAM,OAAQzH,KAAMxR,EAAM,GAAIof,IAAKpf,EAAM,IAC3C,CAAEiZ,KAAM,OAAQzH,KAAMxR,EAAM,GAAIof,IAAK,KAExCpf,EAAM,IAAMA,EAAM,IACzB0B,EAAO4D,KACHwzF,EAAW94F,EAAM,IACX,CAAEiZ,KAAM,QAASzH,KAAMxR,EAAM,GAAIof,IAAKpf,EAAM,IAC5C,CAAEiZ,KAAM,OAAQzH,KAAMxR,EAAM,GAAIof,IAAK,KAInDs+B,EAAYm7C,EAAUn7C,UAO1B,OAJIA,EAAYlsC,EAAKhW,QACjBkG,EAAO4D,KAAK,CAAE2T,KAAM,OAAQzH,KAAMA,EAAKhQ,MAAMk8C,GAAYt+B,IAAK,KAG3D1d,CACX,C,sHCvDA,cAUA,yCACIpG,EACA09F,GAEA,OAAO,IAAAC,gBAAe39F,EAAO09F,EACjC,C,4HCfA,WACA,WACA,WAeME,EAAkD,CACpD9iF,MAAO,GACPC,UAAW,GACXusD,QAAS,QAMb,+BACI3zD,EACAkqF,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAiB,GACf11D,GAAQ,EAAH,8BAAQq1D,GAAqBG,GACxC,OAAQpqF,EAAMK,WACV,IAAK,YACDiqF,IAAkB,IAAAC,yBAAwBvqF,EAAOqqF,GAAoBz1D,EAAMxtB,UAC3E,MACJ,IAAK,aACDkjF,IAAkB,IAAAE,0BAAyBxqF,EAAOkqF,EAAgBC,GAClE,MACJ,IAAK,QACDG,IAAkB,IAAAG,qBAAoBzqF,EAAOkqF,EAAgBC,GAAev1D,EAAMztB,MAClF,MACJ,IAAK,WACIkjF,aAAgB,EAAhBA,EAAkBK,oBACnBJ,GAAkB,MAAQ11D,EAAM++B,SAS5C,OAAO22B,CACX,C,iICzDA,WAmBA,oCACIjB,EACAa,EACAC,G,QAEIG,EAAiB,GACrB,OAAQjB,EAAW9oF,gBACf,IAAK,WACG4pF,IACAG,GAgBhB,SACIrnF,EACAinF,EACAC,G,QAEIG,EAAiB,GACb9pF,EAAWyC,EAAQ,O,IAC3B,IAAoB,qBAAAzC,GAAM,8BAAE,CAAvB,IAAMR,EAAK,QACZsqF,IAAkB,IAAAK,qBACd3qF,EACAkqF,EACAC,OACAhwF,EACA,CACIuwF,kBAAkB,G,mGAI9B,IAAMj8C,EAAYxrC,EAASF,OAAOxW,OAAS,EACrCq+F,EAAYn8C,EAAY,EAAI,EAC5Bo8C,EAAc5nF,EAASF,OAAO0rC,GAAWtuC,OAAO0S,oBACtD,OAAIg4E,GAA+B,aAAhBA,EACU,IAAIP,GAG7BM,GACAT,EAAYW,mBAERR,EADuC,MAAvCrnF,EAASF,OAAO0rC,GAAW/pC,SACV,MAAMylF,EAAYW,iBAAgB,KAAKR,EAEvC,OAAOA,IAG5BH,EAAYY,gBAERT,EADuC,MAAvCrnF,EAASF,OAAO0rC,GAAW/pC,SACPylF,EAAYY,cAAa,KAAKT,EAEjC,KAAKA,GAIvBA,EAAiBJ,EAAeH,QAC3C,CA1DkCiB,CAAuB3B,EAAYa,EAAgBC,IAEzE,MACJ,IAAK,kBACDG,GAwDZ,SACIt/B,EACAk/B,EACAC,G,QAEIG,EAAiB,GACrB,GAA0B,cAAtBt/B,EAAWjlD,QAAyB,CAC5B,IAAAvF,EAAWwqD,EAAU,O,IAC7B,IAAoB,qBAAAxqD,GAAM,8BAAE,CAAvB,IAAMR,EAAK,QACZsqF,GACI,MACA,IAAAK,qBAAoB3qF,EAAOkqF,EAAgBC,OAAahwF,EAA0B,CAC9EuwF,kBAAkB,IAEtBR,EAAeH,O,oGAI3B,OAAUO,EAAc,IAC5B,CA3E8BW,CAAyB5B,EAAYa,EAAgBC,GACvE,MACJ,QACY,IAAA3pF,EAAW6oF,EAAU,O,IAC7B,IAAoB,qBAAA7oF,GAAM,8BAAE,CAAvB,IAAMR,EAAK,QACZsqF,IAAkB,IAAAK,qBAAoB3qF,EAAOkqF,EAAgBC,E,oGAIzE,OAAOG,CACX,C,gIC1CA,WAgDA,SAASz4B,EAActvD,GACnB,IAAI+nF,EAAiB/nF,EAAKA,KAa1B,OAZIA,EAAKxP,OACLu3F,EAAiB,IAAI/nF,EAAKA,KAAI,KAAKA,EAAKxP,KAAKoN,OAAOqR,KAAI,KAE9B,QAA1BjP,EAAKpC,OAAOub,aACZ4uE,EAAiB,KAAKA,EAAc,MAEpC/nF,EAAKpC,OAAO2hB,gBACZwoE,EAAiB,KAAKA,EAAc,MAEpC/nF,EAAKpC,OAAO0hB,SACZyoE,EAAiB,IAAIA,EAAc,KAEhCA,CACX,CAlDA,mCACIljF,EACAvD,G,QAEQ7B,EAAaoF,EAAS,SAC1BkjF,EAAiB,G,IACrB,IAAsB,qBAAAtoF,GAAQ,8BAAE,CAA3B,IAAMmB,EAAO,QACd,OAAQA,EAAQhB,aACZ,IAAK,OACDmoF,GAAkBz4B,EAAc1uD,GAChC,MACJ,IAAK,QACDmnF,GAAkB,MAAKnnF,EAAQyc,KAAO,SAAO,KAAKzc,EAAQuc,IAAG,IAC7D,MACJ,IAAK,MACI7b,aAAO,EAAPA,EAAS6mF,oBACVJ,GAAkB,M,mGAQlC,GAAIljF,EAAU5B,UAAW,CACb,IAAAO,EAAYqB,EAAU5B,UAAS,QACjCyb,EAAS,EAAAwkE,iBAAiB1/E,GAC5Bkb,IACAqpE,EAAiB,GAAGrpE,EAASqpE,E,CAIrC,OAAOA,CACX,C,4HC9CA,WA4CA,SAASY,EAAgBC,G,QACjBx3B,EAAU,IACNtyD,EAAU8pF,EAAS,M,IAC3B,IAAmB,qBAAA9pF,GAAK,8BACpB,OADW,QACElB,OAAOM,WAChB,IAAK,SACDkzD,GAAW,UACX,MACJ,IAAK,MACDA,GAAW,SACX,MACJ,QACIA,GAAW,Q,kGAIvB,OAAOA,EAAU,IACrB,CArDA,+BACIxsD,EACA+iF,EACAC,G,gBAEIG,EAAiB,GACbnpF,EAASgG,EAAK,KAClBuQ,GAAW,E,IACf,IAAkB,qBAAAvW,GAAI,8BAAE,CAAnB,IAAMC,EAAG,QACVkpF,GAAkB,I,IAClB,IAAmB,+BAAAlpF,EAAIC,QAAK,8BAAE,CAAzB,IAAMC,EAAI,Q,IACX,IAAoB,+BAAAA,EAAKd,SAAM,8BAAE,CAA5B,IAAMR,EAAK,QACZsqF,IAAkB,IAAAK,qBACd3qF,EACAkqF,EACAC,EACA,CACIx2B,QAAS,IAEb,CACI+2B,kBAAkB,G,mGAI9BJ,GAAkB,G,mGAEtBA,GAAkBJ,EAAeH,QAC7BryE,IACA4yE,GAAkBY,EAAgB9pF,GAClCsW,GAAW,E,mGAInB,OAAO4yE,CACX,C,sHC1CA,WAKML,EAAuC,CACzCmB,UAAW,OACXrB,QAAS,MAMb,0BACI19F,EACA09F,G,aAAA,IAAAA,IAAAA,EAAA,GAEA,IAAI7B,EAAW,GACTiC,EAA2B,CAC7BY,cAAe,EACfD,iBAAkB,G,IAEtB,IAAoB,qBAAAz+F,EAAMmU,QAAM,8BAAE,CAA7B,IAAMR,EAAK,UAC2B,eAApBA,EAAMK,WAAuD,aAAzBL,EAAMO,kBACzC4pF,EAAYY,cAAgB,GAAKZ,EAAYW,iBAAmB,KAChFX,EAAYY,cAAgB,EAC5BZ,EAAYW,iBAAmB,EAC/B5C,GAAY6B,EAAQA,SAGxB7B,IAAY,IAAAyC,qBAAoB3qF,EAAO+pF,EAASI,EAAa,CACzDhjF,MAAO4iF,EAAQA,QACf3iF,UAAW2iF,EAAQqB,UACnBz3B,QAASo2B,EAAQqB,W,mGAIzB,OAAOlD,CACX,C,uGCtCA,eAWA,0BACY,KAAAvtE,OAAyB,KACzB,KAAAwkC,kBAAyC,IA2DrD,QAtDI,YAAAhW,QAAA,WACI,MAAO,UACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,CAClB,EAOA,YAAA2uB,QAAA,WACI1zC,KAAK+kB,OAAS,KACd/kB,KAAKupD,kBAAoB,IAC7B,EAQA,YAAAjX,cAAA,SAAc/W,G,QACV,GAAKv7B,KAAK+kB,QAIa,oBAAnBwW,EAAMsE,UAAiC,CACvC,GAAgC,UAAV,QAAlB,EAAAtE,EAAMqV,oBAAY,eAAEx8B,MAAiB,CACrC,IAAMqhF,GAAS,IAAAC,6BACqB,UAAV,QAAtB,EAAA11F,KAAKupD,yBAAiB,eAAEn1C,MAAkBpU,KAAKupD,kBAAoB,KACnEhuB,EAAMqV,cAEN6kD,GAAUl6D,EAAMqV,aAAajB,oBAC7B3vC,KAAK+kB,OAAO2gB,SAAS,CACjBloB,eAA2B,gBAAXi4E,EAA2B,aAAe,WAC1Dh4E,cAAe,EACX,IAAAk4E,+BAA8Bp6D,EAAMqV,aAAajB,sB,CAMjE3vC,KAAKupD,kBAAoBhuB,EAAMqV,Y,CAEvC,EACJ,EA7DA,GAAa,EAAAglD,eAAAA,C,mJCHb,yCAA8CC,GAClC,IAAAxnD,EAAiCwnD,EAAM,YAA1BjrC,EAAoBirC,EAAM,QAAjBltC,EAAWktC,EAAM,OAC3Ch5F,EAAS,GAEb,GAAI8rD,EAMA,IALA,IAAMxmC,EAAW9qB,KAAKD,IAAIwzD,EAAQ/nC,IAAK8lC,EAAO9lC,KACxCT,EAAU/qB,KAAKC,IAAIszD,EAAQ/nC,IAAK8lC,EAAO9lC,KACvCf,EAAWzqB,KAAKD,IAAIwzD,EAAQp/C,IAAKm9C,EAAOn9C,KACxCuW,EAAU1qB,KAAKC,IAAIszD,EAAQp/C,IAAKm9C,EAAOn9C,KAEpCvU,EAAI6qB,EAAU7qB,GAAK8qB,EAAS9qB,IACjC,IAAK,IAAIc,EAAIoqB,EAAUpqB,GAAKqqB,EAASrqB,IAAK,CACtC,IAAM2T,EAAO2iC,EAAYp3C,IAAMo3C,EAAYp3C,GAAGc,GAC1C2T,GAAuB,iBAARA,IACf7O,GAAU,IAAM6O,EAAKc,UAAY,I,CAMjD,OAAO3P,CACX,EAUA,uCACIi5F,EACA9sC,GAEA,IAAK8sC,EACD,MAAO,YAIP,IAAUC,EAIVD,EAAkB,SAHTE,EAGTF,EAAkB,QAFLG,EAEbH,EAAkB,YADNI,EACZJ,EAAkB,WAGRK,EAIVntC,EAAiB,SAHRotC,EAGTptC,EAAiB,QAFJqtC,EAEbrtC,EAAiB,YADLstC,EACZttC,EAAiB,WAIfutC,GAFcl/F,KAAK+vF,IAAI4O,EAAcD,GAAgB,IACvC1+F,KAAK+vF,IAAI8O,EAAiBD,GAAmB,GAK3DO,GAFan/F,KAAK+vF,IAAIgP,EAAaD,GAAe,IACrC9+F,KAAK+vF,IAAIkP,EAAgBD,GAAkB,GAI9D,OACIN,IAAiBI,GACjBH,IAAgBI,GAChBH,IAAoBI,GACpBH,IAAmBI,EAEZ,KAGPE,EAAUD,EACH,YACAC,EAAUD,EACV,cAGA,WAEf,C,yHCvFA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,UACA,WAsCME,EAA6C,CAC/CC,YAAY,EACZC,eAAe,EACfC,YAAY,EACZx9E,UAAU,EACVy9E,YAAY,EACZC,cAAc,EACdC,cAAc,EACdC,mBAAmB,EACnBC,oBAAoB,GAOxB,aAgBI,WAAoBtwE,GAApB,gBAAoB,IAAAA,IAAAA,EAAA,QAAAA,QAAAA,EAfZ,KAAA5B,OAAyB,KA0GzB,KAAA3L,SAAoB,CACxB89E,WAAYl3F,KAAK2mB,QAAQvN,UAAYpZ,KAAK2mB,QAAQrN,SAAWtZ,KAAK2mB,QAAQtN,YAC1E89E,kBAAmB,SAACtpE,EAAQtW,EAAiB/F,EAAWvD,G,MAC9C,EAAoC,EAAK0Y,QAAvCvN,EAAQ,WAAEE,EAAO,UAAED,EAAU,aAC/ByC,GAAc,IAAA5S,aAAYqO,EAAiB/F,EAAW,CACxD4H,SAAQ,EACRE,QAAO,EACPD,WAAU,IAGd,SAAIyC,IAAe,EAAKiJ,SACbqyE,EACH,EAAKryE,OAAOiC,eACI,QAAhB,EAAAlL,EAAY3e,YAAI,eAAEoN,OAAOqR,OAAQ,GACjCE,EAAYnP,KAIxB,EACAwY,QAAS,WACToC,aAAc,EAAAC,aAAa0wC,UAGvB,KAAAm/B,YAAyB,CAC7B,CACIH,WAAYl3F,KAAK2mB,QAAQ+vE,aAAc12F,KAAK2mB,QAAQgwE,eACpDQ,kBAAmB,SAAC1gG,EAAO6gG,EAAkB9lF,EAAWvD,GACpD,WAAAspF,qBACI9gG,EACA+a,EACAvD,EACA,EAAK0Y,QAAQ+vE,WACb,EAAK/vE,QAAQgwE,cACb,EAAKhwE,QAAQqwE,kBANjB,EAQJ7xE,QAAS,iBACToC,aAAc,EAAAC,aAAa6wC,YAE/Br4D,KAAKoZ,UAGD,KAAAo+E,UAAQ,uDACTx3F,KAAKq3F,cAAW,IACnB,CACIH,UAAWl3F,KAAK2mB,QAAQkwE,WACxB1xE,QAAS,aACToC,aAAc,EAAAC,aAAasiB,OAC3BqtD,kBAAmB,SAACtpE,EAAQtW,EAAiB/F,EAAWvD,GACpD,WAAAwpF,iBAAgBlgF,EAAiB/F,EAAWvD,EAA5C,GAER,CACIipF,UAAWl3F,KAAK2mB,QAAQmwE,aACxB3xE,QAAS,eACToC,aAAc,EAAAC,aAAasiB,OAC3BqtD,kBAAmB,SAACtpE,EAAQtW,EAAiB/F,EAAWvD,GACpD,WAAAypF,mBAAkBngF,EAAiB/F,EAAWvD,EAA9C,GAER,CACIipF,UAAWl3F,KAAK2mB,QAAQowE,aACxB5xE,QAAS,cACToC,aAAc,EAAAC,aAAasiB,OAC3BqtD,kBAAmB,SAACtpE,EAAQtW,EAAiB/F,EAAWvD,GACpD,WAAA0pF,mBAAkBpgF,EAAiB/F,EAAWvD,EAA9C,K,GAIJ,KAAA2pF,cAA2B,CAC/B,CACIV,UAAWl3F,KAAK2mB,QAAQswE,mBACxBE,kBAAmB,SAAC1gG,EAAO6gG,EAAkB9lF,EAAWvD,GACpD,WAAA4pF,8BAA6BphG,EAAO+a,EAAWvD,EAA/C,EACJkX,QAAS,qBACToC,aAAc,EAAAC,aAAa6wC,YAE/Br4D,KAAKoZ,SArKyD,CAwQtE,OAnQI,YAAAm6B,QAAA,WACI,MAAO,YACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,CAClB,EAOA,YAAA2uB,QAAA,WACI1zC,KAAK+kB,OAAS,IAClB,EAEQ,YAAA+yE,kCAAR,SAA0C/yE,EAAiBwW,GACvD,IAAMiB,EAAWjB,EAAMiB,SACjBvnB,EAAY8P,EAAOyE,kBACrBuuE,GAAe,EACnB,GAC2B,eAAvBv7D,EAASw7D,WACT/iF,GACmB,UAAnBA,EAAUb,MACVa,EAAUya,MAAMC,WACC,KAAjB6M,EAASuN,KACX,CACQ,MAA+D/pC,KAAK2mB,QAAlE,EAAQ,WAAE,EAAO,UAAE,EAAU,aAAE,EAAU,aAAE,EAAa,iBAEhE,IAAAje,wCACIqc,GACA,SAACtuB,EAAO8gB,EAAiB0gF,EAAYC,GACjC,IAAMzR,GAAO,IAAA0R,kBAAiB1hG,EAAO,EAAY,GAC3ColB,GAAe,IAAA1S,gBAAeoO,EAAiB,CACjD6B,SAAQ,EACRE,QAAO,EACPD,WAAU,IAId,OAFA0+E,IAAiBl8E,KAAkB4qE,GAE5B,CACX,G,CAGR,OAAOsR,CACX,EAEA,YAAAxlD,2BAAA,SAA2BhX,GACvB,SAAIv7B,KAAK+kB,QAEI,UADDwW,EAAMsE,YAEC7/B,KAAK83F,kCAAkC93F,KAAK+kB,OAAQwW,EAI3E,EAQA,YAAA+W,cAAA,SAAc/W,GACV,GAAIv7B,KAAK+kB,OACL,OAAQwW,EAAMsE,WACV,IAAK,QACD7/B,KAAKo4F,uBAAuBp4F,KAAK+kB,OAAQwW,GACzC,MACJ,IAAK,UACDv7B,KAAKq4F,mBAAmBr4F,KAAK+kB,OAAQwW,GACrC,MACJ,IAAK,iBACDv7B,KAAK6gD,0BAA0B7gD,KAAK+kB,OAAQwW,GAI5D,EA+EQ,YAAA+8D,qBAAR,SAA6BvzE,EAAiByyE,GAC1C,IAAMlwE,EAA2C,CAC7CC,aAAc,GACdpC,QAAS,GACTuC,mBAAenjB,GAmCnB,OAhCA,IAAAmE,wCACIqc,GACA,SAACtuB,EAAO8gB,EAAiB/F,EAAW0mF,EAAejqF,G,QAC3CsqF,OAAsCh0F,E,WAC/Bi0F,GACP,GAAIA,EAAQtB,QAAS,CACjB,IAAM,EAASsB,EAAQrB,kBACnB1gG,EACA8gB,EACA/F,EACAvD,GAGJ,GAAI,E,MACsB,kBAAX,IACPqZ,EAAcI,cAAgB,WAAM,WAExC6wE,EAAiBC,E,cAb7B,IAAsB,qBAAAhB,GAAQ,oB,YAAZ,SAAY,Y,kGAwB9B,OALIe,IACAjxE,EAAcC,aAAegxE,EAAehxE,aAC5CD,EAAcnC,QAAUozE,EAAepzE,WAGlCozE,CACb,GACAjxE,GAEGA,CACX,EAEQ,YAAA8wE,uBAAR,SAA+BrzE,EAAiBwW,GAC5C,IAAMiB,EAAWjB,EAAMiB,SACjBvnB,EAAY8P,EAAOyE,kBAEE,eAAvBgT,EAASw7D,WACT/iF,GACmB,UAAnBA,EAAUb,MACVa,EAAUya,MAAMC,WAGP,MADD6M,EAASuN,MAET/pC,KAAKs4F,qBAAqBvzE,EAAQ/kB,KAAKw3F,SAIvD,EAEQ,YAAAa,mBAAR,SAA2BtzE,EAAiBwW,GACxC,IAAMiB,EAAWjB,EAAMiB,SACvB,IAAKA,EAASkjB,mBAAqBnkB,EAAMk9D,qBACrC,OAAQj8D,EAASrnC,KACb,IAAK,YACG6K,KAAK2mB,QAAQiwE,aACb,IAAA8B,QAAO3zE,EAAQyX,GAEnB,MACJ,IAAK,MACIA,EAASslB,UAEkB,kBADP9hD,KAAKs4F,qBAAqBvzE,EAAQ/kB,KAAKq3F,aAC3ClyE,SACboW,EAAMiB,SAASwf,iBAGvB,MACJ,IAAK,QAE2B,sBADPh8C,KAAKs4F,qBAAqBvzE,EAAQ/kB,KAAK43F,eAC3CzyE,SACboW,EAAMiB,SAASwf,iBAKnC,EAEQ,YAAA6E,0BAAR,SAAkC97B,EAAiBwW,GACzC,MAAoCv7B,KAAK2mB,QAAvCvN,EAAQ,WAAEE,EAAO,UAAED,EAAU,aACjB,SAAhBkiB,EAAMsO,SAAsBzwB,GAAYE,GAAWD,KACnD,IAAAoS,YAAW1G,EAAQ,CACf3L,SAAQ,EACRE,QAAO,EACPD,WAAU,GAGtB,EACJ,EAxRA,GAAa,EAAAs/E,iBAAAA,EA0Rb,IAAMvB,EAAe,SAAC9sE,EAAe/P,EAAa5N,GAC9C,IAAMisF,EAAStuE,EAAIrD,cAAc,KAGjC,OAFA2xE,EAAOh9E,KAAOrB,EACdq+E,EAAOn8D,YAAc9vB,EACdisF,CACX,C,qKCvVA,WAYMC,EAAoE,CACtE,IACA,IACA,IACA,IACA,IACA,KAGEC,EAA0C,CAC5CxgF,MAAO,MACP4O,QAAS,gBAGP6xE,EAGF,IAAIC,IAAI,CACR,CACI,K,eAEIlgF,UAAW,WACX9M,YAAa,WACb+M,aAAc,YACdhN,WAAY,YACT+sF,IAGX,CACI,K,eAEIhgF,UAAW,aACX9M,YAAa,WACb+M,aAAc,WACdhN,WAAY,YACT+sF,IAGX,CACI,K,eAEIhgF,UAAW,YACX9M,YAAa,WACb+M,aAAc,YACdhN,WAAY,YACT+sF,IAGX,CACI,K,eAEIhgF,UAAW,WACX9M,YAAa,WACb+M,aAAc,aACdhN,WAAY,YACT+sF,IAGX,CACI,K,eAEIhgF,UAAW,WACX9M,YAAa,WACb+M,aAAc,YACdhN,WAAY,YACT+sF,IAGX,CACI,K,eAEIhgF,UAAW,aACX9M,YAAa,WACb+M,aAAc,aACdhN,WAAY,YACT+sF,MAaf,SAAgBG,EACZxiG,EACAwX,EACAirF,GAEA,IAAM7+F,GAAK,IAAA2jE,eAAc,KAAM+6B,EAAqBr6F,IAAIw6F,IAClD5uE,GAAM,IAAAC,+BACZ,IAAA1T,UAASyT,EAAKjwB,IACd,IAAAmwB,YAAW/zB,EAAO6zB,EAAKrc,EAC3B,CATA,kCAoBa,EAAA4pF,6BAA+B,SACxCphG,EACA+a,EACAvD,GAGA,IAAMrD,GAAS,IAAAV,sBACXzT,EACA,CAAC,YACD,CAAC,YAAa,oBAElB,GACImU,EAAO,IACsB,cAA7BA,EAAO,GAAGR,MAAMK,WACkB,YAAlCG,EAAO,GAAGR,MAAMO,eAEhB,OAAO,EAGX,IAAMwuF,EAAU3nF,EAAUpF,SAASK,QAC/B,SAAC2sF,EAAK7rF,GAAY,MAAyB,SAAxBA,EAAQhB,YAAyB6sF,EAAM7rF,EAAQZ,KAAOysF,CAAvD,GAClB,IAGJ,QAAID,EAAQxiG,OAAS,IAIdkiG,EAAgCvrF,MAAK,SAAA+rF,GACxC,IAAMC,EAAeH,EAAQ99F,MAAM,IAAIkV,OAAM,SAAAhV,GAAQ,OAAAA,IAAS89F,CAAT,IAMrD,OALIC,IACA9nF,EAAUpF,SAAWoF,EAAUpF,SAASC,QAAO,SAAA1U,GAAK,MAAiB,QAAjBA,EAAE4U,WAAF,IACpD0sF,EAA8BxiG,EAAOwX,EAASorF,GAC9CprF,EAAQo1B,oBAAqB,GAE1Bi2D,CACX,GACJ,C,wGCpKA,eAUA,2BACI/hF,EACA/F,EACAvD,GAEA,IAAM7B,EAAWmL,EAAgB5K,KAAKtR,MAAM,KAE5C,GAAe,OADA+Q,EAASA,EAASzV,OAAS,GACrB,CACjB,IAAM4iG,EAAYhiF,EAAgB5K,KAAK+1B,YAAY,MAInD,OAHMrxB,GAAc,IAAA1K,kBAAiB4Q,EAAiB/F,EAAW+nF,EAAWA,EAAY,IAC5E5sF,KAAO0E,EAAY1E,KAAKE,QAAQ,KAAM,KAClDoB,EAAQo1B,oBAAqB,GACtB,C,CAEP,IAAM12B,EAAOP,EAASpO,MAEtB,GADkB2O,IAAQA,aAAI,EAAJA,EAAMtM,QAAQ,QAAS,GAChB,OAAhBsM,EAAKkF,OAAiB,CAC7B0nF,EAAYhiF,EAAgB5K,KAAKtM,QAAQsM,GAA/C,IACM0E,EAOAmoF,GAPAnoF,GAAc,IAAA1K,kBAChB4Q,EACA/F,EACA+nF,EACAA,EAAY5sF,EAAKhW,OAAS,IAGCgW,KAAKhW,OACpC,GAA4B,MAAxB0a,EAAY1E,KAAK,IAAmD,MAArC0E,EAAY1E,KAAK6sF,EAAa,GAG7D,OAFAnoF,EAAY1E,KAAO0E,EAAY1E,KAAKE,QAAQ,KAAM,KAClDoB,EAAQo1B,oBAAqB,GACtB,C,CAInB,OAAO,CACX,C,oGC5CA,eACA,WAWA,sBAA2Bte,EAAiB5L,GACxC,IAAI4oC,EAA0B,KACxB03C,EAA4B,IAElC,IAAA/wF,wCACIqc,GACA,SAAC8I,EAAQtgB,EAASiE,GACd,IAAIkoF,EAA2C,KAE/C,QAAInsF,EAAQpQ,QAGPu8F,GAAkB,IAAAxwF,aAAYqE,EAASiE,EAAW2H,MACnDugF,EAAgBv8F,OAEhBs8F,EAAMh5F,KAAKi5F,EAAgBv8F,MAEpB,GAIf,GACA,CACIoqB,aAAc,EAAAC,aAAa0wC,SAC3BrsC,cAAe,SAACC,EAAc3tB,IACrB4jD,GAAc03C,EAAMp5F,QAAQyrB,IAAqC,IAClEi2B,EAAa5jD,EAErB,EACAupB,cAAe,WAAM,OAAAq6B,CAAA,GAGjC,C,+FC5CA,eAOA,kBAAuBh9B,EAAiByX,IACpC,IAAA9zB,wCAAuCqc,GAAQ,SAAC8I,EAAQ/R,EAAam8E,GACjE,SAAIn8E,aAAW,EAAXA,EAAa3e,QACb2e,EAAY3e,UAAOoH,EACnBi4B,EAASwf,kBAEF,EAGf,GACJ,C,8GCXA,kCAAuC29C,GACnC,IAAMx6F,EAAQw6F,EAAO1+F,cACrB,GAAIkE,EAAO,CAEP,IADA,IAAItC,EAAS,EACJ/D,EAAI,EAAGA,EAAIqG,EAAMxI,OAAQmC,IAE9B+D,EAAkB,GAATA,GADQsC,EAAMopE,WAAWzvE,GAAK,GAAK,GAIhD,OAAO+D,C,CAGf,C,kGClBA,eAKA,oBAAyB+8F,GACrB,IAAMtqF,EAAQsqF,EAAU/sF,QAAQ,iBAAkB,IAC5CgtF,EAAcn+F,SAAS4T,GAC7B,OAAQlQ,MAAMy6F,IAA6B,IAAAC,wBAAuBxqF,GAArCuqF,CACjC,C,0GCTA,eACA,WAOA,WAoBA,4BACIpjG,EACAsjG,EACAC,QADA,IAAAD,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,GAEA,IAAM1kE,GAAgC,IAAAxlB,kCAAiCrZ,GAAO,GAC9E,GAAK6+B,EAA8B,GAAnC,CAGA,IAAM7jB,EAAS6jB,EAA8B,GAAG,GAC1C9jB,EAAY8jB,EAA8B,GAAG,GAC7C2kE,EAAoBzoF,aAAS,EAATA,EAAWpF,SAAS,GAE9C,GACIqF,GACsB,mBAAtBA,EAAOlF,aACP0tF,GACiC,QAAjCA,EAAkB1tF,YACpB,CACE,IAAM2tF,EAAaD,EAAkBttF,KAAKkF,OACpCsoF,EAAaC,EAAe17F,IAAIw7F,GAEtC,GAAIC,GAAcJ,EACd,MAAO,CAAEjrF,SAAU,KAAMg2E,UAAWqV,GACjC,GAAIH,EAA0B,CAC3B,MAAoCK,EAAqB5jG,EAAO+a,GAA9D8oF,EAAY,eAAEC,EAAe,kBAC/BC,EAAgBC,EAAqBhkG,EAAO6jG,GAC5CI,EAAoBC,EAAqBL,GACzCM,GAAgB,IAAAC,uBAClBX,EACAM,EACAE,GAGJ,GAAIE,EACA,MAAO,CACH9rF,SAAU,KACVg2E,UAAW8V,EACXtrF,MAAOwrF,EACHZ,EACAQ,EACAE,EACAJ,EACAD,G,GAOxB,EAEA,IAAMO,EAAW,SACbZ,EACAQ,EACAE,EACAJ,EACAD,GAEA,IAAM9a,EAAUsb,EAAUb,GAC1B,OAAOQ,GAAqBA,IAAsBE,GAAiBnb,EAC7D,GACCA,GAAWib,IAAsBE,GAAiBL,GAAmBC,EACtEA,EAAgB,OAChBj2F,CACV,EAEMk2F,EAAuB,SACzBhkG,EACAukG,GAEA,OAAOA,GAAmB,IAAAjyF,2BAA0BtS,EAAOukG,GAAkBrkG,YAAS4N,CAC1F,EAEM81F,EAAuB,SACzB5jG,EACA+a,GAEA,IAAM5G,GAAS,IAAAV,sBACXzT,EACA,CAAC,YACD,CAAC,cACH,GACE6jG,OAAiD/1F,EACjDg2F,GAAkB,EACtB,GAAI3vF,EAAQ,CACR,IAAMqwF,EAAiBrwF,EAAOnN,OAAOmN,OAAOvK,QAAQmR,GAEpD,GAAIypF,GAAkB,EAClB,IAAK,IAAIniG,EAAImiG,EAAiB,EAAGniG,GAAK,EAAGA,IAAK,CAC1C,IAAMoU,EAAOtC,EAAOnN,OAAOmN,OAAO9R,GAClC,IAAI,IAAAkU,oBAAyCE,EAAM,YAAa,CAC5DotF,EAAeptF,EACf,K,CAEAqtF,EAAkBU,EAAiB,C,EAMnD,MAAO,CAAEX,aAAY,EAAEC,gBAAe,EAC1C,EAEMI,EAAuB,SAAClU,G,MAC1B,GAAKA,KAAQA,EAAKt5E,OAAOxW,OAAS,GAGlC,OAAyC,QAAlC,OAAAqY,oBAAmBy3E,EAAKt5E,OAAO,WAAG,eAAEk2E,gBAC/C,EAEM+W,EAAsC,IAAIpB,IAAoB,CAChE,CAAC,IAAK,EAAA7hC,eAAeE,MACrB,CAAC,IAAK,EAAAF,eAAeG,MACrB,CAAC,KAAM,EAAAH,eAAeI,QACtB,CAAC,KAAM,EAAAJ,eAAeM,WACtB,CAAC,SAAO,EAAAN,eAAeS,iBACvB,CAAC,KAAM,EAAAT,eAAeO,eACtB,CAAC,IAAK,EAAAP,eAAeK,YACrB,CAAC,IAAK,EAAAL,eAAeQ,UAGnBojC,EAAY,SAACb,GACf,IAAMzoF,EAASyoF,EAAWrtF,QAAQ,WAAY,IAE9C,MADgB,YACD2N,KAAK/I,EACxB,C,+HC1JA,IAGWypF,EAQAC,EAXX,WACA,YAEA,SAAWD,GACP,yBACA,+BACA,+BACA,+BACA,8BACH,CAND,CAAWA,IAAAA,EAAc,KAQzB,SAAWC,GACP,iBACA,mBACA,iCACA,4CACH,CALD,CAAWA,IAAAA,EAAS,KAOpB,IAAMC,EAAqC,CACvC,IAAK,EACL,IAAK,EACL,IAAK,GAGHC,EAAkB,CACpB,EAAA9iC,kBAAkBa,WAClB,EAAAb,kBAAkBgB,eAClB,EAAAhB,kBAAkBe,4BAClB,EAAAf,kBAAkBc,uBAEhBiiC,EAAkB,CACpB,EAAA/iC,kBAAkBiB,WAClB,EAAAjB,kBAAkBoB,eAClB,EAAApB,kBAAkBmB,4BAClB,EAAAnB,kBAAkBkB,uBAEhB8hC,EAAoB,CAAC,IAAK,IAAK,IAAK,IAAK,KACzCC,EAAoB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACnDC,EAAoB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAoCnDC,IAAkB,MACpB,GAA0B,SAAAngG,GAAQ,OAAAogG,EAAcpgG,SAASgJ,CAAvB,EAClC,KAA6B,SAAAhJ,GAAQ,OAAAqgG,EAAgBrgG,SAASgJ,CAAzB,EACrC,KAA6B,SAAAhJ,GAAQ,OAAAsgG,EAAgBtgG,SAASgJ,CAAzB,EACrC,KAA6B,SAAAhJ,GAAQ,OAAAugG,EAAgBvgG,SAASgJ,CAAzB,EACrC,KAA6B,SAAAhJ,GAAQ,OAAAwgG,EAAgBxgG,SAASgJ,CAAzB,E,GAGnCw3F,IAAe,MACjB,GAAiB,EAAAxjC,kBAAkBiB,WACnC,KAAkB,EAAAjB,kBAAkBoB,eACpC,KAAyB,EAAApB,kBAAkBkB,sBAC3C,KAA+B,EAAAlB,kBAAkBmB,4B,GAG/CoiC,IAAe,MACjB,GAAiB,EAAAvjC,kBAAkBa,WACnC,KAAkB,EAAAb,kBAAkBgB,eACpC,KAAyB,EAAAhB,kBAAkBc,sBAC3C,KAA+B,EAAAd,kBAAkBe,4B,GAG/CuiC,IAAe,MACjB,GAAiB,EAAAtjC,kBAAkBS,WACnC,KAAkB,EAAAT,kBAAkBY,eACpC,KAAyB,EAAAZ,kBAAkBU,sBAC3C,KAA+B,EAAAV,kBAAkBW,4B,GAG/C0iC,IAAe,MACjB,GAAiB,EAAArjC,kBAAkBK,WACnC,KAAkB,EAAAL,kBAAkBQ,eACpC,KAAyB,EAAAR,kBAAkBM,sBAC3C,KAA+B,EAAAN,kBAAkBO,4B,GAG/C6iC,IAAa,MACf,GAAiB,EAAApjC,kBAAkBC,QACnC,KAAkB,EAAAD,kBAAkBE,YACpC,KAAyB,EAAAF,kBAAkBG,mBAC3C,KAA+B,EAAAH,kBAAkBI,yB,GAuBrD,iCACIqjC,EACAC,EACAvB,GAEA,IAAMwB,EAAUF,EAAiBnqF,OAC3BsqF,EAAqC,MAAfD,EAAQ,IAA8C,MAAhCA,EAAQA,EAAQvlG,OAAS,GAGrEijG,EAAYuC,EAAsBD,EAAQv/F,MAAM,GAAI,GAAKu/F,EAAQv/F,MAAM,GAAI,GAC3E2S,GAAQ,IAAAwrF,UAASlB,GACjBwC,EAAkBb,EAAkBl7F,QAAQu5F,GAAa,EAE/D,MACKtqF,GACDA,EAAQ,IACN2sF,GAAqBG,GACtBH,GAAqBG,IAwB9B,SAAuB9sF,EAAgB2sF,GACnC,OAAOA,GAAqB3sF,GAAS2sF,EAAoB,IAAM3sF,CACnE,CA1BkD+sF,CAAc/sF,EAAO2sF,IAJnE,CASA,IAAMrB,EAeV,SAA0BtrF,GACtB,OAAO3N,OAAO2N,IAAU,gBAAgBkL,KAAKlL,EACjD,CAjB0BgtF,CAAiB1C,GA1CT,SAC9B2C,EACAJ,EACAzB,GAEA,IAAM8B,EAAqBL,EACrB,EACAf,EAAWmB,EAAUA,EAAU5lG,OAAS,IAE9C,GAAI6lG,EAAoB,CACpB,IACM5B,EAxFgB,SAACjuF,EAAc+tF,GACzC,IAAKt7F,MAAM1D,SAASiR,IAChB,OAAO,EACJ,GAAI,UAAU6N,KAAK7N,GAAO,CAC7B,GAC2B,IAAtB+tF,GACGW,EAAgBh7F,QAAQq6F,IAAsB,GAC9Cc,EAAkBn7F,QAAQsM,EAAK,KAAO,IACxC+tF,GAA8B,MAAT/tF,EAEvB,OAAO,EACJ,GACmB,IAAtB+tF,IACEA,GAA8B,MAAT/tF,EAEvB,OAAO,C,MAER,GAAI,UAAU6N,KAAK7N,GAAO,CAC7B,GAC0B,GAArB+tF,GACGY,EAAgBj7F,QAAQq6F,IAAsB,GAC9Ce,EAAkBp7F,QAAQsM,EAAK,KAAO,IACxC+tF,GAA8B,MAAT/tF,EAEvB,OAAO,EACJ,GACkB,GAArB+tF,IACEA,GAA8B,MAAT/tF,EAEvB,OAAO,C,CAGnB,CAwD8B8vF,CADPN,EAAsBI,EAAU5/F,MAAM,GAAI,GAAK4/F,EAAU5/F,MAAM,GAAI,GAC9B+9F,GACpD,OAAOE,EAAgBc,EAAmBd,GAAe4B,QAAsBj4F,C,CAGvF,CA4BUm4F,CACIR,EACAC,EACAC,EAAkB1B,OAAoBn2F,QAE1CA,EACN,OAAOq2F,C,CACX,C,4HCvKA,WACA,WACA,WAgBA,+BACInkG,EACA+a,EACAvD,EACA8rF,EACAC,EACAhD,QAFA,IAAA+C,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,GAGA,IAAMz8E,GAAgB,IAAA46E,kBAAiB1hG,EAAOsjG,EAAuBC,GACrE,GAAIz8E,EAAe,CACf/L,EAAUpF,SAAShM,OAAO,EAAG,GACrB,IAAA0O,EAA+ByO,EAAa,SAAlCunE,EAAqBvnE,EAAa,UAAvBjO,EAAUiO,EAAa,MAKpD,OAJAo/E,EAAYlmG,EAAOqY,EAAUg2E,EAAWx1E,EAAO0nF,GAC/C/oF,EAAQo1B,oBAAqB,EAiCrC,SAAyB5sC,EAAqCwX,GACpD,IAAC4P,GAAD,aAAyB,IAAA3T,sBAC3BzT,EACA,CAAC,YACD,IACH,GAJ0B,GAM3B,GAAIonB,IAAwB,IAAA7Q,oBAAmB6Q,EAAqBzT,MAAO,YAAa,CAC5E,IAAA5M,EAAgBqgB,EAAoB,KAA9BzT,EAAUyT,EAAoB,MAC5C5P,EAAQkB,cAAe,IAAA/F,sBAAmB,oBAAEgB,IAAK,YAAK5M,IAAI,G,CAElE,CA3CQo/F,CAAgBnmG,EAAOwX,IAEhB,C,CAEX,OAAO,CACX,EAEA,IAAM0uF,EAAc,SAChBlmG,EACAqY,EACAg2E,EACAx1E,EACA0nF,IAEA,IAAApuF,aAAYnS,EAAOqY,EAAUkoF,GAC7B,IAAMj6E,EAA4B,MAAZjO,EAClBQ,GAASA,EAAQ,GAAKyN,IACtB,IAAAjU,yBAAwBrS,EAAO6Y,IAEnC,IAAAzG,mBACIpS,EACAsmB,EACM,CACIsmE,iBAAkByB,EAClB71E,yBAAyB,GAE7B,CACIq0E,mBAAoBwB,EACpB71E,yBAAyB,GAG3C,C,2GC/DA,eAOM4tF,EAAiC,IAAI7D,IAAoB,CAC3D,CAAC,MAAO,KACR,CAAC,MAAO,KACR,CAAC,MAAO,OAMZ,6BACIzhF,EACA/F,EACAvD,G,MAEM6uF,EAAgD,QAArC,EAAAvlF,EAAgB5K,KAAKtR,MAAM,KAAK2C,aAAK,eAAE6T,OAClDlF,EAAOmwF,EAAWD,EAAUn+F,IAAIo+F,QAAYv4F,EAElD,GAAIu4F,GAAYnwF,EAAM,CAClB,IAAM6sF,EAAajiF,EAAgB5K,KAAKhW,OAAS,EAC3C4iG,EAAYC,EAAasD,EAASnmG,OAKxC,OAJoB,IAAAgQ,kBAAiB4Q,EAAiB/F,EAAW+nF,EAAWC,GAChE7sF,KAAOA,EAEnBsB,EAAQo1B,oBAAqB,GACtB,C,CAGX,OAAO,CACX,C,2GCnCA,eAQM05D,EAAa,SAACjmG,GAMhB,MALyC,CACrC,EAAG,KACH,EAAG,KACH,EAAG,MAESA,IAAU,IAC9B,EAEMkmG,EAAW,CAAC,KAAM,KAAM,KAAM,MAqDpC,SAASC,EAAgBtwF,EAAcuwF,QAAA,IAAAA,IAAAA,GAAA,GACnC,IAAMC,EAASD,EAAgBvwF,EAAOA,EAAKzR,UAAU,EAAGyR,EAAKhW,OAjD1C,GAmDnB,GADiB,UAAU6jB,KAAK2iF,GAClB,CACV,IAAMC,EAAe1hG,SAASyhG,GAC9B,OAAO9lG,KAAK+vF,IAAIgW,GAAgB,GAC1BA,EACA1hG,SAASyhG,EAAOjiG,UAAUiiG,EAAOxmG,OAAS,G,CAEpD,OAAO,IACX,CAtDI,6BACA4gB,EACA/F,EACAvD,G,MAEMnX,EAA6C,QAArC,EAAAygB,EAAgB5K,KAAKtR,MAAM,KAAK2C,aAAK,eAAE6T,OACjDwrF,GAAuB,EAC3B,GAAIvmG,EAAO,CAEP,GADkBkmG,EAAS38F,QAAQvJ,IAAU,EAC9B,CACX,IAAMwY,EAAQkC,EAAUpF,SAAS/L,QAAQkX,GACnC+lF,EAAgB9rF,EAAUpF,SAASkD,EAAQ,GAC7C8tF,EAA8B,KAE9BE,GAC6B,QAA7BA,EAAc/wF,aACsE,QAAlF6wF,EAAeH,EAAgBK,EAAc3wF,MAAM,KACrDowF,EAAWK,KAAkBtmG,IAE7BumG,GAAuB,E,KAExB,CACH,IAAME,EAAUzmG,EAAMoE,UAAUpE,EAAMH,OA1B3B,GA4BU,QADfymG,EAAeH,EAAgBnmG,KACRimG,EAAWK,KAAkBG,IACtDF,GAAuB,E,CAI3BA,KACuB,IAAA12F,kBACnB4Q,EACA/F,EACA+F,EAAgB5K,KAAKhW,OAAS,EAC9B4gB,EAAgB5K,KAAKhW,OAAS,GAGnB4T,OAAO4hB,yBAA2B,QACjDle,EAAQo1B,oBAAqB,E,CAGrC,OAAOg6D,CACX,C,6GCrCA,iBASI,WAAoB12E,GAApB,WAAoB,KAAAA,QAAAA,EARZ,KAAAzU,UAAgC,KAChC,KAAA6S,OAAyB,KACzB,KAAAy4E,eAAyB,EAuEzB,KAAAC,UAAY,W,QACZ,EAAKvrF,WAAa,EAAKsrF,gBACH,QAApB,OAAK72E,SAAQ+2E,eAAO,gBAAG,EAAKxrF,WAC5B,EAAKsrF,eAAgB,EAE7B,CAtEqD,CAuEzD,OAlEI,YAAAjqD,QAAA,WACI,MAAO,aACX,EAMA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,CAClB,EAKA,YAAA2uB,QAAA,W,MACI1zC,KAAKy9F,aAEa,QAAd,EAAAz9F,KAAKkS,iBAAS,eAAEoD,cAChBtV,KAAKkS,UAAUoD,WAAW+gB,YAAYr2B,KAAKkS,WAC3ClS,KAAKkS,UAAY,MAErBlS,KAAK+kB,OAAS,IAClB,EAMA,YAAAutB,cAAA,SAAc/W,GACV,GAAuB,eAAnBA,EAAMsE,WAA8BtE,EAAMze,MAAMnmB,OAAS,EAAG,CACpD,IAAA6lC,EAAoBjB,EAAK,SAAfze,EAAUye,EAAK,MAEjCv7B,KAAKy9F,YAEAz9F,KAAK2mB,QAAQg3E,kBACdnhE,EAASwf,iBAGTh8C,KAAK49F,cAAcphE,EAAS+iB,MAAO/iB,EAASijB,SAC5Cz/C,KAAK2mB,QAAQk3E,OAAO79F,KAAKkS,UAAY4K,EAAc9c,KAAKy9F,WACxDz9F,KAAKw9F,eAAgB,E,CAGjC,EAEQ,YAAAI,cAAR,SAAsBzlG,EAAWC,G,QAW7B,OAVK4H,KAAKkS,WAAalS,KAAK+kB,SACxB/kB,KAAKkS,UAAYlS,KAAK+kB,OAAOiC,cAAcC,cAAc,OAEzDjnB,KAAKkS,UAAUqG,MAAMtB,SAAW,QAChCjX,KAAKkS,UAAUqG,MAAMD,MAAQ,IAC7BtY,KAAKkS,UAAUqG,MAAM6L,OAAS,IAC9BpkB,KAAK+kB,OAAOiC,cAAcoR,KAAKjR,YAAYnnB,KAAKkS,YAEtC,QAAd,EAAAlS,KAAKkS,iBAAS,SAAEqG,MAAMnN,YAAY,OAAQjT,EAAI,MAChC,QAAd,EAAA6H,KAAKkS,iBAAS,SAAEqG,MAAMnN,YAAY,MAAOhT,EAAI,QACpC4H,KAAKkS,SAClB,EAQJ,EAhFA,GAAa,EAAA4rF,sBAAAA,C,4GC/Bb,eA2CA,aAQI,WAAoBC,GAAA,KAAAA,mBAAAA,EAPZ,KAAAh5E,OAAyB,KACzB,KAAAi5E,YAAwB,EAM0B,CAkF9D,OA7EI,YAAAzqD,QAAA,WACI,MAAO,eACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,EACd/kB,KAAKg+F,YAAch+F,KAAK+9F,mBAAmBziG,KAAI,SAAAghF,GAC3C,OAAAA,EAAY2hB,gBAAgBthG,OAAO,EAAnC,GAER,EAOA,YAAA+2C,QAAA,WACI1zC,KAAK+kB,OAAS,IAClB,EAQA,YAAAutB,cAAA,SAAc/W,GACNv7B,KAAK+kB,QAEI,UADDwW,EAAMsE,WAEN7/B,KAAKo4F,uBAAuBp4F,KAAK+kB,OAAQwW,EAIzD,EAEQ,YAAA68D,uBAAR,SAA+BrzE,EAAiBwW,GAAhD,WACUiB,EAAWjB,EAAMiB,SACjBvnB,EAAY8P,EAAOyE,kBACnBr0B,EAAMqnC,EAASuN,KAEjB/pC,KAAK+9F,mBAAmBpnG,OAAS,GACV,eAAvB6lC,EAASw7D,WACT/iF,GACmB,UAAnBA,EAAUb,MACVa,EAAUya,MAAMC,WAChBx6B,GACA6K,KAAKg+F,YAAY39F,QAAQlL,IAAQ,IAEjC,IAAAuT,wCACIqc,GACA,SAAC8I,EAAQtW,EAAiB/F,EAAW0mF,EAAejqF,GAWhD,QAViB,EAAK8vF,mBAAmBzwF,MACrC,SAAC,G,IAAE2wF,EAAe,kBAAEC,EAAiB,oBACjC,OAAOC,EAD8C,sBAEjD5mF,EACA0mF,EACAC,EACA1sF,EAER,MAGAvD,EAAQo1B,oBAAqB,GACtB,EAGf,GAGZ,EACJ,EA1FA,GAAa,EAAA+6D,oBAAAA,C,mHC3Cb,WACA,WACA,WACA,UACA,WAoBMC,EAAsD,CACxDC,sBAAsB,EACtBC,aAAa,EACbC,gBAAgB,EAChBC,YAAY,EACZC,iBAAiB,GAGfC,EAAuD,CACzDL,sBAAsB,EACtBC,aAAa,EACbC,gBAAgB,EAChBC,YAAY,EACZC,iBAAiB,GAGfjI,EAAsF,CACxFmI,aAAcP,EACdQ,iCAAiC,GAUrC,aAYI,WAAYl4E,QAAA,IAAAA,IAAAA,EAAA,GAXJ,KAAA5B,OAAyB,KACzB,KAAA+1B,SAAgC,KAChC,KAAAgkD,4BAA6B,EAC7B,KAAAC,qBAA4C,KAC5C,KAAAC,kBAAkD,WAAM,UAQ5D,IAAMC,GACuB,IAAzBt4E,EAAQi4E,aACFD,GACyB,IAAzBh4E,EAAQi4E,cAA0Bj4E,EAAQi4E,cAE1C,EAAD,8BAAMP,GAA4B13E,EAAQi4E,cADzCP,EAEVr+F,KAAK2mB,SAAU,EAAH,6CAAQ8vE,GAAmB9vE,GAAO,CAAEi4E,aAAcK,GAClE,CA0OJ,OAxOY,YAAAC,yBAAR,SAAiCriG,GAC7B,OAAOA,EAAS,WAAM,UAAO,WAAM,SACvC,EAEQ,YAAAsiG,qBAAR,SAA6Bp6E,GACzB,cAAe/kB,KAAK2mB,QAAQy4E,sBACxB,IAAK,WACD,OAAOp/F,KAAK2mB,QAAQy4E,qBACxB,IAAK,UACD,OAAOp/F,KAAKk/F,yBAAyBl/F,KAAK2mB,QAAQy4E,sBACtD,QACI,OAAOp/F,KAAKk/F,yBACRn6E,EAAO2Y,6BAA6B,mBAGpD,EAKA,YAAA6V,QAAA,WACI,MAAO,MACX,EAQA,YAAAC,WAAA,SAAWzuB,GAAX,WACI/kB,KAAK+kB,OAASA,EACd/kB,KAAKg/F,kBAAoBh/F,KAAKm/F,qBAAqBp6E,GAE/CA,EAAOyK,iBAAiBstB,YACxB98C,KAAK86C,SAAW96C,KAAK+kB,OAAOohB,eAAe,CACvCk5D,YAAa,CACT94D,eAAgB,SAAAyU,GAAK,SAAKskD,uBAAuBv6E,EAAQi2B,EAApC,KAIrC,EAOA,YAAAtH,QAAA,W,MACI1zC,KAAK+kB,OAAS,KACD,QAAb,EAAA/kB,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,SAAW,IACpB,EAQA,YAAAxI,cAAA,SAAc/W,GACV,GAAIv7B,KAAK+kB,OACL,OAAQwW,EAAMsE,WACV,IAAK,UACD7/B,KAAKq4F,mBAAmBr4F,KAAK+kB,OAAQwW,GACrC,MACJ,IAAK,QACGv7B,KAAK++F,uBACL/+F,KAAK+kB,OAAO8K,gBAAgB7vB,KAAK++F,sBACjC/+F,KAAK++F,qBAAuB,MAKhD,EAUA,YAAAxsD,2BAAA,SAA2BhX,GACvB,GACIv7B,KAAK+kB,QACL/kB,KAAK2mB,QAAQi4E,aAAaJ,gBACP,WAAnBjjE,EAAMsE,WACgB,OAAtBtE,EAAMiB,SAASrnC,MACdomC,EAAMiB,SAASslB,SAClB,CACE,IAAM7sC,EAAYjV,KAAK+kB,OAAOyE,kBACxBsb,EACiB,UAAnB7vB,aAAS,EAATA,EAAWb,MAAkBa,EAAUya,MAAMoV,eAAiB,KAC5DvzB,EAAQuzB,EACR9kC,KAAK+kB,OAAOkE,eAAeijC,2BAA2BpnB,EAAgB,SACtE,KACAuJ,EAAc98B,IAAS,IAAAg+B,iBAAgBh+B,GAE7C,GAAI88B,EAAa,CACb,IAAMtsB,EAAUssB,EAAYA,EAAY13C,OAAS,GAC3C64C,EAAWztB,GAAWA,EAAQA,EAAQprB,OAAS,GAErD,GAAuB,iBAAZ64C,GAAwBA,EAASp6B,SAAS0vB,GAGjD,OAAO,C,EAKnB,OAAO,CACX,EAEQ,YAAAuzD,mBAAR,SAA2BtzE,EAAiBwW,GACxC,IAAMiB,EAAWjB,EAAMiB,SACjB+iE,EAAmB/iE,EAASsoB,SAAWtoB,EAASuoB,QAEtD,IAAKvoB,EAASkjB,mBAAqBnkB,EAAMk9D,qBACrC,OAAQj8D,EAASrnC,KACb,IAAK,YAGI6K,KAAKw/F,6BAA6Bz6E,KACnC,IAAA06E,gBAAe16E,EAAQyX,EAAUx8B,KAAK2mB,SAE1C,MAEJ,IAAK,SAII4U,EAAMiB,SAASslB,WAChB,IAAA29C,gBAAe16E,EAAQyX,EAAUx8B,KAAK2mB,SAE1C,MAEJ,IAAK,MACI44E,IACD,IAAAG,aAAY36E,EAAQyX,EAAUx8B,KAAK2mB,QAAQi4E,cAE/C,MACJ,IAAK,eACG75E,EAAOyK,iBAAiBstB,YACxB98C,KAAK8+F,4BAA6B,GAEtC,MAEJ,IAAK,QAEIS,GACAhkE,EAAMiB,SAASwiB,aA5MvB,MA6MOzjB,EAAMiB,SAASmjE,UAEf,IAAAC,eACI76E,EACAyX,EACAx8B,KAAKg/F,kBAAkBj6E,GACvB/kB,KAAK2mB,QAAQk5E,0BAGrB,MAEJ,SACI,IAAAC,eAAc/6E,EAAQyX,GAItC,EAEQ,YAAA8iE,uBAAR,SAA+Bv6E,EAAiByX,GAG5C,GACKx8B,KAAK8+F,4BACJtiE,aAAoBujE,aACtBvjE,EAASkjB,iBAHb,CAOA1/C,KAAK8+F,4BAA6B,EAElC,IAAIkB,GAAU,EACd,OAAQxjE,EAASw7D,WACb,IAAK,wBACIh4F,KAAKw/F,6BAA6Bz6E,KAEnCi7E,GAAU,IAAAP,gBACN16E,EACA,IAAIk7E,cAAc,UAAW,CACzB9qG,IAAK,YACLwqG,QA5PN,EA6PMO,MA7PN,IA+PElgG,KAAK2mB,UAGb,MACJ,IAAK,uBACDq5E,GAAU,IAAAP,gBACN16E,EACA,IAAIk7E,cAAc,UAAW,CACzB9qG,IAAK,SACLwqG,QAvQL,GAwQKO,MAxQL,KA0QClgG,KAAK2mB,SAKbq5E,IACAxjE,EAASwf,iBAITh8C,KAAK++F,qBAAuBh6E,EAAOyE,kB,CAE3C,EAEQ,YAAAg2E,6BAAR,SAAqCz6E,GACjC,IAAMo7E,EAAMngG,KAAK2mB,QAAQy5E,yBACzB,cAAeD,GACX,IAAK,WACD,OAAOA,EAAIp7E,GACf,IAAK,UACD,OAAOo7E,EACX,QACI,OAAO,EAEnB,EACJ,EA9PA,GAAa,EAAAE,WAAAA,C,gHCpDb,eAMa,EAAAC,uBAA8C,SAAAryF,GACvD,GAA4B,cAAxBA,EAAQuJ,aAQZ,IAJM,MAAwBvJ,EAAQqD,YAA9BE,EAAS,YAAEC,EAAM,SACnBnC,EAAQkC,EAAUpF,SAAS/L,QAAQoR,GACnC01C,GAAmB,IAAA98C,aAAYmH,GAE5B1Y,EAAIwW,EAAQ,EAAGxW,GAAK,EAAGA,IAAK,CACjC,IAAMyU,EAAU45C,EAAiB/6C,SAAStT,GAE1CyU,EAAQH,YAAa,GAEjB,IAAAioE,eAAc7jE,EAAWjE,EAASU,EAAQ0uE,iBAC1C1uE,EAAQuJ,aAAe,Q,CAGnC,C,qHCxBA,eACA,WACA,WACA,WAwBA,uCACIhN,EACAmc,GAEA,OAAO,SAAA1Y,G,MACH,GAA4B,cAAxBA,EAAQuJ,aAAZ,CAIA,IAAMgxD,EAAyB,WAAbh+D,EACZ,EAA4CyD,EAAQqD,YAAlDE,EAAS,YAAEC,EAAM,SAAEjU,EAAI,OAAEqV,EAAY,eACvCzG,EAAWoF,EAAUpF,UA6GnC,SAAiBoF,G,QACLpF,EAAaoF,EAAS,SAE9B,GAAkD,OAAjB,QAA7B,EAAApF,EAASA,EAASzV,OAAS,UAAE,eAAE4V,aAAqB,CACpD,IAAMg0F,EAAoBn0F,EAASC,QAAO,SAAAlU,GAAK,MAAiB,mBAAjBA,EAAEoU,WAAF,IAEqB,OAAjB,QAA/C,EAAAg0F,EAAkBA,EAAkB5pG,OAAS,UAAE,eAAE4V,eACjD,IAAAlC,aAAYmH,GAAWpF,SAASpO,K,CAG5C,CArHQwiG,CAAQhvF,GAER,IAEI6qE,EACAnnE,EAHE5F,EAAQlD,EAAS/L,QAAQoR,IAAW+2D,EAAY,GAAK,GACrD4U,EAAkBhxE,EAASkD,GAIjC,GAAI8tE,GACI,IAAA/H,eAAc7jE,EAAW4rE,EAAiBnvE,EAAQ0uE,cAAenyE,KACjEyD,EAAQuJ,aAAe,cAIvB,IAAAZ,yBAAwBpF,SAEzB,GAwEf,SACIg3D,EACAp8D,EACAoF,EACAhU,GAEA,OACKgrE,GACkB,GAAnBp8D,EAASzV,QACkB,mBAA3ByV,EAAS,GAAGG,aACZiF,EAAUjH,OAAOW,YACjBxP,SAAS8V,EAAUjH,OAAOW,cAC1B,IAAA+G,mCAAkCzU,EAAM,CAAC,WAAY,aAAc,CAAC,cAAgB,CAE5F,CArFYijG,CAAuBj4B,EAAWp8D,EAAUoF,EAAWhU,KACtD0X,EAiEb,SAAiB1X,GACb,IAAMkjG,EAAaljG,EAAKA,EAAK7G,OAAS,GACtC,MAAoC,YAA7B+pG,EAAW/1F,eAA+B+1F,EAAa,IAClE,CApEoBC,CAAQnjG,KAEhB,IAAAwL,qBAAoBkM,EAAM,WAC1BjH,EAAQuJ,aAAe,aACpB,GAAK6kE,GAAgB,IAAAukB,qBAAoBpjG,EAAMgU,EAAWg3D,GAAa,CAClE,IAAOr+D,EAAwCkyE,EAAa,MAAtC,EAAyBA,EAAa,KAAhCwkB,EAAmBxkB,EAAa,eAEpE,GAA+B,aAA3BlyE,EAAcM,UAA0B,CACxC,IAAML,GAAQ,IAAAC,aAAYF,GAEtB02F,GAEI,IAAAxrB,eAAcjrE,EAAOy2F,EAAgB5yF,EAAQ0uE,cAAenyE,KAC5DyD,EAAQuJ,aAAe,UAGvBgxD,EACAv6D,EAAQmf,cAAgBhjB,GAEsC,OAAjB,QAAzC,EAAAA,EAAMgC,SAAShC,EAAMgC,SAASzV,OAAS,UAAE,eAAE4V,eAC3C,IAAAlC,aAAYD,GAAOgC,SAASpO,MAGhCiQ,EAAQqD,YAAc,CAClBG,OAAM,EACND,UAAWpH,EACX5M,KAAI,EACJqV,aAAY,GAEhB5E,EAAQmf,cAAgB5b,IAG5B,IAAAsvF,yBACIn6E,EAAQk5E,yBACR5xF,EAAQqD,YAAYE,UACpBvD,EAAQmf,eAGZnf,EAAQuJ,aAAe,SAI3BvJ,EAAQ8uE,iBAAmBlqE,C,MAGvB,IAAAyiE,cACI,IAAAjrE,aAAY,EAAK,IAAIO,OACrBT,OACA5F,EACA0J,EAAQ0uE,cACRnyE,KAGJyD,EAAQuJ,aAAe,Q,MAO/BvJ,EAAQuJ,aAAe,iB,CAE/B,CACJ,C,yHCxHA,WAkBa,EAAAupF,iBAAwC,SAAA9yF,GACzC,IAAAuJ,EAAiBvJ,EAAO,aAEhC,GACoB,mBAAhBuJ,GACgB,cAAhBA,GACgB,SAAhBA,EACF,CACU,IAAAlG,EAA+BrD,EAAO,YAAzB0uE,EAAkB1uE,EAAO,cACtCzQ,EAAoB8T,EAAW,KAAzBE,EAAcF,EAAW,UACjCkrB,EAAWmgD,aAAa,EAAbA,EAAengD,SAC1BltB,GAAQ,IAAA2C,mCACVzU,EACA,CAAC,mBACD,CAAC,YAAa,aAEZo0F,EAAQp0F,EAAK8R,GAEnB,GAAIsiF,GAAkC,oBAAzBA,EAAMjnF,gBAAyD,cAAjBinF,EAAMzhF,QAAyB,CACtF,IAAM,EAAS3S,EAAK8R,EAAQ,GACtB0xF,EAAkB,EAAOp2F,OAAOvK,QAAQuxF,GAE1CqP,EAAarP,KACb,IAAAnhF,aAAY,EAAQmhF,GACpBp1D,SAAAA,EAAUwf,iBACV/tC,EAAQuJ,aAAe,SAEL,WAAlBglB,aAAQ,EAARA,EAAUrnC,MACVy8F,EAAMhnF,OAAOvK,QAAQmR,IAAc,GACnC0vF,EAAiB1vF,KAEjB2vF,GAAc,IAAA92F,aAAYunF,GAAQ,EAAQoP,EAAiBxvF,GAC3DgrB,SAAAA,EAAUwf,iBACV/tC,EAAQuJ,aAAe,Q,EAIvC,EAEA,IAAMypF,EAAe,SAACrP,GAClB,OAC4B,IAAxBA,EAAMhnF,OAAOjU,QACiB,cAA9Bi7F,EAAMhnF,OAAO,GAAGH,WAChBy2F,EAAiBtP,EAAMhnF,OAAO,GAEtC,EAEMs2F,EAAmB,SAAC1vF,GACtB,OAAOA,EAAUpF,SAASmE,OACtB,SAAA5Y,GAAK,MAAkB,oBAAlBA,EAAE4U,aAAuD,OAAlB5U,EAAE4U,WAAzC,GAEb,EAEM40F,EAAgB,SAClBvP,EACAn0F,EACA2jG,EACA5vF,G,MAEM6wC,EAAYuvC,EAAMhnF,OAAOvK,QAAQmR,GAEvC,GAAI6wC,GAAa,EAAG,CAChB,IAAMg/C,GAAgB,IAAAh3F,aAAY5M,GAElC,GAAI4kD,EAAYuvC,EAAMhnF,OAAOjU,OAAS,EAAG,CACrC,IAAM2qG,GAAsD,IAAA5wF,uBACxDkhF,EAAMzhF,QACNyhF,EAAMrnF,SAGV,EAAA+2F,EAAS12F,QAAOnK,KAAI,4CACbmxF,EAAMhnF,OAAOxK,OAAOiiD,EAAY,EAAGuvC,EAAMhnF,OAAOjU,OAAS0rD,EAAY,KAAE,IAG9Eg/C,EAAcz2F,OAAOxK,OAAOghG,EAAa,EAAG,EAAGE,E,CAGnDD,EAAcz2F,OAAOxK,OAAOghG,EAAa,EAAG,EAAG5vF,GAC/CogF,EAAMhnF,OAAOxK,OAAOiiD,EAAW,GAEJ,GAAvBuvC,EAAMhnF,OAAOjU,QACb0qG,EAAcz2F,OAAOxK,OAAOghG,EAAY,E,CAGpD,C,mHCtGA,WAca,EAAAG,WAAkC,SAAAtzF,G,QAC3C,GAA4B,cAAxBA,EAAQuJ,aAAZ,CAIM,MAA8BvJ,EAAQqD,YAApCE,EAAS,YAAEC,EAAM,SAAEjU,EAAI,OACzB8R,GAAQ,IAAA2C,mCACVzU,EACA,CAAC,YACD,CAAC,YAAa,oBAEZ0P,EAAO1P,EAAK8R,GACZ7R,EAASD,EAAK8R,EAAQ,GAE5B,GAC4B,aAAxBpC,aAAI,EAAJA,EAAMvC,iBACNuC,EAAKC,OAAOxW,OAAS,GACrB6a,EAAUpF,SAAS,IAAMqF,GACzBhU,EACF,CACE,IAAM+jG,GAAc,IAAAn3F,aAAY6C,GAC1ByB,EAAY6yF,EAAYr0F,OAAOq0F,EAAYr0F,OAAOxW,OAAS,GAC3DymD,EAAgB3/C,EAAOmN,OAAOvK,QAAQ6M,GACtCsB,EAAe/Q,EAAOmN,OAAOwyC,EAAgB,GAOnD,GAA4C,SAAxCzuC,EAAUpE,OAAO0S,oBACjBukF,EAAYr0F,OAAOnP,MAEnBiQ,EAAQuJ,aAAe,aACpB,GACHtK,EAAKtC,OAAO,IAAM4G,GACS,eAA3BhD,aAAY,EAAZA,EAAc/D,YACiB,YAA/B+D,EAAa7D,gBACb6D,EAAarB,OAAOxW,QAAU6qG,EAAYr0F,OAAOxW,QAIjD,GAF4B,IAAA0T,aAAYmE,GAEpB5D,QAAOnK,KAAI,4CAAI+gG,EAAY52F,SAAM,KACrD,IAAAP,aAAY5M,GAAQmN,OAAOxK,OAAOg9C,EAAe,GAEjDnvC,EAAQuJ,aAAe,YACpB,CACH,IAAMiqF,EAAgBD,EAAY52F,OAAOxK,OACrCohG,EAAY52F,OAAOvK,QAAQmR,GAC3BgwF,EAAY52F,OAAOjU,QAGvB,GAAI6qG,EAAYr0F,OAAOxW,OAAS,EAAG,CAC/B,IAAM0nB,GAAc,IAAAC,gBAChBkjF,EAAYr0F,OAAOxQ,MAAM,GAAI,GAC7B6kG,EAAYxuF,aAAazI,QAG7B8T,EAAYzT,OAAS62F,EAAcnmG,KAC/B,SAAA8O,GAAS,WAAAC,aAAYD,EAAZ,KAGb,IAAAC,aAAY5M,GAAQmN,OAAOxK,OAAOg9C,EAAgB,EAAG,EAAG/+B,E,MAExD,OAAAhU,aAAY5M,GAAQmN,QAAOxK,OAAM,6BAACg9C,EAAgB,EAAG,IAAC,YAAKqkD,IAAa,IAG5ExzF,EAAQuJ,aAAe,O,GAGnC,C,8GCpFA,eAMa,EAAAkqF,qBAA4C,SAAAzzF,GACrD,GAA6B,oBAAzBA,EAAQuJ,aAAoC,CACpC,IAAAlG,EAAgBrD,EAAO,YACvBuD,EAAoBF,EAAW,UAApB9T,EAAS8T,EAAW,KACjCgD,EAAQ9W,EAAK,GACbmkG,EAAcnkG,EAAK,GAKrBgU,EAAUpF,SAASmE,OACf,SAAA5Y,GAAK,MAAkB,oBAAlBA,EAAE4U,aAAuD,OAAlB5U,EAAE4U,WAAzC,KAETiF,EAAUpF,SAASC,QAAO,SAAA1U,GAAK,MAAkB,OAAlBA,EAAE4U,WAAF,IAAwB5V,QAAU,IAE7DC,OAAOsF,KAAKsV,EAAUjH,QAAQ5T,OAAS,GACvC6a,EAAUjH,OAAS,CAAC,EACpB0D,EAAQuJ,aAAe,SAEA,GAAvBlD,EAAM1J,OAAOjU,QACb2d,EAAM1J,OAAO,IAAM4G,IACnBmwF,GACyB,mBAAxBrtF,EAAM3J,gBACqB,YAAxB2J,EAAM3J,gBACkB,WAAxB2J,EAAM3J,kBAGV,IAAA8F,aAAYkxF,EAAartF,GAEzB9W,EAAKumB,QACL9V,EAAQuJ,aAAe,S,CAIvC,C,sJC3BWoqF,E,WAbX,WA4BA,SAASC,EAAuBr3F,GAC5B,OAAO,SAAAyD,GACH,GAA4B,cAAxBA,EAAQuJ,aAWZ,IAPM,MAAwBvJ,EAAQqD,YAA9BG,EAAM,SAAED,EAAS,YACnBusB,EAAavsB,EAAUpF,SAAS/L,QAAQoR,GACxCqwF,EAA0B,WAAbt3F,EAEbu3F,EAiEd,SACIvwF,EACAgkB,EACAwsE,EACA/zF,G,yFAEMi9C,EAAO82C,EAAU,GAAK,EACtB51F,EAAWoF,EAAUpF,SACrBixE,GAAqB,IAAA5oB,uBAAsBjjD,EAAUjH,OAAOqtB,YAEzD9+B,EAAI08B,EAAc01B,E,sBAAMpyD,GAAK,GAAKA,EAAIsT,EAASzV,QAAM,a,QACpD4W,EAAUnB,EAAStT,IAETyT,a,IACP,mB,IAyCA,oB,IAcA,8B,oBArDOwW,EAAIi/E,EAAU,EAAIz0F,EAAQZ,KAAKhW,OAAS,E,wBAC5CosB,GAAK,GAAKA,EAAIxV,EAAQZ,KAAKhW,QAGrBoB,EAAIwV,EAAQZ,KAAKoW,GACjBk/E,GAAc,IAAA3hF,eAAcvoB,GAC5Bg7F,GAAQ,IAAAxyE,SAAQxoB,GAGlB,GAAM,CAAEkqG,YAAW,EAAElP,MAAK,EAAEpmF,MAFlBs1F,IAAgBlP,KANG,M,OAQjC,GAAI,SAAoC,CAWpC,GARApzE,GAFIA,EAAUpS,EAAQZ,MAEJzR,UAAU,EAAG6nB,GAAKpD,EAAQzkB,UAAU6nB,EAAI,GAErDs6D,IACD19D,GAAU,IAAAu1D,eAAcv1D,EAASqiF,IAGrC/zF,EAAQuJ,aAAe,SAEnBmI,EAaA,OANAvT,EAAShM,OAAOtH,EAAG,GAEfoyD,EAAO,IACPpyD,GAAKoyD,GAGT,MAZA39C,EAAQZ,KAAOgT,EAEXurC,EAAO,IACPnoC,GAAKmoC,E,yBAtBjBnoC,GAAKmoC,E,aAmCT,a,OAII,SAAM,CAAE+2C,aAAa,EAAMlP,OAAO,EAAOpmF,MAAM,I,OAUnD,OAVI,WAEAP,EAAShM,OAAOtH,EAAG,GAEfoyD,EAAO,IACPpyD,GAAKoyD,GAGTj9C,EAAQuJ,aAAe,SAE3B,O,OAGA,a,QAGA,MAAO,CAAP,EAAO,M,eA/D6C1e,GAAKoyD,E,cAmErE,MAAO,CAAP,EAAO,M,IA9Icg3C,EAAgB,IAAA73F,aAAYmH,GAAYusB,EAAY+jE,EAAY7zF,GAC7Ek0F,EAAOJ,EAAS11D,OAEXnkB,EAAQ,EAAgC,GAATA,IAAiCi6E,EAAKC,MAAQ,CAC5E,MAA+BD,EAAKrrG,MAAlCmrG,EAAW,cAAElP,EAAK,QAAEpmF,EAAI,OAMhC,OAAQub,GACJ,KAAK,EACDA,EAAQ6qE,EACF,EACAkP,EACA,EACA,EACNE,EAAOJ,EAAS11D,MAAK,GACrB,MAEJ,KAAK,EACGy1D,GAAc/O,GACd7qE,EAAQ,EACRi6E,EAAOJ,EAAS11D,MAAK,IACd41D,EACPE,EAAOJ,EAAS11D,MAAK,GAErBnkB,EAAQ,EAEZ,MAEJ,KAAK,EACG45E,GAAc/O,GACd7qE,EAAQ,EACRi6E,EAAOJ,EAAS11D,MAAK,IACd1/B,EACPw1F,EAAOJ,EAAS11D,MAAK,GAErBnkB,EAAQ,EAEZ,MAEJ,KAAK,EACG+5E,IAAgBlP,EAChB7qE,EAAQ,EAERi6E,EAAOJ,EAAS11D,MAAK,GAEzB,MAEJ,KAAK,EACG0mD,EACAoP,EAAOJ,EAAS11D,MAAK,GACd41D,GACP/5E,EAAQ45E,EAAa,EAA0B,EAC/CK,EAAOJ,EAAS11D,MAAK,IAErBnkB,EAAQ45E,EAAa,EAAsB,E,CAK/D,CACJ,EAxFA,SAAWF,GACP,qBACA,iCACA,mBACA,yBACA,qBACA,gBACH,CAPD,CAAWA,IAAAA,EAAe,KA6Kb,EAAAS,2BAA6BR,EAAuB,WAKpD,EAAAS,4BAA8BT,EAAuB,W,sKC/LlE,eA+EA,SAASU,EAAuBjuF,GAG5B,IAFA,IAAIkuF,GAAW,EAEN1pG,EAAIwb,EAAM1J,OAAOjU,OAAS,EAAGmC,GAAK,EAAGA,IAAK,CAC/C,IAAMsR,EAAQkK,EAAM1J,OAAO9R,GAEJ,cAAnBsR,EAAMK,YACN83F,EAAuBn4F,GAEI,GAAvBA,EAAMQ,OAAOjU,UACb,IAAA0T,aAAYiK,GAAO1J,OAAOxK,OAAOtH,EAAG,GACpC0pG,GAAW,G,CAKnBA,GACAluF,EAAM1J,OAAOzO,QAAQ,EAAAya,wBAE7B,CAjFA,qCACImO,EACAtuB,EACA+lC,EACA3/B,EACAoR,GAKA,OAHAA,EAAQ6Y,kBAAmB,EAC3B7Y,EAAQo7B,iBAAkB,EAElBxsC,GACJ,IAAK,aAKD,OAHAoR,EAAQo7B,iBAAkB,GAGnB,EAEX,IAAK,kBAGD,OADA7M,EAASwf,kBACF,EAEX,IAAK,QACL,IAAK,aAiBD,OAfAxf,EAASwf,kBACT,IAAAzsC,uBAAsB9Y,GACtB8rG,EAAuB9rG,GAET,SAAVoG,IAEAoR,EAAQ6Y,kBAAmB,GAK/B/B,EAAOkF,aAAa,wBAAyB,CACzCuS,SAAQ,KAGL,EAEnB,EAKA,4BAAiCA,EAAyB8rB,GACtD,OACKA,GAAS9rB,EAASqoB,SAAWroB,EAASuoB,UACrCuD,GAAS9rB,EAASsoB,UAAYtoB,EAASqoB,MAEjD,EAKA,yCAA8CroB,GAC1C,OAAOA,EAASuoB,UAAYvoB,EAASqoB,MACzC,C,wGC7EA,eAMa,EAAA49C,eAAsC,SAAAx0F,GACvC,IAAAuJ,EAA8BvJ,EAAO,aAAvBqD,EAAgBrD,EAAO,YAE7C,GAAoB,cAAhBuJ,GAAgD,mBAAhBA,EAAmC,CAC3D,IAAA/F,EAAsBH,EAAW,OAAzBE,EAAcF,EAAW,UACnChC,EAAQkC,EAAUpF,SAAS/L,QAAQoR,GACnCixF,EAAYpzF,EAAQ,EAAIkC,EAAUpF,SAASkD,EAAQ,GAAK,KAGhC,SAA1BozF,aAAS,EAATA,EAAWn2F,eACX,IAAArD,aAAYw5F,EAAWlxF,EAAW,CAC9B4H,UAAU,KAEdnL,EAAQ0uE,gBAER1uE,EAAQ0uE,cAAct5C,oBAAqB,E,CAKvD,C,0HC1BA,WACA,WACA,WAqBa,EAAAs/D,kBAAyC,SAAA10F,GAC1C,IAAAuJ,EAA8BvJ,EAAO,aAAvBqD,EAAgBrD,EAAO,YAE7C,GAAoB,cAAhBuJ,GAAgD,mBAAhBA,EAAmC,CAC3D,IAAAha,EAAS8T,EAAW,KACtBhC,GAAQ,IAAA2C,mCACVzU,EACA,CAAC,YACD,CAAC,YAAa,oBAGZolG,EAAmBplG,EAAK8R,GACxB0vD,EAAaxhE,EAAK8R,EAAQ,GAEhC,GAAyC,cAArCszF,aAAgB,EAAhBA,EAAkBj4F,iBAAiCq0D,EAAY,CAC/D,IAAI3xD,GAAW,IAAAhD,aAAYu4F,GAEvBC,EAAgBx1F,GAChBA,EAASF,OAAOnP,OAEhBqP,EAAWy1F,EAAkB70F,EAASZ,EAAU2xD,GAE5C/wD,EAAQ0uE,gBACR1uE,EAAQ0uE,cAAcxtE,cAAe,IAAA/F,sBAAmB,oBACpDiE,I,YACG7P,EAAKb,MAAM2S,EAAQ,KAAE,MAKpCrB,EAAQuJ,aAAe,O,EAGnC,EAEA,IAAMqrF,EAAkB,SAACx1F,GACrB,OAAkC,IAA3BA,EAASzC,OAAOjU,QAAgBuqG,EAAiB7zF,EAASzC,OAAO,GAC5E,EAEMs2F,EAAmB,SAAC92F,GACtB,MACwB,cAApBA,EAAMK,WACoB,IAA1BL,EAAMgC,SAASzV,QACmB,oBAAlCyT,EAAMgC,SAAS,GAAGG,aACgB,OAAlCnC,EAAMgC,SAAS,GAAGG,WAE1B,EAEMu2F,EAAoB,SACtB70F,EACAZ,EACA2xD,G,MAEQ1tD,EAAgBrD,EAAO,YACzB2rF,EAAY56B,EAAWp0D,OAAOvK,QAAQgN,GACtC01F,EAAczxF,EAAYE,UAC1B6wC,EAAYh1C,EAASzC,OAAOvK,QAAQ0iG,GACpCpnB,GAAe,IAAAkD,gBAAevtE,GAE9BnE,EAAS61F,EAAmB31F,GAC5BgR,GAAkD,IAAAC,gBACpDnR,EACAE,EAAS2F,aAAazI,QAG1B8T,EAAYzT,OAAOnK,KAAKk7E,IAExB,IAAAz9D,YAAoCG,EAAY9T,OAAQ8C,EAAS9C,OAAQ,EAAA4T,aAEzE,IAAM8kF,EAAsB51F,EAASzC,OAAOjU,OAAS0rD,EAAY,EAejE,OAbIA,GAAa,GAAK4gD,EAAsB,IACxC,EAAA5kF,EAAYzT,QAAOnK,KAAI,6CAChB,IAAA4J,aAAYgD,GAAUzC,OAAOxK,OAAOiiD,EAAY,EAAG4gD,KAAoB,IAIlF3xF,EAAYE,UAAYmqE,GACxB,IAAAtxE,aAAY20D,GAAYp0D,OAAOxK,OAAOw5F,EAAY,EAAG,EAAGv7E,GAEpDpQ,EAAQmf,eAAiB21E,IACzB90F,EAAQmf,cAAgBuuD,GAGrBt9D,CACX,EAEM2kF,EAAqB,SAAC31F,GACxB,OAAOA,EAASF,OAAO7R,KAAI,SAAA6H,GACvB,OAAO,IAAA0L,iBACH1L,EAAM2L,UAAQ,gCAEP3L,EAAMoH,QAAM,CACf2E,yBAAqB3K,EACrB0Y,yBAAqB1Y,IAEzBpB,EAAM4L,QAEd,GACJ,C,gHC1HA,eACA,WAMa,EAAAm0F,uBAEc,SAAArD,GAA4B,gBAAA5xF,G,QAC7C,EAAsBA,EAAQqD,YAA5BE,EAAS,YAAEhU,EAAI,OACjB6kD,EAA8C,QAAlC,EAAO,QAAP,EAAA7kD,EAAK,UAAE,eAAEoN,OAAOvK,QAAQmR,UAAU,SAAK,EAEzD,GAA4B,cAAxBvD,EAAQuJ,cAAgC6qC,GAAa,EAAG,CACxD,IAAMx+B,GAAU,IAAAg7D,gBACZ5wE,EAAQqD,aACR,EACAuuF,IAGJ,IAAAx1F,aAAY7M,EAAK,IAAIoN,OAAOxK,OAAOiiD,EAAY,EAAG,EAAGx+B,GAErD5V,EAAQuJ,aAAe,QACvBvJ,EAAQmf,cAAgBvJ,EACxB5V,EAAQqD,YAAYE,UAAYqS,C,CAExC,CAjBuD,C,wGCTvD,eACA,WACA,WACA,WACA,WACA,WAQA,WAKA,WAeA,0BAA+BkB,EAAiByX,EAAyB7V,GACrE,IAAIq5E,GAAU,EACR/qF,EAAY8P,EAAOyE,kBACjBq1E,EAAoCl4E,EAAO,gCAwBnD,OAiCJ,SACI1R,EACAunB,EACA2mE,G,QAEA,GAAKluF,EAEE,IAAsB,SAAlBA,EAAUb,KACjB,OAAO,EACJ,GAAKa,EAAUya,MAAMC,UAcrB,CAEGmV,GADApV,EAAQza,EAAUya,OACKoV,eAD7B,IAEMC,EAAcrV,EAAMqV,YAG1B,SACI,IAAA1vB,cAAayvB,EAAgB,gBAC5B,IAAA0lB,eAAchuB,KAO3B,SAAyBA,EAAyB7vB,EAAY0T,G,QAC1D,GAAoB,aAAhBmc,EAASrnC,KAAsBkrB,GAAU,EACzC,OAAO,EAKX,GAAIA,IAFiC,QAAtB,EAAc,QAAd,EAAA1T,EAAKumB,iBAAS,eAAEv8B,cAAM,QAAI,GAEnB,CAElB,IAAMmf,EAAcnJ,EAAKmJ,YASzB,SAPI,IAAAT,cAAaS,EAAa,kBAC1B,IAAAolB,iBAAgBplB,EAAa,OAC7B,IAAAq8D,mBAAkBr8D,KACjBA,EAAYD,W,CAOjB,OAAO,CAEf,CA7BautF,CAAgB5mE,EAAUsI,EAAgBC,IA+BvD,SAAwBvI,EAAyB7vB,EAAY0T,G,QACzD,MAAuB,UAAhBmc,EAASrnC,KAAmBkrB,GAAgC,QAAtB,EAAc,QAAd,EAAA1T,EAAKumB,iBAAS,eAAEv8B,cAAM,QAAI,GAAK,CAChF,CAhCgB0sG,CAAe7mE,EAAUsI,EAAgBC,I,CAvBjD,GAAIo+D,EACA,OAAO,EAGX,IACQr+D,EADFpV,EAAQza,EAAUya,MAClB,EAAmCza,EAAUya,MAGnD,SAHQoV,EAAc,oBAAc,iBAEG,IAAAzvB,cAAayvB,EAAgB,gBAG/D,IAAA0lB,eAAchuB,IACf9M,EAAMuV,UAAYvV,EAAMqV,aAA+C,QAAhC,EAAwB,QAAxB,EAAAD,EAAe5R,iBAAS,eAAEv8B,cAAM,QAAI,G,CAf/E,OAAO,CA8Bf,CA3FQ2sG,CAA6BruF,EAAWunB,IAAYqiE,IACpD95E,EAAOE,oBACH,SAACxuB,EAAOwX,GACJ,IAAMpR,GAAS,IAAA4a,iBACXhhB,EAqBpB,SACI+lC,EACA8rB,EACA3hC,GAEA,IAAM6hD,EAA4B,UAAhBhsC,EAASrnC,IACrBouG,GACF,IAAAC,+BAA8BhnE,KAAcgsC,EAAY,EAAA83B,uBAAyB,KAC/EmD,GAAsB,IAAAC,kBAAiBlnE,EAAU8rB,GACjDkgB,EACI,EAAA65B,2BACA,EAAAC,4BACJ,KAEAqB,GAA2B,IAAAC,6BAC7Bp7B,EAAY,UAAY,WACxB7hD,GAGEk9E,EAAer7B,EAA+B,KAAnB,EAAAu4B,iBACjC,MAAO,CACHwC,EACAE,EACAj7B,EAAY,KAAO,EAAA+4B,WACnBoC,EACAE,EACA,EAAAnC,qBAER,CAhDoBoC,CAAetnE,IAAYzX,EAAOyK,iBAAiB84B,MAAO3hC,GAC1D1Y,GACFuJ,aAGF,OADAwoF,GAAU,IAAA+D,2BAA0Bh/E,EAAQtuB,EAAO+lC,EAAU3/B,EAAQoR,EAEzE,GACA,CACIuuB,SAAQ,EACRjV,aAAc,EAAAC,aAAa2iB,SAC3BziB,cAAe,WAAM,OAAA8U,EAAS0jE,KAAT,EACrB5+D,qBAAqB,EACrBnc,QAAyB,UAAhBqX,EAASrnC,IAAkB,kBAAoB,uBAK7D6qG,CACX,C,uGC7DA,eACA,WACA,WACA,WACA,WAWA,yBACIj7E,EACAyX,EACAwiE,EACAa,QAAA,IAAAA,IAAAA,EAAA,IAEA,IAAM5qF,EAAY8P,EAAOyE,kBAEzBzE,EAAOE,oBACH,SAACxuB,EAAOwX,G,QA2CcuD,EAzCZ3U,GAAS,IAAA4a,iBAAgBhhB,EAAO,GAAIwX,GAG1C,GAAIgH,GAA+B,SAAlBA,EAAUb,KAAiB,CAGxCvX,EAAO2a,aAAe,aAEtB,IAAMmmE,EAAQnhD,EAASslB,SACjB,GACA,CAAC,EAAA2gD,eAAgB,EAAAE,kBAAmB,EAAA5B,mBAEtC/B,IA6BUxtF,EA7BkD,QAAlB,EAAA3U,EAAOyU,mBAAW,eAAEE,aAgCzEA,EAAUorB,YAAcprB,EAAUpF,SAASkB,MAAK,SAAAnV,GAAK,MAAiB,UAAjBA,EAAEoU,WAAF,OA/B1CoxE,EAAMl9E,MAAK,IAAAyiG,wBAAuBrD,KAGtC,IAAApqB,cAAakI,EAAO9gF,E,CAGxB,MAA2B,SAAvBA,EAAO2a,eAEPvJ,EAAQ8X,iBAAqC,QAAlB,EAAAlpB,EAAOyU,mBAAW,eAAEG,OAAOlH,QAEtD,IAAAgF,uBAAsB9Y,GAEtB+lC,EAASwf,kBACF,EAIf,GACA,CACIxf,SAAQ,EACR8E,qBAAqB,EACrB/Z,aAAc,EAAAC,aAAa2iB,SAC3BziB,cAAe,WAAM,OAAA8U,EAAS0jE,KAAT,EACrB/6E,QAAS,kBAGrB,C,uGCjEA,eAYM6+E,EAAiC,SAAA/1F,GACnC,GAA4B,SAAxBA,EAAQuJ,aAAyB,CAC3B,MAAwBvJ,EAAQqD,YAA9BG,EAAM,SAAED,EAAS,YACnBlC,EAAQkC,EAAUpF,SAAS/L,QAAQoR,GAEzC,GAAInC,GAAS,EAAG,CACZ,IAAM3C,GAAO,IAAAiT,YAPb,IAO6BnO,EAAOlH,OAAQkH,EAAOtU,KAAMsU,EAAOqC,MAEhEnH,EAAKS,YAAa,EAElBoE,EAAUpF,SAAShM,OAAOkP,EAAO,EAAG3C,E,EAGhD,EAKA,yBAA8BoY,EAAiByX,GAG3C,GAmCJ,SAAqCvnB,EAAgCunB,GACjE,SAAKvnB,IAGA,IAAAu1C,eAAchuB,KACfA,EAASrnC,KACQ,SAAhBqnC,EAASrnC,KAAyC,GAAvBqnC,EAASrnC,IAAIwB,QAEhB,SAAlBse,EAAUb,MAAoBa,EAAUya,MAAMC,UAI7D,CA/CQs0E,CAFcl/E,EAAOyE,kBAEkBgT,GA+BvC,OA9BAzX,EAAOsC,eAEPtC,EAAOE,oBACH,SAACxuB,EAAOwX,G,MACEpR,GAAS,IAAA4a,iBAAgBhhB,EAAO,CAACutG,GAAY/1F,GAKnD,OAFAA,EAAQ6Y,kBAAmB,EAEA,SAAvBjqB,EAAO2a,eAEPvJ,EAAQ8X,iBAAqC,QAAlB,EAAAlpB,EAAOyU,mBAAW,eAAEG,OAAOlH,QAEtD,IAAAgF,uBAAsB9Y,IAGf,EAIf,GACA,CACI6qC,qBAAqB,EACrB9E,SAAQ,EACRjV,aAAc,EAAAC,aAAa2iB,SAC3BziB,cAAe,WAAM,OAAA8U,EAAS0jE,KAAT,EACrB/6E,QAAS,oBAIV,CAEf,C,oGClEA,eACA,UACA,WACA,UACA,WAEA,WAgBA,uBACIJ,EACAyX,EACA7V,GAEA,IAAM1R,EAAY8P,EAAOyE,kBAEzB,OAAQvU,aAAS,EAATA,EAAWb,MACf,IAAK,QACD2Q,EAAOE,oBACH,SAACxuB,EAAOwX,GACJ,OAoCpB,SACIxX,EACA+lC,EACAvuB,EACA0Y,GAEA,IAAM/b,GAAS,IAAAV,sBACXzT,EACA,CAAC,WAAY,aACb,IAEE2T,EAAQQ,EAAOjU,OAAS,EAAIiU,EAAO,GAAGR,WAAQ7F,EAEpD,GAAIqG,EAAOjU,OAAS,GAChB,GAAIgwB,EAAQ23E,qBAGR,OAFA,IAAAt1F,qBAAoBvS,EAAO+lC,EAASslB,SAAW,UAAY,UAC3DtlB,EAASwf,kBACF,OAER,IAAI,IAAAhvC,oBAA0C5C,EAAO,cACxD,GAAIuc,EAAQ63E,eACR,OAAO,IAAA0F,sBAAqBztG,EAAO2T,EAAOoyB,QAE3C,GAAyB,eAArBpyB,aAAK,EAALA,EAAOK,YACd,GAAIkc,EAAQ+3E,gBACR,OAAO,IAAAyF,sBAAqB1tG,EAAO2T,EAAOoyB,EAAUvuB,QAErD,IAAI,IAAAjB,oBAAyC5C,EAAO,aACnDuc,EAAQ83E,WACR,OAAO,IAAA2F,iBAAgB3tG,EAAO2T,EAAOoyB,EAAUvuB,GAGvD,OAAO,CACX,CArE2Bo2F,CAAU5tG,EAAO+lC,EAAUvuB,EAAS0Y,EAC/C,GACA,CACIxB,QAAS,eACTqX,SAAQ,EACRjV,aAAc,EAAAC,aAAa2iB,SAC3BziB,cAAe,WAAM,OAAA8U,EAAS0jE,KAAT,IAG7B,MAEJ,IAAK,QACGv5E,EAAQ43E,aACRx5E,EAAOE,oBACH,SAAAxuB,GACI,OAAO,IAAA6tG,kBAAiB7tG,EAAO+lC,EACnC,GACA,CACIrX,QAAS,eACTqX,SAAQ,EACRjV,aAAc,EAAAC,aAAa2iB,SAC3BziB,cAAe,WAAM,OAAA8U,EAAS0jE,KAAT,IAM7C,C,yGC5DA,cACA,WAYA,2BACIzpG,EACA4W,EACAmvB,EACAvuB,GAEA,IAAMs2F,EA2BV,SAA+Bl3F,GAC3B,OAAOA,EAASzC,OAAOyB,QACnB,SAAAjC,GACI,MAAmB,aAAnBA,EAAMK,WAA4BL,EAAMgC,SAASkB,MAAK,SAAAC,GAAW,OAAAA,EAAQH,UAAR,GAAjE,GAEZ,CAhC8Bo3F,CAAsBn3F,GAChD,OAmBJ,SAAgCA,GAC5B,MACoC,aAAhCA,EAASzC,OAAO,GAAGH,WAC2B,mBAA9C4C,EAASzC,OAAO,GAAGwB,SAAS,GAAGG,WAEvC,CAvBSk4F,CAAuBp3F,IACI,GAA5Bk3F,EAAkB5tG,QACiB,cAAnC4tG,EAAkB,GAAG95F,YAIrB,IAAAzB,qBACIvS,EACA+lC,EAASslB,SAAW,UAAY,cAChCv9C,EACA0J,GAEJuuB,EAASwf,kBAEF,IAVA,IAAAmoD,sBAAqB1tG,EAAO8tG,EAAkB,GAAI/nE,EAAUvuB,EAY3E,C,6GCrCA,eACA,WAYMy2F,EAAY,OAkBlB,gCACIjuG,EACA+a,EACAgrB,EACAvuB,GAEA,IAAM02F,EAAmBnzF,EAAUpF,SAASC,QAAO,SAAAkB,GAAW,OAAAA,EAAQH,UAAR,IACxD4pC,EAC0B,IAA5B2tD,EAAiBhuG,QAAoD,oBAApCguG,EAAiB,GAAGp4F,YAKzD,GAJsBiF,EAAUpF,SAASmE,OACrC,SAAAhD,GACI,OAAAA,EAAQH,YAAsC,QAAvBG,EAAQhB,aAAuD,GAA9BgB,EAAQZ,KAAKkF,OAAOlb,MAA5E,IAEW,CACT,MAAyC6a,EAAUjH,OAAjDW,EAAU,aAAEG,EAAW,cACzBsC,EAAsB,QADc,YAE1C,GACI6uB,EAASslB,YACNn0C,KAAWzC,GAA4B,OAAdA,IACvByC,KAAWtC,GAA8B,OAAfA,IAE/B,OAAO,GAEX,IAAArC,qBACIvS,EACA+lC,EAASslB,SAAW,UAAY,cAChCv9C,EACA0J,E,MAGJ,GAAK+oC,EA6BE,CACH,IAAMxhB,EAAchkB,EAAUpF,SAASkT,WACnC,SAAA/R,GAAW,MAAwB,oBAAxBA,EAAQhB,WAAR,IAGf,GAAKiwB,EAASslB,SAKP,CACH,GAAItsB,GAAe,EACf,OAAO,EAKX,GAA2B,SAHrBovE,EAAUpzF,EAAUpF,SAASopB,EAAc,IAGrCjpB,YAAuB,CAC/B,IAAM,EAAqBq4F,EAAQj4F,KAAKhW,OAHpB+tG,EAKpB,GAAIE,EAAQj4F,OAAS+3F,GACjB,IAAAr6F,aAAYmH,GAAWpF,SAAShM,OAAOo1B,EAAc,EAAG,OACrD,IAAIovE,EAAQj4F,KAAKzR,UAAU,KAAwBwpG,EAKtD,OAAO,GAJP,IAAAtzF,eAAcI,EAAWozF,GAAS,SAAAj4F,GAC9BA,EAAKA,KAAOA,EAAKA,KAAKzR,UAAU,EAAG,EACvC,G,OApBY,CACpB,IAAM2rD,EAAer1C,EAAUpF,SAASopB,GAAajrB,OAC/Cq6F,GAAU,IAAAhlF,YAAW8kF,EAAW79C,IAEtC,IAAAx8C,aAAYmH,GAAWpF,SAAShM,OAAOo1B,EAAa,EAAGovE,E,MAtC7C,CACd,IAAI,OAAgDrgG,EAChD,OAA+CA,EAUnD,GARAiN,EAAUpF,SAASjQ,SAAQ,SAACoR,EAAS+B,GAC7B/B,EAAQH,aACH,IACD,EAA4BkC,GAEhC,EAA2BA,EAEnC,KACI,IAA6B,EAe7B,OAAO,EAdP,IAAMu1F,EAAuBrzF,EAAUpF,SAAS,GAC1C04F,GAAY,IAAAllF,YACd4c,EAASslB,SAAW4iD,EA9D1B,IA+DMG,EAAqBt6F,QAEnBkH,GAAS,IAAAwG,uBAAsB4sF,EAAqBt6F,SAE1D,IAAAF,aAAYmH,GAAWpF,SAAShM,OAC5B,EACA,EAA2B,EAA4B,EACvD0kG,EACArzF,E,CAuChB,OADA+qB,EAASwf,kBACF,CACX,C,0GC7HA,eACA,WAUA,4BAAiCvlD,EAAqC+lC,GAClE,IAAMnO,GAAa,IAAAC,uBAAsB73B,GAAO,GAChD,SAAI43B,IAQR,SAA8BA,G,QACpBtM,EAAUsM,EAAW9iB,KAAK8iB,EAAW9iB,KAAK5U,OAAS,GACnD64C,EAAWztB,aAAO,EAAPA,EAAStW,MAAMsW,EAAQtW,MAAM9U,OAAS,GAEvD,OAAmC,QAA5B,EAAkB,QAAlB,EAAA03B,EAAW9iB,KAAK,UAAE,eAAEE,MAAM,UAAE,eAAE2B,cAAcoiC,aAAQ,EAARA,EAAUpiC,WACjE,CAbsB+F,CAAqBkb,MACnC,IAAArlB,qBAAoBvS,EAAO+lC,EAASslB,SAAW,UAAY,UAC3DtlB,EAASwf,iBACF,GAGf,C,6GCnBA,eACA,WAiBA,gCACIvlD,EACAiV,EACA8wB,G,QAEMvH,GAAqB,IAAA3G,uBAAsB73B,GAAO,GAExD,GAAIw+B,EAAoB,CAEpB,IAAMlT,EAAUkT,EAAmB1pB,KAAK0pB,EAAmB1pB,KAAK5U,OAAS,GACnEqrB,EAAaD,EAAUA,EAAQtW,MAAM9U,OAAS,GAAK,EACnD64C,EAAWztB,aAAO,EAAPA,EAAStW,MAAMuW,GAEhC,IAAKwa,EAASslB,UAAYtS,GAAYA,IAAa9jC,EAAM,CACrD,IAAM2iB,GAAa,IAAAhkB,aAAY4qB,IAC/B,IAAA/sB,gBAAemmB,EAAY,gBAG3B,IAAAjmB,oBAAmBimB,EAAY,CAC3BvM,SAAUuM,EAAW9iB,KAAK5U,OAAS,EACnCoqB,YAAa,EACbgB,QAASsM,EAAW9iB,KAAK5U,OAAS,EAClCqrB,WAAYA,KAEhB,IAAAgP,gBAAe3C,EAAY53B,EAAM8T,QAGjC,IAAMuqC,EACmD,QAArD,EAA2C,QAA3C,EAAAzmB,EAAW9iB,KAAK8iB,EAAW9iB,KAAK5U,OAAS,UAAE,eAAE8U,MAAM,UAAE,eAAEb,OAAO,GAClE,GAAiC,aAA7BkqC,EAAgBrqC,UAA0B,CAC1C,IAAMgH,GAAS,IAAAwG,uBAAsBxhB,EAAM8T,SAE3C,IAAAF,aAAYyqC,GAAiB1oC,SAASzO,QAAQ8T,IAC9C,IAAAmF,yBAAwBk+B,IACxB,IAAA58B,cAAamW,EAAW9iB,KAAK8iB,EAAW9iB,KAAK5U,OAAS,GAAG8U,MAAM,GAAIgG,E,CAIvE,OADA+qB,EAASwf,kBACF,C,EAIf,OAAO,CACX,C,4HC7DA,WAoEA,+BACIx+C,EACA4M,EACA26F,GAIA,I,MAFM3c,GAAU,EAAH,iCAAO5qF,IAAI,G,aAGpB,IAAM8W,EAAQ8zE,EAAQ,GAChB94E,EAAQgF,EAAM1J,OAAOvK,QAAQ+J,GAEnC,GAAIkF,EAAQ,E,cAIZ,IAAIyH,EAAYzC,EAAM1J,OAAO0E,GAASy1F,EAAS,GAAK,IAEpD,GAAIhuF,EAAW,CACX,KAA8B,cAAvBA,EAAUtM,WAA2B,CACxC,IAAMmL,EAAQmB,EAAUnM,OAAOm6F,EAAS,EAAIhuF,EAAUnM,OAAOjU,OAAS,GAEtE,IAAKif,E,aACM,CAAExL,MAAO2M,EAAWvZ,KAAM4qF,IAC9B,GAAuB,cAAnBxyE,EAAMnL,U,OACb29E,EAAQzqF,QAAQoZ,G,OACT,CAAE3M,MAAOwL,EAAOpY,KAAM4qF,IAE7BA,EAAQzqF,QAAQoZ,GAChBA,EAAYnB,C,cAIb,CAAExL,MAAO2M,EAAWvZ,KAAM4qF,G,CAC9B,IAAI,IAAAtT,kBAAiBxgE,GAAQ,CAGhC8zE,EAAQrkE,QAER,IAAI,GAAgB,EACd,EAAUzP,EACV7E,EAAiB,QAAV,EAAA24E,EAAQ,UAAE,eAAEx9E,OAAO2I,MAC5B,SAAApb,GAAK,MAAe,aAAfA,EAAEsS,YAA6B,EAAetS,EAAEiU,SAAS/L,QAAQ,KAAa,CAA9E,IAGT,IAAIoP,E,cAEA,IAAMoxF,EAAiBpxF,EAAKrD,SAAS,GAAgB24F,EAAS,GAAK,IAEnE,GAAIlE,E,aAEO,CAAEz2F,MAAOqF,EAAMjS,KAAM4qF,EAASyY,eAAc,IAGnDz2F,EAAQqF,C,KAMb,IAA4B,YAAxB6E,EAAM3J,gBAAwD,aAAxB2J,EAAM3J,e,cACnDy9E,EAAQrkE,QACR3Z,EAAQkK,C,GAtDT8zE,EAAQzxF,OAAS,GAAG,C,oEA4D3B,OAAO,IACX,C,+GC/HA,mCACIkpG,EACAruF,EACAmqE,GAEA,GAAIkkB,GAA4BA,EAAyBlpG,OAAQ,CAC7D,IAAM,EAAS6a,EAAUjH,OACnB,EAAYoxE,EAAapxE,OAC/Bs1F,EAAyB1jG,SAAQ,SAAAhH,GAC7B,IAAM6vG,EAAc,EAAO7vG,QAEPoP,IAAhBygG,IACA,EAAU7vG,GAAO6vG,EAEzB,G,CAER,C,uHCzBA,WACA,WAuBA,0BACI1zF,EACA2zF,EACApF,G,WADA,IAAAoF,IAAAA,GAAA,QACA,IAAApF,IAAAA,EAAA,IAEQ,IAAAruF,EAAsBF,EAAW,UAAtBG,EAAWH,EAAW,OACnCqqE,GAAoD,IAAAjsE,kBACtD,EACA,CAAC,EACD8B,EAAU7B,gBAGd,IAAAuO,YAAWy9D,EAAapxE,OAAQiH,EAAUjH,OAAQ,EAAA0qE,mBAClD,IAAA6rB,yBAAwBjB,EAA0BruF,EAAWmqE,GAE7D,IAAMnmD,EAAchkB,EAAUpF,SAAS/L,QAAQoR,GACzCrF,EAAWoF,EAAUpF,SAAShM,OAChCo1B,EACAhkB,EAAUpF,SAASzV,OAAS6+B,IAGhC,EAAAmmD,EAAavvE,UAAS3L,KAAI,4CAAI2L,IAAQ,IAEtC,IAAM80F,EAAgD,GAA7B1vF,EAAUpF,SAASzV,OACtCuuG,GAAmC1zF,EAAUorB,aAAeqoE,EAYlE,OAVI/D,GAAoBgE,EACpB1zF,EAAUpF,SAAS3L,MAAK,IAAAuX,UAASvG,EAAOlH,SAChC22F,IACR,IAAAtqF,yBAAwBpF,GAG5BF,EAAYE,UAAYmqE,GAExB,IAAA9G,oBAAmBrjE,GAEZmqE,CACX,C,2GC7DA,eACA,WAEA,WAeA,aAUI,WAAoB1tE,EAA6B0Y,G,QAA7B,KAAA1Y,QAAAA,EATZ,KAAA8W,OAAyB,KAU7B/kB,KAAKmlG,mBAAgD,QAA3B,EAAAx+E,aAAO,EAAPA,EAASw+E,0BAAkB,QAjB3B,4BAkB1BnlG,KAAKolG,sBAAsD,QAA9B,EAAAz+E,aAAO,EAAPA,EAASy+E,6BAAqB,QAjB9B,2BAkBjC,CA4FJ,OAvFI,YAAA7xD,QAAA,WACI,MAAO,aACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,EAEd,IAAMwlC,EAAMxlC,EAAOiC,cAAciL,YAE7Bs4B,IACAvqD,KAAKiO,QAAQo3F,cAAc7xD,WAAW+W,GACtCvqD,KAAKiO,QAAQq3F,iBAAiB9xD,WAAW+W,IAG7CvqD,KAAK+kB,OAAOsiB,eAAe,EAAAk+D,qBAAsBvlG,KAAKmlG,mBAAoB,CACtE,EAAAK,wBAEJxlG,KAAK+kB,OAAOsiB,eAAe,EAAAo+D,wBAAyBzlG,KAAKolG,sBAAuB,CAC5E,EAAAM,0BAER,EAOA,YAAAhyD,QAAA,WACI1zC,KAAKiO,QAAQo3F,cAAc3xD,UAC3B1zC,KAAKiO,QAAQq3F,iBAAiB5xD,UAE1B1zC,KAAK+kB,SACL/kB,KAAK+kB,OAAOsiB,eAAe,EAAAk+D,qBAAsB,MACjDvlG,KAAK+kB,OAAOsiB,eAAe,EAAAo+D,wBAAyB,MAEpDzlG,KAAK+kB,OAAS,KAEtB,EAQA,YAAAutB,cAAA,SAAc/W,GACV,GAAKv7B,KAAKiO,QAAQtB,MAAS3M,KAAK+kB,OAIhC,OAAQwW,EAAMsE,WACV,IAAK,QACD,IAAM5qB,EAAYjV,KAAK+kB,OAAOyE,kBAE9B,GAAuB,UAAnBvU,aAAS,EAATA,EAAWb,MAAiB,CAC5B,IAAMhK,EAAQpK,KAAK+kB,OACdkE,eACA4mC,wBAAwB56C,EAAUya,MAAMoV,iBAE7C,IAAA6gE,iBAAgB3lG,KAAK+kB,OAAQ/kB,KAAKiO,QAAS,CAAC7D,GAAQ,CAACA,G,CAGzD,MACJ,IAAK,iBACImxB,EAAMqO,cAAgBrO,EAAMsO,QAAU,EAAAriB,aAAa8wC,UACpD,IAAAqtC,iBAAgB3lG,KAAK+kB,OAAQ/kB,KAAKiO,SAGtC,MAEJ,IAAK,oBACD,IAAA03F,iBACI3lG,KAAK+kB,OACL/kB,KAAKiO,QACLstB,EAAMosB,mBACNpsB,EAAMqsB,sBAKtB,EACJ,EAzGA,GAAa,EAAAg+C,kBAAAA,C,kHClBb,eACA,WASA,oCAAyC/9B,GACrC,YADqC,IAAAA,IAAAA,EAAuB,EAAAg+B,cACrD,CACHl5F,KAAM,KACNikD,WAAW,EACXC,WAAW,EACXi1C,OAAQ,GACRC,aAAc,EACdl+B,aAAY,EACZw9B,eAAe,IAAAW,uBAAsB,EAAAC,uBACrCX,kBAAkB,IAAAU,uBAAsB,EAAAE,0BAEhD,C,4FCrBA,eAYA,gBACInhF,EACA9W,EACAtB,EACAikD,EACAC,GAEA5iD,EAAQtB,KAAOA,EACfsB,EAAQ2iD,YAAcA,EACtB3iD,EAAQ4iD,YAAcA,GAEtB,IAAA80C,iBAAgB5gF,EAAQ9W,EAC5B,C,uGCxBA,eAUA,yBAA8B8W,EAAiB9W,EAA6B+zF,GACxE,GAAI/zF,EAAQ63F,OAAOnvG,OAAS,EAAG,CAC3B,IAAMo2D,EACDi1C,IAAmC,GAAxB/zF,EAAQ83F,aAEb93F,EAAQ83F,aAAe/D,EAAU,GAAK,GAAK/zF,EAAQ63F,OAAOnvG,QAC3DsX,EAAQ63F,OAAOnvG,OAFfsX,EAAQ63F,OAAOnvG,OAAS,GAIlC,IAAAwvG,gBAAephF,EAAQ9W,EAAS8+C,E,CAExC,C,iGCpBA,eACA,WACA,WAWA,mBACIhoC,EACA9W,EACAm4F,EACAC,GAEA,QAFA,IAAAA,IAAAA,GAAA,GAEIp4F,EAAQtB,KAAM,CACdoY,EAAOsC,eACP,IAAIi/E,GAAa,EAEjB,EAAG,CACC,IAAM52E,EAAQzhB,EAAQ63F,OAAO73F,EAAQ83F,aAErC,GAAKr2E,GAAU3K,EAAOkE,eAAegxB,eAAevqB,EAAMoV,gBAEnD,CACH,IAAMyhE,GAAc,IAAAC,oBAAmB92E,EAAO02E,EAAan4F,EAAQ63F,QAEnE73F,EAAQ63F,OAAO1lG,OAAO6N,EAAQ83F,YAAa,IAC3C,IAAAI,gBACIphF,EACA9W,EACAA,EAAQ83F,aAAe93F,EAAQ63F,OAAOnvG,OAAS,EAAIsX,EAAQ83F,YAC3DQ,GAGJD,GAAa,C,MAZb,IAAAH,gBAAephF,EAAQ9W,EAAS,E,OAc/Bo4F,GAAcp4F,EAAQ63F,OAAO73F,EAAQ83F,cAE9C93F,EAAQo3F,cAAcvxD,QAElB7lC,EAAQ63F,OAAOnvG,OAAS,GACxBsX,EAAQo3F,cAAcoB,UAAUx4F,EAAQ63F,QAGxCQ,IACAvhF,EAAOsC,eACPtC,EAAOkF,aAAa,iBAAkB,CAClC8f,KAAMq8D,EACNv8D,OAAQ,EAAAriB,aAAa8wC,U,MAI7B,IAAA6tC,gBAAephF,EAAQ9W,GAAU,EAEzC,C,8HCtBA,aAII,WAAoBy4F,GAAA,KAAAA,SAAAA,CAAmB,CA6B3C,OA3BI,YAAAlzD,WAAA,SAAW+W,IAnBf,SAA+BA,GAC3B,MACsD,mBAA1CA,EAA4Bo8C,WACQ,iBAApCp8C,EAA4Bq8C,GAE5C,EAeYC,CAAsBt8C,IAVgC,mBAUGA,EAAIq8C,IAAIE,WAVnBC,MAW9C/mG,KAAK8mG,WAAav8C,EAAIq8C,IAAIE,WAC1B9mG,KAAKgnG,UAAY,IAAIz8C,EAAIo8C,UAEzB3mG,KAAK8mG,WAAWC,IAAI/mG,KAAK0mG,SAAU1mG,KAAKgnG,WAEhD,EAEA,YAAAtzD,QAAA,W,QACmB,QAAf,EAAA1zC,KAAK8mG,kBAAU,SAAEG,OAAOjnG,KAAK0mG,UACf,QAAd,EAAA1mG,KAAKgnG,iBAAS,SAAElzD,QAChB9zC,KAAKgnG,eAAYziG,EACjBvE,KAAK8mG,gBAAaviG,CACtB,EAEA,YAAAkiG,UAAA,SAAUX,G,QACN,GAAI9lG,KAAKgnG,U,IACL,IAAoB,qBAAAlB,GAAM,8BAAE,CAAvB,IAAMp2E,EAAK,QACZ1vB,KAAKgnG,UAAUhtD,IAAItqB,E,mGAG/B,EAEA,YAAAokB,MAAA,W,MACkB,QAAd,EAAA9zC,KAAKgnG,iBAAS,SAAElzD,OACpB,EACJ,EAjCA,GA0CA,iCAAsC4yD,GAClC,OAAO,IAAIQ,EAAoBR,EACnC,C,2PC9Ea,EAAAnB,qBAAuB,0BAKvB,EAAAU,sBAAwB,wBAKxB,EAAAT,sBAAwB,eAAe,EAAAS,sBAAqB,IAK5D,EAAAR,wBAA0B,6BAK1B,EAAAS,yBAA2B,2BAK3B,EAAAR,yBAA2B,eAAe,EAAAQ,yBAAwB,IAKlE,EAAAL,aAAe,E,4GCjC5B,eAiFA,SAASsB,EACLz3E,EACAoV,EACAC,EACAC,EACAC,G,aAGI,IAAA5vB,cAAayvB,EAAgB,eAC7B,IAAAzvB,cAAa2vB,EAAc,cAC3BD,GAAe,GACfA,IAAgD,QAAhC,EAAwB,QAAxB,EAAAD,EAAe5R,iBAAS,eAAEv8B,cAAM,QAAI,IACpDsuC,GAAa,GACbA,IAA4C,QAA9B,EAAsB,QAAtB,EAAAD,EAAa9R,iBAAS,eAAEv8B,cAAM,QAAI,KAEhD+4B,EAAMwV,SAASJ,EAAgBC,GAC/BrV,EAAMyV,OAAOH,EAAcC,GAEnC,CA9FA,8BACIvV,EACA02E,EACAgB,G,MAEA,KACK,IAAA/xF,cAAaqa,EAAMoV,eAAgB,gBACnC,IAAAzvB,cAAaqa,EAAMsV,aAAc,aAElC,OAAO,KAwBX,IArBA,IAAMhS,EAAWtD,EAAMoV,eACjBuiE,EAAkB33E,EAAMoV,eACxBwiE,EAAe53E,EAAMqV,YAAcqhE,EAAYzvG,OAE/C60B,EAAewH,EAASyJ,aAAe,GACvC9c,EACF6L,EAAatwB,UAAU,EAAGw0B,EAAMqV,aAChCqhE,GACC12E,EAAMsV,cAAgBtV,EAAMoV,eACvBtZ,EAAatwB,UAAUw0B,EAAMuV,UAA+B,QAApB,EAAAjS,EAASyJ,mBAAW,eAAE9lC,QAC9D,IACJ4wG,EAQF,CAAC,EAEIzuG,EAAI,EAAGA,EAAIsuG,EAAYzwG,OAAQmC,IAAK,CACzC,IAAM7B,EAAImwG,EAAYtuG,GAEtB,GAAI7B,EAAE6tC,gBAAkBpV,EAAMsV,cAAgB/tC,EAAE8tC,aAAerV,EAAMuV,UAAW,CAC5E,IAAMF,EACFrV,EAAMoV,gBAAkBpV,EAAMsV,aACxB/tC,EAAE8tC,YAAcrV,EAAMuV,UAAYvV,EAAMqV,YAAcqhE,EAAYzvG,OAClEM,EAAE8tC,YAAcrV,EAAMuV,UAC1BA,EACFhuC,EAAE6tC,gBAAkB7tC,EAAE+tC,aAChBD,GAAe9tC,EAAEguC,UAAYhuC,EAAE8tC,aAC/B9tC,EAAEguC,UAEZsiE,EAAczuG,GAAK,CACfgsC,eAAgB7tC,EAAE6tC,eAClBE,aAAc/tC,EAAE+tC,aAChBD,YAAW,EACXE,UAAS,E,MAENhuC,EAAE+tC,cAAgBtV,EAAMoV,gBAAkB7tC,EAAEguC,WAAavV,EAAMqV,cACtEwiE,EAAczuG,GAAK,CACfgsC,eAAgB7tC,EAAE6tC,eAClBE,aAAc/tC,EAAE+tC,aAChBD,YAAa9tC,EAAE8tC,YACfE,UAAWhuC,EAAEguC,W,CAgBzB,OAXAvV,EAAMs0B,iBACNhxB,EAASE,UAAYvT,GAErB,IAAAxE,eAAcosF,GAAeprG,SAAQ,SAAArD,GAC3B,MAA2DyuG,EAAczuG,GAAvEisC,EAAW,cAAEE,EAAS,YAAEH,EAAc,iBAAEE,EAAY,eAE5DmiE,EAAaC,EAAYtuG,GAAIgsC,EAAgBC,EAAaC,EAAcC,EAC5E,IAEAkiE,EAAaz3E,EAAO23E,EAAiBC,EAAcD,EAAiBC,GAE7D53E,CACX,C,wGC/EA,eAOA,0BACI3K,EACA9W,EACAqB,EACAk4F,GAEAv5F,EAAQq3F,iBAAiBxxD,QACzB7lC,EAAQ83F,YAAcz2F,EAEtB,IAAMogB,EAAQzhB,EAAQ63F,OAAO73F,EAAQ83F,aAErC,GAAIr2E,EAAO,CACPzhB,EAAQq3F,iBAAiBmB,UAAU,CAAC/2E,IACpC,IAAI4a,OAAI,EAEJr8B,EAAQ45D,cAAgB,IAAMv9B,EAAOvlB,EAAOqiB,wBAC5C,IAAAuD,oBACI5lB,EAAO0kC,qBACPnf,EACAvlB,EAAOkE,eACPyG,EAAM4b,wBACNr9B,EAAQ45D,cACR,E,MAIR55D,EAAQ83F,aAAe,EAG3BhhF,EAAOkF,aAAa,oBAAqB,CACrC87E,YAAa93F,EAAQ83F,YACrBD,OAAQ73F,EAAQ63F,OAChB0B,iBAAgB,GAExB,C,6BCjCA,SAASC,EAAa/xD,EAAWC,GAC7B,OAAID,EAAG5Q,gBAAkB6Q,EAAG7Q,eACjB4Q,EAAG3Q,YAAc4Q,EAAG5Q,YAEpB2Q,EAAG5Q,eAAe8jB,wBAAwBjT,EAAG7Q,gBAChD+jB,KAAKC,6BACF,EACD,CAEd,C,qEAbA,sBAA2Bg9C,GACvB,OAAOA,EAAOlmG,KAAK6nG,EACvB,C,wHCNA,WACA,WACA,WAOA,2BACI1iF,EACA9W,EACA05C,EACAC,G,MAIA,QALA,IAAAD,IAAAA,EAAA,WACA,IAAAC,IAAAA,EAAA,MAEA35C,EAAQo3F,cAAcvxD,QAElB7lC,EAAQtB,KAAM,CACN,MAA+BsB,EAAO,KAAhC,EAAyBA,EAAO,UAArB,EAAcA,EAAO,UACxC,EAAY8W,EAAOkE,eAYzB,GATIhb,EAAQ63F,OADRl+C,EACiB35C,EAAQ63F,OAAOz5F,QAC5B,SAAApV,GACI,OAAC2wD,EAAqBt6C,MAAK,SAAAnV,GAAK,OAAAA,EAAEid,SAASne,EAAE6tC,eAAb,KAChC,EAAUmV,eAAehjD,EAAE6tC,gBAAgB,EAD3C,IAIS,GAGjB6iB,EAAoB,CACpB,IAAM+/C,EAAY//C,EAAmBrsD,KAAI,SAAAnE,GACrC,WAAAw5D,iBAAgBx5D,EAAG,EAAM,EAAW,GAAW,EAA/C,IAEJ8W,EAAQ63F,QAAS,EAAA73F,EAAQ63F,QAAOzkG,OAAM,4CAAIqmG,IAAS,G,MAEnDz5F,EAAQ63F,OAAS,EAAUn1C,gBAAgB,EAAM,EAAW,IAGhE,IAAAg3C,YAAW15F,EAAQ63F,O,MAEnB73F,EAAQ63F,OAAS,GAGjB73F,EAAQ63F,OAAOnvG,OAAS,GACxBsX,EAAQo3F,cAAcoB,UAAUx4F,EAAQ63F,SAG5C,IAAAK,gBAAephF,EAAQ9W,GAAU,EACrC,C,8GClDA,eACA,WAOA,aAOI,WAAoBq5B,GAAA,KAAAA,OAAAA,EANZ,KAAAviB,OAAyB,IAMmB,CA2CxD,OAtCI,YAAAwuB,QAAA,WACI,MAAO,gBACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,CAClB,EAOA,YAAA2uB,QAAA,WACI1zC,KAAK+kB,OAAS,IAClB,EAQA,YAAAutB,cAAA,SAAc/W,GACLv7B,KAAK+kB,QAIa,kBAAnBwW,EAAMsE,WAAiCtE,EAAMsO,QAAU,EAAAriB,aAAakmB,aACpE,IAAAk6D,uBAAsB5nG,KAAK+kB,OAAQ/kB,KAAKsnC,OAEhD,EACJ,EAlDA,GAAa,EAAAugE,qBAAAA,C,8HCRb,WAUA,iCAAsC9iF,EAAiB4B,GAC/CA,EAAQmhF,wBAOhB,SAA0B/iF,EAAiBgjF,G,QACjCC,EAAUjjF,EAAOkE,eAAew7B,cAAc,K,IAEpD,IAAgB,qBAAAujD,GAAO,8BAAE,CAApB,IAAM/tG,EAAC,QACJ8tG,EAAQ9tG,KACR,IAAAm4E,oBAAmBn4E,GAAG,E,mGAGlC,CAdQguG,CAAiBljF,EAAQ4B,EAAQmhF,uBAIzC,C,yGChBA,eAUMI,EAA2C,SAAC3tF,GAAgB,OAAAA,CAAA,EAQlE,aAgBI,WACY4tF,EACAx3F,EACAy3F,GAHZ,gBACY,IAAAD,IAAAA,EAAA,QAAAA,QAAAA,EACA,KAAAx3F,OAAAA,EACA,KAAAy3F,YAAAA,EAlBJ,KAAArjF,OAAyB,KACzB,KAAAyM,UAA8B,KAC9B,KAAA82B,OAAiB,EACjB,KAAAxN,SAAgC,KAEhC,KAAA1O,YAA2B,KAC3B,KAAAi8D,YAAwC,KAiHtC,KAAAC,QAAU,SAACttD,GACjB,EAAKutD,iBAAiBvtD,EAAErqC,QAAgB,SAACiL,EAAM3hB,G,MACrCkuG,EACQ,aAAVntD,EAAE5mC,KAC2B,mBAAhB,EAAK+zF,QACR,EAAKA,QAAQvsF,EAAM3hB,GACnB,EAAKkuG,QACT,KACI,QAAd,IAAK32E,iBAAS,SAAE+9B,gBAAgB,QAAS44C,EAC7C,GACJ,CA9GG,CA+HP,OA1HI,YAAA50D,QAAA,WACI,MAAO,WACX,EAMO,YAAAC,WAAP,SAAkBzuB,GACd/kB,KAAK+kB,OAASA,EACd/kB,KAAKwxB,UAAYzM,EAAOkE,eACxBjpB,KAAKsoD,QAAUvjC,EAAOyK,iBAAiB84B,MACvCtoD,KAAK86C,SAAW/1B,EAAOohB,eAAe,CAClCqiE,UAAW,CAAEjiE,eAAgBvmC,KAAKsoG,SAClCG,SAAU,CAAEliE,eAAgBvmC,KAAKsoG,UAEzC,EAKO,YAAA50D,QAAP,WACQ1zC,KAAK86C,WACL96C,KAAK86C,WACL96C,KAAK86C,SAAW,MAGpB96C,KAAKosC,YAAc,KACnBpsC,KAAKqoG,YAAc,KACnBroG,KAAK+kB,OAAS,IAClB,EAMO,YAAAutB,cAAP,SAAqB/W,GAArB,I,MACQmtE,EADR,OAGI,GAAuB,WAAnBntE,EAAMsE,UAAwB,CAC9B,IACM,EACiB,UAAnB5qB,OAFEA,EAAuB,QAAX,EAAAjV,KAAK+kB,cAAM,eAAEyE,wBAElB,EAATvU,EAAWb,MAAkBa,EAAUya,MAAMqb,wBAA0B,KAEvE,GAAQ,GAAQ/qC,KAAKosC,cACrBpsC,KAAKosC,YAAc,EACnBpsC,KAAKqoG,YAAc,KAEnBroG,KAAKuoG,iBAAiB,GAAM,SAAC3sF,EAAM3hB,GAE3B,EAAKwiC,cACJisE,GAAc,IAAAz/F,WAAU,EAAKwzB,eAC9BisE,EAAY/uF,eAAiBiC,IAE7B,EAAKysF,YAAcpuG,EAE3B,I,MAED,GAAuB,SAAnBshC,EAAMsE,UAAsB,CACnC,IAAM5qB,EACA9W,EACiB,UAAnB8W,OAFEA,EAAuB,QAAX,EAAAjV,KAAK+kB,cAAM,eAAEyE,wBAElB,EAATvU,EAAWb,MAAkBa,EAAUya,MAAMqb,wBAA0B,KAGvE5sC,GACAA,GAAQ6B,KAAKosC,aACbpsC,KAAKqoG,aACLroG,KAAKqoG,YAAYjzF,SAASjX,IAC1BA,EAAKs+B,cACJisE,GAAc,IAAAz/F,WAAU9K,EAAKs+B,eAE9Bz8B,KAAKqoG,YAAY9xE,aAAa,OAAQmyE,EAAY/uF,c,KAE5B,WAAnB4hB,EAAMsE,WAA0BtE,EAAMskB,WAC7C7/C,KAAKuoG,iBAAiBhtE,EAAMiB,SAAS7rB,QAAgB,SAACiL,EAAMg9E,G,QACxD,KACqB,QAAhB,IAAKwP,mBAAW,oBAAhB,EAAmBxP,EAAQr9D,EAAMiB,YAClC,EAAK4xB,oBAAoB7yB,EAAMiB,WACL,IAA1BjB,EAAMiB,SAAS0e,OACjB,CACE3f,EAAMiB,SAASwf,iBAEf,IAAMrrC,EAAS,EAAKA,QAAU,SACxB,EAAoB,QAAX,IAAKoU,cAAM,eAAEiC,cAAciL,YAE1C,IACI,WAAQ02E,KAAK/sF,EAAMjL,E,CACrB,SAAM,C,CAEhB,IAC0B,kBAAnB4qB,EAAMsE,YACC,QAAd,EAAA7/B,KAAKwxB,iBAAS,SAAE+9B,gBAAgB,QAAS,MAEjD,EAcQ,YAAAg5C,iBAAR,SAAyBpqG,EAAYwjB,G,MAC3B1nB,EAAkB,QAAd,EAAA+F,KAAKwxB,iBAAS,eAAE06B,2BACtB/tD,EACA,WAEEyd,EAAO3hB,aAAC,EAADA,EAAGu8B,aAAa,QAEzB5a,GAAQ3hB,GACR0nB,EAAS/F,EAAM3hB,EAEvB,EAEQ,YAAAm0D,oBAAR,SAA4B7yB,GACxB,OAAOv7B,KAAKsoD,MAAQ/sB,EAAMwpB,QAAUxpB,EAAMupB,OAC9C,EACJ,EAnJA,GAAa,EAAA8jD,gBAAAA,C,0HClBb,eACA,WACA,WAGA,WA+BA,SAAgBC,IACZ,IAAMC,EAAiC,CACnCjjF,IAAK,MACLtN,MAAO,wEACP4oC,UAAW,EAAA4nD,sBAAsBC,aAE/BC,EAAmC,CACrCpjF,IAAK,MACLtN,MAAO,+CACP4oC,UAAW,EAAA4nD,sBAAsBG,cACjC7b,SAAU,IAQd,OALI4b,GACA,EAAAE,QAAQhtG,SAAQ,SAAAhE,GACZ,SAAAixG,QAAQjtG,SAAQ,SAAA/D,GAAC,MAAI,OAAsB,QAAtB,EAAA6wG,EAAc5b,gBAAQ,eAAE5sF,KAMzD,SAA6BtI,EAAkBC,GAC3C,IAcMyE,EAdAwsG,EAAmB,KAALlxG,EAAW,OAAS,QAClCmxG,EAAmB,KAALlxG,EAAW,MAAQ,SACjCmxG,EAAW,EAAAC,SAASpxG,EAAID,GAE9B,MAAO,CACH0tB,IAAK,MACLs7B,UAAW,EAAA4nD,sBAAsBU,WACjClxF,MAAO,gDAAgDngB,EAAID,EAAC,WAAWkxG,EAAW,MAAMC,EAAW,YAAY,EAAAI,iBAAgB,aAAa,EAAAA,iBAAgB,uBAAuBH,EAAQ,OAC3Lx6F,QAAS,CAAE5W,EAAC,EAAEC,EAAC,GACfi1F,UAKExwF,EAA8B,GACpC,CAAC,EAAG,GAAGV,SAAQ,SAAAuwF,GACX,OAAC,EAAG,GAAGvwF,SAAQ,SAAAkuE,GACXxtE,EAAO4D,KAMnB,SAAmCisF,EAAeriB,GAC9C,IAAMpzD,EACK,GAAPozD,EACM,SAASqiB,EAAK,cAAa,EAAAid,kBAA4B,EAARjd,GAAS,MACxD,OAAOA,EAAK,aAAY,EAAAid,kBAA4B,EAARjd,GAAS,MACzDkd,EAAmB,GAATld,EAAa,QAAU,QAEvC,MAAO,CACH7mE,IAAK,MACLtN,MAAO,0BAA0Bm0E,EAAK,aAAaA,EAAK,MAAMz1E,EAAQ,qBAAqB2yF,EAEnG,CAjBwBC,CAA0Bnd,EAAOriB,GACjD,GAFA,IAIGxtE,GATX,CAlB8DitG,CAAoB3xG,EAAGC,GAAG,GAA5E,IAGD,CAAC6wG,EAAeH,EAAaA,EAAaA,EAAaA,EAClE,CAvCA,8BAAmCx+E,GAa/B,OAZgBu+E,IACXvtG,KAAI,SAAAyuC,GACD,IAAMggE,GAAU,IAAA9iF,eAAc8iB,EAAMzf,GACpC,GACIy/E,IACA,IAAA10F,cAAa00F,EAAS,kBACtB,IAAA7uE,iBAAgB6uE,EAAS,OAEzB,OAAOA,CAEf,IACC19F,QAAO,SAAA09F,GAAW,QAAEA,CAAF,GAE3B,EAMA,e,gHCpCA,WAiFA,SAASC,EACLC,EACAC,EACAC,EACAC,EACAplB,GAEA,IAAMC,EAAWklB,GAAa,EAAIC,GAAqBplB,EACjDl3E,EAAWq8F,EAAYF,EAAiBC,EAE9C,OADmB7yG,KAAKC,IAAID,KAAKD,IAAI0W,EAAUm3E,GAAW,GACtCklB,CACxB,CAnFa,EAAAE,QAA2E,CACpF/rD,YAAa,SAAC,G,IAAEgsD,EAAQ,WAAO,wBAAMA,EAAN,EAC/BC,WAAY,SAAC,EAA6BvvD,EAAGwvD,EAAMC,EAAIC,G,QAAxCJ,EAAQ,WAAEnyG,EAAC,IAAEC,EAAC,IAAEuuB,EAAO,UACjC8jF,GAAD,gBAAW,IAAAE,kBAAiBF,EAAIC,EAAqB,QAAjB,EAAAJ,EAASnkB,gBAAQ,QAAI,GAAE,IAAxD,GAAEukB,EAAE,KAGH,IAAA7kB,EAMAykB,EAAQ,QALRxkB,EAKAwkB,EAAQ,SAJRvkB,EAIAukB,EAAQ,YAHRtkB,EAGAskB,EAAQ,aAFRrkB,EAEAqkB,EAAQ,WADRpkB,EACAokB,EAAQ,cAEZ,QACoB/lG,IAAhBwhF,QACiBxhF,IAAjByhF,QACezhF,IAAf0hF,QACkB1hF,IAAlB2hF,QACqB3hF,IAArBimG,EAAKzkB,kBACiBxhF,IAAtBimG,EAAKxkB,mBACezhF,IAApBimG,EAAKvkB,iBACkB1hF,IAAvBimG,EAAKtkB,oBACO3hF,IAAZshF,QACathF,IAAbuhF,EAEA,OAAO,EAGH,IAAApY,EAAwB/mD,EAAO,SAArBgnD,EAAchnD,EAAO,UACjCikF,EAAe,EAAI7kB,EAAcC,EACjC6kB,EAAgB,EAAI5kB,EAAaC,EAEvC,GACI0kB,EAAe,GACfC,EAAgB,QACHtmG,IAAbmpE,QACcnpE,IAAdopE,EACF,CACE,IAAMm9B,EAAYjlB,EAAU+kB,EACtBG,EAAajlB,EAAW+kB,EACxBG,EACG,KAAL7yG,EACM6xG,EAAKQ,EAAKzkB,YAAa0kB,EAAIK,EAAW9kB,EAActY,GACpDqY,EACJklB,EACG,KAAL9yG,EACM6xG,EAAKQ,EAAKxkB,cAAeykB,EAAIK,EAAW/kB,EAAarY,GACrDsY,EACJklB,EACG,KAAL9yG,EACM4xG,EAAKQ,EAAKvkB,WAAYykB,EAAIK,EAAY7kB,EAAevY,GACrDsY,EACJklB,EACG,KAAL/yG,EACM4xG,EAAKQ,EAAKtkB,eAAgBwkB,EAAIK,EAAY9kB,EAAYtY,GACtDuY,EASV,OAPAokB,EAASvkB,YAAcilB,EACvBV,EAAStkB,aAAeilB,EACxBX,EAASrkB,WAAailB,EACtBZ,EAASpkB,cAAgBilB,EACzBb,EAASzkB,QAAUilB,GAAa,EAAIE,EAAUC,GAC9CX,EAASxkB,SAAWilB,GAAc,EAAIG,EAASC,IAExC,C,CAEP,OAAO,CAEf,E,wHC9EJ,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,SACA,WACA,WACA,WA6BM1U,EAA4C,CAC9C/9E,YAAa,UACbg1D,SAAU,GACVC,UAAW,GACXy9B,eAAe,EACfC,eAAe,EACfC,mBAAmB,EACnBC,cAAe,CAAC,SAAU,WAIxBC,EAAU,YACVC,EAAmB,YACnBC,EAAyB,sBACzBC,EAA0B,iBAShC,aAoBI,WAAYhlF,GAnBF,KAAA5B,OAAyB,KAC3B,KAAA6mF,WAAqC,KACrC,KAAAC,cAAyC,KACvC,KAAAh3F,QAAkC,KAClC,KAAAi3F,cAA4C,KAC9C,KAAAC,iBAA4C,KAC5C,KAAAC,WAA2D,GAC3D,KAAAC,YAAuC,KACvC,KAAAC,QAAyB,KACzB,KAAAC,iBAA2B,EAC3B,KAAAC,YAAsB,EACtB,KAAAC,SAA6B,GAC7B,KAAAC,SAA6B,GAC7B,KAAAC,SAA6B,GAC7B,KAAAz6E,UAAoB,EACpB,KAAAgpB,SAAgC,KAC9B,KAAA0xD,WAAY,EAIlBxsG,KAAK2mB,SAAU,EAAH,8BAAQ8vE,GAAmB9vE,EAC3C,CAywBJ,OApwBI,YAAA4sB,QAAA,WACI,MAAO,WACX,EAQA,YAAAC,WAAA,SAAWzuB,GAAX,WACI/kB,KAAK+kB,OAASA,EACd/kB,KAAK86C,SAAW/1B,EAAOohB,eAAe,CAClC8jB,KAAM,CACF1jB,eAAgB,WACR,EAAKimE,WAAa,EAAKznF,SAAW,EAAKA,OAAO4E,cAC9C,EAAK8iF,4BACD,EAAK1nF,OACL,EAAKqnF,YACL,EAGZ,GAEJ9rD,UAAW,CACP/Z,eAAgB,SAAAmmE,GACZ,GAAI,EAAK3nF,OAAQ,CACb,IAAMpU,EAAS+7F,EAAG/7F,OACd,EAAKg8F,iBAAiBh8F,KACtBA,EAAOgX,GAAKhX,EAAOgX,GAAK6jF,E,CAGpC,GAEJoB,QAAS,CACLrmE,eAAgB,SAAAmmE,GACZ,GAAI,EAAK3nF,OAAQ,CACb,IAAMpU,EAAS+7F,EAAG/7F,OACd,EAAKg8F,iBAAiBh8F,IAAWA,EAAOgX,GAAGsT,SAASuwE,KACpD76F,EAAOgX,GAAKhX,EAAOgX,GAAG9a,QAAQ2+F,EAAS,IAAI35F,O,CAGvD,IAGZ,EAOA,YAAA6hC,QAAA,WACQ1zC,KAAK86C,WACL96C,KAAK86C,WACL96C,KAAK86C,SAAW,MAEpB96C,KAAKwsG,WAAY,EACjBxsG,KAAK6sG,YACL7sG,KAAK+kB,OAAS,IAClB,EAQA,YAAAutB,cAAA,SAAc/W,GACV,GAAKv7B,KAAK+kB,OAGV,OAAQwW,EAAMsE,WACV,IAAK,YACD7/B,KAAK8sG,iBAAiB9sG,KAAK+kB,OAAQwW,GACnC,MACJ,IAAK,UACDv7B,KAAK+sG,eAAe/sG,KAAK+kB,OAAQwW,GACjC,MACJ,IAAK,UACDv7B,KAAKgtG,eAAehtG,KAAK+kB,OAAQwW,GACjC,MACJ,IAAK,iBACDv7B,KAAKitG,sBAAsBjtG,KAAK+kB,OAAQwW,GACxC,MACJ,IAAK,wBACDv7B,KAAKktG,mBAAmB3xE,EAAMgB,YAC9B,MACJ,IAAK,0BACDv8B,KAAKmtG,gCAGjB,EAEQ,YAAAA,8BAAR,WACQntG,KAAKwsG,WAAaxsG,KAAK+kB,SAAW/kB,KAAK+kB,OAAO4E,eAC9C3pB,KAAKysG,4BACDzsG,KAAK+kB,OACL/kB,KAAKosG,YACL,GAEJpsG,KAAKotG,qBACLptG,KAAK6sG,YAEb,EAEQ,YAAAK,mBAAR,SAA2B3wE,GACRA,EAAW5G,iBAAiB,OACpCx5B,SAAQ,SAAAgc,GACPA,EAAMpJ,QAAQ+9E,oBACP30E,EAAMpJ,QAAQ+9E,WAE7B,GACJ,EAEQ,YAAA6f,iBAAR,SAAyBh8F,GACrB,OACI,IAAA0E,cAAa1E,EAAQ,mBACpB,IAAAuqB,iBAAgBvqB,EAAQ,YAEjB,IAAAuqB,iBAAgBvqB,EAAQ,SACxBA,EAAOggC,oBACP,IAAAt7B,cAAa1E,EAAOggC,kBAAmB,kBACvC,IAAAzV,iBAAgBvqB,EAAOggC,kBAAmB,QAG1D,EAEQ,YAAAo8D,eAAR,SAAuBhoF,EAAiBwW,GACpC,IAAMtmB,EAAY8P,EAAOyE,kBACzB,GAAKvU,GAA+B,SAAlBA,EAAUb,MAAoBpU,KAAKwsG,UAAW,CAC5D,IAAMa,EACFrtG,KAAK2sG,iBAAiBpxE,EAAMiB,SAAS7rB,SA5K5B,IA6KT4qB,EAAMiB,SAAS0e,OACnBl7C,KAAKysG,4BAA4B1nF,EAAQ/kB,KAAKosG,WAAYiB,E,CAElE,EAEQ,YAAAP,iBAAR,SAAyB/nF,EAAiBwW,GAElCv7B,KAAKwsG,WACLxsG,KAAK2sG,iBAAiBpxE,EAAMiB,SAAS7rB,SArLxB,IAsLb4qB,EAAMiB,SAAS0e,SACdl7C,KAAKosG,YAENpsG,KAAKysG,4BAA4B1nF,EAAQ/kB,KAAKosG,WAEtD,EAEQ,YAAAkB,cAAR,SAAsBvoF,GAClB,IAAM9P,EAAY8P,EAAOyE,kBACF,UAAnBvU,aAAS,EAATA,EAAWb,OACX2Q,EAAOE,oBAAmB,SAAAxuB,GACtB,IAAM82G,GAAe,IAAAC,kBAAiB/2G,EAAOwe,EAAUkD,MAAMwP,IACvD8lF,GAAe,IAAAD,kBACjB/2G,EACAwe,EAAUkD,MAAMwP,GAAG9a,QAAQ2+F,EAAS,IAAI35F,QAE5C,GAAI07F,GAAgBE,EAAc,CAC9B,IAAMC,EAAeH,EAAa/7F,UAAUpF,SAAS/L,QACjDktG,EAAap1F,QAEjB,IAAA9N,aAAYkjG,EAAa/7F,WAAWpF,SAAShM,OAAOstG,EAAc,GAClE,IAAMngG,EAAUkgG,EAAat1F,MACvB3G,EAAYi8F,EAAaj8F,UAM/B,OALA,IAAAJ,eAAcI,EAAWjE,GAAS,SAAA4K,GAC9BA,EAAM/K,YAAa,EACnB+K,EAAMgmD,4BAA6B,CACvC,KAEO,C,CAEX,OAAO,CACX,GAER,EAEQ,YAAA6uC,eAAR,SAAuBjoF,EAAiBwW,GAChCv7B,KAAKwsG,YAEsB,WAAvBjxE,EAAMiB,SAASrnC,KACQ,WAAvBomC,EAAMiB,SAASrnC,KACQ,cAAvBomC,EAAMiB,SAASrnC,KAEY,WAAvBomC,EAAMiB,SAASrnC,KACf6K,KAAKotG,qBAETptG,KAAK6sG,cAEqB,SAAtBtxE,EAAMiB,SAASrnC,KAAkB6K,KAAKosG,YACtC7wE,EAAMiB,SAASwf,iBAEnBh8C,KAAKysG,4BACD1nF,EACA/kB,KAAKosG,YACL,GACA,IAIhB,EAEQ,YAAAuB,kBAAR,WACQ3tG,KAAK6rG,gBACL7rG,KAAK6sG,aACL,IAAAh7B,eAAc7xE,KAAK6rG,cAAe,IAClC7rG,KAAKwsG,WAAY,EACjBxsG,KAAKosG,YAAa,EAE1B,EAEQ,YAAAwB,mBAAR,SAA2BryE,GACnBv7B,KAAKwsG,WAAajxE,EAAMyO,gBAAkB2hE,IAC1C3rG,KAAK6sG,YACL7sG,KAAKwsG,WAAY,EACjBxsG,KAAKosG,YAAa,EAE1B,EAEQ,YAAAa,sBAAR,SAA8BloF,EAAiBwW,GAC3C,OAAQA,EAAMsO,QACV,KAAK,EAAAriB,aAAakmB,WACd1tC,KAAK2tG,oBACL,MACJ,KAAK,EAAAnmF,aAAasiB,OACd9pC,KAAK4tG,mBAAmBryE,GACxB,MACJ,KAAK,EAAA/T,aAAak3B,KACd1+C,KAAKstG,cAAcvoF,GAG/B,EAKU,YAAA0nF,4BAAV,SACI1nF,EACAqnF,EACAiB,EACAQ,GAJJ,IAMQC,EANR,OAOU74F,EAAY8P,EAAOyE,kBACrBukF,GAAiB,EAErBhpF,EAAOE,oBACH,SAACxuB,EAAOwX,GACJ,IAAM+/F,GAAe,IAAAC,kBAAiBx3G,GAChCy3G,EAAwBL,EACxBG,GACA,IAAAR,kBAAiB/2G,GACnBoG,GAAS,EAKb,GAFAoR,EAAQ6Y,iBAAmB,UAGvBumF,IACAa,aAAqB,EAArBA,EAAuB/1F,SAAS61F,aAAY,EAAZA,EAAc71F,SAC9C+1F,aAAqB,EAArBA,EAAuB/1F,MAAM5N,OAAOgkE,aAAc,EAAA4/B,gBAClDN,EACF,CACQ,MAAyD,EAAvD,EAAO,UAAE,EAAa,gBAAE,EAAa,gBAAE,EAAW,eAErD,EAAKrB,WAAaqB,IACnBK,GACA,GACA,GACA,GACA,KAEA,IAAA98F,eACI88F,EAAsB18F,UACtB08F,EAAsB/1F,OACtB,SAAAA,GACI,IAAMi2F,GAAc,IAAAC,aAChBtpF,EACA,EACA5M,EACA,EACA,EACA,EAAKg0F,iBAAmB,EAAKC,WAC7B,IAGA,EAAKD,iBAAkC,gBAAfiC,KACxBngG,EAAQ6Y,kBAAmB,GAE/B,IAAMwnF,GACFJ,aAAqB,EAArBA,EAAuB/1F,UAAU61F,aAAY,EAAZA,EAAc71F,OACnDA,EAAM/K,WAAakhG,GAAejB,EAClCl1F,EAAMgmD,2BAA6BmwC,GAAejB,EAClDl1F,EAAM5N,OAAOgkE,gBAAahqE,EAEH,UAAnB0Q,aAAS,EAATA,EAAWb,OAAoBa,EAAUya,MAAMC,YACpB,IAAAvQ,uBAAsB3oB,GAAO,GACd6W,MAAK,SAAAkE,GAC3C,OAAAA,EAAUpF,SAAS6uB,SAAS9iB,EAA5B,MAGAA,EAAM/K,YAAa,EAG/B,IAGAigG,IACA,IAAAkB,yBAAwBL,GAG5B,EAAKrB,YACLhwG,GAAS,GAGb,EAAK2vG,WAAY,EACjB,EAAKJ,YAAa,GAGd4B,GACmB,UAAnB/4F,aAAS,EAATA,EAAWb,OACVi5F,GACAQ,IAED,EAAKrB,WAAY,EACjB,EAAKJ,WAAaA,GAClB,IAAAh7F,eAAc48F,EAAax8F,UAAWw8F,EAAa71F,OAAO,SAAAA,GACtD21F,EAAoB31F,EACpB41F,EAAmD,OAA3CC,EAAax8F,UAAUjH,OAAOC,UACtC,EAAKshG,eAAgB,IAAA0C,qBAAoBr2F,EAAOlD,EAAUkD,OAC1DA,EAAM5N,OAAOgkE,WAAa,WAC9B,IAEA1xE,GAAS,E,CAIjB,OAAOA,CACX,GACA,CACIgvB,cAAe,SAACp1B,EAAO0H,IAEd0vG,GACDC,GACAA,GAAqBr3G,GACrBq3G,EAAkBvjG,OAAOgkE,YAAc,EAAA4/B,iBACvC,IAAA94F,cAAalX,EAAM,kBACnB,IAAA+8B,iBAAgB/8B,EAAM,SAElBiuG,EACA,EAAKqC,cAAc1pF,EAAQ5mB,EAAM4vG,GAEjC,EAAKW,qBAAqB3pF,EAAQ5mB,EAAM4vG,GAGpD,EACA5oF,QAASwmF,GAEb,CACItiF,iBAAiB,GAG7B,EAEQ,YAAAslF,aAAR,SACI5pF,EACA5M,EACAy2F,GAHJ,WAKS5uG,KAAK8rG,gBACN9rG,KAAK8rG,eAAgB,IAAA+C,0BAAyB9pF,EAAQ5M,IAIvB,GAA9BnY,KAAK8rG,cAAcjmB,SAA+C,GAA/B7lF,KAAK8rG,cAAchmB,UACtD3tE,EAAM22F,UAcP9uG,KAAK+uG,4BAA4B52F,GACjCnY,KAAKgvG,qBAAqBjqF,EAAQ5M,EAAOy2F,KAZzCz2F,EAAMkvD,OAAS,WACX,EAAK0nC,4BAA4B52F,GACjC,EAAK62F,qBAAqBjqF,EAAQ5M,EAAOy2F,GACzCz2F,EAAMkvD,OAAS,KACflvD,EAAMmvD,QAAU,IACpB,EACAnvD,EAAMmvD,QAAU,WACZnvD,EAAMkvD,OAAS,KACflvD,EAAMmvD,QAAU,IACpB,EAKR,EAEQ,YAAAynC,4BAAR,SAAoC52F,G,QACI,KAAd,QAAlB,EAAAnY,KAAK8rG,qBAAa,eAAEjmB,UAAkD,KAAf,QAAlB,EAAA7lF,KAAK8rG,qBAAa,eAAEhmB,YACzD9lF,KAAK8rG,cAAcjmB,QAAU1tE,EAAM43C,YACnC/vD,KAAK8rG,cAAchmB,SAAW3tE,EAAM82F,aAE5C,EAEQ,YAAAD,qBAAR,SACIjqF,EACA5M,EACAy2F,GAEK5uG,KAAK8rG,gBACN9rG,KAAK8rG,eAAgB,IAAA+C,0BAAyB9pF,EAAQ5M,IAG1DnY,KAAK+rG,kBAAmB,IAAAmD,qBAAoBnqF,EAAQ/kB,KAAK2mB,QAAS3mB,KAAK8rG,eACvE9rG,KAAKksG,QAAU/zF,EAAMqe,aAAa,OAE5B,OAOF,IAAA24E,oBACApqF,EACA5M,EACAnY,KAAK2mB,QACL3mB,KAAK8rG,cACL9rG,KAAK+rG,iBACL6C,GAZAvC,EAAQ,WACRC,EAAQ,WACRz3F,EAAO,UACP+2F,EAAU,aACVwD,EAAU,aACV7C,EAAQ,WASZvsG,KAAK4rG,WAAaA,EAClB5rG,KAAK6rG,cAAgB1zF,EACrBnY,KAAK6U,QAAUA,EACf7U,KAAKisG,YAAcmD,EACnBpvG,KAAKmsG,iBAAkB,IAAAkD,wBAAuBl3F,GAC9CnY,KAAKqsG,SAAWA,EAChBrsG,KAAKssG,SAAWA,EAChBtsG,KAAKusG,SAAWA,EAChBvsG,KAAK8xB,UAAY/M,EAAOkE,eAAe8I,qBAEvChN,EAAOsiB,eAAeokE,EAAkB,gCAAiC,CACrE,iBAAgB,IAAAt+D,mBAAkBntC,KAAK6rG,cAAclkF,IAAG,MAG5D5C,EAAOsiB,eAAeqkE,EAAwB,4BAClD,EAEO,YAAAgD,qBAAP,SAA4B3pF,EAAiB5M,EAAyB41F,GAAtE,I,IAAA,OACI,GAAI/tG,KAAK8rG,gBACL9rG,KAAK2uG,aAAa5pF,EAAQ5M,EAAO,CAAC,SAAU,WACxCnY,KAAK6rG,eAAiB7rG,KAAK8rG,eAAiB9rG,KAAK6U,SAAW7U,KAAKisG,aAAa,CAC9E,IAAMqD,IAAoBvqF,EAAOyK,iBAAiBqiC,iBAClD7xD,KAAKgsG,YAAa,EAAH,sDACR,IAAAuD,uBACCvvG,KAAK6U,QACL7U,KAAK8rG,cACL9rG,KAAK2mB,QACL,EAAAoiF,sBAAsByG,aACtB,EAAAC,SACA,WAEQ,EAAK3D,eACL,EAAKD,eACL,EAAKh3F,SACL,EAAKo3F,eAEL,IAAAyD,eACI,EAAK5D,cACL,EAAKnlF,QACL,EAAKklF,cACL,EAAKI,YACL,EAAKp3F,QACL,EAAKw3F,cACL9nG,EACAwpG,GAEJ,EAAK5B,iBAAkB,EAE/B,GACAnsG,KAAK8xB,UACLw9E,KACH,iBACE,IAAAC,uBACCvvG,KAAK6U,QACL7U,KAAK8rG,cACL9rG,KAAK2mB,QACL,EAAAoiF,sBAAsB4G,aACtB,EAAAC,SACA,W,QAEQ,EAAK9D,eACL,EAAKD,eACL,EAAKh3F,SACL,EAAKo3F,eAEL,IAAAyD,eACI,EAAK5D,cACL,EAAKnlF,QACL,EAAKklF,cACL,EAAKI,YACL,EAAKp3F,aACLtQ,OACAA,EACAwpG,GACA,GAEJ,EAAK8B,wBACD9qF,EACA,EAAK8mF,cACL,EAAKh3F,QACL,EAAKy3F,SACa,QAAlB,IAAKR,qBAAa,eAAE3lB,YACN,QAAZ,IAAKx/D,eAAO,eAAE2kF,oBAEpB,EAAKwE,4BACD,EAAKzD,SACL,EAAKP,cAAc3lB,UAG/B,GACAnmF,KAAK8xB,UACLw9E,KACH,IAGL,IAAAI,eACI1vG,KAAK8rG,cACL9rG,KAAK2mB,QACL3mB,KAAK6rG,cACL7rG,KAAKisG,YACLjsG,KAAK6U,QACL7U,KAAKqsG,cACL9nG,EACAwpG,GAGJ/tG,KAAK6vG,wBACD9qF,EACA/kB,KAAK6rG,cACL7rG,KAAK6U,QACL7U,KAAKssG,SACa,QAAlB,EAAAtsG,KAAK8rG,qBAAa,eAAE3lB,YACN,QAAZ,EAAAnmF,KAAK2mB,eAAO,eAAE2kF,mB,CAIhC,EAEQ,YAAAwE,4BAAR,SAAoCzD,EAA4BlmB,GAC5D,IAAM4pB,GAAgB,IAAAC,2BAA0B3D,QAC/B9nG,IAAb4hF,IACA,IAAA8pB,oBAAmBF,EAAe5pB,EAE1C,EAEQ,YAAA0pB,wBAAR,SACI9qF,EACA5M,EACAtD,EACAy3F,EACAnmB,EACAmlB,GAEA,IAAM4E,EAAWnrF,EAAOqiB,qBAClB+oE,GAAa,IAAAC,eAAcj4F,EAAMG,MAAOH,EAAMiM,QACpD,GAAI8rF,GAAY5D,GAAYA,EAAS31G,OAAS,EAAG,CAC7C,IAAM05G,EAAU/D,EAAS,GACnBgE,EAAgBD,EAAQ1/D,mBAE1B,IAAAt7B,cAAai7F,EAAe,kBAC5B,IAAAp1E,iBAAgBo1E,EAAe,SAE/B,IAAAC,oBACIL,EACA/pB,QAAAA,EAAY,EACZtxE,EACAw7F,EACAC,EACAH,EACA7E,E,CAIhB,EAEO,YAAAkF,mBAAP,SAA0BvvF,GACtB,MACkB,WAAdA,GACc,WAAdA,GACc,SAAdA,GACc,SAAdA,CAER,EAEO,YAAAwvF,mBAAP,SAA0Bt4F,GACtB,OAAO,IAAAs4F,oBAAmBt4F,EAC9B,EAEQ,YAAAs2F,cAAR,SAAsB1pF,EAAiB5M,EAAyB41F,GAAhE,WACQ/tG,KAAK8rG,gBACL9rG,KAAK2uG,aAAa5pF,EAAQ5M,EAAO,CAAC,SAC9BnY,KAAK8rG,eAAiB9rG,KAAK6rG,eAAiB7rG,KAAK6U,SAAW7U,KAAKisG,cACjEjsG,KAAKgsG,YAAa,EAAH,kCACR,IAAAuD,uBACCvvG,KAAK6U,QACL7U,KAAK8rG,cACL9rG,KAAK2mB,QACL,EAAAoiF,sBAAsBU,WACtB,EAAAY,SACA,WAEQ,EAAKyB,eACL,EAAKD,eACL,EAAKh3F,SACL,EAAKo3F,eAEL,IAAAyD,eACI,EAAK5D,cACL,EAAKnlF,QACL,EAAKklF,cACL,EAAKI,YACL,EAAKp3F,aACLtQ,EACA,EAAKgoG,SACLwB,GAEJ,EAAK3B,YAAa,EAE1B,GACApsG,KAAK8xB,YACH/M,EAAOyK,iBAAiBqiC,oBAC7B,IAEL,IAAA69C,eACI1vG,KAAK8rG,cACL9rG,KAAK2mB,QACL3mB,KAAK6rG,cACL7rG,KAAKisG,YACLjsG,KAAK6U,aACLtQ,EACAvE,KAAKusG,SACLwB,IAIhB,EAEO,YAAA2C,UAAP,WACI,GAAK1wG,KAAK+kB,OAAV,CAGK/kB,KAAK+kB,OAAOyK,iBAAiBC,UAC9BzvB,KAAK+kB,OAAOC,QAEhB,IAAM/P,EAAYjV,KAAK+kB,OAAOyE,kBACP,UAAnBvU,aAAS,EAATA,EAAWb,OACXpU,KAAKysG,4BACDzsG,KAAK+kB,QACL,GACA,E,CAGZ,EAEQ,YAAA4rF,UAAR,SACI5rF,EACA5M,EACAy2F,EACA3tF,GAEAjhB,KAAK2uG,aAAa5pF,EAAQ5M,EAAOy2F,GAC5B5uG,KAAK6rG,eAAkB7rG,KAAK8rG,eAAkB9rG,KAAK6U,SAAY7U,KAAKisG,cAIzEhrF,EAAUjhB,KAAK8rG,gBAEf,IAAA4D,eACI1vG,KAAK8rG,cACL9rG,KAAK2mB,QACL3mB,KAAK6rG,cACL7rG,KAAKisG,YACLjsG,KAAK6U,SAGT7U,KAAKysG,4BACD1nF,GACA,GACA,GACA,GAER,EAKO,YAAA8nF,UAAP,W,QACe,QAAX,EAAA7sG,KAAK+kB,cAAM,SAAEsiB,eAAeokE,EAAkB,MACnC,QAAX,EAAAzrG,KAAK+kB,cAAM,SAAEsiB,eAAeqkE,EAAwB,MACpD1rG,KAAK6rG,cAAgB,KACrB7rG,KAAK4rG,WAAa,KAClB5rG,KAAK6U,QAAU,KACf7U,KAAK8rG,cAAgB,KACrB9rG,KAAK+rG,iBAAmB,KACxB/rG,KAAKgsG,WAAW7vG,SAAQ,SAAAqoD,GAAU,OAAAA,EAAO9Q,SAAP,IAClC1zC,KAAKgsG,WAAa,GAClBhsG,KAAKisG,YAAc,KACnBjsG,KAAKksG,QAAU,KACflsG,KAAKmsG,iBAAkB,EACvBnsG,KAAKosG,YAAa,EAClBpsG,KAAKqsG,SAAW,GAChBrsG,KAAKssG,SAAW,GAChBtsG,KAAKusG,SAAW,EACpB,EAEQ,YAAAa,mBAAR,WACI,IAAIj1F,EAAiC,KAcrC,OAbInY,KAAK4rG,YAAc5rG,KAAK4rG,WAAW3vE,gBAE/Bj8B,KAAK4rG,WAAWj7D,oBAChB,IAAAt7B,cAAarV,KAAK4rG,WAAWj7D,kBAAmB,kBAChD,IAAAzV,iBAAgBl7B,KAAK4rG,WAAWj7D,kBAAmB,SAEnDx4B,EAAQnY,KAAK4rG,WAAWj7D,oBAE5B,IAAA7T,QAAO98B,KAAK4rG,YACZ5rG,KAAK4rG,WAAa,KAClB5rG,KAAK6U,QAAU,MAGZsD,CACX,EAEO,YAAAy4F,UAAP,SAAiBpmG,G,MACPyK,EAAuB,QAAX,EAAAjV,KAAK+kB,cAAM,eAAEyE,kBAC/B,GAAKxpB,KAAK+kB,QAAW9P,GAAgC,UAAnBA,EAAUb,KAA5C,CAGA,IAAM+D,EAAQlD,EAAUkD,MACpBnY,KAAK+kB,QACL/kB,KAAK2wG,UAAU3wG,KAAK+kB,OAAQ5M,EAAO,CAAC,SAAS,SAAA2zF,GACzC,IAAM3lB,EAAW2lB,EAAc3lB,UAAY,EAEtCA,GAAY9uF,KAAK8C,GAAK,GAAKgsF,EAAY,EAAI9uF,KAAK8C,GAAM,GACtDgsF,IAAa9uF,KAAK8C,GAAK,GAAKgsF,GAAa,EAAI9uF,KAAK8C,GAAM,EAEvC,eAAdqQ,EACAshG,EAActlB,iBAAmBslB,EAActlB,gBAE/CslB,EAAcvlB,mBAAqBulB,EAAcvlB,kBAGnC,aAAd/7E,EACAshG,EAActlB,iBAAmBslB,EAActlB,gBAE/CslB,EAAcvlB,mBAAqBulB,EAAcvlB,iBAG7D,G,CAER,EAEO,YAAAsqB,YAAP,SAAmB1qB,G,MACTlxE,EAAuB,QAAX,EAAAjV,KAAK+kB,cAAM,eAAEyE,kBAC/B,GAAKxpB,KAAK+kB,QAAW9P,GAAgC,UAAnBA,EAAUb,KAA5C,CAGA,IAAM+D,EAAQlD,EAAUkD,MACpBnY,KAAK+kB,QACL/kB,KAAK2wG,UAAU3wG,KAAK+kB,OAAQ5M,EAAO,IAAI,SAAA2zF,GACnCA,EAAc3lB,UAAY2lB,EAAc3lB,UAAY,GAAKA,CAC7D,G,CAER,EACJ,EA/xBA,GAAa,EAAA2qB,gBAAAA,C,4GCtEb,eACA,WACA,WACA,WAgBA,8BACIxmF,EACAghF,EACAyF,GAEA,IAAMC,EAkBV,SAA6BD,GACzB,IAAMl0G,EAA8B,GAapC,OAXA,EAAAo0G,GAAG90G,SAAQ,SAAAhE,GACP,SAAA+4G,GAAG/0G,SAAQ,SAAA/D,GACP,IAAM+4G,EAAoB,IAALh5G,IAAkB,IAALC,GAAWg5G,EAAoBj5G,EAAGC,GAAK,KACrE24G,GAAsBI,GACtBJ,EAAmBI,EAAah5G,EAAGC,GAEnC+4G,GACAt0G,EAAO4D,KAAK0wG,EAEpB,GARA,IAUGt0G,CACX,CAjC2Bw0G,CAAoBN,GACrCO,EAsCV,SAA2BP,GACvB,IAAMl0G,EAA8B,GAYpC,OAXA,EAAAo0G,GAAG90G,SAAQ,SAAAhE,GACP,SAAA+4G,GAAG/0G,SAAQ,SAAA/D,GACP,IAAM+4G,EAAoB,IAALh5G,IAAkB,IAALC,GAAWg5G,EAAoBj5G,EAAGC,GAAK,KACrE24G,GAAsBI,GACtBJ,EAAmBI,EAAah5G,EAAGC,GAEnC+4G,GACAt0G,EAAO4D,KAAK0wG,EAEpB,GARA,IAUGt0G,CACX,CApDyB00G,CAAkBR,GAGvC,OAFgBzF,EAAoB0F,EAAiBA,EAAe3vG,OAAOiwG,IAGtEh2G,KAAI,SAAAi5B,GACD,IAAMi9E,GAAS,IAAAvqF,eAAcsN,EAASjK,GACtC,IAAI,IAAAjV,cAAam8F,EAAQ,kBAAmB,IAAAt2E,iBAAgBs2E,EAAQ,OAChE,OAAOA,CAEf,IACCnlG,QAAO,SAAAkoB,GAAW,QAAEA,CAAF,GAC3B,EA2CA,IAAMk9E,EAAoB,SAACjnG,EAAmB8+F,EAAqBD,GAC/D,MAAO,6EAAmH7+F,EAAS,WAAW8+F,EAAvI,SAAiLD,EAAjL,mHACX,EAEA,SAAS+H,EAAoBj5G,EAAkBC,GAC3C,IAAMixG,EAAmB,KAALlxG,EAAW,OAAS,QAClCmxG,EAAmB,KAALlxG,EAAW,MAAQ,SAIvC,MAAY,IAALD,GAAgB,IAALC,EACZ,KACA,CACIytB,IAAK,MACLtN,MAAO,qBAAqB8wF,EAAW,KAPnB,IAALlxG,EAAU,MAAQ,OAO0B,IAAImxG,EAAW,KANtD,IAALlxG,EAAU,MAAQ,OAOjCi1F,SAAU,CACN,CACIxnE,IAAK,MACLtN,MAAOk5F,EATPr5G,EAAID,EASgCmxG,EAAaD,GACjDloD,UAAW,EAAA4nD,sBAAsByG,aACjCzgG,QAAS,CAAE5W,EAAC,EAAEC,EAAC,KAIrC,C,gHCvGA,WASa,EAAAq3G,QAA6E,CACtFnxD,YAAa,SAAC,G,IAAEgsD,EAAQ,WAAO,wBAAMA,EAAN,EAC/BC,WAAY,SAAC,EAA6BvvD,EAAGwvD,EAAMkH,EAAQC,G,QAA5Cx5G,EAAC,IAAEC,EAAC,IAAEkyG,EAAQ,WAAE3jF,EAAO,UAClC,GACI6jF,EAAK1kB,UACL0kB,EAAK3kB,cACgBthF,IAArBoiB,EAAQ+mD,eACcnpE,IAAtBoiB,EAAQgnD,UACV,CACE,IAAM/zE,EACF4wG,EAAK3kB,QAAU,GAAK2kB,EAAK1kB,SAAW,EAAoB,EAAf0kB,EAAK3kB,QAAiB2kB,EAAK1kB,SAAW,EAClF4rB,GAAD,gBAAmB,IAAA/G,kBAAiB+G,EAAQC,EAAyB,QAAjB,EAAArH,EAASnkB,gBAAQ,QAAI,GAAE,IAApE,GAAEwrB,EAAM,KACf,IAAMC,EAAsB,IAALz5G,EACjB05G,EAAoB,IAALz5G,EACf05G,IACAF,GAAkBC,KAAkBlrF,EAAQykF,eAAiBpwD,EAAE8G,UACjEp9B,EAAWktF,EACTpH,EAAK3kB,QACLxuF,KAAKC,IAAIkzG,EAAK3kB,QAAU6rB,GAAe,KAALv5G,GAAY,EAAI,GAAIwuB,EAAQ+mD,UAChE7oD,EAAYgtF,EACVrH,EAAK1kB,SACLzuF,KAAKC,IAAIkzG,EAAK1kB,SAAW6rB,GAAe,KAALv5G,GAAY,EAAI,GAAIuuB,EAAQgnD,WAsBrE,OApBImkC,GAAuBl4G,EAAQ,IAC3BA,EAAQ,GAER8qB,EAAWG,EAAYjrB,GACR+sB,EAAQ+mD,WAEnB7oD,GADAH,EAAWiC,EAAQ+mD,UACI9zE,IAI3BirB,EAAYH,EAAW9qB,GACP+sB,EAAQgnD,YAEpBjpD,GADAG,EAAY8B,EAAQgnD,WACG/zE,IAKnC0wG,EAASzkB,QAAUnhE,EACnB4lF,EAASxkB,SAAWjhE,GACb,C,CAEP,OAAO,CAEf,E,mHCrDJ,uCAA4CktF,EAA2BC,GACnED,EAAQ51G,SAAQ,SAAAq1G,GACN,MAAWA,EAAOziG,QAAhB3W,EAAC,IAAED,EAAC,IAGN85G,EADa,CAAC,IAAK,IAAK,IAAK,KACH5xG,SAFZjI,QAAAA,EAAK,KAAOD,QAAAA,EAAK,MAEkB,EACvDq5G,EAAOj5F,MAAM2O,QAAU+qF,GAAgBD,EAAU,OAAS,EAC9D,GACJ,C,4GCXA,eACA,WACA,WAGA,WAwDA,SAASE,EAAkBx5F,G,MACvB,MAAO,CACHmN,IAAK,MACLssF,UAAW,6BACX55F,MAAO,kCAAkC,EAAA65F,mBAAkB,MAAM,EAAAA,mBAAkB,KACnF/kB,SAAU,CACN,CACIxnE,IAAK,OACLssF,UAAW,6BACX34E,YAAU,GACN64E,EAAG,sCACHC,UAAW,uCACX,EAAC,gBAAiB,IAClB,EAAAC,OAAQ75F,E,IAGhB,CACImN,IAAK,OACLssF,UAAW,6BACX34E,WAAY,CACR64E,EAAG,4CACHE,OAAQ75F,KAK5B,CArEA,8BAAmC4R,EAAekoF,GAC9C,OAemB,EAfEA,EAgBrB95F,EAAW,cACX+5F,EAAqB,wBACrBnH,EAAiB,oBAEXoH,EAAa,EAAAC,YAAc,EAC1B,CACH,CACI9sF,IAAK,MACLs7B,UAAW,EAAA4nD,sBAAsB6J,aACjCr6F,MAAO,yDAAyDG,EAAW,SACvE4yF,GAAqB,EAAAuH,kCAAoC,EAAAC,mBAAiB,aACjE,EAAAC,WAAU,mBAAmB,EAAAC,aAAY,MACtD3lB,SAAU,CACN,CACIxnE,IAAK,MACLs7B,UAAW,EAAA4nD,sBAAsB4G,aACjCp3F,MAAO,sCAAsCk6F,EAAqB,qBAAqB/5F,EAAW,4BAA4B,EAAAi6F,YAAW,aAAa,EAAAA,YAAW,aAC7JD,EAAa,EAAAM,cAAY,uBACN,EAAAL,YAAW,uBAClCtlB,SAAU,CAAC6kB,EAAkBx5F,SAlCxCpd,KAAI,SAAAi5B,GACD,IAAM87E,GAAU,IAAAppF,eAAcsN,EAASjK,GACvC,IAAI,IAAAjV,cAAag7F,EAAS,kBAAmB,IAAAn1E,iBAAgBm1E,EAAS,OAClE,OAAOA,CAEf,IACChkG,QAAO,SAAAgkG,GAAW,QAAEA,CAAF,IAQ3B,IAAuB,EACnB33F,EACA+5F,EACAnH,EAEMoH,CAZV,C,gHC3BA,WASa,EAAA9C,QAA6E,CACtFtxD,YAAa,SAAC,G,IAAEgsD,EAAQ,WAAO,wBAAMA,EAAN,EAC/BC,WAAY,SAAC,EAAuBvvD,EAAGwvD,EAAMkH,EAAQC,G,QAAtCrH,EAAQ,WAAE3jF,EAAO,UAC5B,GAAI2jF,EAASxkB,SAAU,CACnB,IAAMvtF,EAAW+xG,EAASxkB,SAAW,EAAI,EAAAmtB,6BACnCC,EAAO36G,EAAWlB,KAAKkD,IAAiB,QAAb,EAAAiwG,EAAKrkB,gBAAQ,QAAI,GAAKurB,EACjDyB,EAAO56G,EAAWlB,KAAKiD,IAAiB,QAAb,EAAAkwG,EAAKrkB,gBAAQ,QAAI,GAAKwrB,EACnDyB,EAAa/7G,KAAK6C,MAAMg5G,EAAMC,GAElC,IAAKn4D,EAAE6J,QAAUl+B,QAAoCpiB,IAAzBoiB,EAAQ0sF,aAA4B,CAC5D,IAAMC,EAAaF,EAAa,EAAAG,YAGhCH,EADI/7G,KAAKqD,MAAM44G,EAAa3sF,EAAQ0sF,cAAgB1sF,EAAQ0sF,aAC1B,EAAAE,W,CAGtC,GAAIjJ,EAASnkB,UAAYitB,EAErB,OADA9I,EAASnkB,SAAWitB,GACb,C,CAGf,OAAO,CACX,E,4GC/BJ,eAQA,8BACII,EACArtB,EACAtxE,EACA4+F,EACAC,EACAC,EACArI,GAEA,GAAIqI,EAGA,OAFAF,EAAal7F,MAAM2O,QAAU,YAC7BwsF,EAAan7F,MAAM2O,QAAU,QAG7BusF,EAAal7F,MAAM2O,QAAU,GAC7BwsF,EAAan7F,MAAM2O,QAAU,GAC7B,IAAM0sF,EAAmBH,EAAanoE,wBAChCuoE,EAAch/F,EAAQy2B,wBACtBwoE,EAAiB,EAAAnB,YAAc,EAAAI,WAAa,EAAAgB,qBAClD,GAAIH,GAAoBC,EAAa,CACjC,IAAIG,EAAmBryG,OAAOsyG,iBACxBC,EAAQ/tB,EAAW,EAAAotB,YAEzB,GAAIW,EAAQ,IAAMA,GAAS,IAAML,EAAYtoE,IAAMioE,EAAWjoE,IAAMuoE,EAEhEE,EADYJ,EAAiBroE,IAAMioE,EAAWjoE,SAE3C,GACH2oE,IAAU,IACVA,IAAU,KACVL,EAAYrqG,KAAOgqG,EAAWhqG,KAAOsqG,EAGrCE,EADaJ,EAAiBpqG,KAAOgqG,EAAWhqG,UAE7C,GACH0qG,GAAS,IACTA,GAAS,KACTV,EAAW5pG,MAAQiqG,EAAYjqG,MAAQkqG,EACzC,CACE,IAAMlqG,EAAQgqG,EAAiBhqG,MAAQ4pG,EAAW5pG,MAClDoqG,EAAmB38G,KAAKD,IAAIo8G,EAAW5pG,MAAQiqG,EAAYjqG,MAAOA,E,MAC/D,IACFsqG,IAAU,KAAOA,GAAS,MAC3BV,EAAWhoE,OAASqoE,EAAYroE,OAASsoE,EAC3C,CACE,IAAMtoE,EAASooE,EAAiBpoE,OAASgoE,EAAWhoE,OACpDwoE,EAAmB38G,KAAKD,IAAIo8G,EAAWhoE,OAASqoE,EAAYroE,OAAQA,E,CAGxE,IAAM2oE,EAAY98G,KAAKC,IAAID,KAAKD,IAAI,EAAA27G,WAAYiB,GAAmB,GAC7DI,EAAY/8G,KAAKC,IAAID,KAAKD,IAAI,EAAAu7G,YAAaqB,EAAmBG,GAAY,GAChFV,EAAal7F,MAAMgzB,KACd4oE,GAAa7I,EAAoB,EAAI,EAAAyI,sBAAwB,KAClEN,EAAal7F,MAAM6L,OAAS+vF,EAAY,KACxCT,EAAan7F,MAAMgzB,KAAO6oE,EAAY,I,CAGlD,C,sZC3Da,EAAAC,mBAAqB,GAKrB,EAAAN,qBAAuB,EAKvB,EAAApB,YAAc,GAKd,EAAAI,WAAa,GAKb,EAAAQ,YAAc,IAAMl8G,KAAK8C,GAKzB,EAAA84G,6BAA+B,EAAAN,YAAc,EAAI,EAAAI,WAKjD,EAAAX,mBAAqB,EAKrB,EAAA5I,SAAmC,CAC5C8K,GAAI,EACJC,GAAI,GACJC,GAAI,IACJC,GAAI,KAMK,EAAAxD,GAAsB,CAAC,IAAK,GAAI,KAKhC,EAAAC,GAAsB,CAAC,IAAK,GAAI,KAKhC,EAAA8B,aAAe,EAKf,EAAAF,kBAAoB,EAAAC,WAAa,EAAAgB,qBAKjC,EAAAlB,iCAAmC,EAAAE,WAKnC,EAAArJ,iBAAmB,GAKnB,EAAAC,kBAAoB,EAKpB,EAAAR,QAA2B,CAAC,IAAK,KAKjC,EAAAC,QAA2B,CAAC,IAAK,KAKjC,EAAAsL,iBAAmB,EAAI,EAAAL,mBAAqB,EAAI,EAAAN,qBAKhD,EAAAY,aAAe,a,6BChG5B,IAAY5L,E,iFAAAA,EAAA,EAAAA,wBAAA,EAAAA,sBAAqB,KAI7B,yBAKA,2BAKA,2BAKA,wBAKA,0BAKA,sB,oGCjCJ,cACA,WACA,WACA,WAkBA,uBACIhkF,EACA5M,EACAy8F,EACAtK,EACAvgF,EACA8qF,EACA7G,G,MAEI9jF,EAAS,GACP4qF,EAAe9G,QAAAA,EAAgB71F,EAC/B48F,EAAmE,QAApD,OAAAvG,qBAAoBoG,EAAmBE,UAAa,aAAIvwG,EACvE2jB,GAAQ,IAAA8sF,oBAAmB1K,EAAUyK,GAE3C,OAAQ7sF,GACJ,IAAK,aAEDgC,EAASogF,EAASxgF,KAAO,GACzB,MACJ,IAAK,eAGDI,EAASH,EACT,MACJ,IAAK,eAEDG,GAAS,IAAA+qF,iBAAgBjH,QAAAA,EAAgB71F,EAAOmyF,GAIrCpgF,GAAUH,IAWzBG,EANcnF,EAAOkF,aAAa,YAAa,CAC3C9R,MAAOA,EACPyR,YAAa0gF,EAASxgF,KAAO3R,EAAM2R,IACnCC,YAAW,EACXG,OAAM,IAEKA,QAGfA,GAAUogF,EAASxgF,KAGnB,IAAA0kF,qBAAoBoG,EAAmBE,EAAc,OAIrD,IAAAtG,qBAAoBoG,EAAmBE,EAAcxK,GAIzD,IAAM4K,GAAqB,IAAAC,uBAAsB7K,GAWjD,OATI4K,IACAN,EAAkB9qF,IAAMI,GAEpB2qF,GAAgC,gBAAT3sF,KACvB0sF,EAAkBrqG,OAAO+N,MAAQ48F,EAAmBE,YAAc,KAClER,EAAkBrqG,OAAO6Z,OAAS8wF,EAAmBG,aAAe,OAIrEntF,CACX,C,0GCjFA,8BAAmC0W,GAC/B,IAAKA,EACD,OAAO,EAGX,IACI,IAAM02E,EAAS12E,EAAIpE,cAAcvT,cAAc,UAC/CquF,EAAOh9F,MAAQ,GACfg9F,EAAOlxF,OAAS,GAChB,IAAMnW,EAAUqnG,EAAOC,WAAW,MAClC,QAAItnG,IACAA,EAAQunG,UAAU52E,EAAK,EAAG,GAC1B3wB,EAAQwnG,aAAa,EAAG,EAAG,EAAG,IACvB,E,CAIb,SACE,OAAO,C,CAEf,C,0HCnBMC,EAAmD,CAAC,YACpDC,EAA+C,CACjD,cACA,eACA,aACA,iBAEEC,GAAgB,uDACfF,IAAW,gBACXC,IAAS,GAEVE,GAAW,EAAH,qDAAOD,IAAgB,gBAZoB,CAAC,UAAW,cAYhB,GA2ErD,SAASE,EAAc5uB,EAAaC,GAChC,OAAa5iF,MAAN2iF,GAAyB3iF,MAAN4iF,GAAmB9vF,KAAK+vF,IAAIF,EAAKC,GAAM,IACrE,CAhCA,8BACImjB,EACAyL,GAEA,OAAKzL,GAAaA,EAASxgF,MAAO+rF,EAASvoG,MAAK,SAAAnY,GAAO,QAuBnC,iBAvB6Cm1G,EAASn1G,GAAnB,KAGnDygH,EAAiBrlG,OAAM,SAAApb,GAAO,OAAA2gH,EAAcxL,EAASn1G,GAAM,EAA7B,KAC7Bm1G,EAAS/jB,mBACT+jB,EAAS9jB,iBACRuvB,KAAcA,GAAazL,EAASnkB,WAAa4vB,EAAU5vB,UAI7D4vB,GACAL,EAAYnlG,OAAM,SAAApb,GAAO,OAAA2gH,EAAcxL,EAASn1G,GAAM4gH,EAAU5gH,GAAvC,KACzBwgH,EAAUplG,OAAM,SAAApb,GAAO,OAAA2gH,EAAcxL,EAASn1G,GAAM4gH,EAAU5gH,GAAvC,KACvB4gH,EAAUxvB,oBAAsB+jB,EAAS/jB,mBACzCwvB,EAAUvvB,kBAAoB8jB,EAAS9jB,gBAEhC,eAEA,eAVA,aAPA,SAmBf,C,4GCxFA,eACA,WACA,WACA,WA2BA,8BACIzhE,EACA5M,EACAwO,EACA2jF,EACAkI,EACAvxF,GAEA,IAAMmuF,EAAa4G,EAAW79F,EAAOmyF,GAC/BhgF,EAAMvF,EAAOiC,cAEfslF,EAA6B,IAC5B3lF,EAAQ0kF,eAAiBpqF,EAAU5gB,QAAQ,WAAa,IACzDisG,GAAW,IAAA2J,oBAAmB3rF,EAAKkoF,IAEvC,IAAInG,EAA6B,GAC7BprF,EAAU5gB,QAAQ,WAAa,IAC/BgsG,GAAW,IAAA6J,oBAAmB5rF,IAAO3D,EAAQ2kF,oBAGjD,IAAIiB,EAA6B,GAC7BtrF,EAAU5gB,QAAQ,SAAW,IAC7BksG,GAAW,IAAA4J,oBAAmB7rF,IAGlC,IAAMzV,EAAUuhG,EACZrxF,EACAqqF,EACAzoF,EACA2jF,EACA+B,EACAC,EACAC,GAEE8J,GAAY,IAAApxG,MAAKqlB,EAAKnS,EAAO,QAEnC,MAAO,CAAEtD,QAAO,EAAE+2F,WADC0K,EAAiBzhG,EAASwhG,GACfjH,WAAU,EAAE/C,SAAQ,EAAEC,SAAQ,EAAEC,SAAQ,EAC1E,EAEA,IAAM+J,EAAmB,SAACzhG,EAAsBwhG,GAC5C,IAAME,EAAaF,EAAUG,aAAa,CACtCp5E,KAAM,SAIV,OAFAi5E,EAAU1uF,GA5DiB,sBA6D3B4uF,EAAWpvF,YAAYtS,GAChBwhG,CACX,EAEMD,EAAgB,SAClBrxF,EACA5M,EACAwO,EACA2jF,EACA+B,EACAC,EACAvC,G,MAEMz/E,EAAMvF,EAAOiC,cACbnS,EAAUyV,EAAIrD,cAAc,QAC5BwvF,EAAWnsF,EAAIrD,cAAc,OAEnCwvF,EAASlgF,aACL,QACA,gFAEJkgF,EAAStvF,YAAYhP,GACrBtD,EAAQ0hB,aACJ,QACA,oDAAoE,QAAjB,EAAA+zE,EAASnkB,gBAAQ,QAAI,GAAC,SAE7EtxE,EAAQ0D,MAAM2O,QAAUnC,EAAOyK,iBAAiBC,SAC1C,sBACA,cAEN,IAAMrX,EAASs+F,EAAa3xF,EAAQ4B,EAAQjO,aAqB5C,OApBA7D,EAAQsS,YAAYsvF,GACpB5hG,EAAQsS,YAAY/O,GACpBvD,EAAQ0D,MAAM+uC,WAAa,OAEvB+kD,IAAYA,aAAQ,EAARA,EAAU11G,QAAS,GAC/B01G,EAASlwG,SAAQ,SAAAw6G,GACb9hG,EAAQsS,YAAYwvF,EACxB,IAEArK,GAAYA,EAAS31G,OAAS,GAC9B21G,EAASnwG,SAAQ,SAAAlF,GACb4d,EAAQsS,YAAYlwB,EACxB,IAEA8yG,GAAWA,EAAQpzG,OAAS,GAC5BozG,EAAQ5tG,SAAQ,SAAApE,GACZ8c,EAAQsS,YAAYpvB,EACxB,IAGG8c,CACX,EAEM6hG,EAAe,SAAC3xF,EAAiBrM,GACnC,IACMk+F,EADM7xF,EAAOiC,cACMC,cAAc,OAKvC,OAJA2vF,EAAargF,aACT,QACA,oEAAoE7d,EAAW,yBAE5Ek+F,CACX,EAEMZ,EAAa,SAAC79F,EAAyBmyF,GACzC,IAAM8E,EAAaj3F,EAAMuiB,WAAU,GAUnC,OATA00E,EAAW72F,MAAM44C,eAAe,aAC5Bm5C,EAASxgF,MACTslF,EAAWtlF,IAAMwgF,EAASxgF,IAC1BslF,EAAWh0E,gBAAgB,MAC3Bg0E,EAAW72F,MAAM44C,eAAe,aAChCi+C,EAAW72F,MAAM44C,eAAe,cAChCi+C,EAAW72F,MAAMD,MAAQgyF,EAASzkB,QAAU,KAC5CupB,EAAW72F,MAAM6L,OAASkmF,EAASxkB,SAAW,MAE3CspB,CACX,C,yGC1IA,6BACI9E,EACAc,EACAyL,EACAC,GAEM,IAAAjxB,EAAsBykB,EAAQ,QAArBxkB,EAAawkB,EAAQ,SACpC,GAAe/lG,MAAXshF,GAAoCthF,MAAZuhF,EAA5B,CAGA,IAAMlsF,EAAQksF,EAAW,EAAID,EAAUC,EAAW,EAElD+wB,EAAcx/G,KAAK6B,MAAM29G,GACzBC,EAAez/G,KAAK6B,MAAM49G,GAC1BjxB,EAAUxuF,KAAK6B,MAAM2sF,GACrBC,EAAWzuF,KAAK6B,MAAM4sF,GAEtBwkB,EAASzkB,QAAUgxB,EACnBvM,EAASxkB,SAAWgxB,EAEhB1L,GAAiBxxG,EAAQ,IAAMisF,IAAYgxB,GAAe/wB,IAAagxB,KACnED,EAAchxB,EACdykB,EAASxkB,SAAW+wB,EAAcj9G,EAElC0wG,EAASzkB,QAAUixB,EAAel9G,E,CAG9C,C,mHCvCA,eAKA,qCAA0Cm2G,GACtC,OAAOA,EACFz0G,KAAI,SAAAq7G,GACD,IAAMI,EAAeJ,EAAQhmE,kBAC7B,IACI,IAAAt7B,cAAa0hG,EAAc,kBAC3B,IAAA77E,iBAAgB67E,EAAc,OAE9B,OAAOA,CAEf,IACC1qG,QAAO,SAAAmlG,GAAU,QAAEA,CAAF,GAC1B,C,0ICjBA,WAUa,EAAArD,eAAiB,YAK9B,4BACI75F,EACA8wB,GAEA,IAAI4xE,EAA8C,KAoBlD,OAnBA,IAAA3tG,yBACIiL,EACA,aACA,SAAC9C,G,YACG,IAAsB,qBAAAA,EAAUpF,UAAQ,8BAAE,CAArC,IAAMmB,EAAO,QACd,GAC2B,SAAvBA,EAAQhB,cACN64B,GAAW73B,EAAQhD,OAAOod,IAAMyd,GAC9B73B,EAAQhD,OAAOgkE,YAAc,EAAA4/B,gBAGjC,OADA6I,EAAoB,CAAE7+F,MAAO5K,EAASiE,UAAS,IACxC,C,mGAGf,OAAO,CACX,IACA,GAGGwlG,CACX,C,yGCxCA,eAcA,2BAAgC7+F,EAAyBmyF,GACrD,IAAM4K,GAAqB,IAAAC,uBAAsB7K,GACjD,IAAK4K,EACD,MAAO,GAIP,IAAA/uB,EASAmkB,EAAQ,SARRzkB,EAQAykB,EAAQ,QAPRxkB,EAOAwkB,EAAQ,SANRpkB,EAMAokB,EAAQ,cALRvkB,EAKAukB,EAAQ,YAJRtkB,EAIAskB,EAAQ,aAHRrkB,EAGAqkB,EAAQ,WAFRhkB,EAEAgkB,EAAQ,aACN4J,EAAQ/tB,GAAY,EACpB38E,EAAOu8E,GAAe,EACtBn8E,EAAQo8E,GAAgB,EACxBz6C,EAAM06C,GAAc,EACpBz6C,EAAS06C,GAAiB,EAC1B+wB,EANF3M,EAAQ,eAMqBnyF,EAAMkuE,cACjC6wB,EAAS5wB,GAAgBnuE,EAAMkuE,cAC/B/tE,EAAQutE,GAAW1tE,EAAM43C,YACzB3rC,EAAS0hE,GAAY3tE,EAAM82F,aAE3BkI,EAAaD,GAAU,EAAI1tG,EAAOI,GAClCwtG,EAAcH,GAAW,EAAI1rE,EAAMC,GACnClhB,EAAMnS,EAAMqiB,cACZ+vB,EAAMjgC,EAAI2H,YAGVolF,GAAmB9sD,aAAG,EAAHA,EAAK8sD,mBAAoB,EAC5C/B,EAAShrF,EAAIrD,cAAc,UACzBmuF,EAA8BF,EAAkB,YAAnCG,EAAiBH,EAAkB,aACxDI,EAAOh9F,MAAQ88F,EAAciC,EAC7B/B,EAAOlxF,OAASixF,EAAegC,EAE/B,IAAMppG,EAAUqnG,EAAOC,WAAW,MAElC,IAkBI,OAjBItnG,IACAA,EAAQqpG,MAAMD,EAAkBA,GAChCppG,EAAQspG,UAAUnC,EAAc,EAAGC,EAAe,GAClDpnG,EAAQhK,OAAOiwG,GACfjmG,EAAQqpG,MAAMhN,EAAS/jB,mBAAqB,EAAI,EAAG+jB,EAAS9jB,iBAAmB,EAAI,GACnFv4E,EAAQunG,UACJr9F,EACA++F,EAAS1tG,EACTytG,EAAU1rE,EACV4rE,EACAC,GACC9+F,EAAQ,GACR8L,EAAS,EACV9L,EACA8L,IAGDkxF,EAAOkC,UAAU,YAAa,E,CACvC,SACE,OAAOr/F,EAAM2R,G,CAErB,C,6GC9DA,iCACIwgF,EACAmN,GAGI,IAASn/F,EAOTgyF,EAAQ,QANElmF,EAMVkmF,EAAQ,SALRnkB,EAKAmkB,EAAQ,SAJK9gG,EAIb8gG,EAAQ,YAHM1gG,EAGd0gG,EAAQ,aAFI/+D,EAEZ++D,EAAQ,WADO9+D,EACf8+D,EAAQ,cAEZ,GACc/lG,MAAV6f,GACS7f,MAAT+T,GACQ/T,MAARiF,GACSjF,MAATqF,GACOrF,MAAPgnC,GACUhnC,MAAVinC,EANJ,CAWA,IAAM0oE,EAAQ/tB,QAAAA,EAAY,EAGpB/2B,EAAgB92C,GAAS,EAAI9O,EAAOI,GACpC8tG,EAAiBtzF,GAAU,EAAImnB,EAAMC,GAGrCmsE,EAAeF,EAAaroD,EAAgB92C,EAC5Cs/F,EAAgBH,EAAaC,EAAiBtzF,EAQpD,MAAO,CACHgxF,YALA/9G,KAAK+vF,IAAIuwB,EAAetgH,KAAKiD,IAAI45G,IAAU78G,KAAK+vF,IAAIwwB,EAAgBvgH,KAAKkD,IAAI25G,IAM7EmB,aAJAh+G,KAAK+vF,IAAIuwB,EAAetgH,KAAKkD,IAAI25G,IAAU78G,KAAK+vF,IAAIwwB,EAAgBvgH,KAAKiD,IAAI45G,IAK7E9kD,cAAa,EACbsoD,eAAc,EACdC,aAAY,EACZC,cAAa,E,CAErB,C,+GChEA,eACA,WAUA,iCACI/iG,EACAy1F,EACA3jF,EACAkxF,EACArzD,EACAkrD,EACA59E,EACAgmF,GAEA,OAmBJ,SAAyBjjG,EAAsBgjG,GAC3C,OAAO,IAAAniF,SAAQ7gB,EAAQ8gB,iBAAiB,IAAMkiF,GAClD,CArBWE,CAAgBljG,EAASgjG,GAAcv8G,KAC1C,SAAAi5B,GACI,WAAI,EAAAyjF,kBACAzjF,EACA,CACI+1E,SAAUA,EACV3jF,QAASA,EACTkxF,aAAY,EACZ1/G,EAAGo8B,EAAQxlB,QAAQ5W,EACnBC,EAAGm8B,EAAQxlB,QAAQ3W,GAEvBs3G,EACAlrD,EACA1yB,EACAgmF,EAZJ,GAeZ,C,6GCtCA,eAQMG,EAAqB,QACrBC,EAAoB,OAKb,EAAAhJ,oBAAsB,SAC/BnqF,EACA4B,EACA2jF,G,QAEA,MAAO,CACH5xF,YACIiO,EAAQjO,cAAgBqM,EAAOgE,aAAemvF,EAAoBD,GACtExF,sBAAuB1tF,EAAOgE,aAAemvF,EAAoBD,EACjEtE,cAAc,IAAAvD,eAA8B,QAAhB,EAAA9F,EAASzkB,eAAO,QAAI,EAAoB,QAAjB,EAAAykB,EAASxkB,gBAAQ,QAAI,GACxEwlB,oBAAqB3kF,EAAQ2kF,kBAErC,C,0GC1BA,eAOA,4BAAiC70G,GAC7B,IAAMoZ,GAAa,IAAAC,kCAAiCrZ,GAAO,GAE3D,OAAyB,GAArBoZ,EAAWlZ,QAA+C,SAAhCkZ,EAAW,GAAG,GAAGtD,aAA0BsD,EAAW,GAAG,GAC5E,CACHsI,MAAOtI,EAAW,GAAG,GACrB2B,UAAW3B,EAAW,GAAG,IAGtB,IAEf,C,0OClBA,eAaA,SAAgBsoG,EAAMrhH,GAClB,OAAOA,EAAQ,IACnB,CA4GA,SAASshH,EAAmBthH,GACxB,IAAMuhH,EAA+B,iBAAVvhH,EAAqB4E,SAAS5E,GAASA,EAClE,OAAQsI,MAAMi5G,EAClB,CAjHA,UAOA,yBAA8BxyB,EAAiBC,GAC3C,SAAOD,GAAWC,IAAaD,EAAU,EAAA6uB,kBAAoB5uB,EAAW,EAAA4uB,kBAG5E,EASA,4BAAiCv8G,EAAWC,EAAW87G,GACnD,GAAS,GAAL/7G,GAAe,GAALC,EACV,MAAO,CAAC,EAAG,GAEf,IAAMkgH,EAAajhH,KAAK+C,KAAKjC,EAAIA,EAAIC,EAAIA,GAEzC,OADA87G,EAAQ78G,KAAK6C,MAAM9B,EAAGD,GAAK+7G,EACpB,CAACoE,EAAajhH,KAAKiD,IAAI45G,GAAQoE,EAAajhH,KAAKkD,IAAI25G,GAChE,EAKA,sBACI3/E,EACAgkF,EACAC,GAEIjkF,IACAA,EAAQhc,MAAM+5F,UAAY,UAASiG,GAAuB,EAAI,GAAC,MAC3DC,GAAqB,EAAI,GAAC,IAGtC,EAKA,oCACI3jG,EACAsD,EACAG,EACA8L,EACAq0F,GAGA,GADkBtgG,EAAMI,MAAMK,YACf,CACX,IAAMD,EAAcR,EAAMI,MAAMI,YAAc,EAAIjd,SAASyc,EAAMI,MAAMI,aAAe,EACtF,OAAI8/F,GACA5jG,EAAQ0D,MAAMD,MAAQ6/F,EAAMz8G,SAASyc,EAAMI,MAAMD,OAASK,QAC1D9D,EAAQ0D,MAAM6L,OAAS+zF,EAAMz8G,SAASyc,EAAMI,MAAM6L,QAAUzL,MAGhE9D,EAAQ0D,MAAMD,MAAQ6/F,EAAM7/F,EAAQK,QACpC9D,EAAQ0D,MAAM6L,OAAS+zF,EAAM/zF,EAASzL,I,CAG1C9D,EAAQ0D,MAAMD,MAAQ6/F,EAAM7/F,GAC5BzD,EAAQ0D,MAAM6L,OAAS+zF,EAAM/zF,EACjC,EAKA,mBACImQ,EACA/qB,EACA+hC,EACA3hC,EACA4hC,EACAlzB,EACA8L,GAEAmQ,EAAQhc,MAAM/O,UAAgBjF,IAATiF,EAAqB2uG,EAAM3uG,GAAQ+qB,EAAQhc,MAAM/O,KACtE+qB,EAAQhc,MAAMgzB,SAAchnC,IAARgnC,EAAoB4sE,EAAM5sE,GAAOhX,EAAQhc,MAAMgzB,IACnEhX,EAAQhc,MAAM3O,WAAkBrF,IAAVqF,EAAsBuuG,EAAMvuG,GAAS2qB,EAAQhc,MAAM3O,MACzE2qB,EAAQhc,MAAMizB,YAAoBjnC,IAAXinC,EAAuB2sE,EAAM3sE,GAAUjX,EAAQhc,MAAMizB,OAC5EjX,EAAQhc,MAAMD,WAAkB/T,IAAV+T,EAAsB6/F,EAAM7/F,GAASic,EAAQhc,MAAMD,MACzEic,EAAQhc,MAAM6L,YAAoB7f,IAAX6f,EAAuB+zF,EAAM/zF,GAAUmQ,EAAQhc,MAAM6L,MAChF,EAQA,kCAAuCjM,GAC3B,IAAAI,EAAUJ,EAAK,MAGvB,QADuB,KAAnBI,EAAMsmB,UAAsC,YAAnBtmB,EAAMsmB,UAA6C,SAAnBtmB,EAAMsmB,WAG9Du5E,EAAmB7/F,EAAM6L,UAAWg0F,EAAmB7/F,EAAMD,OAMtE,EAUA,sCACIH,EACAugG,EACAC,GAEA,IAAMC,EAAYzgG,EAAMI,MAAMK,YACxBD,EACFigG,GAAazgG,EAAMI,MAAMI,YACnB,EAAIjd,SAASyc,EAAMI,MAAMI,aACzBigG,EACA,EACA,EAEV,MAAO,CACHtgG,MAAOogG,EAAe//F,EACtByL,OAAQu0F,EAAgBhgG,EAEhC,C,iHCpJA,eAUA,mCAAwCq+F,GACpC,IAAMxlG,EAAYwlG,EAAkBxlG,UAC9BlC,EAAQkC,EAAUpF,SAAS/L,QAAQ22G,EAAkB7+F,OAC3D,GAAI7I,EAAQ,EAAG,CACX,IAAMupG,EAAernG,EAAUpF,SAASkD,EAAQ,GAC1CwpG,EAActnG,EAAUpF,SAASkD,EAAQ,GAC/C,GACIupG,GACAC,GAC2B,mBAA3BA,EAAYvsG,aACgB,mBAA5BssG,EAAatsG,aACbusG,EAAY1rG,YACZyrG,EAAazrG,WACf,CACE,IAAM2rG,GAAmB,IAAA1uG,aAAYmH,GACrCunG,EAAiB3sG,SAAShM,OAAOkP,EAAQ,EAAG,GAC5CypG,EAAiB3sG,SAAShM,OAAOkP,EAAO,E,CAE5C,OAAO0nG,C,CAEf,C,wGC9BA,IAAM78G,EAAK9C,KAAK8C,GAEV6+G,EAAqB,EAAL7+G,EADH,EAEb8+G,EAAiB,CAAC,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,KAAM,KAoB/D,8BAAmClH,EAAwB5rB,GACvD4rB,EAAQ51G,SAAQ,SAAAq1G,GACN,MAAWA,EAAOziG,QAAhB3W,EAAC,IAAED,EAAC,IACZq5G,EAAOj5F,MAAM2gG,OAhBrB,SAAuB/yB,EAAkB/tF,EAAgBD,QAAhB,IAAAC,IAAAA,EAAA,SAAgB,IAAAD,IAAAA,EAAA,IACrD,IAAMghH,EANV,SAAkChzB,GAC9B,IAAMizB,EAAM/hH,KAAKqD,MAAMyrF,EAAW6yB,GALnB,EAMf,OAAOI,EAAM,EAAIA,EANF,EAMqBA,CACxC,CAGqBC,CAAyBlzB,GACpCmzB,EAAoBlhH,EAAID,EACxBohH,EAAgBN,EAAe54G,QAAQi5G,GACvCE,EAAeD,GAAiB,GAAKA,EAAgBJ,EAC3D,OAAOK,EAAeP,EAAeO,EAdtB,GAcmD,EACtE,CAUiCC,CAActzB,EAAU/tF,EAAGD,GAAE,SAC1D,GACJ,C,uJC5BA,WACA,WAWA,SAAgBq2G,EACZoG,EACAz8F,EACAuhG,GAEA,IAAMC,GAAuB,IAAAjkC,qBACzBk/B,OACqBrwG,IAArBm1G,EACM,SAAAnvG,GAEI,OADSmvG,CAEb,OACAn1G,GAEV,OAAO,EAAP,8BAAYq1G,EAAmBzhG,IAAWwhG,EAC9C,CAEA,SAASC,EAAmBzhG,GACxB,MAAO,CACH2R,IAAK3R,EAAMqe,aAAa,QAAU,GAClCqvD,QAAS1tE,EAAM43C,YACf+1B,SAAU3tE,EAAM82F,aAChB3oB,aAAcnuE,EAAMmuE,aACpBD,cAAeluE,EAAMkuE,cACrBN,YAAa,EACbC,aAAc,EACdC,WAAY,EACZC,cAAe,EACfC,SAAU,EAElB,CA9BA,wBAoCA,oCACIphE,EACA5M,GAEA,IAAI0hG,EAAqCD,EAAmBzhG,GAa5D,OAZA4M,EAAOE,oBAAmB,SAAAxuB,GACtB,IAAMo1G,GAAgB,IAAAoC,kBAAiBx3G,GACvC,SAAIo1G,aAAa,EAAbA,EAAe1zF,UACf,IAAA/G,eAAcy6F,EAAcr6F,UAAWq6F,aAAa,EAAbA,EAAe1zF,OAAO,SAAA2hG,GACzDD,EAAgBrL,EAAoBsL,EAAY3hG,EACpD,KAEO,EAGf,IAEO0hG,CACX,C,uGClEA,eACA,WACA,WACA,WACA,WACA,SACA,WAGA,WAYA,yBACIvP,EACA3jF,EACAxO,EACA8zF,EACAp3F,EACAw3F,EACAE,EACAwB,EACA0K,GAGI,IAAAtyB,EAOAmkB,EAAQ,SANRpkB,EAMAokB,EAAQ,cALRvkB,EAKAukB,EAAQ,YAJRtkB,EAIAskB,EAAQ,aAHRrkB,EAGAqkB,EAAQ,WAFR/jB,EAEA+jB,EAAQ,kBADR9jB,EACA8jB,EAAQ,gBAENyP,GAAoB,IAAA5E,uBAAsB7K,EAAUiC,IAAYA,aAAQ,EAARA,EAAU51G,QAAS,GACzF,GAAKojH,EAAL,CAII,IAAA3E,EAMA2E,EAAiB,YALjB1E,EAKA0E,EAAiB,aAJjB3qD,EAIA2qD,EAAiB,cAHjBrC,EAGAqC,EAAiB,eAFjBpC,EAEAoC,EAAiB,aADjBnC,EACAmC,EAAiB,cAEfC,GAAoB5E,EAAcuC,GAAgB,EAClDsC,GAAkB5E,EAAeuC,GAAiB,EAClDsC,EAAa9qD,GAAiB22B,GAAe,GAC7Co0B,EAAc/qD,GAAiB42B,GAAgB,GAC/Co0B,EAAY1C,GAAkBzxB,GAAc,GAC5Co0B,EAAe3C,GAAkBxxB,GAAiB,GAGxDrxE,EAAQ0D,MAAMiG,UAAey7F,EAAc,KAC3CplG,EAAQ0D,MAAMgG,aAAkB07F,EAAiB,EAAC,MAClDplG,EAAQ0D,MAAMrN,WAAgB8uG,EAAgB,KAC9CnlG,EAAQ0D,MAAMlN,YAAiB2uG,EAAgB,KAE/CnlG,EAAQ0D,MAAM+5F,UAAY,UAAUnsB,EAAQ,QAC5C,IAAAm0B,0BAAyBzlG,EAASsD,EAAOw/F,EAAcC,IAAiBa,GACxE5jG,EAAQ0D,MAAM0J,cAAgB,cAI1B8rF,GACAl5F,EAAQ0D,MAAM1N,UAAY,QACrB0hG,IACDN,EAAY1zF,MAAM/O,MAAO,IAAA2uG,OAAM+B,GAC/BjO,EAAY1zF,MAAM3O,OAAQ,IAAAuuG,QAAOgC,KAGrCtlG,EAAQ0D,MAAM1N,UAAY,OAGzB4tG,IAEDxM,EAAY1zF,MAAMD,OAAQ,IAAA6/F,OAAM/oD,GAChC68C,EAAY1zF,MAAM6L,QAAS,IAAA+zF,OAAMT,IAGrCzL,EAAY1zF,MAAMtB,SAAW,YAG7B,IAAAsjG,YAAWtO,EAAYhwE,cAAesqD,EAAmBC,GACzD,IAAM2pB,GAAa,IAAAC,eAAcuH,EAAcA,GAO/C,GALKpL,IAEDN,EAAY1zF,MAAMuS,QAAasvF,EAAS,WAAWF,EAAU,MAG7D3N,GAAYA,EAAS51G,OAAS,EAAG,CACjC,IAAM6jH,EAAgBjO,EAAS,GACzBkO,EAAelO,EAASlgG,QAC1B,SAAA09F,GAAW,OAAAA,EAAQ5oD,YAAc,EAAA4nD,sBAAsBC,WAA5C,IAET0R,GAAc,IAAAhlF,SAChB8kF,EAAc7kF,iBAAiB,IAAI,EAAAozE,sBAAsBU,cAG7D,IAAAkR,SACIH,EACAN,EACAE,EACAD,EACAE,OACA91G,OACAA,IAEJ,IAAAo2G,SAAQF,EAAa,GAAI,EAAG,EAAGN,OAAa51G,OAAWA,EAAW61G,IAClE,IAAAO,SAAQF,EAAa,QAAIl2G,EAAW,EAAG,EAAG81G,EAAcF,OAAa51G,IACrE,IAAAo2G,SAAQF,EAAa,GAAIP,OAAY31G,EAAW,EAAG,OAAGA,EAAW81G,IACjE,IAAAM,SAAQF,EAAa,GAAI,EAAGL,OAAW71G,EAAW,EAAG21G,OAAY31G,QAEhDA,IAAb4hF,IACA,IAAA8pB,oBAAmByK,EAAav0B,E,CAIxC,GAAIkmB,IAAaoM,EAAY,CACzB,IAAM1oD,EAAcl7C,EAAQk7C,YACtBk/C,EAAep6F,EAAQo6F,aAEvB2L,GAAmB,IAAAC,4BAA2B1iG,EAAO43C,EAAak/C,IAExE,IAAA6L,mBACIxQ,EACA3jF,EAAQykF,gBAAiB,EACzBwP,EAAiBtiG,MACjBsiG,EAAiBx2F,QAGrB,IAAM2rF,GAAgB,IAAAC,2BAA0B3D,QAE/B9nG,IAAb4hF,IACA,IAAA8pB,oBAAmBF,EAAe5pB,IAGtC,IAAA40B,6BAA4BhL,EAAeI,E,EAEnD,C,qvBCtJA,eAAS,iFAAA6K,eAAe,IAIxB,eAAS,6EAAAC,WAAW,IACpB,eAAS,mFAAAC,iBAAiB,IAC1B,eAAS,4EAAA7a,UAAU,IAEnB,eAAS,kFAAA1H,gBAAgB,IAGzB,eACI,8EAAAwiB,YAAY,IACZ,gFAAAC,cAAc,IACd,mFAAAC,iBAAiB,IACjB,qFAAAC,mBAAmB,IACnB,8EAAAC,YAAY,IACZ,+EAAAC,aAAa,IACb,8EAAAC,YAAY,IACZ,iFAAAC,eAAe,IACf,mFAAAC,iBAAiB,IACjB,gFAAAC,cAAc,IACd,mFAAAC,iBAAiB,IACjB,sFAAAC,oBAAoB,IACpB,sFAAAC,oBAAoB,IACpB,oFAAAC,kBAAkB,IAClB,qFAAAC,mBAAmB,IAEvB,eAAS,gFAAAC,cAAc,IAEvB,eAAS,uFAAApe,qBAAqB,IAC9B,eAAS,iFAAAqe,eAAe,IAExB,eAAS,kFAAAC,gBAAgB,IACzB,eAAS,gFAAAC,cAAc,IACvB,eAAS,iFAAAzT,eAAe,IAExB,eAAS,8EAAA0T,YAAY,IAGrB,cAAS,qFAAAle,mBAAmB,IAC5B,eAAS,iFAAA0S,eAAe,IAExB,eAAS,sFAAAjJ,oBAAoB,IAE7B,cAAS,6EAAA0U,WAAW,IACpB,eAAS,mFAAA3W,iBAAiB,IAC1B,eAAS,0FAAA4W,wBAAwB,IACjC,aAAS,sEAAAjpG,IAAI,IACb,eAAS,yEAAA1G,OAAO,IAChB,eAAS,+EAAA4vG,aAAa,IAItB,cAAS,gFAAA7mB,cAAc,G,wGCtDvB,cA6BMa,EAA2C,CAC7CvqE,eAAe,EACf+hD,MAAM,EACNhiD,QAAQ,GAMZ,aAeI,WAAoBtF,QAAA,IAAAA,IAAAA,EAAA,QAAAA,QAAAA,EAdZ,KAAA5B,OAAyB,KACzB,KAAA23F,YAAa,EACb,KAAAC,cAAe,EACf,KAAAC,qBAAsB,EACtB,KAAAC,YAAa,EACb,KAAAC,aAA8B,IAS0B,CAkKpE,OA7JI,YAAAvpE,QAAA,WACI,MAAO,UACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,CAClB,EAOA,YAAA2uB,QAAA,WACI1zC,KAAK+kB,OAAS,KACd/kB,KAAK+8G,qBACL/8G,KAAK88G,aAAe,IACxB,EAQA,YAAAxqE,cAAA,SAAc/W,GACV,GAAIv7B,KAAK+kB,OACL,OAAQwW,EAAMsE,WACV,IAAK,QACD7/B,KAAKo4F,uBAAuBp4F,KAAK+kB,OAAQwW,GACzC,MACJ,IAAK,UACDv7B,KAAKg9G,qBAAqBzhF,GAC1Bv7B,KAAKq4F,mBAAmB98D,GACxB,MACJ,IAAK,iBACDv7B,KAAK6gD,0BAA0BtlB,GAI/C,EAEQ,YAAA68D,uBAAR,SAA+BrzE,EAAiBwW,GAC5C,IAAMiB,EAAWjB,EAAMiB,SACjBvnB,EAAY8P,EAAOyE,kBACzB,GACIvU,GACkB,SAAlBA,EAAUb,MACVa,EAAUya,MAAMC,WACM,cAAtB6M,EAASw7D,UAET,OAAQx7D,EAASuN,MACb,IAAK,IACG/pC,KAAK2mB,QAAQsnD,OACTjuE,KAAK08G,aACL,IAAAO,WAAUl4F,EAAQ,IAAK,CAAEe,WAAY,SACrC9lB,KAAK08G,YAAa,GAElB18G,KAAK08G,YAAa,GAI1B,MACJ,IAAK,IACG18G,KAAK2mB,QAAQuF,gBACTlsB,KAAK48G,sBACL,IAAAK,WAAUl4F,EAAQ,IAAK,CAAEmH,eAAe,IACxClsB,KAAK48G,qBAAsB,GAE3B58G,KAAK48G,qBAAsB,GAGnC,MACJ,IAAK,IACG58G,KAAK2mB,QAAQsF,SACTjsB,KAAK28G,eACL,IAAAM,WAAUl4F,EAAQ,IAAK,CAAEkH,QAAQ,IACjCjsB,KAAK28G,cAAe,GAEpB38G,KAAK28G,cAAe,GAG5B,MACJ,IAAK,IACG38G,KAAK2mB,QAAQm8C,aACT9iE,KAAK68G,aACL,IAAAI,WAAUl4F,EAAQ,IAAK,CAAC,EAAgB/kB,KAAK2mB,QAAQm8C,YACrD9iE,KAAK68G,YAAa,GAElB78G,KAAK68G,YAAa,GAM1C,EAEQ,YAAAxkB,mBAAR,SAA2B98D,GACvB,IAAMiB,EAAWjB,EAAMiB,SACvB,IAAKjB,EAAMk9D,uBAAyBj8D,EAASkjB,iBACzC,OAAQljB,EAASrnC,KACb,IAAK,QACD6K,KAAK+8G,qBACL/8G,KAAK88G,aAAe,KACpB,MACJ,IAAK,IACyB,MAAtB98G,KAAK88G,cAAwB98G,KAAK08G,WAClC18G,KAAK08G,YAAa,EACW,MAAtB18G,KAAK88G,cAAwB98G,KAAK48G,oBACzC58G,KAAK48G,qBAAsB,EACE,MAAtB58G,KAAK88G,cAAwB98G,KAAK28G,aACzC38G,KAAK28G,cAAe,EACS,MAAtB38G,KAAK88G,cAAwB98G,KAAK68G,aACzC78G,KAAK68G,YAAa,GAEtB78G,KAAK88G,aAAe,KACpB,MACJ,QACI98G,KAAK88G,aAAetgF,EAASrnC,IAI7C,EAEQ,YAAA6nH,qBAAR,SAA6BzhF,GACpBA,EAAMk9D,sBAA+C,cAAvBl9D,EAAMiB,SAASrnC,MACpB,MAAtB6K,KAAK88G,cAAwB98G,KAAK08G,WAClC18G,KAAK08G,YAAa,EACW,MAAtB18G,KAAK88G,cAAwB98G,KAAK48G,oBACzC58G,KAAK48G,qBAAsB,EACE,MAAtB58G,KAAK88G,cAAwB98G,KAAK28G,aACzC38G,KAAK28G,cAAe,EACS,MAAtB38G,KAAK88G,cAAwB98G,KAAK68G,aACzC78G,KAAK68G,YAAa,GAEtB78G,KAAK88G,aAAe,KAE5B,EAEQ,YAAAj8D,0BAAR,SAAkCtlB,GACV,UAAhBA,EAAMsO,QACN7pC,KAAK+8G,oBAEb,EAEQ,YAAAA,mBAAR,WACI/8G,KAAK08G,YAAa,EAClB18G,KAAK28G,cAAe,EACpB38G,KAAK48G,qBAAsB,EAC3B58G,KAAK68G,YAAa,CACtB,EACJ,EAjLA,GAAa,EAAAR,eAAAA,C,iHCtCb,WAaA,qBACIt3F,EACAm4F,EACA3yG,EACAu4D,IAEA,IAAAp6D,wCACIqc,GACA,SAAC8I,EAAQtW,EAAiB/F,EAAWq1C,EAAc54C,GAC/C,GAAIsJ,EAAgB5K,KAAK4K,EAAgB5K,KAAKhW,OAAS,IAAMumH,EAAW,CACpE,IAAM7rG,EAAckG,EAAgB5K,KAC9BwwG,EAAmB9rG,EAAY1U,MAAM,GAAI,GAO/C,GANAsR,EAAQ8X,kBAAmB,EAAH,8BACjB8gC,GAAY,CACf36B,gBAAiB26B,EAAa36B,cAC9BD,SAAU46B,EAAa56B,OACvBnG,YAAY+gC,aAAY,EAAZA,EAAc/gC,YAAa,YAASvhB,IAEhD44G,EAAiB98G,QAAQ68G,IAAc,EAAG,CAC1C,IAAME,EAAgB/rG,EAAY1a,OAC5B0mH,EAAiBhsG,EAClBnW,UAAU,EAAGkiH,EAAgB,GAC7B16E,YAAYw6E,GAEjB,MAqCkBvwG,EApCe0E,IAoCD/B,EApCc+tG,GAqCzC,IAAuC,GAAjC1wG,EAAK2C,EAAQ,GAAGuC,OAAOlb,SApC9BymH,EAAgBC,EAAiB,EACnC,CACE,IAAMC,GAAgB,IAAA32G,kBAClB4Q,EACA/F,EACA6rG,EACAD,GAeJ,OAZAE,EAAc3wG,KAAO2wG,EAAc3wG,KAAKE,QAAQqwG,EAAW,IAAIvgH,MAAM,GAAI,GACzE2gH,EAAc/yG,QAAS,EAAH,8BACb+yG,EAAc/yG,QACdA,GAEHu4D,IACAw6C,EAAcxpG,KAAO,CACjBvJ,OAAQu4D,IAIhB70D,EAAQo1B,oBAAqB,GACtB,C,GAc/B,IAAsC12B,EAAc2C,EAVxC,OAAO,CACX,GAER,C,6BCnDA,SAAgBiuG,EAAsBzmH,EAAeqZ,GACjD,IAAM0V,EAAM1V,EAAQpR,cACpB,MAAW,OAAP8mB,GAAuB,KAAPA,EACT,KAEJ/uB,CACX,C,oGAjBa,EAAAokH,kBAAoD,CAC7D5iG,MAAOilG,EACPn5F,OAAQm5F,EACR,cAAeA,EACf,aAAcA,GAOlB,yB,wNChBA,WACA,WACA,WAQMC,EAAoB,0CACpBC,EAAoB,6CACpBC,EAAgB,kBAChBC,EAAmB,qBACnBC,EAAiB,QACjBC,EAAuB,oBA0D7B,SAAgBC,EACZp/E,EACA8C,EACA1B,EACAvB,EACAwB,GAeA,IAAMljC,GACD6hC,EAASkG,cAAcg5E,IACxBp8E,EAAWrJ,UAAU2H,EAAavB,EAAcvG,KAAO+H,GAC3D,GAAIljC,GAAUA,EAAO+nC,cAAcg5E,IAC/B,IAAA9+E,gBAAeJ,EAAU7hC,aAAM,EAANA,EAAQu7B,UAC9B,CAEH,IAAMJ,EAAOuG,EAAcvG,KAAO+lF,EAAax/E,EAAcvG,KAAM8H,QAAcv7B,EAEjF,GAAIyzB,GAAQuG,EAAcvG,MAAQA,EAAM,CACpC,IAAM1N,EAAMkX,EAAWrJ,UAAUH,IACjC,IAAA8G,gBAAeJ,EAAUpU,aAAG,EAAHA,EAAK8N,K,EAG1C,CAMA,SAAgB2lF,EAAa/lF,EAAc8H,GACvC,IACI,GAAI9H,EAAK78B,MAAMqiH,GAAoB,CAC/B,IAAMQ,EAAUl+E,EAAW3kC,MAAMuiH,GAEjC1lF,GADWgmF,EAAUA,EAAQ,GAAK,QACtBhmF,EAAO,O,CAEvB,GAAIA,EAAK78B,MAAMsiH,GAAoB,CAC/B,IAAMQ,EAAan+E,EAAW3kC,MAAMwiH,GAEpC3lF,GADcimF,EAAaA,EAAW,GAAK,WAC5BjmF,EAAO,U,UAG1B,OAAOA,C,CAEf,CAMA,SAAgBkmF,EACZ3iF,EACA4iF,EACAC,IAEA,IAAAC,WAAU9iF,EAAMmE,iBAAkB,aAAa,SAACn1B,EAAQgqB,GAE/C4pF,GAC8B,SAA9B5pF,EAAQhc,MAAMK,cACTwlG,GAA8C,IAA7B7pF,EAAQhc,MAAMK,eAErCrO,EAAOwO,aAAe8kG,EACtBtzG,EAAOwB,WAAa8xG,EACpBtzG,EAAOyB,YAAc6xG,EACrBtzG,EAAOuO,UAAY+kG,EAE3B,KAEA,IAAAS,cAAa/iF,EAAMmE,iBAAkB,QAAS,EAAA28B,eAClD,CAhIA,yCACI9gC,EACAiG,EACA28E,EACAC,GAEQ,IAAA1/E,EAAmDnD,EAAK,SAA9CuE,EAAyCvE,EAAK,WAAlCwE,EAA6BxE,EAAK,UAAvBgD,EAAkBhD,EAAK,cAG5D6iF,GACAN,EAAsBp/E,EAAU8C,EAAY1B,EAAYvB,EAAewB,GAI3E,IAAMlqB,EAAa6oB,EAAS7oB,YAExB,IAAAR,cAAaQ,EAAY,iBACH,OAAtBA,EAAW1F,SACX0F,EAAWA,YAEQpZ,MAAMW,KAAKyY,EAAW2vB,YAAYj1B,OAAM,SAACqF,GAExD,IAAMzF,GAAU,IAAAkF,cAAaO,EAAO,iBAAmBA,EAAMzF,QAE7D,MAAkB,QAAXA,GAEU,SAAXA,GACAyF,GAASC,EAAWuiC,SAE9B,KAGkBviC,EAAWuiC,WACzB7c,EAAMmD,SAAS6/E,gBAAgB1oG,EAAWuiC,WAIlD8lE,EACI3iF,EACA4iF,EACAC,EAER,EAMA,0BAwCA,iBAqBA,4BAyBa,EAAA/hD,eAA+C,SAAC/nD,EAAOigB,EAAStmB,GACzE,IAAM0B,GAAgB,EAAH,eAAQ1B,EAAQ0B,eAEN,cAAzB2E,EAAM3J,gBACN2J,EAAM/J,OAAOsJ,YACZ5F,EAAQ0B,cAAckE,YAEvB5F,EAAQ0B,cAAckE,UAAYS,EAAM/J,OAAOsJ,WAGnD5F,EAAQiI,yBAAyBN,MAAMtB,EAAOigB,EAAStmB,GAE1B,cAAzBqG,EAAM3J,gBAAkC2J,EAAM/J,OAAOsJ,YACrD5F,EAAQ0B,cAAgBA,SACjB2E,EAAM/J,OAAOsJ,UAE5B,C,oHC/KA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WAgBA,aAQI,WACYsqG,EACAK,QAAA,IAAAA,IAAAA,EAAA,CAOJ1nF,gBAAiB,EAAAokF,kBACjBtkF,sBAAuB,GACvBC,yBAA0B,GAC1BE,oBAAqB,CAAC,IAXlB,KAAAonF,wBAAAA,EACA,KAAAK,wBAAAA,EATJ,KAAAz5F,OAAyB,IAqB9B,CAqIP,OAhII,YAAAwuB,QAAA,WACI,MAAO,OACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,CAClB,EAOA,YAAA2uB,QAAA,WACI1zC,KAAK+kB,OAAS,IAClB,EAQA,YAAAutB,cAAA,SAAc/W,GACV,GAAKv7B,KAAK+kB,QAA6B,eAAnBwW,EAAMsE,WAIrBtE,EAAMmE,iBAAX,CAIQ,IAAAM,EAA4CzE,EAAK,eAAjCgD,EAA4BhD,EAAK,cAAlBmD,EAAanD,EAAK,SAEnDkjF,GAAc,IAAAC,mBAAkB,CAClC1+E,eAAc,EACdtB,SAAQ,EACRigF,mBAAoBpgF,EAAcwmC,MAClCliC,wBAAyBtE,EAAcsE,wBACvCgF,YAAa7nC,KAAK+kB,OAAOyK,iBACzBoS,QAASrD,EAAcqD,UAErBpD,EAAYjD,EAAMiD,UAExB,OAAQigF,GACJ,IAAK,eACD,IAAAG,qCACIrjF,EAAMmE,iBACNnE,EAAMuE,YAAcvE,EAAMgD,cAAcqD,SAAW,IAEvD,MACJ,IAAK,iBACD,IAAAi9E,mCAAkCtjF,GAClC,MACJ,IAAK,cACL,IAAK,eACL,IAAK,sBACiB,WAAdiD,GAAwC,gBAAdA,IAE1B,IAAAsgF,+BACIvjF,EACAv7B,KAAK+kB,OAAO2c,kBACV1hC,KAAKm+G,wBACQ,uBAAfM,GAGR,MACJ,IAAK,eACDljF,EAAMmE,iBAAiB9I,sBAAsBn2B,KACzC,EAAAs+G,mBAAmBC,wBAEvB,MACJ,IAAK,qBACD,IAAAC,oCAAmC1jF,EAAOv7B,KAAK+kB,OAAO2c,iBACtD,MAEJ,IAAK,kBACD,IAAAw9E,iCAAgC3jF,IAIxC,IAAA8iF,WAAU9iF,EAAMmE,iBAAkB,OAAQ,EAAAy/E,YAC1C,IAAAd,WAAU9iF,EAAMmE,iBAAkB,YAAa,EAAA0/E,8BAC/C,IAAAf,WAAU9iF,EAAMmE,iBAAkB,YAAa,EAAA2/E,oBAC/C,IAAAhB,WAAU9iF,EAAMmE,iBAAkB,QAAS,EAAA0/E,8BAC3C,IAAAf,WAAU9iF,EAAMmE,iBAAkB,QAAS,EAAA4/E,kBAC3C,IAAAhB,cAAa/iF,EAAMmE,iBAAkB,SAAU,EAAA6/E,sBAE7B,gBAAd/gF,KACA,IAAA6/E,WAAU9iF,EAAMmE,iBAAkB,QAAS,EAAA8/E,qBAC3C,IAAAnB,WAAU9iF,EAAMmE,iBAAkB,YAAa,EAAA8/E,qBAGnDx/G,KAAKy/G,mBAAmBlkF,E,CAC5B,EAEQ,YAAAkkF,mBAAR,SAA2BlkF,G,QACvB,GAAIv7B,KAAKw+G,wBAAyB,CACxB,MAKFx+G,KAAKw+G,wBAJL,EAAe,kBACf,EAAmB,sBACnB5nF,EAAqB,wBACrBC,EAAwB,4BAE5B,IAAA1b,eAAc,GAAiBhf,SAAQ,SAAAhH,GACnC,WAAAuqH,wBACInkF,EAAMmE,iBAAiB5I,gBACvB3hC,EACA,EAAgBA,GAHpB,KAMJ,IAAAgmB,eAAc,GAAqBhf,SAAQ,SAAAhH,GACvC,WAAAuqH,wBACInkF,EAAMmE,iBAAiB3I,oBACvB5hC,EACA,EAAoBA,GAHxB,KAMJ,EAAAomC,EAAMmE,iBAAiB9I,uBAAsBn2B,KAAI,4CAAIm2B,IAAqB,KAC1E,EAAA2E,EAAMmE,iBAAiB7I,0BAAyBp2B,KAAI,4CAAIo2B,IAAwB,G,CAExF,EACJ,EA3JA,GAAa,EAAAokF,YAAAA,C,2ICjCb,WACA,WACA,WACA,WACA,WAcM0E,EAAc,QACdC,EAAwB,gCAExBC,EAAsB,SAACt1G,UAClBA,EAAOM,iBACPN,EAAOW,kBACPX,EAAOY,WAClB,EAOA,8CACIowB,EACAiG,GAEQ,IAAA9C,EAA8CnD,EAAK,SAAzCgD,EAAoChD,EAAK,cAA1BmE,EAAqBnE,EAAK,iBAE3D,GAAIgD,EAAcvG,OAASuG,EAAc5xB,MAAQ4xB,EAAcpmB,MAAO,CAGlE,IAAMmS,EAAMkX,EAAWrJ,UAAUoG,EAAcvG,OAE/C,IAAA8G,gBAAeJ,EAAUpU,aAAG,EAAHA,EAAK8N,K,EAGlC,IAAAimF,WAAU3+E,EAAkB,QAAS,EAAAogF,iCAErC,IAAAxB,cAAa5+E,EAAkB,WAAW,SAACprB,EAAOigB,EAAStmB,G,QAGvD,MAFcsmB,EAAQiC,aAAampF,IAAgB,IAEzC1kF,SAlCY,uBAkCuBhtB,EAAQ6lD,WAAW3mD,OAAOxW,OAAS,GAAhF,CAGA,IAAMopH,EAAgBxrF,EAAQqQ,cAtCf,8CAuCf,GAAIm7E,EAAe,CACT,MAuElB,SAAmCxrF,EAAsBwrF,GACrD,IAAM5+D,EAAY5sB,EAAQ4sB,UAAUjmD,UAAU,IAAM,IAC9C24D,EAAQn4D,SAASylD,GAAa,EAE9B6+D,GADQD,EAAcvpF,aAAampF,IAAgB,IAC1BxkH,MAAMykH,GAC/B,gBACFI,aAAgB,EAAhBA,EAAmB,GAAGnzG,QAAQ,IAAK,IAAIxR,MAAM,SAAU,GAAE,GADtD4kH,EAAc,KAAEC,EAA2B,KAE5CnjG,EAAgBw2C,EAAoBzZ,IAAImmE,GAExCE,EAAsBC,EAAiB1hH,IAAIqhH,EAAcvzG,WACzD6zG,EAAoB9sD,EAAoB70D,IAAIuhH,GAElD,MAAO,CACHpsD,MAAK,EACLssD,oBAAmB,EACnBE,kBAAiB,EACjBH,4BAA2B,EAC3BnjG,cAAa,EACbg+E,UACIh+E,KACEsjG,GACFN,EAAcvzG,YACV8zG,EAAgBD,EAAmBH,GAEnD,CAxFgBK,CAA0BhsF,EAASwrF,GANnClsD,EAAK,QACLssD,EAAmB,sBACnBE,EAAiB,oBACjB,EAA2B,8BAC3BtjG,EAAa,gBACb,EAAS,aAIb,IAAAyjG,iBACIzjG,EAAgB,KAAO,KACvBwX,EACAtmB,EACA4lD,EACA5lD,EAAQ6lD,WACRx/C,EACA,CAACurG,IAIL,IAAMY,EAAe,CACjBn9B,oBACKvmE,GAAiBojG,EACZ,EAAAhpD,eAAegpD,QACf57G,EACV8+E,iBACItmE,GAAiBsjG,EACX,EAAA9nD,kBAAkB8nD,QAClB97G,IAId,IAAAm8G,mBAAkBzyG,EAASsmB,EAASjgB,EAAOmsG,EAAcV,GAAe,SAAA1yG,GAChE,IACAA,EAASF,OACLE,EAASF,OAAOxW,OAAS,GAC3B4T,OAAO2E,oBAAsBxT,SAAS,IAE5CmkH,EAAoBxyG,EAASF,OAAOE,EAASF,OAAOxW,OAAS,GAAG4T,QAChEs1G,EAAoBxyG,EAAS9C,OACjC,G,MAEwC,QAAxC,KAAA0D,EAAQiI,0BAAyBqe,eAAO,gBAAGjgB,EAAOigB,EAAStmB,E,CAEnE,GACJ,EAmDA,IAAMmyG,EAA6D,IAAIpnB,IAAI,CACvE,CAAC,IAAK,QACN,CAAC,IAAK,UACN,CAAC,IAAK,UACN,CAAC,IAAK,aACN,CAAC,IAAK,YACN,CAAC,IAAK,cACN,CAAC,IAAK,eAGJzlC,EAAmE,IAAIylC,IAAI,CAC7E,CAAC,aAAc,cACf,CAAC,aAAc,sBACf,CAAC,aAAc,WACf,CAAC,aAAc,cACf,CAAC,aAAc,yBACf,CAAC,aAAc,cACf,CAAC,aAAc,gBAGnB,SAASsnB,EACLD,EACAnxG,GAEA,IAAMkvE,GAAS,IAAA1gE,yBACX,EAAA66C,kBAAkB8nD,GAClB3kH,SAASwT,IAEb,OAAQmxG,GACJ,IAAK,UACL,IAAK,aACL,IAAK,aACL,IAAK,aACL,IAAK,aACD,OAAOjiC,EAAS,IACpB,IAAK,qBACL,IAAK,wBACD,OAAOA,EAAS,IAEpB,QACI,OAEZ,C,+ZChMa,EAAAuiC,uCAAmD,CAC5D,yBACA,0BACA,2BACA,4BACA,yBACA,uBAKS,EAAAC,kBAA4B,kBAI5B,EAAAC,kBAA4B,kBAI5B,EAAAC,aAAuB,iBAIvB,EAAAC,gBAA0B,oBAI1B,EAAAC,gBAA0B,iBAI1B,EAAAC,UAAoB,YAIpB,EAAAC,kCAA4C,uBAI5C,EAAAC,wBAAkC,uBAIlC,EAAAC,gCAA0C,0BAI1C,EAAAC,uBAAqB,uDAC3B,EAAAV,yCAAsC,IACzC,2B,GAMS,EAAAW,uBACT,QAAQ,EAAAP,gBAAe,SAAS,EAAAD,aAAY,KAAK,EAAAK,wBAAuB,KAAK,EAAAC,gCAA+B,IAC5G,EAAAT,uCAAuCrlH,KAAI,SAAAvD,GAAK,2BAAqBA,EAAC,IAAtB,IAA4ByD,KAAK,KAKxE,EAAA+lH,sBAAgC,cAAc,EAAAX,kBAAiB,OAAO,EAAAI,gBAAe,eAAe,EAAAH,kBAAiB,OAAO,EAAAG,gBAAe,IAAI,EAAAM,sB,0ICjE5J,WACA,WACA,WACA,WAoBME,EAAoB,CAAC,KAAM,KAAM,MACjCC,EAAwBD,EAAkBhmH,KAAK,KAiB/CkmH,EAA6D,SAC/Dn3G,EACAgqB,GAEA,IAAMtS,EAAgBsS,EAAQhc,MAAM0J,cACd,UAAlBA,IACA1X,EAAO4hB,yBAA2B,SAEhB,QAAlBlK,IACA1X,EAAO4hB,yBAA2B,MAE1C,EAUMw1F,EAAqD,SACvDrtG,EACAigB,EACAtmB,GAEA,IAAM2zG,EAAartF,EAAQpkB,QAO3B,GALIokB,EAAQjZ,QAAQ,EAAAgmG,0BAChB/sF,EAAQhc,MAAM44C,eAAe,WAC7B58B,EAAQhc,MAAM44C,eAAe,WAG7B58B,EAAQ8uB,UAAUjuC,SAAS,EAAA8rG,mCAC3BjzG,EAAQusD,kBAAkB5kD,MAAMtB,EAAOigB,EAAStmB,QAIpD,IAAI,EAAAozG,sBAAsB/zG,MAAK,SAAA6zC,GAAa,OAAA5sB,EAAQ8uB,UAAUjuC,SAAS+rC,EAA3B,IAA5C,CAEO,GA2GX,SACIygE,EACArtF,EACAtmB,GAEA,OACIA,EAAQ6lD,WAAW3mD,OAAOxW,OAAS,GACnC6qH,EAAkBjxG,OAAM,SAAAsV,GAAO,OAAAA,GAAO+7F,CAAP,MAC9BrtF,EAAQ+vB,QAAQm9D,EAEzB,CArHeI,CAAuBD,EAAYrtF,EAAStmB,GAAU,CACrD,IAAA6lD,EAAe7lD,EAAO,WAC9B6lD,EAAW3mD,OAAS,GACpB2mD,EAAWkL,gBAAaz6D,C,CAG5B0J,EAAQiI,yBAAyBqe,QAAQjgB,EAAOigB,EAAStmB,E,CAC7D,EAKM6zG,EAAyD,SAC3DxtG,EACAigB,EACAtmB,G,cAEM9K,EAAQzH,SAAgD,QAAvC,EAAA64B,EAAQiC,aAAa,0BAAkB,QAAI,IAC5Ds9B,EAAa7lD,EAAQ6lD,WACrBhlD,GACqD,QAAvD,EAAAglD,EAAW3mD,OAAOc,EAAQ6lD,WAAW3mD,OAAOxW,OAAS,UAAE,eAAEmY,YAChC,QAAxB,EAAAylB,EAAQ+vB,QAAQ,gBAAQ,eAAEn0C,QAAQlV,eACjC2T,GAAkC,IAAAC,iBAAgBC,EAAUb,EAAQwlB,aAK1E,IAJA,IAAA+E,aAAYjE,EAAStmB,EAAQwqB,cAAc4mC,gBAAiBzwD,EAASrE,OAAQ0D,IAC7E,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAcm6B,UAAWhkD,EAASrE,OAAQ0D,GACvEA,EAAQ6lD,WAAW3mD,OAAS2mD,EAAWiuD,mBAAqB9zG,EAAQ6lD,WAAW3mD,OAE3EhK,EAAQ,EACR,GAAIA,EAAQ8K,EAAQ6lD,WAAW3mD,OAAOxW,OAClC,KAAOwM,GAAS8K,EAAQ6lD,WAAW3mD,OAAOxW,QACtCsX,EAAQ6lD,WAAW3mD,OAAO1M,KAAKmO,QAGnCX,EAAQ6lD,WAAW3mD,OAAO/M,OAAO+C,EAAO8K,EAAQ6lD,WAAW3mD,OAAOxW,OAAS,GAC3EsX,EAAQ6lD,WAAW3mD,OAAOhK,EAAQ,GAAKyL,EAIZ,QAAnC,KAAAX,EAAQiI,0BAAyBqgD,UAAE,gBAAGjiD,EAAOigB,EAAStmB,GAEtD,IAAM+wD,EAAalL,EAAWkL,WAC9B,GAAIA,EAAY,CACZ,IAAMgjD,EAAYhjD,EAAWp0D,OAAOo0D,EAAWp0D,OAAOjU,OAAS,GACpC,cAAvBqrH,EAAUv3G,WAAyD,YAA5Bu3G,EAAUr3G,gBAoH7D,SACIgS,EACA4X,EACA0tF,GAEA,GAAKtlG,GAAyC,MAAzBA,EAAa7N,SAAlC,CAIA,IAAM23E,EAAOlyD,EAAQ+vB,QAAQ,MACvBwP,EAAamuD,EAAInuD,WACjB,eAYV,SACI2yB,EACAv5E,GAEA,IAAM8Q,EACF9Q,GAAQzQ,MAAMW,MAAKqpF,aAAI,EAAJA,EAAM9wD,iBAAiB,QAAS,IAAIt1B,QAAQ6M,GAKnE,MAAO,CAHHxR,UAAS+qF,aAAI,EAAJA,EAAMjwD,aAAa,WAAY,MAAQxY,GAAaA,EAAY,EAAIA,EAAY,GAC3EtiB,UAASwR,aAAI,EAAJA,EAAMspB,aAAa,qBAAsB,IAGxE,CAvB+B0rF,CAAwBz7B,EAAMlyD,GAAQ,GAA1DhH,EAAK,KAAEqlC,EAAS,KAElBkB,EAAWoL,iBACZpL,EAAWoL,eAAiB,IAGhC,IAAM9wD,EAA6B0lD,EAAWoL,eAAetM,GACzDxkD,GAAUmf,EAAQnf,GAAU,IAC5BuO,EAAapS,OAAO2E,oBAAsBqe,GAE9CumC,EAAWoL,eAAetM,GAAarlC,C,CAC3C,CAxIY40F,CADqBH,EAAU70G,OAAO60G,EAAU70G,OAAOxW,OAAS,GAC9B49B,EAAStmB,E,CAInD,IAAMm0G,EAAqC,GAC3CtuD,EAAW3mD,OAAOhR,SAAQ,SAAAvE,GACtB,IAAMkW,EAAkC,CACpCiB,SAAS,EAAF,eAAOnX,EAAEmX,SAChBxE,QAAQ,EAAF,eAAO3S,EAAE2S,QACfuE,SAAUlX,EAAEkX,UAEhBszG,EAAU3hH,KAAKqN,EACnB,IACAgmD,EAAWiuD,kBAAoBK,EAC/BtuD,EAAW3mD,OAAS,EACxB,EAOMk1G,EAAmE,SACrE93G,EACAgqB,GAE8B,UAA1BA,EAAQhc,MAAM2O,UACd3c,EAAO0S,yBAAsB1Y,GAGjCgG,EAAOW,gBAAa3G,EACpBgG,EAAOc,iBAAc9G,CACzB,EAKM+9G,EAAoE,SACtE/3G,GAEAA,EAAOW,gBAAa3G,EACpBgG,EAAOY,iBAAc5G,CACzB,EAgCMg+G,EAA4D,SAC9Dh4G,EACAgqB,IAGIA,EAAQ4sB,UAAUlmB,SAAS,EAAAkmF,0BAC3B5sF,EAAQ4sB,UAAUlmB,SAAS,EAAAmmF,0CAEpB72G,EAAO8f,eAEtB,EAQA,6CAAkDqiF,IAC9C,IAAA2R,WAAU3R,EAAGhtE,iBAAkB,UAAWgiF,IAC1C,IAAArD,WAAU3R,EAAGhtE,iBAAkB,iBAAkB2iF,IACjD,IAAAhE,WAAU3R,EAAGhtE,iBAAkB,kBAAmB2iF,IAClD,IAAAhE,WAAU3R,EAAGhtE,iBAAkB,YAAa4iF,IAC5C,IAAAjE,WAAU3R,EAAGhtE,iBAAkB,YAAa8iF,IAC5C,IAAAnE,WAAU3R,EAAGhtE,iBAAkB,QAAS8iF,IACxC,IAAAnE,WAAU3R,EAAGhtE,iBAAkB,UAAW6iF,IAE1C,IAAAjE,cAAa5R,EAAGhtE,iBAAkB,UAAWiiF,IAC7C,IAAArD,cAAa5R,EAAGhtE,iBAAkB,KAAMoiF,EAC5C,EAEA,IAAMU,EAA4D,SAC9Dj4G,EACAgqB,GAEIA,EAAQhc,MAAMrN,WAAWivB,WAAW,aAC7B5vB,EAAOW,UAEtB,C,yHC9OA,WAGMu3G,EAAkB,eAClBC,EAAY,SAEZ7kF,EAAwB,KAgB9B,SAASC,EAAmB9F,EAAc+F,QAAA,IAAAA,IAAAA,EAAA,GAMtC,IALA,IAAMC,EAAgBhG,EAAKj5B,cACvBk/B,EAAaD,EAAc39B,QAAQqiH,EAAW3kF,GAC9CxhB,EAAe0hB,EAAaykF,EAC5BxkF,EAAWlG,EAAK98B,UAAUqhB,EAAcA,EAAe,IAEnDshB,EAAsBrjB,KAAK0jB,IAAaD,GAAc,GAE1D1hB,GADA0hB,EAAaD,EAAc39B,QAAQqiH,EAAWzkF,EAAa,IAC/BykF,EAC5BxkF,EAAWlG,EAAK98B,UAAUqhB,EAAcA,EAAe,GAI3D,MAAO,CAAE0hB,WAAU,EAAEE,cADCH,EAAc39B,QA7BlB,WA6ByC09B,GAE/D,CAsBA,4BAAiC4kF,GAC7B,IAAMC,EAAyC,IAAI5pB,IACnD,OAAK2pB,GApDT,SAAkCrmF,GAI9B,I,MAHM7G,EAAmB,GAErB,EAAgCqI,EAAmBxB,GAAjD2B,EAAU,aAAEE,EAAa,gBACxBF,GAAc,GAAKE,GAAiB,GAAG,CAC1C,IAAM0kF,EAAevmF,EAChBphC,UAAU+iC,EAAaykF,EAAkBvkF,GACzCtsB,OACL4jB,EAAOh1B,KAAKoiH,GACT5kF,GAAF,EAAgCH,EAAmBxB,EAAa6B,EAAgB,IAApE,WAAEA,EAAa,e,CAEhC,OAAO1I,CACX,CA2CuBqtF,CAAyBH,GAEjCxmH,SAAQ,SAAAwQ,GAEf,IADA,IAAI2C,EAAQ,E,aAER,IAAMyzG,EAAUp2G,EAAKtM,QAAQ,IAAKiP,EAAQ,GACpC0zG,EAAgBr2G,EAAKtM,QAAQ,IAAK0iH,GAClCE,EAAkBt2G,EAAKtM,QAAQ,IAAK0iH,GAC1CzzG,EAAQyzG,EAGR,IAAMG,EAAev2G,EAChBzR,UAAU6nH,EAAU,EAAGE,GACvBp2G,QAAQ41G,EAAiB,IACzB51G,QAAQ,OAAQ,IAChBmP,YACAD,WAGConG,EAAWx2G,EACZzR,UAAU+nH,EAAiBD,EAAgB,GAC3CjnG,WACAC,YACConG,EAAiC,CAAC,EAGxBD,EAAS9nH,MAAM,KACvBc,SAAQ,SAAA6sC,GAEN,mBAAeA,EAAM3tC,MAAM,KAAI,GAA9BlG,EAAG,KAAE2B,EAAK,KACjB,GAAI3B,GAAO2B,EAAO,CACd,IAAMusH,EAAcluH,EAAI0X,QAAQ41G,EAAiB,IAAIzmG,YAAYD,WAC3DunG,EAAgBxsH,EAAM+V,QAAQ41G,EAAiB,IAAIzmG,YAAYD,WAErEqnG,EAAOC,GAAeC,C,CAE9B,IAEA,IAAMv5E,EAAqB,CACvB,0BAA2Bq5E,EAAO,2BAClC,qBAAsBA,EAAO,uBAAyB,IACtD,iBAAkBA,EAAO,oBAEzB,IAAAjoG,eAAc4uB,GAAMz8B,MAAK,SAAAnY,GAAO,QAAE40C,EAAK50C,EAAP,KAChCytH,EAAY7b,IAAImc,EAAcn5E,E,EAxC/Bz6B,GAAS,G,GA2CpB,IAEOszG,GAnDIA,CAoDf,C,6HCjHA,eACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WAUA,+CACIljF,EACAijF,GAEA,IAAMC,GAAyC,IAAAW,kBAAiBZ,IAEhE,IAAArE,cAAa5+E,EAAkB,UAAW8jF,EAA4BZ,KACtE,IAAAvE,WAAU3+E,EAAkB,QAAS,EAAA+jF,6BACrC,IAAApF,WAAU3+E,EAAkB,QAAS,EAAAogF,iCACrC,IAAAzB,WAAU3+E,EAAkB,kBAAmB,EAAAogF,iCAC/C,IAAAzB,WAAU3+E,EAAkB,YAAa,EAAAgkF,kBACzC,IAAArF,WAAU3+E,EAAkB,YAAa,EAAAikF,sBACzC,IAAAtF,WAAU3+E,EAAkB,QAAS,EAAAkkF,gBACzC,EAEA,IAAMJ,EAA8B,SAChCK,GAEA,OAAO,SAACvvG,EAAOigB,EAAStmB,GACpB,IAAMwnB,GAAS,IAAAquF,WAAUvvF,IAIjB,IAAAwvF,iBAAgBtuF,EAAQnhB,EAAOigB,EAAStmB,EAAS41G,KACjD,IAAAG,qBAAoBvuF,EAAQlB,IAGhCtmB,EAAQiI,yBAAyBqe,QAAQjgB,EAAOigB,EAAStmB,EAEjE,CACJ,C,6GClDA,eAEMg2G,EAAgC,YAYtC,+BAAoCxuF,EAAgClB,GAChE,MAXkC,WAY9BkB,EAbsB,2BAcrB,IAAAyF,iBAAgB3G,EAAS,MAAQ0vF,EAA8BzpG,KAAK+Z,EAAQ3Y,OAXpD,gBAYzB6Z,EAbY,cAepB,C,wHCpBA,WACA,WACA,WAkBMyuF,EAAW,WACXC,EAAkB,SAElBC,EAAuB,iBA0M7B,SAASC,EACL95G,EACAgqB,GAEIA,EAAQhc,MAAMrN,YAAoD,GAAtCxP,SAAS64B,EAAQhc,MAAMrN,cACnDX,EAAOY,YAAc,OAErBopB,EAAQhc,MAAMlN,aAAsD,GAAvC3P,SAAS64B,EAAQhc,MAAMlN,eACpDd,EAAOe,aAAe,MAE9B,CA/LA,2BACImqB,EACAnhB,EACAigB,EACAtmB,EACArC,G,MAEMkoD,EAAa7lD,EAAQ6lD,WACtBA,EAAWwwD,kBACZxwD,EAAWwwD,gBAAkB,IAAItrB,KAErC,IAAMurB,EAAgB9uF,EAAOyuF,IAAa,GAI1C,GAAIK,EAAcxlH,gBAAkBolH,EAChC,OAAO,EAGL,mBAAmBI,EAAclpH,MAAM,KAAI,GAA1CmpH,EAAO,KAAErhH,EAAK,KAWrB,GARA2wD,EAAW2wD,UAAYthH,GAASzH,SAASyH,EAAMw+C,OAAO,IACtDmS,EAAW4wD,SAAWF,GA7CF,KA+CY,GAA5B1wD,EAAW3mD,OAAOxW,SAClBm9D,EAAW3mD,OACN2mD,EAAW4wD,UAAY5wD,EAAWwwD,gBAAgB5lH,IAAIo1D,EAAW4wD,WAAc,IAGpFH,GAAiBjwG,GAAyC,iBAAzBw/C,EAAW2wD,UAAwB,CAC5D,IAAAA,EAAwB3wD,EAAU,UAAvB4wD,EAAa5wD,EAAU,SAEpC,EAAeloD,EAASlN,IAAO8lH,EAAO,IAAIrhH,GAC1C,EAtDU,WAuD6B,QAAzC,eAAY,EAAZ,EAAe,kCAA0B,eAAEpE,eACrC,KACA,MAGV,IAAAyhH,iBAAgB,EAAUjsF,EAAStmB,EAASw2G,EAAW3wD,EAAYx/C,EAAO,CACtE+vG,IAEHvwD,EAAW3mD,OAAO2mD,EAAW3mD,OAAOxW,OAAS,GACzC4T,OAA0Bm6G,SAAWA,EAE1C,IAAMtmC,EAiCd,SAA+BqiC,EAAwC3xG,GACnE,IACI61G,EADEC,GAAenE,aAAY,EAAZA,EAAe,6BAA8B,UAGlE,GAAIA,aAAY,EAAZA,EAAe,kBAAmB,CAClC,IAAIoE,EAAwB,GAC5B,OAAQD,GACJ,IAAK,cACDC,EAAgB,aAChB,MACJ,IAAK,cACDA,EAAgB,aAChB,MACJ,IAAK,cACDA,EAAgB,aAChB,MACJ,IAAK,cACDA,EAAgB,aAChB,MACJ,QACIA,EAAgB,SAQxBF,EAAgB,KALElE,EAAa,mBAAqB,IAC/C5zG,QAAQ,KAAM,IACdA,QAAQ,IAAK,IACbA,QAAQu3G,EAAsB,KAAOS,EAAgB,KAEzB,I,MAEjC,OAAQD,GACJ,IAAK,cACDD,EAAgB,cAChB,MACJ,IAAK,cACDA,EAAgB,cAChB,MACJ,IAAK,cACDA,EAAgB,cAChB,MACJ,QACIA,EAAgB,UAK5B,OAAO,IAAAnvC,4BAA2B1mE,EAAU61G,EAChD,CAhFuBG,CAAsB,EAAc,GAC7CC,EAAqB3mC,EACrB,CACIkF,mBAAgC,MAAZ,EAAmBlF,OAAS75E,EAChD8+E,iBAA8B,MAAZ,EAAmBjF,OAAS75E,QAElDA,EAqBN,OAnBA,IAAAm8G,mBACIzyG,EACAsmB,EACAjgB,EACAywG,EA2JZ,SAA0BxwF,GACtB,IAAM1e,EAAa0e,EAAQoc,kBACvBq0E,GAAkB,EAEtB,GAAInvG,EACA,IAAK,IAAI/c,EAAI,EAAGA,EAAI+c,EAAW2vB,WAAW7uC,OAAQmC,IAAK,CACnD,IAAM8c,EAAQC,EAAW2vB,WAAW1sC,GACpC,IAAI,IAAAuc,cAAaO,EAAO,mBACL,IAAAkuG,WAAUluG,GACIsuG,IAAa,IAExBnlH,gBAAkBolH,EAAiB,CACjDa,GAAkB,EAClB,K,EAMhB,OAAOnvG,GAAcmvG,EAAmBnvG,OAA6BtR,CACzE,CA9KY0gH,CAAiB1wF,IACjB,SAAAlnB,GACoB,MAAZ,GAmEpB,SACIA,EACAY,EACAwyG,EACAlsF,G,QAEM,EAMFtmB,EAAQ6lD,WALRkL,EAAU,aACV0lD,EAAQ,WACRJ,EAAe,kBACfG,EAAS,YACTt3G,EAAM,SAGJ/C,EA4BV,SAA8B40D,GAC1B,IAAK,IAAI1vD,IAAS0vD,aAAU,EAAVA,EAAYp0D,OAAOjU,SAAU,GAAK,EAAG2Y,EAAQ,EAAGA,IAAS,CACvE,IAAMzS,EAASmiE,aAAU,EAAVA,EAAYp0D,OAAO0E,GAClC,GAAIzS,KAAW,IAAAk4E,SAAQl4E,GACnB,OAAOA,C,CAKnB,CArCkBqoH,CAAqBlmD,GACnC,IACyB,eAApB50D,aAAK,EAALA,EAAOK,YACoB,YAAxBL,EAAMO,gBACL85G,IACsD,QAAnD,EAAwB,QAAvB,EAAAr6G,EAAM+C,OAAOs3G,UAAU,eAAEl6G,cAAyB,eAAEm6G,WAAYA,IACzEA,EACF,CACE,IAAMn3F,GAAQkzF,aAAY,EAAZA,EAAe,uBACvB/kH,SAAS+kH,EAAa,uBACtB0E,IACAC,GAAad,aAAe,EAAfA,EAAiB5lH,IAAIgmH,KAAa,GAExCngH,MAATgpB,GAAuBnuB,MAAMmuB,IAAU63F,EAAWzuH,QAAUwW,EAAOxW,QAGnE,IAAAukC,iBAAgB3G,EAAS,QACzB,IAAAlf,cAAakf,EAAQ0H,cAAe,kBACpC,IAAAf,iBAAgB3G,EAAQ0H,cAAe,OACvC1H,EAAQ0H,cAAc0U,mBAAqBpc,GAC3C6wF,EAAWzuH,QAAU49B,EAAQ0H,cAAc1O,QAE3ClgB,EAASF,OAAOE,EAASF,OAAOxW,OAAS,GAAG4T,OAAO2E,oBAC/CqlB,EAAQ0H,cAAc1O,OAT1BlgB,EAASF,OAAOE,EAASF,OAAOxW,OAAS,GAAG4T,OAAO2E,oBAAsBqe,C,CAYrF,CA1GoB83F,CAAeh4G,EAAUY,EAAS,EAAcsmB,EAExD,IAIAu/B,EAAW3mD,OAAOxW,OAAS,GAC3Bm9D,EAAWwwD,gBAAgB5lH,IAAIgmH,IAAa5wD,EAAW3mD,QAEvD2mD,EAAWwwD,gBAAgBvd,IAAI2d,GAAU,EAAF,iCAAM5wD,EAAW3mD,SAAM,KAE3D,C,CAGX,OAAO,CACX,C,uLCzHA,eAOMomD,EAAsB,CACxB,EAAG,UACHt5D,EAAG,cACHqrH,EAAG,cACHxsH,EAAG,cACHsrF,EAAG,eAGD5wB,EAAwB,CAC1ByvB,KAAM,OACNC,OAAQ,SACRC,OAAQ,UA4HZ,SAASoiC,EAAyBC,GAC9B,IAAMv3G,EAAUu3G,EAMhB,OAJKv3G,EAAQw3G,qBACTx3G,EAAQw3G,mBAAqB,CAAC,GAG3Bx3G,CACX,CAxGA,2CAAgDstB,IAC5C,IAAA+iF,cAAa/iF,EAAMmE,iBAAkB,KAAM,EAAAgmF,qBAC3C,IAAApH,cAAa/iF,EAAMmE,iBAAkB,KAAM,EAAAimF,uBAC3C,IAAArH,cAAa/iF,EAAMmE,iBAAkB,KAAM,EAAAkmF,gBAC/C,EASa,EAAAF,mBAAyD,SAClEpxG,EACAigB,EACAixF,G,QAEMv3G,EAAUs3G,EAAyBC,GAEzC,GAAIv3G,EAAQw3G,mBAAoB,CAC5B,IAAMI,EAAatxF,EAAQiC,aAAa,QACxC,GAAIqvF,EAAY,CACZ,IAAMxoG,EAAYk2C,EAAoBsyD,GAChC32G,EAAsBxT,SAAS64B,EAAQiC,aAAa,UAAY,MAAQ,EAE9EvoB,EAAQw3G,mBAAmBloG,cAAgBF,EAC3CpP,EAAQw3G,mBAAmBv2G,oBAAsBA,C,EAItB,QAAnC,KAAAjB,EAAQiI,0BAAyBwgD,UAAE,gBAAGpiD,EAAOigB,EAAStmB,EAC1D,EASa,EAAA03G,qBAA2D,SACpErxG,EACAigB,EACAixF,G,QAEMv3G,EAAUs3G,EAAyBC,GAEzC,GAAIv3G,EAAQw3G,mBAAoB,CAC5B,IAAMI,EAAatxF,EAAQiC,aAAa,QACxC,GAAIqvF,EAAY,CACZ,IAAMxoG,EACFm2C,EAAsBqyD,GAC1B53G,EAAQw3G,mBAAmBloG,cAAgBF,C,EAIhB,QAAnC,KAAApP,EAAQiI,0BAAyBghD,UAAE,gBAAG5iD,EAAOigB,EAAStmB,EAC1D,EAUa,EAAA23G,gBAAmD,SAACtxG,EAAOigB,EAASixF,G,QACvEv3G,EAAUs3G,EAAyBC,GACrCM,GAA4B,EAEhC,GAAI73G,EAAQw3G,mBAAoB,CACtB,MAAyCx3G,EAAQw3G,mBAA/CloG,EAAa,gBAAErO,EAAmB,sBAC1C,GAAIqO,EAAe,CACf,IAAM5O,EAAYV,EAAQ6lD,WAAW3mD,OAAOc,EAAQ6lD,WAAW3mD,OAAOxW,OAAS,GAC/EgY,EAAUpE,OAAOgT,cAAgBA,EAE7BrO,IACA42G,GAA4B,EAC5Bn3G,EAAUpE,OAAO2E,oBAAsBA,SAEhCjB,EAAQw3G,mBAAmBv2G,4BAE/BjB,EAAQw3G,mBAAmBloG,a,EAIP,QAAnC,KAAAtP,EAAQiI,0BAAyBqgD,UAAE,gBAAGjiD,EAAOigB,EAAStmB,GAElD63G,UACO73G,EAAQ6lD,WAAW3mD,OAAOc,EAAQ6lD,WAAW3mD,OAAOxW,OAAS,GAAG4T,OAClE2E,mBAEb,C,kHC1IA,IAAM62G,EAAmB,IAUzB,sCACIx7G,EACAgqB,GAGA,IAAIyxF,EAEAD,EAAiBvrG,KAAK+Z,EAAQhc,MAAM2N,cACnC9mB,MAAO4mH,EAAmBtqH,SAAS64B,EAAQhc,MAAM2N,aAElD3b,EAAO2b,YAEF8/F,EAAmB,IApBe,KAqBrChrH,WACgD,WAA3Cu5B,EAAQhc,MAAM2N,WAAWnnB,gBAChCwL,EAAO2b,WAAa,OAE5B,C,0GCtBa,EAAAs5F,mBAA4D,SACrEj1G,EACAgqB,GAEIA,EAAQhc,MAAM8R,wBACP9f,EAAO8f,eAEtB,C,oHCdA,eAMa,EAAA+0F,4BAA0D,SACnE70G,GAEA,EAAAk/D,WAAWttE,SAAQ,SAAAhH,GACf,IAAM2B,EAAQyT,EAAOpV,GACjByF,EAAgB,GACpB,GACI9D,GACA,EAAA87E,iBAAiBtlE,MAAK,SAAA24G,GAAU,OAAAnvH,EAAMuJ,QAAQ4lH,IAAW,IAAMrrH,EAAQqrH,EAAvC,IAClC,CACE,IAAMn4G,EAAWhX,EAAM+V,QAAQjS,EAAO,IAAIohB,YAC1CzR,EAAOpV,GAAO2Y,C,CAEtB,GACJ,C,yGCpBA,eAIMo4G,EAAoB,0CAMb,EAAA5G,gBAAyD,SAClE/0G,EACAgqB,EACAtmB,GAEA,IAAMk4G,EAAel4G,EAAQqpB,gBACrBhf,EAAU/N,EAAM,MAEpB+N,GAAS6tG,GAAgBD,EAAkB1rG,KAAKlC,KAC7B,IAAAzK,oBAAmByK,EAAOic,GAG5B4xF,WACN57G,EAAO+N,aACP/N,EAAO6Z,OAG1B,C,mGC3BA,eAGMgiG,EAAsB,CAAC,QAAS,SAAU,SAAU,UAAW,YAC/DC,EAAsB,0BAKf,EAAAlH,UAAuD,SAAC50G,EAAQgqB,GACzE,IAAK,IAAA2G,iBAAgB3G,EAAS,KAA9B,CAIA,IAAIha,EACJ,IACIA,EAAM,IAAI25E,IAAI3/D,EAAQ3Y,K,CACxB,SACErB,OAAMhW,C,EAILgW,IAAsD,IAA/C6rG,EAAoB/lH,QAAQka,EAAI+rG,WACxCD,EAAoB7rG,KAAK+Z,EAAQ3Y,SAEjC2Y,EAAQ6G,gBAAgB,QACxB7wB,EAAOqR,KAAO,G,CAEtB,C,sGCda,EAAA8nG,gBAAiE,SAC1En5G,EACAgqB,EACAgyF,EACA7xD,GAEiC,KAA7BngC,EAAQhc,MAAMrN,aACdX,EAAOW,WAAawpD,EAAaxpD,YAGrCX,EAAOgU,kBAAeha,CAC1B,C,sHCpBa,EAAAu7G,+BAAiE,SAACv1G,EAAQgqB,G,OAC9D,QAAjB,EAAAhqB,EAAOo4D,kBAAU,eAAExoC,WAAW,cACvB5vB,EAAOo4D,UAEtB,C,2GCTA,eAOM6jD,EAAoB,IAAIxtB,IAO5B,CACE,CAAC,YAAa,CAAEj9F,EAAG,iBAAkBpE,EAAG,iBAAkBI,EAAG,mBAC7D,CAAC,cAAe,CAAEgE,EAAG,mBAAoBpE,EAAG,mBAAoBI,EAAG,qBACnE,CAAC,eAAgB,CAAEgE,EAAG,oBAAqBpE,EAAG,oBAAqBI,EAAG,sBACtE,CAAC,aAAc,CAAEgE,EAAG,kBAAmBpE,EAAG,kBAAmBI,EAAG,sBAMvD,EAAAsnH,kBAA+D,SAAC90G,EAAQgqB,GACjF,EAAAk1C,WAAWttE,SAAQ,SAAAhH,GACf,IAAKoV,EAAOpV,GAAM,CACd,IAAMsxH,EAAWD,EAAkB9nH,IAAIvJ,GAGnCsxH,GACAlyF,EAAQhc,MAAMkuG,EAAS1qH,IACvBw4B,EAAQhc,MAAMkuG,EAAS9uH,KACtB48B,EAAQhc,MAAMkuG,EAAS1uH,KAExBwS,EAAOpV,GAAUo/B,EAAQhc,MAAMkuG,EAAS1qH,GAAE,IAAIw4B,EAAQhc,MAAMkuG,EAAS9uH,G,CAGjF,GACJ,C,2GC5Ba,EAAAgsH,oBAAuE,SAChFp5G,G,OAEqB,QAAjB,EAAAA,EAAOW,kBAAU,eAAEivB,WAAW,cACvB5vB,EAAOW,UAEtB,C,uGCTa,EAAA04G,gBAAyD,SAACr5G,EAAQgqB,G,OACtD,QAAjB,EAAAhqB,EAAOW,kBAAU,eAAEivB,WAAW,cACvB5vB,EAAOW,WAEdX,EAAOmgE,kBACAngE,EAAOmgE,SAEtB,C,yGCZa,EAAAq0C,mBAAqB,CAI9BC,uBAAwB,4BAKxB0H,aAAc,SAKdC,6BAA8B,U,oHCjBlC,eASa,EAAAC,2BAAgD,SAAAC,GAEzD,QADqBA,EAAK,SACRjiF,cAAc,EAAA28E,sBACpC,C,2GCZA,eACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WA2DMuF,EAAqB,IAAI9tB,IAA6C,CACxE,CAAC,cAAe,EAAA+tB,uBAChB,CAAC,eAAgB,EAAAC,wBACjB,CAAC,cAAe,EAAAC,uBAChB,CAAC,oBAAqB,EAAAC,6BACtB,CAAC,gBAAiB,EAAAN,4BAClB,CAAC,eAAgB,EAAAO,uBACjB,CAAC,cAAe,EAAAC,4BAChB,CAAC,sBAAuB,EAAAC,uBACxB,CAAC,iBAAkB,EAAAC,4BAUvB,6BAAkCC,GAC9B,IAAI1qH,EAAsC,KAQ1C,OANAiqH,EAAmB3qH,SAAQ,SAACqrH,EAAMryH,IACzB0H,GAAU2qH,EAAKD,KAChB1qH,EAAS1H,EAEjB,IAEO0H,QAAAA,EAAU,SACrB,C,gHChGA,cAWa,EAAAmqH,uBAA4C,SAAAH,GAGrD,MAX0B,0CASCA,EAAK,eAEV,EAAA9H,mBAAmB4H,6BAC7C,C,6GCNa,EAAAU,sBAA2C,SAACR,GAC7C,IAAAlI,EAAgDkI,EAAK,mBAAjChkF,EAA4BgkF,EAAK,wBAE7D,SACIlI,IACAA,EAAmB1jF,SAZS,6BAaO,IAAnC4H,aAAuB,EAAvBA,EAAyBlsC,SACK,SAA9BksC,EAAwB,GAEhC,C,+GClBA,cAYa,EAAAokF,sBAA2C,SAAAJ,GAC5C,IAAA7mF,EAAmB6mF,EAAK,eAEhC,MAXiC,eAY7B7mF,EAAe,EAAA++E,mBAAmB2H,eACiCniH,MAAnEy7B,EAAe,EAAA++E,mBAAmB4H,6BAE1C,C,+GCnBA,cASa,EAAAQ,sBAA2C,SAAAN,GAEpD,QADqBA,EAAK,SACRjiF,cAAc,EAAAm6E,mBAAmBC,uBACvD,C,kHCZA,cAWa,EAAAsI,yBAA8C,SAAAT,GAGvD,MAX6B,gBASFA,EAAK,eAEV,EAAA9H,mBAAmB2H,aAC7C,C,qHCfA,cAWa,EAAAQ,4BAAiD,SAAAL,GAC1D,MAT+B,oBASxBA,EAAM7mF,eAAe,EAAA++E,mBAAmB2H,aACnD,C,+GCbA,cAGMe,EAAsB,UACtBC,EAAuB,wCAShB,EAAAX,sBAA2C,SAAAF,GAC5C,IAAA7mF,EAAyC6mF,EAAK,eAA9BjlF,EAAyBilF,EAAK,QAArBh/E,EAAgBg/E,EAAK,YAEtD,OACI7mF,EAAeynF,IAAwBC,GAZ1B,iBAab1nF,EAAe,EAAA++E,mBAAmB2H,kBAG9B7+E,EAAYpY,UACZmS,IACAA,aAAO,EAAPA,EAAS/0B,QAAQ,KAAM,IAAIxM,QAAWonH,EAAmB,KAAKC,KACzD,EAGjB,C,kHClBa,EAAAN,2BAAgD,SAAAP,GACjD,IAAAc,EAAsDd,EAAK,yBAAjChkF,EAA4BgkF,EAAK,wBACnE,SACIc,GACmC,IAAnC9kF,aAAuB,EAAvBA,EAAyBlsC,SACK,OAA9BksC,EAAwB,GAEhC,C,6HChBA,WA2BA,SAAS+kF,EACLtzG,EACAnW,EACA8P,EACA1D,GAEA,GAAIpM,EAAK4oE,WAAale,KAAKg/D,UAAW,CAElC,IAAMl7G,GAAO,IAAAiT,YAAWzhB,EAAK+0B,WAAa,GAAI3oB,IAC9C,IAAAyW,YAAW1M,EAAO3H,E,MACf,IAAI,IAAA0I,cAAalX,EAAM,gBAAiB,CAC3C,IAAM6tB,GAAS,iBAAmCzhB,IAClD,IAAAiuB,aAAYr6B,EAAM8P,EAAQwqB,cAAclrB,QAASye,EAAW/d,GAE5D,IAAK,IAAInV,EAAI,EAAGA,EAAIqF,EAAKqnC,WAAW7uC,OAAQmC,IACxC8uH,EAA4BtzG,EAAOnW,EAAKqnC,WAAW1sC,GAAImV,EAAS+d,E,CAG5E,CAhCa,EAAAuzF,qBAA4D,SACrEjrG,EACAigB,EACAtmB,GAEA,IAAM1D,EAAoC,CAAC,GAC3C,IAAAiuB,aAAYjE,EAAStmB,EAAQwqB,cAAclrB,QAAShD,EAAQ0D,GAE5D25G,EAA4BtzG,EAAOigB,EAAStmB,EAAS1D,EACzD,C,iGCZA,qBACIm1B,EACAsJ,EACArS,G,MAEK+I,EAAiB/I,0BAClB+I,EAAiB/I,wBAA0B,CAAC,GAE3C+I,EAAiB/I,wBAAwBqS,KAC1CtJ,EAAiB/I,wBAAwBqS,GAAS,IAGP,QAA/C,EAAAtJ,EAAiB/I,wBAAwBqS,UAAM,SAAEvoC,KAAKk2B,EAC1D,C,8GCdA,kCACIr7B,EACAkD,EACAspH,GAEA,IAAMC,EACoB,mBAAfD,EACDA,EACA,SAAChxH,GAAkB,OAACgxH,EAAchxH,EAAQ,IAAvB,EAC7B,GAAKwE,EAAIkD,GAEF,CACH,IAAM,EAAmBlD,EAAIkD,GAC7BlD,EAAIkD,GAAQ,SAAC1H,EAAeqZ,GACxB,IAAM63G,EACyB,mBAApB,EACD,EAAiBlxH,EAAOqZ,KACxB,GACArZ,EAEV,OAAKkxH,EAGMD,EAAQC,EAAI73G,GAFZ,IAIf,C,MAfA7U,EAAIkD,GAAQupH,CAiBpB,C,4ICpCA,WACA,WAqBME,EAAe,SAAC19G,UACXA,EAAOW,UAClB,EAKA,2BACI4D,EACAylB,EACAtmB,EACAi6G,EACAp0D,EACAx/C,EACA6zG,QAAA,IAAAA,IAAAA,EAAA,IAEA,IAAMv5G,GAAkC,IAAAC,iBAAgBC,GAMxD,IALA,IAAA0pB,aAAYjE,EAAStmB,EAAQwqB,cAAcm6B,UAAWhkD,EAASrE,OAAQ0D,IACvE,IAAAuqB,aAAYjE,EAAS4zF,EAAkB9mH,OAAO4mH,GAAer5G,EAASrE,OAAQ0D,GAI1Ei6G,EAAYp0D,EAAW3mD,OAAOxW,OAC9B,KAAOuxH,GAAap0D,EAAW3mD,OAAOxW,QAClCm9D,EAAW3mD,OAAO1M,KAAKmO,QAG3BklD,EAAW3mD,OAAO/M,OAAO8nH,EAAWp0D,EAAW3mD,OAAOxW,OAAS,GAC/Dm9D,EAAW3mD,OAAO+6G,EAAY,GAAKt5G,EAGvCklD,EAAWkL,WAAa1qD,CAC5B,EAKA,6BACIrG,EACAsmB,EACAjgB,EACAywG,EACAhF,EACAqI,GAEA,IAAMt0D,EAAa7lD,EAAQ6lD,WACrBnlD,EAAYmlD,EAAW3mD,OAAO2mD,EAAW3mD,OAAOxW,OAAS,GAC3DouH,GAAsBp2G,IACtB,IAAAK,oBAAmBL,GAAW,SAAA/C,GAAY,OAAAhV,OAAO0gB,OAAO,CAAC,EAAG1L,EAAUm5G,EAA5B,IAG9C,IAAM13G,GAAW,IAAAiR,gBAAew1C,EAAW3mD,OAAQc,EAAQ0B,eAU3D,IARA,IAAA6oB,aAAYjE,EAAStmB,EAAQwqB,cAAcC,eAAgBzqB,EAAQ0B,cAAe1B,IAClF,IAAAuqB,aAAYjE,EAAStmB,EAAQwqB,cAAcwmC,gBAAiB5xD,EAAS9C,OAAQ0D,IAC7E,IAAAuqB,aACIjE,EACA,CAAC,EAAAurF,+BAAgCuI,GACjCh7G,EAAS9C,OACT0D,GAEA8xG,EAAe,CACf,IAAMx1G,GAAM,iBAAmC0D,EAAQ0B,gBACvD,IAAA6oB,aAAYunF,EAAe9xG,EAAQwqB,cAAcC,eAAgBnuB,EAAQ0D,GACzEZ,EAAS2F,aAAazI,OAASA,C,CAGnC69G,SAAAA,EAA2B/6G,GAE3BY,EAAQusD,kBAAkB5kD,MAAMvI,EAAUknB,EAAStmB,IACnD,IAAA4I,UAASvC,EAAOjH,EACpB,EAEA,IAAMg7G,EAAiE,SACnE99G,EACAgqB,EACAgyF,EACA7xD,IAEK,IAAAx5B,iBAAgB3G,EAAS,OAC1B39B,OAAOsF,KAAKw4D,GAAcv4D,SAAQ,SAAAmsH,GAC9B,IAAMnzH,EAAMmzH,EACNvtD,EAAYutD,EAEP,WAAPnzH,GACqBoP,MAArBgG,EAAOwwD,IACPxwD,EAAOwwD,IAAcrG,EAAav/D,WAE3BoV,EAAOwwD,EAEtB,GAER,C,iGC7GA,qBAA0BxmC,GACtB,IAAM13B,EAAiC,CAAC,EAUxC,QATc03B,aAAO,EAAPA,EAASiC,aAAa,WAAY,IAC1Cn7B,MAAM,KAAKc,SAAQ,SAAA09B,GACrB,IAAMC,EAAaD,EAAKx5B,QAAQ,KAC1B7B,EAAOq7B,EAAKl9B,MAAM,EAAGm9B,GACrBhjC,EAAQ+iC,EAAKl9B,MAAMm9B,EAAa,GAClCt7B,GAAQ1H,IACR+F,EAAO2B,EAAKqT,QAAU/a,EAAM+a,OAEpC,IACOhV,CACX,C,oGCZA,wBACI6iC,EACAsJ,EACA7f,GAEKuW,EAAiBvW,oBAClBuW,EAAiBvW,kBAAoB,CAAC,GAG1CuW,EAAiBvW,kBAAkB6f,GAAS7f,CAChD,C,0GCfA,eACA,WACA,WAaA,aAGI,WACoBpE,EACA+vC,EACRukC,GAFQ,KAAAt0E,OAAAA,EACA,KAAA+vC,QAAAA,EACR,KAAAukC,iBAAAA,EALL,KAAA7uF,UAAoC,IAMxC,CAiDP,OAxCI,YAAA+9G,mBAAA,SACI9xH,EACAkwB,EACA0c,GAHJ,WAKIrjC,KAAK+kB,OAAOC,SAEZ,IAAAtc,wCACI1I,KAAK+kB,QACL,SAACpU,EAAQ4G,EAAiB/F,EAAWuO,EAAG9R,GACpC,IAAMu6G,EAAwC,GAQ9C,SAPoB,IAAAC,gBAChB,EAAKpvB,iBACL7nF,EACA+F,EACAixG,KAIAA,EAAkBrsH,SAAQ,SAAAhE,GAAK,OAACA,EAAEiV,YAAa,CAAhB,KAC/B,IAAAod,YAAW7Z,EAAQla,EAAOwX,GAC1BA,EAAQo1B,mBAAqBA,GACtB,EAIf,GACA1c,EAER,EAKA,YAAA+hG,YAAA,W,QACQ1oH,KAAKwK,YACLxK,KAAKwK,UAAY,KACS,QAA1B,KAAAxK,KAAK80D,SAAQ6zD,qBAAa,iBAElC,EACJ,EAxDA,GAAa,EAAAC,iBAAAA,C,sGCfb,eACA,WACA,WACA,WAkBA,aAUI,WAAoBvvB,EAA2CvkC,GAA3C,KAAAukC,iBAAAA,EAA2C,KAAAvkC,QAAAA,EATvD,KAAAxM,OAAiB,EACjB,KAAAugE,gBAAkB,GAClB,KAAArkE,OAAkC,IAO8C,CA6N5F,OAxNI,YAAAjR,QAAA,WACI,MAAO,QACX,EAMA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAKsoD,QAAUvjC,EAAOyK,iBAAiB84B,MACvCtoD,KAAKwkD,OAAS,IAAI,EAAAokE,iBAAiB7jG,EAAQ/kB,KAAK80D,QAAS90D,KAAKq5F,kBAC9Dr5F,KAAK80D,QAAQg0D,aAAa9oH,KAAKwkD,OACnC,EAKA,YAAA9Q,QAAA,WACI1zC,KAAK80D,QAAQi0D,YACb/oH,KAAKwkD,OAAS,IAClB,EAUA,YAAAjS,2BAAA,SAA2BhX,G,MACvB,SACiB,QAAX,EAAAv7B,KAAKwkD,cAAM,eAAEh6C,YACI,WAAnB+wB,EAAMsE,aACL,IAAAif,mBAAkBvjB,EAAMiB,WACC,SAAtBjB,EAAMiB,SAASrnC,KACO,OAAtBomC,EAAMiB,SAASrnC,KACO,UAAtBomC,EAAMiB,SAASrnC,IAE3B,EAMA,YAAAm9C,cAAA,SAAc/W,GACV,GAAKv7B,KAAKwkD,OAIV,OAAQjpB,EAAMsE,WACV,IAAK,iBACG7/B,KAAKwkD,OAAOh6C,YACR+wB,EAAMsO,QAAU,EAAAriB,aAAakmB,WAC7B1tC,KAAKwkD,OAAOkkE,cAEZ1oH,KAAKgpH,kBAAkBhpH,KAAKwkD,SAGpC,MAEJ,IAAK,UACGxkD,KAAKwkD,OAAOh6C,WACZxK,KAAKipH,oBAAoBjpH,KAAKwkD,OAAQjpB,EAAMiB,UAEhD,MAEJ,IAAK,QACGx8B,KAAKwkD,OAAOh6C,UACZxK,KAAKgpH,kBAAkBhpH,KAAKwkD,QAE5BxkD,KAAKkpH,QAAQlpH,KAAKwkD,OAAQjpB,EAAMiB,UAEpC,MAEJ,IAAK,UACGx8B,KAAKwkD,OAAOh6C,WACZxK,KAAKwkD,OAAOkkE,cAI5B,EAEQ,YAAAO,oBAAR,SAA4BzkE,EAA0BjpB,G,wBAClD,OAAQA,EAAMpmC,KACV,IAAK,YACL,IAAK,aACD,GAAwB,cAApBqvD,EAAOh6C,WAAiD,QAApBg6C,EAAOh6C,UAAqB,CAChE,IAAI2+G,EAA2B,cAAb5tF,EAAMpmC,IAEpBqvD,EAAOz/B,OAAOkE,eAAemf,kBAC7B+gF,GAAeA,GAGY,QAA/B,KAAAnpH,KAAK80D,SAAQs0D,0BAAkB,gBAAGD,EAAc,OAAS,W,CAG7D5tF,EAAMygB,iBACN,MACJ,IAAK,UACL,IAAK,YAESmtE,EAA2B,aAAb5tF,EAAMpmC,IAEF,cAApBqvD,EAAOh6C,YACwB,QAA/B,KAAAxK,KAAK80D,SAAQs0D,0BAAkB,gBACP,QAApB5kE,EAAOh6C,UACD2+G,EACI,UACA,cACJA,EACA,OACA,aAKlB5tF,EAAMygB,iBACN,MACJ,IAAK,SACL,IAAK,WAC8B,QAA/B,KAAAh8C,KAAK80D,SAAQs0D,0BAAkB,gBACd,YAAb7tF,EAAMpmC,IAAoB,WAAa,gBAG3ComC,EAAMygB,iBACN,MACJ,IAAK,OACL,IAAK,MACD,IAAMqtE,EAAUrpH,KAAKsoD,MAAQ/sB,EAAMwpB,QAAUxpB,EAAMupB,QACpB,QAA/B,KAAA9kD,KAAK80D,SAAQs0D,0BAAkB,gBACd,QAAb7tF,EAAMpmC,IACAk0H,EACI,QACA,aACJA,EACA,OACA,aAGV9tF,EAAMygB,iBACN,MACJ,IAAK,SACDwI,EAAOkkE,cACPntF,EAAMygB,iBACN,MAEJ,IAAK,QACL,IAAK,MACoB,QAArB,KAAAh8C,KAAK80D,SAAQw0D,gBAAQ,iBACrB/tF,EAAMygB,iBAGlB,EAEQ,YAAAgtE,kBAAR,SAA0BxkE,GAA1B,YAES,IAAA97C,wCAAuC87C,EAAOz/B,QAAQ,SAAChF,EAAGxS,EAASiE,G,QAC1D+3G,GAAiB,IAAAd,gBACnB,EAAKpvB,iBACL7nF,EACAjE,GACFV,QAAQ,kBAAmB,KACvB28G,EAAiB,EAAKX,gBAe5B,OAZIU,IACEA,EAAe5yH,QAAU6yH,EAAe7yH,QACI,GAA1C4yH,EAAelpH,QAAQmpH,IACtBD,EAAe5yH,OAAS6yH,EAAe7yH,QACM,GAA1C6yH,EAAenpH,QAAQkpH,KAE/B,EAAKV,gBAAkBU,EACU,QAAjC,OAAKz0D,SAAQ20D,4BAAoB,gBAAGF,IAEpC/kE,EAAOkkE,eAGJ,CACX,KAEAlkE,EAAOkkE,aAEf,EAEQ,YAAAQ,QAAR,SAAgB1kE,EAA0BjpB,GAA1C,WAC2B,cAAnBA,EAAMy8D,WAA6Bz8D,EAAMwO,MAAQ/pC,KAAKq5F,mBACtD,IAAA3wF,wCAAuC87C,EAAOz/B,QAAQ,SAAChF,EAAGxS,GACtD,GAAIA,EAAQZ,KAAK2kE,SAAS,EAAK+nB,kBAAmB,CAC9C,IAAMqwB,EAAoBn8G,EAAQZ,KAAKY,EAAQZ,KAAKhW,OAAS,GAE7D,IACK+yH,IACAA,EAAkB73G,SACnB,IAAAyO,eAAcopG,GAChB,CACE,IAAMz0G,EAAYuvC,EAAOz/B,OAAOyE,kBAC1B4E,EACiB,UAAnBnZ,aAAS,EAATA,EAAWb,OAAmBa,EAAUya,MAAMC,UACxC,CACIxxB,KAAM8W,EAAUya,MAAMoV,eACtBzkB,OAAQpL,EAAUya,MAAMqV,aAE5B,KAEN3W,IACA,EAAKy6F,gBAAkB,EAAKxvB,iBAC5B70C,EAAOh6C,UAAY,EAAKsqD,QAAQ60D,UAAU,EAAKd,gBAAiBz6F,G,EAK5E,OAAO,CACX,GAER,EACJ,EAvOA,GAAa,EAAAkuF,aAAAA,C,wGCrBb,eASA,0BACIjjB,EACA7nF,EACA+F,EACAqyG,GAKA,IAHA,IAAI/sH,EAAS,GACT/D,EAAI0Y,EAAUpF,SAAS/L,QAAQkX,GAE5Bze,GAAK,EAAGA,IAAK,CAChB,IAAMyU,EAAUiE,EAAUpF,SAAStT,GAEnC,GAA2B,QAAvByU,EAAQhB,YAAuB,CAC/B1P,EAAS,GACT,K,CAGJ,IAAMyS,EAAQ/B,EAAQZ,KAAK+1B,YAAY22D,GAEvC,GAAI/pF,GAAS,EAAG,CACZzS,EAAS0Q,EAAQZ,KAAKzR,UAAUoU,GAASzS,EAEzC+sH,SAAAA,EAAuBjsH,QACnB2R,EAAQ,GACF,IAAA3I,kBAAiB4G,EAASiE,EAAWlC,EAAO/B,EAAQZ,KAAKhW,QACzD4W,GAGV,K,CAEA1Q,EAAS0Q,EAAQZ,KAAO9P,EAExB+sH,SAAAA,EAAuBjsH,QAAQ4P,E,CAQvC,OAJIzU,EAAI,IACJ+D,EAAS,IAGNA,CACX,C,uGClDA,eAUA,yBAAgBoqB,EAAckqF,EAAgCl6E,GAC1D,IAAKk6E,IAAgBA,EAAYtrF,IAC7B,OAAO,KAGH,IAAAA,EAAoEsrF,EAAW,IAA1EgB,EAA+DhB,EAAW,UAA/DhwD,EAAoDgwD,EAAW,UAApD54F,EAAyC44F,EAAW,MAA7CpiG,EAAkCoiG,EAAW,QAApC33E,EAAyB23E,EAAW,WAAxB9jB,EAAa8jB,EAAW,SACjFt0G,EAASs1G,EACTl7E,EAAS4yF,gBAAgB1X,EAAWtsF,GACpCoR,EAAShQ,cAAcpB,GAmC7B,OAjCItN,GACA1b,EAAO05B,aAAa,QAAShe,GAG7B4oC,IACAtkD,EAAOskD,UAAYA,GAGnBpyC,IAAW,IAAAsG,cAAaxY,EAAQ,kBAChC,IAAAse,eAAcpM,GAAS5S,SAAQ,SAAA2tH,GAC3BjtH,EAAOkS,QAAQ+6G,GAAe/6G,EAAQ+6G,EAC1C,IAGAtwF,IACA,IAAAre,eAAcqe,GAAYr9B,SAAQ,SAAAmxE,GAC9BzwE,EAAO05B,aAAa+2C,EAAU9zC,EAAW8zC,GAC7C,IAGA+f,GACAA,EAASlxF,SAAQ,SAAAyZ,GACb,GAAqB,iBAAVA,EACP/Y,EAAOsqB,YAAY8P,EAASuI,eAAe5pB,SACxC,GAAIA,EAAO,CACd,IAAMm0G,EAAe9iG,EAAcrR,EAAOqhB,GACtC8yF,GACAltH,EAAOsqB,YAAY4iG,E,CAG/B,IAGGltH,CACX,C,0HCxBMmtH,EACK,CACHC,UAAW,YACXC,UAAW,YACXC,QAAS,UACTC,UAaR,SAA6BpvE,GACzB,MAAO,CAACA,EAAEuE,MAAOvE,EAAEyE,MACvB,GAXM4qE,EACK,CACHJ,UAAW,aACXC,UAAW,YACXC,QAAS,WACTC,UAQR,SAA6BpvE,GACzB,IAAIuE,EAAQ,EACRE,EAAQ,EACZ,GAAIzE,EAAEsvE,eAAiBtvE,EAAEsvE,cAAc3zH,OAAS,EAAG,CAC/C,IAAM4zH,EAAQvvE,EAAEsvE,cAAc,GAC9B/qE,EAAQgrE,EAAMhrE,MACdE,EAAQ8qE,EAAM9qE,K,CAElB,MAAO,CAACF,EAAOE,EACnB,GAMA,iBAiBI,WACYy8C,EACAjuF,EACAu8G,EACA11D,EACAhjC,EACR24F,GANJ,WACY,KAAAvuB,QAAAA,EACA,KAAAjuF,QAAAA,EACA,KAAAu8G,SAAAA,EACA,KAAA11D,QAAAA,EACA,KAAAhjC,UAAAA,EArBJ,KAAA44F,MAAgB,EAChB,KAAAC,MAAgB,EAChB,KAAAC,eAAoCrmH,EAkDpC,KAAA46C,YAAc,SAACnE,G,UACnBA,EAAEgB,iBACFhB,EAAE+D,kBACF,EAAK8rE,oBACL,eAA2B,EAAKC,SAASV,UAAUpvE,GAA6B,GAA/E,EAAK0vE,MAAK,KAAE,EAAKC,MAAK,KACvB,EAAKC,UAAoC,QAAxB,OAAK91D,SAAQxW,mBAAW,sBAAG,EAAKrwC,QAAS+sC,EAC9D,EAEQ,KAAAwN,YAAc,SAACxN,G,UACnBA,EAAEgB,iBACI,mBAAiB,EAAK8uE,SAASV,UAAUpvE,GAA6B,GAArEuE,EAAK,KAAEE,EAAK,KACbiyD,GAAUnyD,EAAQ,EAAKmrE,OAAS,EAAK54F,UACrC6/E,GAAUlyD,EAAQ,EAAKkrE,OAAS,EAAK74F,UAEvC,EAAK84F,YACkB,QAAvB,OAAK91D,SAAQy1C,kBAAU,sBAAG,EAAKt8F,QAAS+sC,EAAiB,EAAK4vE,UAAWlZ,EAAQC,MAEpE,QAAb,IAAK6Y,gBAAQ,cAAb,EAAgB,EAAKv8G,QAAS,EAAKiuF,SAE3C,EAEQ,KAAA78C,UAAY,SAACrE,G,UACjBA,EAAEgB,iBACF,EAAK+uE,wBACqB,QAAtB,OAAKj2D,SAAQk2D,iBAAS,sBAAG,EAAK/8G,QAAS+sC,EAAiB,EAAK4vE,cAChD,QAAb,IAAKJ,gBAAQ,cAAb,EAAgB,EAAKv8G,QAAS,EAAKiuF,SAE3C,EAvDIl8F,KAAK8qH,SAAWL,EAAcJ,EAA0BL,EACxD9tB,EAAQv1D,iBAAiB3mC,KAAK8qH,SAASb,UAAWjqH,KAAKm/C,YAC3D,CAsDJ,OAjDI,YAAAzL,QAAA,WACI1zC,KAAKk8F,QAAQt1D,oBAAoB5mC,KAAK8qH,SAASb,UAAWjqH,KAAKm/C,aAC/Dn/C,KAAK+qH,sBACT,EAEA,sBAAW,wBAAS,C,IAApB,WACI,OAAO/qH,KAAK8qH,UAAYT,EAA0B,QAAU,OAChE,E,gCAEQ,YAAAQ,kBAAR,WACI,IAAMvgG,EAAMtqB,KAAKk8F,QAAQ1hE,cACzBlQ,EAAIqc,iBAAiB3mC,KAAK8qH,SAASZ,UAAWlqH,KAAKwoD,aAAa,GAChEl+B,EAAIqc,iBAAiB3mC,KAAK8qH,SAASX,QAASnqH,KAAKq/C,WAAW,EAChE,EAEQ,YAAA0rE,qBAAR,WACI,IAAMzgG,EAAMtqB,KAAKk8F,QAAQ1hE,cACzBlQ,EAAIsc,oBAAoB5mC,KAAK8qH,SAASZ,UAAWlqH,KAAKwoD,aAAa,GACnEl+B,EAAIsc,oBAAoB5mC,KAAK8qH,SAASX,QAASnqH,KAAKq/C,WAAW,EACnE,EA8BJ,EAjFA,GAAa,EAAA24D,kBAAAA,C,2HCnEb,WA4BA,8BACIvjG,EACA02B,QAAA,IAAAA,IAAAA,EAAA,IAEA,IAAMC,EAAQ32B,EACTnZ,KAAI,SAAAi5B,GAAW,WAAA8W,eAAc9W,EAAQ+W,wBAAtB,IACfjqC,OAAO8pC,GACP9+B,QAAO,SAAAkoB,GAAW,QAAEA,CAAF,IAEjB13B,EAAe,CACjB0uC,IAAKl0C,KAAKC,IAAG,MAARD,MAAI,mCAAQ+zC,EAAM9vC,KAAI,SAAArE,GAAK,OAAAA,EAAEs0C,GAAF,MAAM,IACtCC,OAAQn0C,KAAKD,IAAG,MAARC,MAAI,mCAAQ+zC,EAAM9vC,KAAI,SAAArE,GAAK,OAAAA,EAAEu0C,MAAF,MAAS,IAC5ChiC,KAAMnS,KAAKC,IAAG,MAARD,MAAI,mCAAQ+zC,EAAM9vC,KAAI,SAAArE,GAAK,OAAAA,EAAEuS,IAAF,MAAO,IACxCI,MAAOvS,KAAKD,IAAG,MAARC,MAAI,mCAAQ+zC,EAAM9vC,KAAI,SAAArE,GAAK,OAAAA,EAAE2S,KAAF,MAAQ,KAG9C,OAAO/M,EAAO0uC,IAAM1uC,EAAO2uC,QAAU3uC,EAAO2M,KAAO3M,EAAO+M,MAAQ/M,EAAS,IAC/E,C,wGC7CA,eAEA,WAwBMouH,EAAsC,CACxC,EAAA9P,aACA,EAAAC,eACA,EAAAC,kBACA,EAAAC,oBACA,EAAAC,aACA,EAAAC,cACA,EAAAC,aACA,EAAAC,gBACA,EAAAC,kBACA,EAAAC,eACA,EAAAC,kBACA,EAAAC,qBACA,EAAAC,qBACA,EAAAC,mBACA,EAAAC,qBAOJ,aAQI,WAAoBiP,QAAA,IAAAA,IAAAA,EAAA,QAAAA,UAAAA,EAPZ,KAAAnmG,OAAyB,KACzB,KAAAujC,OAAQ,CAMsD,CAuG1E,OAlGI,YAAA/U,QAAA,WACI,MAAO,UACX,EAQA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,EACd/kB,KAAKsoD,QAAUtoD,KAAK+kB,OAAOyK,iBAAiB84B,KAChD,EAOA,YAAA5U,QAAA,WACI1zC,KAAK+kB,OAAS,IAClB,EAUA,YAAAwtB,2BAAA,SAA2BhX,GACvB,MACuB,WAAnBA,EAAMsE,YACLtE,EAAMiB,SAASsoB,SAAWvpB,EAAMiB,SAASqoB,QAAUtpB,EAAMiB,SAASuoB,YACjE/kD,KAAKmrH,gBAAgB5vF,EAE/B,EAQA,YAAA+W,cAAA,SAAc/W,GACV,GAAIv7B,KAAK+kB,QAA6B,WAAnBwW,EAAMsE,UAAwB,CAC7C,IAAMurF,EAAUprH,KAAKmrH,gBAAgB5vF,GAEjC6vF,IACAA,EAAQC,QAAQrrH,KAAK+kB,QACrBwW,EAAMiB,SAASwf,iB,CAG3B,EAEQ,YAAAmvE,gBAAR,SAAwB5vF,GAAxB,WACI,OAAO,IAAA45C,mBAAkB55C,EA5ET,0BA4EiC,SAAAA,GAC7C,IAAMxW,EAAS,EAAKA,OACd,EAAuBwW,EAAMiB,SAA3BsoB,EAAO,UAAEC,EAAO,UACxB,OAAID,GAAWC,EAEJ,KAGPhgC,GACA,EAAKmmG,UAAU7+G,QACX,SAAA++G,GACI,SAAKE,QAAQF,EAAQvjF,cACrB,EAAK0jF,cAAcH,EAAQI,YAAajwF,EAAMiB,SAD9C,IAEN,EAEV,GACJ,EAEQ,YAAA8uF,QAAR,SAAgBzjF,GACZ,OAAQA,GACJ,IAAK,MACD,OAAO7nC,KAAKsoD,MAEhB,IAAK,SACD,OAAQtoD,KAAKsoD,MAEjB,QACI,OAAO,EAEnB,EAEQ,YAAAijE,cAAR,SAAsBC,EAAoCjwF,GAC9C,IAAAupB,EAA8CvpB,EAAK,QAA1CspB,EAAqCtpB,EAAK,OAAlCumB,EAA6BvmB,EAAK,SAAxB2kE,EAAmB3kE,EAAK,MAAjBwpB,EAAYxpB,EAAK,QACrDkwF,EAAazrH,KAAKsoD,MAAQvD,EAAUD,EAK1C,OAHgC,QAA3B0mE,EAAYE,aAAyBD,IAAe5mE,GACzB,OAA3B2mE,EAAYE,aAAwB7mE,IAAW4mE,IAE5B3pE,GAAY0pE,EAAY1pE,UAAY0pE,EAAYtrB,OAASA,CACrF,EACJ,EA/GA,GAAa,EAAAgc,eAAAA,C,mXChDb,IAaWyP,EAbX,WACA,WACA,YAWA,SAAWA,GACP,6BACA,sBACA,cACA,cACA,cACA,cACA,cACA,uBACA,yBACA,uCACA,gCACA,6BACH,CAbD,CAAWA,IAAAA,EAAI,KAoBF,EAAAxQ,aAAgC,CACzCqQ,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,GACL,WAAAjf,YAAWif,EAAQ,CACfgJ,sBAAsB,GAD1B,GAUK,EAAAqtF,eAAkC,CAC3CoQ,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,GACL,WAAAhf,cAAagf,EAAQ,CACjBgJ,sBAAsB,GAD1B,GAUK,EAAAstF,kBAAqC,CAC9CmQ,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,GACL,WAAA/e,iBAAgB+e,EAAQ,CACpBgJ,sBAAsB,GAD1B,GAUK,EAAAutF,oBAAuC,CAChDkQ,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,GAAU,WAAAtd,aAAYsd,EAAZ,GAQV,EAAAw2F,aAAgC,CACzCiQ,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,GAAU,WAAA2e,MAAK3e,EAAL,GAQV,EAAAy2F,cAAiC,CAC1CgQ,YAAa,CACTE,YAAa,MACb5pE,UAAU,EACVo+C,MAAO,GAEXmrB,QAAS,SAAAtmG,GAAU,WAAA2e,MAAK3e,EAAL,EACnB8iB,YAAa,UAQJ,EAAA4zE,aAAgC,CACzC+P,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,GAAU,WAAAmuC,MAAKnuC,EAAL,EACnB8iB,YAAa,UASJ,EAAA8zE,kBAAqC,CAC9C6P,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,GAAU,WAAAmuC,MAAKnuC,EAAL,EACnB8iB,YAAa,OAQJ,EAAA6zE,gBAAmC,CAC5C8P,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,GAAU,WAAAmuC,MAAKnuC,EAAL,GAQV,EAAA62F,eAAkC,CAC3C4P,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,KAEXmrB,QAAS,SAAAtmG,GAAU,WAAAnf,cAAamf,EAAb,GAQV,EAAA82F,kBAAqC,CAC9C2P,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,KAEXmrB,QAAS,SAAAtmG,GAAU,WAAAlf,iBAAgBkf,EAAhB,GAQV,EAAA+2F,qBAAwC,CACjD0P,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,KAEXmrB,QAAS,SAAAtmG,GAAU,WAAAve,gBAAeue,EAAQ,WAAvB,GAQV,EAAAg3F,qBAAwC,CACjDyP,YAAa,CACTE,YAAa,OACb5pE,UAAU,EACVo+C,MAAO,KAEXmrB,QAAS,SAAAtmG,GAAU,WAAAve,gBAAeue,EAAQ,WAAvB,GAQV,EAAAi3F,mBAAsC,CAC/CwP,YAAa,CACTE,YAAa,MACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,IACL,IAAA6mG,+BAA8B7mG,EAAQ,SAC1C,EACA8iB,YAAa,UAQJ,EAAAo0E,oBAAuC,CAChDuP,YAAa,CACTE,YAAa,MACb5pE,UAAU,EACVo+C,MAAO,IAEXmrB,QAAS,SAAAtmG,IACL,IAAA6mG,+BAA8B7mG,EAAQ,UAC1C,EACA8iB,YAAa,S,uHC9PjB,eACA,WAMA,yCAA8C9iB,EAAiB9D,GAC3D8D,EAAOE,oBAAmB,SAACxuB,EAAOwX,GAC9B,IAAMZ,GAAW,IAAA0R,0BAAyBtoB,GAE1C,SACI4W,GACgC,aAAhCA,EAASzC,OAAO,GAAGH,WAC2B,mBAA9C4C,EAASzC,OAAO,GAAGwB,SAAS,GAAGG,eAE/B,IAAAvD,qBAAoBvS,EAAOwqB,OAAW1c,EAAsB0J,GACrD,GAGf,GACJ,C,wHCrBA,WACA,WAiBA,aAeI,WACY49G,EACAC,EACAC,EACAn8E,GAJZ,gBAIY,IAAAA,IAAAA,EAAA,GAHA,KAAAi8E,wBAAAA,EACA,KAAAC,qBAAAA,EACA,KAAAC,gBAAAA,EACA,KAAAn8E,cAAAA,EAlBJ,KAAA7qB,OAAyB,KACzB,KAAAinG,oBAA2C,KAC3C,KAAAC,aAA0D,KAC1D,KAAAC,YAAkC,KAsClC,KAAAC,WAAa,SAAC,G,IACZC,EAD2B,gBAE3BC,EAF0C,iBAI5C,IAAAh3G,cAAa+2G,EAAmB,kBAChC,IAAA/2G,cAAag3G,EAAmB,iBAChC,EAAKH,cACJ,EAAKA,YAAYI,eAAeF,KAChCC,EAAkBj3G,SAASg3G,IAE5B,EAAKG,eAAe,KAE5B,EAgCQ,KAAA/jE,YAAc,SAACjtB,G,QACbyf,EAAIzf,EACJixF,EAA0B,QAAX,IAAKznG,cAAM,eAAEiC,cAAciL,YAEhD,KAAI+oB,EAAEyxE,QAAU,IAAMD,EAAtB,CAIA,EAAKE,mBAEL,IAAMv0H,EAAI6iD,EAAEuE,MAAQitE,EAAaG,QAC3Bv0H,EAAI4iD,EAAEyE,MAAQ+sE,EAAaI,QAC7BC,EAAqC,KAGzC,GAAI,EAAKZ,aACL,IAAK,IAAInzH,EAAI,EAAKmzH,aAAat1H,OAAS,EAAGmC,GAAK,EAAGA,IAAK,CACpD,IAAMkwC,EAAQ,EAAKijF,aAAanzH,GACxBwxC,EAAStB,EAAK,KAEtB,GACI7wC,GAAKmyC,EAAK9gC,KAhHD,IAiHTrR,GAAKmyC,EAAK1gC,MAjHD,IAkHTxR,GAAKkyC,EAAKiB,IAlHD,IAmHTnzC,GAAKkyC,EAAKkB,OAnHD,GAoHX,CACEqhF,EAAe7jF,EACf,K,EAKZ,EAAKujF,eAAeM,EAAc7xE,GAClB,QAAhB,IAAKkxE,mBAAW,SAAE1jE,YAAYrwD,EAAGC,E,CACrC,EAmCQ,KAAA00H,qBAAuB,WAC3B,EAAKb,aAAe,IACxB,CAzIG,CAiKP,OA5JI,YAAA14E,QAAA,WACI,MAAO,WACX,EAMA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,EACd/kB,KAAKgsH,oBAAsBhsH,KAAK+kB,OAAOohB,eAAe,CAClDmkB,UAAW,CAAE/jB,eAAgBvmC,KAAKwoD,eAEdxoD,KAAK+kB,OAAO0kC,qBACpB9iB,iBAAiB,WAAY3mC,KAAKmsH,WACtD,EAmBA,YAAAz4E,QAAA,W,QACUjJ,EAA6B,QAAX,EAAAzqC,KAAK+kB,cAAM,eAAE0kC,qBACrChf,SAAAA,EAAiB7D,oBAAoB,WAAY5mC,KAAKmsH,YAC9B,QAAxB,EAAAnsH,KAAKgsH,2BAAmB,cAAxBhsH,MACAA,KAAK8sH,uBACL9sH,KAAK+sH,qBACL/sH,KAAK+kB,OAAS,KACd/kB,KAAKgsH,oBAAsB,KAC3BhsH,KAAK8rH,0BAAuBvnH,CAChC,EAMA,YAAA+tC,cAAA,SAAc0I,GACV,OAAQA,EAAEnb,WACN,IAAK,QACL,IAAK,iBACL,IAAK,SACL,IAAK,cACD7/B,KAAKusH,eAAe,MACpBvsH,KAAK8sH,uBAGjB,EA2CO,YAAAP,eAAP,SAAsBvjF,EAA6BzN,GAS/C,GAPIv7B,KAAKksH,cACJlsH,KAAKksH,YAAY1f,cAClBxjE,aAAK,EAALA,EAAOz3B,QAASvR,KAAKksH,YAAY36G,OAEjCvR,KAAK+sH,sBAGJ/sH,KAAKksH,aAAeljF,GAAShpC,KAAK+kB,QAAUikB,EAAMz3B,MAAMhG,KAAK5U,OAAS,EAAG,CAE1E,IAAMub,EAAYlS,KAAK6rH,wBACjB7rH,KAAK+kB,OAAOiC,cAAc4d,cAAc5kC,KAAK6rH,8BAC7CtnH,EAENvE,KAAKksH,YAAc,IAAI,EAAAc,YACnBhtH,KAAK+kB,OACLikB,EAAMz3B,MACNy3B,EAAMvF,YACNzjC,KAAK8sH,sBACL,IAAAz3G,cAAanD,EAAW,gBAAkBA,OAAY3N,EACtDg3B,aAAK,EAALA,EAAO0xF,cACPjtH,KAAK8rH,qBACL9rH,KAAK+rH,gB,CAGjB,EAMQ,YAAAgB,mBAAR,W,MACoB,QAAhB,EAAA/sH,KAAKksH,mBAAW,SAAEx4E,UAClB1zC,KAAKksH,YAAc,IACvB,EAEQ,YAAAQ,iBAAR,uBACS1sH,KAAKisH,cAAgBjsH,KAAK+kB,SAC3B/kB,KAAKisH,aAAe,GAELjsH,KAAK4vC,cAAc5vC,KAAK+kB,OAAOkE,gBACvC9sB,SAAQ,SAAAoV,GACX,IAAM+4B,GAAO,IAAAe,eAAc95B,EAAMA,MAAM+5B,yBAEnChB,GAAQ,EAAK2hF,cACb,EAAKA,aAAaxrH,MAAK,EAAD,8BACf8Q,GAAK,CACR+4B,KAAI,IAGhB,IAER,EACJ,EArLA,GAuLA,SAAS4iF,EAAqB17F,GAC1B,OAAOA,EACFizB,cAAc,SACdp4C,QAAO,SAAAkF,GAAS,OAAAA,EAAM4pB,iBAAN,IAChB7/B,KAAI,SAAAiW,GAAS,OACVA,MAAK,EACLkyB,YAAa,KAFH,GAItB,CA/La,EAAAu3E,gBAAAA,C,qGClBb,IAaWmS,EAbX,WACA,WACA,WACA,WACA,WACA,WACA,YAOA,SAAWA,GACP,iBACA,kBACH,CAHD,CAAWA,IAAAA,EAAW,KAiCtB,iBAuBI,WACYpoG,EACQxT,EACAkyB,EACRupB,EACAogE,EACA36E,EACAq5E,EACAC,GARZ,I,EAAA,OACY,KAAAhnG,OAAAA,EACQ,KAAAxT,MAAAA,EACA,KAAAkyB,YAAAA,EACR,KAAAupB,UAAAA,EACA,KAAAogE,gBAAAA,EACA,KAAA36E,WAAAA,EACA,KAAAq5E,qBAAAA,EACA,KAAAC,gBAAAA,EA7BJ,KAAAsB,mBAA8C,KAC9C,KAAAC,iBAA4C,KAG5C,KAAAC,kBAA6C,KAC7C,KAAAC,gBAA2C,KAG3C,KAAAC,aAAwC,KAGxC,KAAAC,WAAsC,KAGtC,KAAAC,oBAA+C,KAC/C,KAAAC,iBAA4C,KAG5C,KAAAl+F,MAAsB,KAoLtB,KAAAm+F,gBAAkB,SAACC,EAAmCv5F,G,MACpDumB,EAAoC,QAAzB,IAAKgxE,4BAAoB,oBAAzB,EAA4BgC,EAAav5F,GACpD43F,EAAa53F,GAAW,EAAKw5F,cAAcx5F,GAKjD,OAJI43F,GACA53F,EAAQoS,iBAAiB,WAAYwlF,GAGlC,WACHrxE,SAAAA,IACIqxE,GACA53F,EAAQqS,oBAAoB,WAAYulF,EAEhD,CACJ,EA4HQ,KAAA6B,gBAAkB,WAYtB,OAXA,EAAKjpG,OAAOC,QAER,EAAK0K,QACL,EAAK3K,OAAO8K,gBAAgB,CAAEzb,KAAM,QAASsb,MAAO,EAAKA,MAAOI,YAAY,IAC5E,EAAKJ,MAAQ,MAGjB,EAAK3K,OAAOsC,eACZ,EAAK2lC,YACL,EAAKihE,oBAAqB,GAEnB,CACX,EAEQ,KAAAC,mBAAqB,WACzB,EAAKD,oBAAqB,EAC1B,EAAKE,eACT,EAEQ,KAAAC,kBAAoB,WACxB,EAAKH,oBAAqB,EAC1B,EAAKI,sBACL,EAAKF,eACT,EAEQ,KAAAG,iBAAmB,WACvB,EAAKC,oBACL,EAAKN,oBAAqB,EAC1B,EAAKI,sBACL,EAAKG,uBACL,EAAKC,sBACL,EAAKC,sBACT,EAcQ,KAAAC,eAAiB,SAACC,GAItB,OAHIA,GACA,EAAKC,oBAEF,EAAKb,iBAChB,EAEQ,KAAAO,kBAAoB,WACxB,EAAKxpG,OAAOkiB,eAAe,EAAKxD,YACpC,EAEQ,KAAAqrF,cAAgB,WACpB,EAAKT,sBACL,EAAKL,iBACT,EAMO,KAAA1E,SAAW,SAAC/3G,G,QAGf,GAFA,EAAKwT,OAAOC,QAERzT,EAAO,CACP,IAAM88B,GAAc,IAAAkB,iBAAgBh+B,GAC9B0D,EAA4B,CAC9B1D,MAAOA,EACPuQ,SAAU,EACVf,YAAa,EACbgB,QAASssB,EAAY13C,OAAS,EAC9BqrB,YAAmC,QAAtB,EAAc,QAAd,EAAAqsB,EAAY,UAAE,eAAE13C,cAAM,QAAI,GAAK,EAC5Cyd,KAAM,SAGV,EAAK2Q,OAAO8K,gBAAgB5a,E,CAEpC,EAEQ,KAAA84G,cAAgB,SAACv1B,GACrB,OAAO,SAACkU,GAEAlU,GACAkU,EAAGqiB,eAAiBv2B,IACpB,IAAAnjF,cAAa,EAAKo9B,WAAoB,kBACtC,IAAAp9B,cAAaq3F,EAAGqiB,cAAuB,iBACrC,EAAKt8E,YAAci6D,EAAGqiB,gBACvB,EAAKviB,aAEN,EAAK94D,SAEb,CACJ,EAlZI1zC,KAAK+tG,MAA+E,QAAvC,QAAhC,EAAAhpF,EAAOiC,cAAciL,mBAAW,eAAEC,iBAAiB3gB,GAAO/G,WACvExK,KAAKgvH,oBACLhvH,KAAKiuH,oBAAqB,CAC9B,CAoZJ,OAlZI,YAAAv6E,QAAA,WACI1zC,KAAKquH,sBACLruH,KAAKyuH,sBACLzuH,KAAKwuH,uBACLxuH,KAAK6uH,oBACL7uH,KAAK0uH,sBACT,EAEA,YAAAliB,UAAA,WACI,OAAOxsG,KAAKiuH,kBAChB,EAEA,YAAA3B,eAAA,SAAenuH,GACX,MAAO,CACH6B,KAAKytH,aACLztH,KAAK0tH,WACL1tH,KAAKqtH,mBACLrtH,KAAKstH,iBACLttH,KAAKutH,kBACLvtH,KAAKwtH,gBACLxtH,KAAK2tH,oBACL3tH,KAAK4tH,kBAEJvhH,QAAO,SAAAmsF,GAAW,SAAEA,aAAO,EAAPA,EAAS76D,IAAX,IAClBrwB,MAAK,SAAAkrF,GAAW,OAAAA,aAAO,EAAPA,EAAS76D,MAAOx/B,IAASq6F,aAAO,EAAPA,EAAS76D,MAAO66D,EAAQ76D,IAAIvoB,SAASjX,EAA9D,GACzB,EAIO,YAAAqqD,YAAP,SAAmBrwD,EAAWC,G,MAEpB62H,GAAY,IAAA5jF,eAAcrrC,KAAKuR,MAAM+5B,yBAE3C,GAAK2jF,EAAL,CAkBA,IAbA,IAAMC,EACF92H,GAAK62H,EAAU1jF,IA/GG,EAgHZ,EACAvrC,KAAK+tG,MACL51G,GAAK82H,EAAUrlH,MAlHH,EAmHR,OACArF,EACJpM,GAAK82H,EAAUzlH,KArHH,EAsHZ,OACAjF,EACJ4qH,EAAkBD,EAAY,EAAI,EAG/Bp2H,EAAI,EAAGA,EAAIkH,KAAKuR,MAAMhG,KAAK5U,OAAQmC,IAAK,CAG7C,IAFA,IAAMwnE,EAAKtgE,KAAKuR,MAAMhG,KAAKzS,GACvBiqB,EAAI,EACDA,EAAIu9C,EAAG70D,MAAM9U,OAAQosB,IAAK,CAC7B,IAAMsoC,EAAKiV,EAAG70D,MAAMsX,GACdqsG,GAAS,IAAA/jF,eAAcggB,EAAG/f,yBAEhC,GAAK8jF,GAAWH,EAAhB,CAMA,IAAMI,EAAiBj3H,GAAKg3H,EAAO5jF,OAC7B8jF,EAAgBtvH,KAAK+tG,MACrB51G,GAAKi3H,EAAOxlH,MA1IJ,EA0IoCulH,EAC5Ch3H,GAAKi3H,EAAOxlH,MACZ2lH,EAAevvH,KAAK+tG,MACpB51G,GAAKi3H,EAAO5lH,KACZrR,GAAKi3H,EAAO5lH,KA9IJ,EA8ImC2lH,EAEjD,GAAIE,GAAkBC,GAAiBC,EAAc,CACjD,GAAU,IAANz2H,GAAwB,GAAbo2H,EAA8B,CACzC,IAAMvlH,GAAUylH,EAAO5lH,KAAO4lH,EAAOxlH,OAAS,EACxC4lH,EAAgBxvH,KAAK+tG,MAAQ51G,EAAIwR,EAASxR,EAAIwR,GACnD3J,KAAKyvH,kBAAkB,0BACpBzvH,KAAK0vH,cACDF,EAAgBnkE,EAAKiV,EAAG70D,MAAMsX,EAAI,IAClC,E,MAEL,GAAU,IAANA,GAAwB,GAAbmsG,EAA+B,CACjD,IAAMS,EAAgC,QAAtB,EAAA3vH,KAAKuR,MAAMhG,KAAKzS,EAAI,UAAE,eAAE2S,MAAM,GACxCmkH,EAAcD,GACd,IAAAtkF,eAAcskF,EAAQrkF,yBACtB,KAEAukF,EAAsBD,EAEtB5vH,KAAK+tG,MACL6hB,EAAYhmH,QAAUwlH,EAAOxlH,MAC7BgmH,EAAYpmH,OAAS4lH,EAAO5lH,KAH5B,MAKLxJ,KAAKyvH,kBAAkB,4BACpBzvH,KAAK0vH,cACDt3H,GAAKg3H,EAAO7jF,IAAM6jF,EAAO5jF,QAAU,GAAKqkF,EAClCF,EACAtkE,GACN,E,MAGRrrD,KAAK0vH,cAAc,OAGtB1vH,KAAKyvH,kBAAkB,gBAAkBzvH,KAAK8vH,cAAczkE,GAG7D,K,GAIR,GAAItoC,EAAIu9C,EAAG70D,MAAM9U,OACb,K,CAIS,GAAbu4H,GACClvH,KAAKyvH,kBAAkB,wBACpBzvH,KAAK+vH,sBAAqB,GACV,GAAbb,GACNlvH,KAAKyvH,kBAAkB,qBACpBzvH,KAAK+vH,sBAAqB,GAE9B/vH,KAAK+vH,qBAAqB,MAI9B/vH,KAAKgvH,mB,CACT,EAEQ,YAAAA,kBAAR,WACI,IAAMgB,EAAkBhwH,KAAKyvH,kBAAkB,iBACzCQ,EAAkBjwH,KAAKyvH,kBAAkB,cAC1CzvH,KAAK0tH,YAAgBsC,GAAmBC,IACzCjwH,KAAK0tH,YAAa,IAAAwC,kBACdlwH,KAAKuR,MACLvR,KAAK+kB,OACL/kB,KAAK+tG,MACLiiB,EAAkB,WAAO,EAAIhwH,KAAKspH,SAClCtpH,KAAKsuH,iBACLtuH,KAAK2uH,eACL3uH,KAAKyyC,WACLzyC,KAAKotH,gBACLptH,KAAK6tH,gBACLoC,IAIHjwH,KAAKytH,cAAiBztH,KAAKyvH,kBAAkB,kBAC9CzvH,KAAKytH,cAAe,IAAA0C,oBAChBnwH,KAAKuR,MACLvR,KAAK+kB,OACL/kB,KAAK+tG,MACL/tG,KAAKkuH,mBACLluH,KAAKguH,gBACLhuH,KAAKyyC,WACLzyC,KAAKotH,gBACLptH,KAAK8rH,sBAGjB,EAiBQ,YAAAgE,cAAR,SAAsBzkE,GACdrrD,KAAKutH,mBAAqBvtH,KAAKutH,kBAAkBpvH,MAAQktD,GACzDrrD,KAAKyuH,uBAGJzuH,KAAKutH,mBAAqBliE,IAC3BrrD,KAAKutH,mBAAoB,IAAA6C,mBACrBpwH,KAAK+kB,OACLsmC,EACArrD,KAAKuR,MACLvR,KAAK+tG,OACL,EACA/tG,KAAKouH,kBACLpuH,KAAKguH,gBACLhuH,KAAKotH,gBACLptH,KAAK8rH,sBAET9rH,KAAKwtH,iBAAkB,IAAA4C,mBACnBpwH,KAAK+kB,OACLsmC,EACArrD,KAAKuR,MACLvR,KAAK+tG,OACL,EACA/tG,KAAKouH,kBACLpuH,KAAKguH,gBACLhuH,KAAKotH,gBACLptH,KAAK8rH,sBAGjB,EAMQ,YAAA4D,cAAR,SAAsBrkE,EAAiCglE,GACnD,IAAMC,EAAWD,EAAerwH,KAAKqtH,mBAAqBrtH,KAAKstH,iBAK/D,IAJW,OAAPjiE,GAAgBilE,GAAYA,EAASnyH,MAAQktD,IAC7CrrD,KAAKwuH,wBAGJxuH,KAAKqtH,qBAAuBrtH,KAAKstH,kBAAoBjiE,EAAI,CAC1D,IAAMklE,GAAc,IAAAC,qBAChBxwH,KAAK+kB,OACLsmC,EACArrD,KAAKuR,MACLvR,KAAK+tG,QACHsiB,EACFrwH,KAAKuuH,kBACLvuH,KAAK8uH,cACL9uH,KAAKotH,gBACLptH,KAAK6tH,iBAELwC,EACArwH,KAAKqtH,mBAAqBkD,EAE1BvwH,KAAKstH,iBAAmBiD,C,CAGpC,EAEQ,YAAAR,qBAAR,SAA6BU,GACH,OAAlBA,GAA2BzwH,KAAK4tH,kBAAqB5tH,KAAK2tH,oBAS1D3tH,KAAK0uH,uBARL1uH,KAAK4tH,kBAAmB,IAAA8C,8BACpB1wH,KAAK+kB,OACL/kB,KAAKuR,QACHk/G,EACFzwH,KAAKotH,gBACLptH,KAAK6tH,gBAKjB,EAEQ,YAAAQ,oBAAR,WACQruH,KAAKytH,gBACL,IAAAkD,yBAAwB3wH,KAAKytH,cAC7BztH,KAAKytH,aAAe,KAE5B,EAEQ,YAAAe,qBAAR,WACQxuH,KAAKqtH,sBACL,IAAAsD,yBAAwB3wH,KAAKqtH,oBAC7BrtH,KAAKqtH,mBAAqB,MAE1BrtH,KAAKstH,oBACL,IAAAqD,yBAAwB3wH,KAAKstH,kBAC7BttH,KAAKstH,iBAAmB,KAEhC,EAEQ,YAAAoB,qBAAR,WACQ1uH,KAAK2tH,uBACL,IAAAgD,yBAAwB3wH,KAAK2tH,qBAC7B3tH,KAAK2tH,oBAAsB,MAE3B3tH,KAAK4tH,oBACL,IAAA+C,yBAAwB3wH,KAAK4tH,kBAC7B5tH,KAAK4tH,iBAAmB,KAEhC,EAEQ,YAAAa,oBAAR,WACQzuH,KAAKutH,qBACL,IAAAoD,yBAAwB3wH,KAAKutH,mBAC7BvtH,KAAKutH,kBAAoB,MAEzBvtH,KAAKwtH,mBACL,IAAAmD,yBAAwB3wH,KAAKwtH,iBAC7BxtH,KAAKwtH,gBAAkB,KAE/B,EAEQ,YAAAqB,kBAAR,WACQ7uH,KAAK0tH,cACL,IAAAiD,yBAAwB3wH,KAAK0tH,YAC7B1tH,KAAK0tH,WAAa,KAE1B,EAqCQ,YAAAS,cAAR,WACInuH,KAAKuuH,oBACLvuH,KAAKiuH,oBAAqB,EAC1B,IAAMv+F,EAAQ1vB,KAAK+kB,OAAOyE,kBAEtBkG,GAAuB,SAAdA,EAAMtb,OACfpU,KAAK0vB,MAAQA,EAAMA,OAGvB1vB,KAAK+kB,OAAOsC,cAChB,EAuDQ,YAAAooG,kBAAR,SAA0Bj3B,G,MACtB,OAA2B,QAApB,EAAAx4F,KAAK+rH,uBAAe,eAAE9wF,SAASu9D,EAC1C,EACJ,EAxbA,GAAa,EAAAw0B,YAAAA,C,kOC9Cb,WACA,WACA,WAEA,WAea,EAAA4D,sBAAwB,oBAIxB,EAAAC,oBAAsB,kBAKnC,6BACI9rG,EACAsmC,EACA95C,EACAw8F,EACAsiB,EACAS,EACAC,EACA3D,EACAtB,GAEA,IAAM70F,EAAWo0B,EAAG7wB,cACdw2F,EAAoB,CACtBnrG,IAAK,MACLtN,MAAO,6BAA4B83G,EAAe,MAAQ,OAAK,8BAE7Dv+F,EAAY/M,EAAOkE,eAAe8I,qBAElC4L,GAAM,IAAA1W,eAAc+pG,EAAmB/5F,IAE5Cm2F,GAAmBn2F,EAASmB,MAAMjR,YAAYwW,GAE/C,IAAM1vB,EAA8B,CAChC8W,OAAM,EACNsmC,GAAE,EACF95C,MAAK,EACLw8F,MAAK,EACLj8E,UAAS,EACTg/F,QAAO,EACP1hE,eAAe,IAAAvhD,oBAAmB0D,EAAMgH,MAAMD,QAE5C24G,EAAcZ,EAAea,EAAwBC,EAoB3D,OAnBAF,EAAYhjH,EAAS0vB,GAmBd,CAAEx/B,KAAMktD,EAAI1tB,IAAG,EAAEyzF,eAVD,IAAIC,EACvB1zF,EACA1vB,EACAgjH,EAV0E,CAC1E3yE,YAAW,EAEXisD,WAAY8lB,EAAeiB,EAAuBC,EAClDvG,UAAW+F,GAQXj/F,EACA/M,EAAOyK,iBAAiBqiC,iBACxBi6D,GAIR,EAEA,kBAGI,WACI5vB,EACAjuF,EACAu8G,EACA11D,EACAhjC,EACA24F,EACAqB,GAPJ,MASI,YAAM5vB,EAASjuF,EAASu8G,EAAU11D,EAAShjC,EAAW24F,IAAY,K,OAClE,EAAK3vE,SAAWgxE,aAAoB,EAApBA,EAAuB,cAAe5vB,G,CAC1D,CAOJ,OArB0B,oBAgBtB,YAAAxoD,QAAA,W,MACiB,QAAb,EAAA1zC,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,cAAWv2C,EAChB,YAAMmvC,QAAO,UACjB,EACJ,EArBA,CAA0B,EAAAskE,mBAsD1B,SAAgB15D,EAAYrwC,EAA6BstB,GAC7C,IAIJroB,EACAs+G,EALInmE,EAAgBp9C,EAAO,GAAnB6iH,EAAY7iH,EAAO,QACzBq8B,GAAO,IAAAe,eAAcggB,EAAG/f,yBAK1BmmF,GAAmB,EAEf1sG,EAAkB9W,EAAO,OAAjBsD,EAAUtD,EAAO,MAG3ByjH,GAAU,IAAAC,qBAAoB5sG,EAAQxT,GAE5C,GAAI+4B,GAAQonF,EAAS,CACjB,IAAK,IAAIz6H,EAAI,EAAGA,GAAIy6H,aAAO,EAAPA,EAASnmH,KAAK5U,QAAQM,IAAK,CAC3C,IAAK,IAAIc,EAAI,EAAGA,EAAI25H,EAAQnmH,KAAKtU,GAAGwU,MAAM9U,OAAQoB,IAAK,CACnD,IAAM2T,EAAOgmH,EAAQnmH,KAAKtU,GAAGwU,MAAM1T,GAEnC,GAAI2T,EAAKo0D,eAAiBzU,EAEtBn4C,EAAWjc,EACXu6H,EAAcz5H,OACX,GAAgBwM,MAAZ2O,GAAwC3O,MAAfitH,EAA0B,CAE1D,GAAK9lH,EAAKo0D,cAIH,CAEH2xD,EAAkB15H,EAClB,K,CAJAy5H,EAAcz5H,C,EAW1B,GAAgBwM,MAAZ2O,EACA,K,CAMR,GAFA49G,SAEiBvsH,IAAb2O,EACA,MAAO,CACHw+G,QAAO,EACPE,aAAcJ,EACdK,WAAYJ,EACZK,UAAW5+G,EACX6+G,gBAAiBL,EAAQnmH,KAAK2H,GAAUkR,OACxC4tG,WAAW,EAAF,iCAAMN,EAAQjuG,SAAM,G,CAKzC,MAAO,CACHiuG,QAAO,EACPE,kBAAcrtH,EACdutH,eAAWvtH,EACXwtH,iBAAkB,EAClBC,UAAW,GACXH,YAAa,EAErB,CAMA,SAAgBP,EACZrjH,EACAstB,EACAqvF,EACAlZ,EACAC,GAEQ,IAAA+f,EAAwC9G,EAAS,QAAxCkH,EAA+BlH,EAAS,UAA7BmH,EAAoBnH,EAAS,gBAGzD,GAAI8G,GAAwBntH,MAAbutH,GAAqDvtH,MAA3BmtH,EAAQnmH,KAAKumH,GAAyB,EAE3E,IAAAznH,aAAYqnH,GAASnmH,KAAKumH,GAAW1tG,QAAU2tG,QAAAA,EAAmB,GAAKpgB,EAQvE,IALA,IAAM9sF,EAAYxtB,KAAKC,IAAIo6H,EAAQnmH,KAAKumH,GAAW1tG,OAAQ,EAAAmxD,+BAGrDhV,EAAWmxD,EAAQnmH,KAAKumH,GAAWrmH,MAEhCoX,EAAM,EAAGA,EAAM09C,EAAS5pE,OAAQksB,IAAO,CAC5C,IAAMwoC,EAAKkV,EAAS19C,GAAKi9C,cAErBzU,IACAA,EAAG9yC,MAAM6L,OAASS,EAAY,KAC9BwmC,EAAG9yC,MAAMy+C,UAAY,a,CAI7B,OAAO,C,CAEP,OAAO,CAEf,CAMA,SAAgBu6D,EACZtjH,EACAstB,EACAqvF,EACAlZ,GAEQ,IAAAngG,EAAiBtD,EAAO,MAAjB8/F,EAAU9/F,EAAO,MACxByjH,EAAiD9G,EAAS,QAAjDgH,EAAwChH,EAAS,aAAnCiH,EAA0BjH,EAAS,WAAvBoH,EAAcpH,EAAS,UAGlE,GAAI8G,GAA2BntH,MAAhBqtH,EAA2B,CACtC,IAAM/3C,GAAe,IAAAxvE,aAAYqnH,GAE3B/kG,EAAS+kF,GAAU3D,GAAS,EAAI,GAEtC,IAAmB,GAAf8jB,EAAkB,CAGlB,IAAMntG,EAAWrtB,KAAKC,IAClB06H,EAAUJ,GAAgBjlG,EAC1B,EAAAsE,8BAEJ4oD,EAAap2D,OAAOmuG,GAAgBltG,C,KACjC,CAEH,IAAMutG,EAAeD,EAAUJ,GAAgBjlG,EACzCulG,EAAmBF,EAAUH,GAAcllG,EACjD,GACIslG,EAAe,EAAAhhG,8BACfihG,EAAmB,EAAAjhG,6BAEnB,OAAO,EAGX4oD,EAAap2D,OAAOmuG,GAAgBK,EACpCp4C,EAAap2D,OAAOouG,GAAcK,C,CAItC,IAAK,IAAI1mH,EAAM,EAAGA,EAAMkmH,EAAQnmH,KAAK5U,OAAQ6U,IAKzC,IAJA,IAAM+0D,EAAWmxD,EAAQnmH,KAAKC,GAAKC,MAC/B0mH,EAAsC,KACtCC,EAAY,EAEPvvG,EAAM,EAAGA,EAAM09C,EAAS5pE,OAAQksB,IAAO,CAC5C,IAAMwoC,EAAKkV,EAAS19C,GAAKi9C,cAErBzU,GACAA,EAAG9yC,MAAMy+C,UAAY,aACrBm7D,EAAS9mE,EACT+mE,EAAYV,EAAQjuG,OAAOZ,IACpBsvG,GAAU5xD,EAAS19C,GAAKL,SAC/B4vG,GAAaV,EAAQjuG,OAAOZ,GACrB09C,EAAS19C,GAAKP,YAErB6vG,EAAS,KACTC,EAAY,GAGZD,IACAA,EAAO55G,MAAMD,MAAQ85G,EAAY,K,CAY7C,OAPInkH,EAAQmhD,cAAgB,IAClB1qC,EAAWzW,EAAQmhD,cAAgBziC,EAAS,KAElDktD,EAAatvE,OAAO+N,MAAQoM,EAC5BnT,EAAMgH,MAAMD,MAAQoM,IAGjB,C,CAEP,OAAO,CAEf,CAEA,SAASwsG,EAAsBjjH,EAA6BiuF,GAChD,IAAA7wC,EAAOp9C,EAAO,GAChBq8B,GAAO,IAAAe,eAAcggB,EAAG/f,yBAC1BhB,IACA4xD,EAAQv0E,GAAK,EAAAipG,sBACb10B,EAAQ3jF,MAAMgzB,IAAMjB,EAAKkB,OA3TN,EA2ToC,KACvD0wD,EAAQ3jF,MAAM/O,KAAO8gC,EAAK9gC,KAAO,KACjC0yF,EAAQ3jF,MAAMD,MAAQgyB,EAAK1gC,MAAQ0gC,EAAK9gC,KAAO,KAC/C0yF,EAAQ3jF,MAAM6L,OAASiuG,MAE/B,CAEA,SAASlB,EAAoBljH,EAA6BiuF,GAC9C,IAAA7wC,EAAcp9C,EAAO,GAAjB8/F,EAAU9/F,EAAO,MACvBq8B,GAAO,IAAAe,eAAcggB,EAAG/f,yBAC1BhB,IACA4xD,EAAQv0E,GAAK,EAAAkpG,oBACb30B,EAAQ3jF,MAAMgzB,IAAMjB,EAAKiB,IAAM,KAC/B2wD,EAAQ3jF,MAAM/O,MAAQukG,EAAQzjE,EAAK9gC,KAAO8gC,EAAK1gC,OAxU5B,EAwU0D,EAAI,KACjFsyF,EAAQ3jF,MAAMD,MAAQ+5G,MACtBn2B,EAAQ3jF,MAAM6L,OAASkmB,EAAKkB,OAASlB,EAAKiB,IAAM,KAExD,CAnNA,gBAwEA,yBAuCA,sB,+GCzOA,mCAAwCitD,G,UAChCA,IACsB,QAAtB,EAAAA,EAAQ44B,sBAAc,SAAE19E,UACxB8kD,EAAQ44B,eAAiB,KACF,QAAvB,EAAW,QAAX,EAAA54B,EAAQ76D,WAAG,eAAEroB,kBAAU,SAAE+gB,YAAYmiE,EAAQ76D,KAC7C66D,EAAQ76D,IAAM,KAEtB,C,kLCrBA,eACA,WACA,WAGA,WAgBa,EAAA20F,uBAAyB,qBAIzB,EAAAC,qBAAuB,mBAKpC,+BACIxtG,EACAsmC,EACA95C,EACAw8F,EACAsiB,EACAmC,EACAC,EACArF,EACAtB,GAEA,IAAMsD,GAAS,IAAA/jF,eAAcggB,EAAG/f,yBAC1BonF,EAAW3tG,EAAOqiB,qBACxB,GAAIgoF,GAAUsD,EAAU,CACpB,IAAMC,EAAevD,EAAO7jF,KAAOmnF,EAASnnF,IAG5C,GAFwB6jF,EAAO5jF,QAAUknF,EAASlnF,QAE3BmnF,EACnB,OAAO,KAEX,IAAM1D,EAAY19G,GAAQ,IAAAk6B,oBAAmB,CAACl6B,GAAQ,CAACmhH,IAAa,KAEpE,GAAIzD,EAAW,CACX,IAAM,EAAW5jE,EAAG7wB,cACdw2F,EAwHlB,SACIX,EACAhtH,EACA0qG,EACA1jF,GAEA,IAAMuoG,EAAgBvvH,EArKO,QADV,UAmLnB,MAAO,CACHwiB,IAAK,MACLtN,MAdkB,+KAA+Oq6G,EAAa,2CAA2CvoG,EAezTgjE,SAAU,CAZuB,CACjCxnE,IAAK,MACLtN,MAHoB,iEAAiE8R,EAAe,KAK/FgmG,GANWtiB,EAAQ,QAAU,QAOV,wDAAwD6kB,EAAa,8BAA8BA,EAAa,6BAA6BA,EAAa,sBACxK,4DAA4DA,EAAa,6BAA6BA,EAAa,8BAA8BA,EAAa,uBAMlJ,KAE9B,CAhJsCC,CACtBxC,EACAtrG,EAAOgE,aACPglF,EACAhpF,EAAOkE,eAAewmC,YAAY,oBAAsB,SAGtD9xB,GAAM,IAAA1W,eAAc+pG,EAAmB,GAuC7C,OArCIX,GAEA1yF,EAAIhW,GAAK,EAAA2qG,uBACT30F,EAAIplB,MAAM/O,MACNukG,EACMkhB,EAAUrlH,MACVqlH,EAAUzlH,KAAO,IAAqD,KAEhFm0B,EAAIplB,MAAMgzB,IAAS6jF,EAAO5jF,OAAS,EAAC,KACnC7N,EAAI9nB,WAA2B0C,MAAMD,MAClC22G,EAAUrlH,MAAQqlH,EAAUzlH,KAAI,OAGpCm0B,EAAIhW,GAAK,EAAA4qG,qBACT50F,EAAIplB,MAAM/O,MAAUukG,EAAQqhB,EAAO5lH,KAAO,EAAI4lH,EAAOxlH,MAAQ,GAAC,KAE9D+zB,EAAIplB,MAAMgzB,IACN0jF,EAAU1jF,IAAM,GAAqD,KAExE5N,EAAI9nB,WAA2B0C,MAAM6L,OAClC6qG,EAAUzjF,OAASyjF,EAAU1jF,IAAG,OAIvC6hF,GAAmB,EAASh1F,MAAMjR,YAAYwW,GAaxC,CAAEA,IAAG,EAAEyzF,eAXE,IAAI0B,EAChBn1F,EACA0tB,EACA95C,EACA8+G,EACAtrG,EACAytG,EACAC,EACA3G,GAGmC3tH,KAAMktD,E,EAIrD,OAAO,IACX,EAMA,iBAEI,WACY1tB,EACA0tB,EACA95C,EACA8+G,EACAtrG,EACAytG,EACA1D,EACRhD,GARJ,WACY,KAAAnuF,IAAAA,EACA,KAAA0tB,GAAAA,EACA,KAAA95C,MAAAA,EACA,KAAA8+G,aAAAA,EACA,KAAAtrG,OAAAA,EACA,KAAAytG,eAAAA,EACA,KAAA1D,cAAAA,EAgBJ,KAAAiE,SAAW,WAEf,IAAMvB,EAAc,EAAKnmE,GAAGhb,UACtB7kC,EACF,EAAK6/C,GAAGpvB,gBAAiB,IAAAf,iBAAgB,EAAKmwB,GAAGpvB,cAAe,MAC1D,EAAKovB,GAAGpvB,mBACR13B,EACJ2O,EAAW1H,GAAOA,EAAI0H,SAEV3O,OAAdiH,aAAG,EAAHA,EAAKC,QAAkClH,MAAZ2O,IAI/B,EAAKs/G,kBAGL,IAAAlqH,6BACI,EAAKyc,OACL,mBACA,SAAAsJ,GACI,EAAKgiG,cACC,IAAAnoH,gBAAemmB,EAAY,gBAC3B,IAAAlmB,mBAAkBkmB,EAAY,cACxC,GACA,CACIja,KAAM,QACN2M,YAAaywG,EACb1vG,SAAU5O,EACV8O,WAAYwvG,EACZzvG,QAAS7O,EACT3B,MAAO,EAAKA,QAIpB,EAAKu9G,gBACT,EAhDI9uH,KAAK29B,IAAIgJ,iBAAiB,QAAS3mC,KAAK+yH,UACxC/yH,KAAK86C,SAAWgxE,aAAoB,EAApBA,EACZuE,EAAe,0BAA4B,wBAC3C1yF,EAER,CA4CJ,OA1CI,YAAA+V,QAAA,W,MACI1zC,KAAK29B,IAAIiJ,oBAAoB,QAAS5mC,KAAK+yH,UAC9B,QAAb,EAAA/yH,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,cAAWv2C,CACpB,EAsCJ,EA7DA,GAAa,EAAAuuH,mBAAAA,C,iLC/Gb,WACA,WACA,WACA,WACA,WAIA,WAoBME,EAAqB,GAId,EAAAC,eAAiB,eAC9B,IAAMC,EAAwB,yBAO9B,4BACI3hH,EACAwT,EACAgpF,EACAolB,EACArC,EACAC,EACAt+E,EACA26E,EACAtB,EACAmE,GAEA,IAAM3lF,GAAO,IAAAe,eAAc95B,EAAM+5B,yBAEjC,IAmHJ,SAA2BvmB,EAAiBulB,EAAmBmI,GAC3D,IAAM2gF,EAAkBruG,EAAOqiB,qBAC/B,IAAI,IAAA/xB,cAAao9B,EAAY,iBAAmB2gF,GAAmB9oF,EAAM,CACrE,IAAM+oF,GAAgB,IAAAhoF,eAAcoH,EAAWnH,yBAE/C,QAAS+nF,GAAiBA,EAAc9nF,KAAOjB,EAAKiB,KAAO6nF,EAAgB7nF,KAAOjB,EAAKiB,G,CAG3F,OAAO,CACX,CA5HS+nF,CAAkBvuG,EAAQulB,EAAMmI,GACjC,OAAO,KAGX,IAAM3gB,EAAY/M,EAAOkE,eAAe8I,qBAClCkF,EAAW1lB,EAAMipB,cAMjBmD,GAAM,IAAA1W,eALc,CACtBpB,IAAK,MACLtN,MAAO,+EAGkC0e,GAE7C0G,EAAIhW,GAAK,EAAAsrG,eACTt1F,EAAIplB,MAAMD,MAAW06G,OACrBr1F,EAAIplB,MAAM6L,OAAY4uG,QAErB5F,GAAmBn2F,EAASmB,MAAMjR,YAAYwW,GAE/C,IAAM1vB,EAA6B,CAC/BsD,MAAK,EACLugB,UAAS,EACTwY,KAAI,EACJyjE,MAAK,EACLhpF,OAAM,EACN4Y,IAAG,EACHw1F,iBAAgB,EAChBrC,QAAO,EACPC,MAAK,EACLd,gBAAe,GAqBnB,OAyDJ,SAAwBhiH,EAA4BiuF,GACxC,IAAA5xD,EAASr8B,EAAO,KACpBq8B,IACA4xD,EAAQ3jF,MAAMgzB,IAASjB,EAAKiB,IAAMynF,EAAkB,KACpD92B,EAAQ3jF,MAAM/O,KAAU8gC,EAAK9gC,KAAOwpH,EAAqB,EAAC,KAElE,CAjFIO,CAAetlH,EAAS0vB,GAkBjB,CAAEx/B,KAAMoT,EAAOosB,IAAG,EAAEyzF,eAhBJ,IAAIoC,EACvB71F,EACA1vB,GACA,WAAO,GACPgiH,EACM,CAAEjF,UAAS,GACX,CACI1sE,YAAW,EACXisD,WAAU,EACVygB,UAAS,GAEnB/8G,EAAQ6jB,UACRg6F,EACA/mG,EAAOyK,iBAAiBqiC,kBAIhC,EA6BA,kBAGI,WACIl0B,EACA1vB,EACAu8G,EAKA11D,EACAhjC,EACAg6F,EACArB,GAXJ,MAaI,YAAM9sF,EAAK1vB,EAASu8G,EAAU11D,EAAShjC,EAAW24F,IAAY,K,OAC9D,EAAK3vE,SAAWgxE,aAAoB,EAApBA,EAAuB,aAAcnuF,G,CACzD,CAOJ,OAzBgC,oBAoB5B,YAAA+V,QAAA,W,MACiB,QAAb,EAAA1zC,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,cAAWv2C,EAChB,YAAMmvC,QAAO,UACjB,EACJ,EAzBA,CAAgC,EAAAskE,mBA8ChC,SAASyb,EAAoB1uG,EAAiBmD,EAAgB9T,G,MAC1D2Q,SAAAA,EAAQsiB,eAAe6rF,EAAuBhrG,EAAyB,QAAjB,aAAa9T,SAAI,QAAI,OAAS,KACxF,CAMA,SAAgBkqC,EAAYrwC,G,MACxBA,EAAQ6iH,UAEA,IAAA/rG,EAAuB9W,EAAO,OAAtBsD,EAAetD,EAAO,MAAf0vB,EAAQ1vB,EAAO,IAEtCwlH,EAAoB1uG,GAAQ,EAAM,QAGlC,IAAM2uG,EAAQniH,EAAM+5B,wBAKd2jF,GAAY,IAAAhoG,eAJQ,CACtBpB,IAAK,MACLtN,MAAO,iEAEwCwM,EAAOiC,eAC1DioG,EAAU12G,MAAMD,MAAWo7G,EAAMp7G,MAAK,KACtC22G,EAAU12G,MAAM6L,OAAYsvG,EAAMtvG,OAAM,KACxC6qG,EAAU12G,MAAMgzB,IAASmoF,EAAMnoF,IAAG,KAClC0jF,EAAU12G,MAAM/O,KAAUkqH,EAAMlqH,KAAI,KACtB,QAAd,EAAAm0B,EAAIroB,kBAAU,SAAE6R,YAAY8nG,GAG5B,IAAM0E,EAAmB5uG,EAAOyE,kBAKhC,MAAO,CACHkoG,SAHY,IAAAC,qBAAoB5sG,EAAQxT,GAIxCoiH,iBAAgB,EAChB1E,UAAS,EAEjB,CAMA,SAAgB1kB,EACZt8F,EACAstB,EACAqvF,GAEQ,IAAAqE,EAAcrE,EAAS,UACvB7lG,EAAW9W,EAAO,OAG1BghH,EAAU12G,MAAMgzB,IAAShQ,EAAMq4F,QAAUZ,EAAkB,KAC3D/D,EAAU12G,MAAM/O,KAAU+xB,EAAMs4F,QAAUb,EAAkB,KAE5D,IAAM5kG,GAAM,IAAA0lG,0BAAyB/uG,EAAQwW,EAAMs4F,QAASt4F,EAAMq4F,SAClE,GAAIxlG,EAAK,CACL,IAAMsB,EAAQ3K,EAAOiC,cAAcmV,cAKnC,OAJAzM,EAAMwV,SAAS9W,EAAIjwB,KAAMiwB,EAAI/N,QAC7BqP,EAAME,UAAS,GAEf7K,EAAO8K,gBAAgB,CAAEzb,KAAM,QAASsb,MAAK,EAAEI,YAAY,KACpD,C,CAEX,OAAO,CACX,CAMA,SAAgBk7F,EACZ/8G,EACAstB,EACAqvF,G,QAEQ7lG,EAAuE9W,EAAO,OAAtEsD,EAA+DtD,EAAO,MAA7C8lH,EAAsC9lH,EAAO,iBAA3BgiH,EAAoBhiH,EAAO,gBAChFsmB,EAAUgH,EAAM5qB,OAQtB,GALAi6G,SAAAA,EAAWqE,UAAUprE,SAGrB4vE,EAAoB1uG,GAAQ,GAExBwP,GAAWtmB,EAAQ0vB,IAInB,OAFAo2F,EAAiBxiH,GACjBtD,EAAQ8iH,OAAM,IACP,EAGP,GACIx/G,EAAM6D,SAASmf,KACdxP,EAAOkE,eAAegxB,eAAe1lB,IACtC07F,EAIA,OAFAlrG,EAAO8K,gBAA2C,QAA3B,EAAA+6F,aAAS,EAATA,EAAW+I,wBAAgB,QAAI,MACtD1lH,EAAQ8iH,OAAM,IACP,EAGX,IAAI,GAA4B,EAG1BjgG,GAAiB,IAAAgjG,0BAAyB/uG,EAAQwW,EAAMs4F,QAASt4F,EAAMq4F,SA6D7E,OA5DI9iG,GAEA,IAAAnoB,mCACIoc,EACA+L,GACA,SAACr6B,EAAOwX,EAAS+lH,G,MAEP,gBAAmB,IAAA1lG,uBAAsB73B,GAAM,GAA9Cw9H,EAAQ,KAAEz2H,EAAI,KACrB,GAAIy2H,EAAU,CACV,IAAM3kH,EAAQ9R,EAAK,GAAGoN,OAAOvK,QAAQ4zH,IACrC,IAAA5pH,aAAY7M,EAAK,IAAIoN,OAAOxK,OAAOkP,EAAO,E,CAG9C,GAAI0kH,IAAMpJ,aAAS,EAATA,EAAW8G,SAAS,CAE1B,IAAMpnG,GAA0C,IAAAC,8BAOhD,GANAD,EAAI1f,OAAOnK,KAAKwzH,QAAAA,GAAY,IAAA5pH,aAAYugH,EAAU8G,UAClD,KAAqB,IAAAlnG,YAAW/zB,GAAO,IAAA4pC,YAAW/V,GAAMrc,EAAS,CAC7Dwc,YAAa,OACbqG,eAAgBkjG,IAGE,CAElB,IAAME,EAA4C,QAA/B,OAAA5lG,uBAAsB73B,GAAO,UAAE,QAAIm0H,EAAU8G,QAChE,GAAIwC,EAAY,CAEZ,IAAMpwG,EAAYowG,EAAW3oH,KAAK,GAAGE,MAAM,GACrCqpC,EAAkBhxB,aAAS,EAATA,EAAWlZ,OAAO,GAE1C,GAAkC,cAA9BkqC,aAAe,EAAfA,EAAiBrqC,WAA0B,CAC3C,IAAMgH,GAAS,IAAAwG,uBAAsBxhB,EAAM8T,SAE3C,IAAAF,aAAYyqC,GAAiB1oC,SAASzO,QAAQ8T,IAC9C,IAAAmF,yBAAwBk+B,IACxB,IAAA58B,cAAazhB,EAAOgb,E,GAIhC,OAAO,C,CAEf,GACA,CAEIujB,kBAAmB,CACf5gB,KAAM,QACN2M,YAAa,EACbe,SAAU,EACVE,WAAY,EACZD,QAAS,EACTxQ,MAAOA,GAEX4T,QAAS,eAKjBJ,EAAO8K,gBAA2C,QAA3B,EAAA+6F,aAAS,EAATA,EAAW+I,wBAAgB,QAAI,MAE1D1lH,EAAQ8iH,OAAM,GACP,CAEf,CAlKA,gBAqCA,eA4BA,a,qLC7PA,WACA,WACA,WACA,WAWMoD,EAAuB,GAIhB,EAAAC,iBAAmB,iBAKhC,8BACI7iH,EACAwT,EACAgpF,EACA+iB,EACAC,EACAt+E,EACA26E,EACAtB,GAIA,IAAKuI,EAAqBtvG,GAFb,IAAAsmB,eAAc95B,EAAM+5B,yBAEOmH,GACpC,OAAO,KAGX,IAAMxb,EAAW1lB,EAAMipB,cACjB1I,EAAY/M,EAAOkE,eAAe8I,qBAClCi/F,EAAoB,CACtBnrG,IAAK,MACLtN,MAAO,6BACHw1F,EAAQ,KAAO,MAAI,yDAIrBpwE,GAAM,IAAA1W,eAAc+pG,EAAmB/5F,GAE7C0G,EAAIhW,GAAK,EAAAysG,iBACTz2F,EAAIplB,MAAMD,MAAW67G,EAAoB,KACzCx2F,EAAIplB,MAAM6L,OAAY+vG,EAAoB,MAEzC/G,GAAmBn2F,EAASmB,MAAMjR,YAAYwW,GAE/C,IAAM1vB,EAA+B,CACjC8/F,MAAK,EACLx8F,MAAK,EACLugB,UAAS,EACTg/F,QAAO,EACPC,MAAK,EACLpzF,IAAG,EACH5Y,OAAM,EACN0tB,WAAU,GAmBd,OAhBA8gF,EAAetlH,EAAS0vB,GAgBjB,CAAEx/B,KAAMoT,EAAOosB,IAAG,EAAEyzF,eAdJ,IAAIkD,EACvB32F,EACA1vB,EACAsmH,EACA,CACIj2E,YAAW,EACXisD,WAAU,EACVygB,UAAS,GAEbl5F,EACA/M,EAAOyK,iBAAiBqiC,iBACxBi6D,GAIR,EAEA,kBAGI,WACI5vB,EACAjuF,EACAu8G,EACA11D,EACAhjC,EACA24F,EACAqB,GAPJ,MASI,YAAM5vB,EAASjuF,EAASu8G,EAAU11D,EAAShjC,EAAW24F,IAAY,K,OAClE,EAAK3vE,SAAWgxE,aAAoB,EAApBA,EAAuB,eAAgB5vB,G,CAC3D,CAOJ,OArB2B,oBAgBvB,YAAAxoD,QAAA,W,MACiB,QAAb,EAAA1zC,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,cAAWv2C,EAChB,YAAMmvC,QAAO,UACjB,EACJ,EArBA,CAA2B,EAAAskE,mBAqD3B,SAAgB15D,EACZrwC,EACAstB,GAEAttB,EAAQ6iH,UAEA,IAAA/rG,EAAkB9W,EAAO,OAAjBsD,EAAUtD,EAAO,MAG3ByjH,GAAU,IAAAC,qBAAoB5sG,EAAQxT,GAGtCgwD,EAAoB,GAC1BmwD,SAAAA,EAASnmH,KAAKpP,SAAQ,SAAAqP,GAClB+1D,EAAQ9gE,KAAK+K,EAAI4Y,OACrB,IACA,IAAMX,EAAmB,GAKzB,OAJAiuG,SAAAA,EAASjuG,OAAOtnB,SAAQ,SAAAmc,GACpBmL,EAAOhjB,KAAK6X,EAChB,IAEO,CACHk8G,aAAcjjH,EAAM+5B,wBACpBomF,QAAO,EACP+C,gBAAiBlzD,QAAAA,EAAW,GAC5BmzD,eAAgBjxG,QAAAA,EAAU,GAElC,CAMA,SAAgB8mF,EACZt8F,EACAstB,EACAqvF,EACAlZ,EACAC,G,QAEQ5D,EAA4B9/F,EAAO,MAA5B6jB,EAAqB7jB,EAAO,UAAjBsD,EAAUtD,EAAO,MACnCumH,EAA2D5J,EAAS,aAAtD6J,EAA6C7J,EAAS,gBAArC8J,EAA4B9J,EAAS,eAArB8G,EAAY9G,EAAS,QAEtE+J,EAAS,EAAOjjB,EAAS8iB,EAAal8G,MAASwZ,GAAai8E,GAAS,EAAI,GACzE6mB,EAAS,EAAOjjB,EAAS6iB,EAAapwG,OAAU0N,EAChD+iG,EAAgBx9H,KAAK+vF,IAAIutC,EAAS,GAAO,KACzCG,EAAgBz9H,KAAK+vF,IAAIwtC,EAAS,GAAO,KAQ/C,GALArjH,EAAMgH,MAAMnN,YAAY,QAAS,MAEjCmG,EAAMgH,MAAMnN,YAAY,SAAU,MAG9BsmH,GAAWA,EAAQnmH,OAASspH,GAAiBC,GAAgB,CAI7D,IAHA,IAAMj7C,GAAe,IAAAxvE,aAAYqnH,GAGxB54H,EAAI,EAAGA,EAAI44H,EAAQnmH,KAAK5U,OAAQmC,IACrC,IAAK,IAAIiqB,EAAI,EAAGA,EAAI2uG,EAAQnmH,KAAKzS,GAAG2S,MAAM9U,OAAQosB,IACjC2uG,EAAQnmH,KAAKzS,GAAG2S,MAAMsX,KAE3B8xG,GAAsB,GAAL/7H,IACjB+gF,EAAap2D,OAAOV,IAAuB,QAAjB,EAAA2xG,EAAe3xG,UAAE,QAAI,GAAK4xG,GAEpDG,GAAsB,GAAL/xG,IACjB82D,EAAatuE,KAAKzS,GAAGsrB,QAA4B,QAAlB,EAAAqwG,EAAgB37H,UAAE,QAAI,GAAK87H,IAO1E,IAAK,IAAIppH,EAAM,EAAGA,EAAM+F,EAAMhG,KAAK5U,OAAQ6U,IAAO,CAC9C,IAAM+0D,EAAWhvD,EAAMhG,KAAKC,GAE5B,GAA6B,GAAzB+0D,EAAS90D,MAAM9U,OAQnB,IAFA,IAAMkuB,EAAYxtB,KAAKC,IAAIo6H,EAAQnmH,KAAKC,GAAK4Y,OAAQ,EAAAmxD,+BAE5C1yD,EAAM,EAAGA,EAAM09C,EAAS90D,MAAM9U,OAAQksB,IAAO,CAClD,IAAMwoC,EAAKkV,EAAS90D,MAAMoX,GAGpB6B,EAAWrtB,KAAKC,IAAIo6H,EAAQjuG,OAAOZ,GAAM,EAAA0yD,+BAE/ClqB,EAAG9yC,MAAMD,MAAQoM,EAAW,KAC5B2mC,EAAG9yC,MAAM6L,OAASS,EAAY,KAC9BwmC,EAAG9yC,MAAMy+C,UAAY,Y,EAG7B,OAAO,C,CAEP,OAAO,CAEf,CAMA,SAAgBg0D,EACZ/8G,EACAstB,EACAqvF,GAEA,OAAI38G,EAAQ8W,OAAO4E,eAIf0qG,EACIpmH,EAAQ8W,QACR,IAAAsmB,eAAcp9B,EAAQsD,MAAM+5B,yBAC5Br9B,EAAQwkC,cAGZxkC,EAAQ0vB,IAAIplB,MAAMw8G,WAAa,UAC/BxB,EAAetlH,EAASA,EAAQ0vB,MAEpC1vB,EAAQ8iH,UAZG,CAcf,CAEA,SAASwC,EAAetlH,EAA8BiuF,GAC1C,IAAA3qF,EAAiBtD,EAAO,MAAjB8/F,EAAU9/F,EAAO,MAC1Bq8B,GAAO,IAAAe,eAAc95B,EAAM+5B,yBAE7BhB,IACA4xD,EAAQ3jF,MAAMgzB,IAASjB,EAAKkB,OAAM,KAClC0wD,EAAQ3jF,MAAM/O,KAAOukG,EACZzjE,EAAK9gC,KAAO2qH,EAAuB,EAAC,KACpC7pF,EAAK1gC,MAAK,KAE3B,CAEA,SAAS2qH,EAAYtmH,EAA8BiuF,GAC/CA,EAAQ3jF,MAAMw8G,WAAa,QAC/B,CAEA,SAASV,EACLtvG,EACAulB,EACAmI,GAEA,IAAM2gF,EAAkBruG,EAAOqiB,qBAC/B,IAAI,IAAA/xB,cAAao9B,EAAY,iBAAmB2gF,GAAmB9oF,EAAM,CACrE,IAAM+oF,GAAgB,IAAAhoF,eAAcoH,EAAWnH,yBAE/C,QACM+nF,GACFA,EAAc7nF,QAAUlB,EAAKkB,QAC7B4nF,EAAgB5nF,QAAUlB,EAAKkB,M,CAIvC,OAAO,CACX,CAhKA,gBAiCA,eAwEA,a,4KCpPA,WACA,WACA,WAwBA,wCACIzmB,EACAxT,EACAk/G,EACArD,EACAtB,G,MAEMxhG,EAAMvF,EAAOiC,cACb8K,EAAY/M,EAAOkE,eAAe8I,qBAElCijG,EAAe1qG,EAAIrD,cAAc,OACvC+tG,EAAaz8G,MAAM6d,QAAU,yCAE7B,IAAM3qB,EAAQglH,EACRh0H,MAAMW,KAAKmU,EAAMhG,MACZjQ,KAAI,SAAAkQ,GAAO,OAAAA,EAAIC,MAAM,EAAV,IACXY,QAAO,SAAAX,GAAQ,OAAAA,CAAA,IACpBjP,MAAMW,MAAkB,QAAb,EAAAmU,EAAMhG,KAAK,UAAE,eAAEE,QAAS,IAEnCigF,EAA4C,GA0ClD,OAxCAjgF,EAAMtP,SAAQ,SAAAuP,GACV,IAAMupH,GAAW,IAAA5pF,eAAc3/B,EAAK4/B,yBACpC,GAAI2pF,EAAU,CACV,IAAMjE,EA6PlB,SAA8B1mF,EAAYmmF,GACtC,IAEMyE,EAAazE,EAAgBnmF,EAAKkB,OAASlB,EAAKiB,IAAMjB,EAAK1gC,MAAQ0gC,EAAK9gC,KAExE2rH,EAAkB99H,KAAKC,IAAI,GAAI49H,EAAaE,IAC5CC,EAAgBH,GAAc,GAAK79H,KAAKD,IAAI89H,EAAa,GAAIC,GAAmB,GAEhFG,GAAgBJ,EAAaG,GAAiB,EAepD,MAAO,CACHxvG,IAAK,MACLtN,MAHkB,qBAZTk4G,EACP,uBAAuB4E,EAAa,aAAY/qF,EAAKiB,IAAM+pF,GAAY,cACnEhrF,EAAK9gC,KAAO,EAVA,GAUiB,KAEjC,UAAU6rH,EAAa,0BAAyB/qF,EAAKiB,IAAM,EAZ3C,GAY4D,cACxEjB,EAAK9gC,KAAO8rH,GAAY,MAOY,6CAJ/B7E,EACT,sTACA,oRAE0F,0BAKpG,CAxRsCoC,CAAqBoC,EAAUxE,GACnD8E,GAAU,IAAAtuG,eAAc+pG,EAAmB1mG,GACjD0qG,EAAa7tG,YAAYouG,GAEzB,IAQMzgE,EAAU,IAAI0gE,EAChBD,EACA9E,EAV2C,CAC3Cl/G,MAAK,EACLugB,UAAS,EACT/M,OAAM,EACN4Y,IAAK43F,EACLE,MAAOhF,GAOP,CACInyE,YAAW,EACXisD,WAAU,EACVygB,UAAS,GAEbl5F,EACAg6F,EACA/mG,EAAOyK,iBAAiBqiC,kBAE5B65B,EAASjrF,KAAKq0D,E,CAEtB,KAECs4D,GAAmB9iG,EAAI8N,MAAMjR,YAAY6tG,GAQnC,CAAEr3F,IAAKq3F,EAAc5D,eANS,CACjC19E,QAAS,WACLg4C,EAASvvF,SAAQ,SAAApF,GAAK,OAAAA,EAAE28C,SAAF,GAC1B,GAG0Dv1C,KAAMoT,EACxE,EAwBA,kBAII,WACIosB,EACQ83F,EACRxnH,EACA6mD,EACAhjC,EACAg6F,EACArB,GAPJ,MASI,YAAM9sF,EAAK1vB,GAAS,WAAO,GAAG6mD,EAAShjC,EAAW24F,IAAY,K,OAPtD,EAAAgL,MAAAA,EAQR,EAAK36E,SAAWgxE,aAAoB,EAApBA,EACZ,EAAK2J,MAAQ,mBAAqB,sBAClC93F,G,CAER,CAMJ,OAvBY,oBAmBR,YAAA+V,QAAA,W,MACiB,QAAb,EAAA1zC,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,cAAWv2C,CACpB,EACJ,EAxBA,CACY,EAAAyzG,mBA6BZ,SAAS0d,EACLnkH,EACApZ,EACAC,EACAq9H,GAEA,GAAIA,EAAO,CACP,IAAK,IAAI38H,EAAI,EAAGA,EAAIyY,EAAMhG,KAAK5U,OAAQmC,IAGnC,IAFA,IAAM0S,EAAM+F,EAAMhG,KAAKzS,GAEdiqB,EAAI,EAAGA,EAAIvX,EAAIC,MAAM9U,OAAQosB,IAAK,CACvC,IAAMrX,EAAOF,EAAIC,MAAMsX,GAEvB,IADMkyG,GAAW,IAAA5pF,eAAc3/B,EAAK4/B,2BACpBlzC,GAAK68H,EAAS1pF,KAAOnzC,GAAK68H,EAASzpF,OAC/C,OAAO1yC,C,CAInB,OAAOzB,KAAKC,IAAI,EAAGia,EAAMhG,KAAK5U,OAAS,E,CAEvC,IAAK4a,EAAMhG,KAAK,GACZ,OAAO,EAEX,IAAMuW,EAAWvQ,EAAMhG,KAAK,GAC5B,IAASzS,EAAI,EAAGA,EAAIgpB,EAASrW,MAAM9U,OAAQmC,IAAK,CAC5C,IACMm8H,EACN,GAFMvpH,EAAOoW,EAASrW,MAAM3S,IACtBm8H,GAAW,IAAA5pF,eAAc3/B,EAAK4/B,2BACpBnzC,GAAK88H,EAASzrH,MAAQrR,GAAK88H,EAASrrH,MAChD,OAAO9Q,C,CAGf,OAAOgpB,EAASrW,MAAM9U,OAAS,CAEvC,CAMA,SAAgB2nD,EACZrwC,EACAstB,GAEQ,IAAAhqB,EAAyBtD,EAAO,MAAzB8W,EAAkB9W,EAAO,OAAjBwnH,EAAUxnH,EAAO,MACxC8W,EAAO8K,gBAAgB,MAEvB,IAAMwe,GAAc,IAAAkB,iBAAgBh+B,GAE9BwsB,EAAa23F,EAAyBnkH,EAAOgqB,EAAMs4F,QAASt4F,EAAMq4F,QAAS6B,GAEjF,OAAIA,EAWO,CACH/D,aAASntH,EACTovH,iBAXqC,CACrCv/G,KAAM,QACN7C,MAAK,EACLuQ,SAAUic,EACVhc,QAASgc,EACThd,YAAa,EACbiB,WAPiBqsB,EAAYtQ,GAAYpnC,OAAS,GAclD03C,YAAW,EACXtQ,WAAU,GAaP,CACH2zF,aAASntH,EACTovH,iBAXqC,CACrCv/G,KAAM,QACN7C,MAAK,EACLuQ,SAAU,EACVC,QALcssB,EAAY13C,OAAS,EAMnCoqB,YAAagd,EACb/b,WAAY+b,GAOZsQ,YAAW,EACXtQ,WAAU,EAGtB,CAMA,SAAgBwsE,EACZt8F,EACAstB,EACAqvF,GAEA,IAAKA,EACD,OAAO,EAGH,IAAAr5G,EAAyBtD,EAAO,MAAzB8W,EAAkB9W,EAAO,OAAjBwnH,EAAUxnH,EAAO,MAChCogC,EAA4Bu8E,EAAS,YAAxB7sF,EAAe6sF,EAAS,WAEvCruG,EAAem5G,EAAyBnkH,EAAOgqB,EAAMs4F,QAASt4F,EAAMq4F,QAAS6B,GAEnF,GAAIA,EAAO,CACP,IAAME,EAAetnF,EAAYtQ,GAAYpnC,OAAS,EAChDmrB,EAAWzqB,KAAKD,IAAI2mC,EAAYxhB,GAChCwF,EAAU1qB,KAAKC,IAAIymC,EAAYxhB,GAErCwI,EAAO8K,gBAAgB,CACnBzb,KAAM,QACN7C,MAAOA,EACPuQ,SAAQ,EACRf,YAAa,EACbgB,QAAO,EACPC,WAAY2zG,G,KAEb,CACH,IAAM50G,EAAc1pB,KAAKD,IAAI2mC,EAAYxhB,GACnCyF,EAAa3qB,KAAKC,IAAIymC,EAAYxhB,GAClCq5G,EAAYvnF,EAAY13C,OAAS,EAEvCouB,EAAO8K,gBAAgB,CACnBzb,KAAM,QACN7C,MAAOA,EACPuQ,SAAU,EACVf,YAAW,EACXiB,WAAU,EACVD,QAAS6zG,G,CAIjB,OAAO,CACX,CAMA,SAAgB5K,EACZ/8G,EACAstB,EACAqvF,GAEA,IAAKA,EACD,OAAO,EAGH,IAAA7lG,EAAW9W,EAAO,OACpBgH,EAAY8P,EAAOyE,kBAMzB,MAJwB,WAApBvU,aAAS,EAATA,EAAWb,OACX2Q,EAAO8K,gBAAgB+6F,EAAU+I,mBAG9B,CACX,CAxHA,gBAsDA,eAiDA,a,6GC5RA,eAOA,+BAAoC5uG,EAAiBxT,GACjD,IAAM9a,GAAQ,IAAA8zB,8BACRtc,GAAU,IAAA0G,yBAAwB,CACpCmd,UAAW/M,EAAOkE,eAAe8I,qBACjCsD,sBAAsB,EACtBzD,mBAAmB,IAGvB3jB,EAAQusD,kBAAkBjmC,QAAQ99B,EAAO8a,EAAOtD,GAEhD,IAAMmjB,EAAa36B,EAAMmU,OAAO,GAEhC,MAAgC,UAAzBwmB,aAAU,EAAVA,EAAY3mB,WAAuB2mB,OAAa7sB,CAC3D,C,oGCpBA,eAKMsxH,EAA6B,UAC7BC,EAAuB,KAK7B,aASI,aARQ,KAAA/wG,OAAyB,KACzB,KAAAs5B,MAAQ,EACR,KAAA03E,cAAwB,EACxB,KAAAC,wBAAkC,CAK3B,CAuMnB,OAlMI,YAAAziF,QAAA,WACI,MAAO,OACX,EAMA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,EACd/kB,KAAK+1H,cAAe,CACxB,EAKA,YAAAriF,QAAA,W,UACQ1zC,KAAKq+C,QACkC,QAAvC,EAA0B,QAA1B,EAAW,QAAX,EAAAr+C,KAAK+kB,cAAM,eAAEiC,qBAAa,eAAEiL,mBAAW,SAAEwuB,aAAazgD,KAAKq+C,OAC3Dr+C,KAAKq+C,MAAQ,GAEjBr+C,KAAK+kB,OAAS,IAClB,EAMA,YAAAutB,cAAA,SAAc/W,GAAd,I,MAAA,OACI,GAAKv7B,KAAK+kB,OAGV,OAAQwW,EAAMsE,WACV,IAAK,cACD7/B,KAAK+1H,cAAe,EACpB/1H,KAAKg2H,wBAAyB,EAC9Bz6F,EAAMokB,cAAc3D,iBAEpB,IAAMi6E,EAAej2H,KAAK+kB,OAAOiC,cAAciL,YAE3CgkG,IACIj2H,KAAKq+C,OACL43E,EAAax1E,aAAazgD,KAAKq+C,OAGnCr+C,KAAKq+C,MAAQ43E,EAAaC,YAAW,WAGjC,GAFA,EAAK73E,MAAQ,EAET,EAAKt5B,SACA,EAAKgxG,aAAc,CACpB,EAAKhxG,OAAOC,QACZ,IAAMmxG,GAAgB,IAAArC,0BAClB,EAAK/uG,OACLwW,EAAMiB,SAASrkC,EACfojC,EAAMiB,SAASpkC,GAGb2jC,EAAW,EAAKhX,OAAOiC,cAAcmV,cAC3C,GAAIg6F,EAAe,CACP,IAAAh4H,EAAiBg4H,EAAa,KAAxB91G,EAAW81G,EAAa,OAGtCp6F,EAASmJ,SAAS/mC,EAAMkiB,GACxB0b,EAASoJ,OAAOhnC,EAAMkiB,GAEtB,IAAM+1G,EAAkBj4H,EAAKs+B,aAAe,GACtC45F,EAAkBD,EAAgB/1G,GACxC,GACIliB,EAAK4oE,WAAale,KAAKg/D,WACvBwO,IACCP,EAAqBt7G,KAAK67G,KAC1BR,EAA2Br7G,KAAK67G,GACnC,CACQ,MAAyBC,EAC3BF,EACA/1G,GAIEk2G,EAAuBl2G,EANZ,YAOXm2G,EAPoB,UAOcn2G,EACpCo2G,EACAF,GAAwBC,EAClBA,GACCD,EAKLG,EAAoBr2G,GAJ1Bo2G,EACIp/H,KAAK+vF,IAAIqvC,GA5GrB,EA6GkB,EACAA,GAGW,IAAjBA,GACAL,EAAgBz/H,QAAU+/H,IAE1B36F,EAASmJ,SAAS/mC,EAAMu4H,GACxB36F,EAASoJ,OAAOhnC,EAAMu4H,G,EAIlC,EAAK3xG,OAAO8K,gBAAgB,CACxBzb,KAAM,QACNsb,MAAOqM,EACPjM,YAAY,IAIhB,EAAKkmG,wBAAyB,C,CAG1C,GAlIY,MAoIhB,MACJ,IAAK,cACD,GAAIh2H,KAAKg2H,uBAAwB,CAC7Bz6F,EAAMiB,SAASwf,iBAEfh8C,KAAK+1H,cAAe,EACpB,IAAMI,GAAgB,IAAArC,0BAClB9zH,KAAK+kB,OACLwW,EAAMiB,SAASrkC,EACfojC,EAAMiB,SAASpkC,GAGnB,GAAI+9H,EAAe,CACP,IAAAh4H,EAAiBg4H,EAAa,KAAxB91G,EAAW81G,EAAa,OAEtC,GAAIh4H,EAAK4oE,WAAale,KAAKg/D,UACvB,OAGJ,IAAMuO,EAAkBj4H,EAAK+0B,WAAa,GACpC33B,EAAO66H,EAAgB5pG,OAAOnM,GAGpC,GAAIw1G,EAA2Br7G,KAAKjf,IAC1BwgC,EAAoC,QAAzB,EAAA/7B,KAAK+kB,OAAOiC,qBAAa,eAAEmV,iBAExCJ,EAASmJ,SAAS/mC,EAAMkiB,GACxB0b,EAASoJ,OAAOhnC,EAAMkiB,EAAS,GAC/BrgB,KAAK+kB,OAAO8K,gBAAgB,CACxBzb,KAAM,QACNsb,MAAOqM,EACPjM,YAAY,UAGjB,GAAIgmG,EAAqBt7G,KAAKjf,GAAO,CAExC,IAAMo7H,EAAkBP,EAAgBl7H,UACpCmlB,EACA+1G,EAAgBz/H,QAIpB,GADIggI,EAAgBhgI,OAAS,IAAM,KAAK6jB,KAAKm8G,GACnB,CAGtB,IADA,IAAIppG,EAAQlN,EAERkN,EAAQ,GACRuoG,EAAqBt7G,KAAK47G,EAAgB5pG,OAAOe,EAAQ,KAEzDA,KAEEwO,EAAoC,QAAzB,EAAA/7B,KAAK+kB,OAAOiC,qBAAa,eAAEmV,iBAExCJ,EAASmJ,SAAS/mC,EAAMovB,GACxBwO,EAASoJ,OAAOhnC,EAAMovB,EAAQ,GAC9BvtB,KAAK+kB,OAAO8K,gBAAgB,CACxBzb,KAAM,QACNsb,MAAOqM,EACPjM,YAAY,I,MAIrB,CACG,IAIAiM,EAJA,EAAyBu6F,EAC3BF,EACA/1G,GAFIu2G,EAAS,YAAEC,EAAO,WAIpB96F,EAAoC,QAAzB,EAAA/7B,KAAK+kB,OAAOiC,qBAAa,eAAEmV,iBAExCJ,EAASmJ,SAAS/mC,EAAMy4H,GACxB76F,EAASoJ,OAAOhnC,EAAM04H,GACtB72H,KAAK+kB,OAAO8K,gBAAgB,CACxBzb,KAAM,QACNsb,MAAOqM,EACPjM,YAAY,I,IAQ5C,EACJ,EAhNA,GAyNA,SAASwmG,EAAmB3pH,EAAc0T,GAKtC,IAJA,IAAIkN,EAAQlN,EACRmN,EAAMnN,EAINkN,EAAQ,IACPuoG,EAAqBt7G,KAAK7N,EAAK4gB,EAAQ,MACvCsoG,EAA2Br7G,KAAK7N,EAAK4gB,EAAQ,KAE9CA,IAIJ,KACIC,EAAM7gB,EAAKhW,SACVm/H,EAAqBt7G,KAAK7N,EAAK6gB,MAC/BqoG,EAA2Br7G,KAAK7N,EAAK6gB,KAEtCA,IAGJ,MAAO,CACHopG,UAAWrpG,EACXspG,QAASrpG,EAEjB,CAnPa,EAAA+uF,YAAAA,C,gHCNb,oCACIx3F,EACA5sB,EACAC,GAEA,IAAMkyB,EAAMvF,EAAOiC,cACbwK,EAAYzM,EAAOkE,eAEzB,GAAI,2BAA4BqB,EAAK,CAEjC,IAAM8D,EAAO9D,EAAYwsG,uBAAuB3+H,EAAGC,GACnD,GAAIg2B,GAAOoD,EAAUyoB,eAAe7rB,EAAI2oG,YACpC,MAAO,CAAE54H,KAAMiwB,EAAI2oG,WAAY12G,OAAQ+N,EAAI/N,O,CAInD,GAAIiK,EAAI0sG,oBAAqB,CAEzB,IAAMtnG,EAAQpF,EAAI0sG,oBAAoB7+H,EAAGC,GACzC,GAAIs3B,GAAS8B,EAAUyoB,eAAevqB,EAAMoV,gBACxC,MAAO,CAAE3mC,KAAMuxB,EAAMoV,eAAgBzkB,OAAQqP,EAAMqV,Y,CAI3D,GAAIza,EAAI2sG,iBAAkB,CAEtB,IAAM1iG,EAAUjK,EAAI2sG,iBAAiB9+H,EAAGC,GACxC,GAAIm8B,GAAW/C,EAAUyoB,eAAe1lB,GACpC,MAAO,CAAEp2B,KAAMo2B,EAASlU,OAAQ,E,CAIxC,OAAO,IACX,C,wHCtCA,WACA,WAIM62G,EAAwB,oBACxBC,EAAkD,CACpD14G,WAAY,cACZC,SAAU,YACV7K,UAAW,SAMf,aAWI,WAAsBujH,EAAmB7sH,GAAzC,WAAsB,KAAA6sH,UAAAA,EAVd,KAAAryG,OAAyB,KAEzB,KAAAsyG,WAAY,EACZ,KAAAC,cAA+B,KAC/B,KAAAx8E,SAAgC,KAuFhC,KAAAiF,mBAAqB,WACrB,EAAKh7B,QACL,EAAKwyG,SAAS,EAAKxyG,QAAQ,EAEnC,EApFI/kB,KAAKuK,OAASA,GAAU,CACpBmU,SAAU,OACV7K,UAAW,UAEnB,CA6HJ,OAxHI,YAAA0/B,QAAA,WACI,MAAO,WACX,EAMA,YAAAC,WAAA,SAAWzuB,GACP/kB,KAAK+kB,OAASA,EACd/kB,KAAK86C,SAAW96C,KAAK+kB,OAAOohB,eAAe,CACvCia,iBAAkB,CACd7Z,eAAgBvmC,KAAK+/C,qBAGjC,EAKA,YAAArM,QAAA,W,MACiB,QAAb,EAAA1zC,KAAK86C,gBAAQ,cAAb96C,MACAA,KAAK86C,SAAW,KAEhB96C,KAAK+kB,OAAS,IAClB,EAMA,YAAAutB,cAAA,SAAc/W,GACV,IAAMxW,EAAS/kB,KAAK+kB,OAEfA,IAIkB,SAAnBwW,EAAMsE,WAAoD,cAA5BtE,EAAMiB,SAASw7D,UAE7Ch4F,KAAKu3H,SAASxyG,GAAQ,GAEH,kBAAnBwW,EAAMsE,WACLtE,EAAMsO,QAAU,EAAAriB,aAAaqgC,kBAC1BtsB,EAAMsO,QAAU,EAAAriB,aAAasgC,oBACjC9nD,KAAKq3H,UAgBc,eAAnB97F,EAAMsE,WACa,kBAAnBtE,EAAMsE,WACa,SAAnBtE,EAAMsE,WACa,iBAAnBtE,EAAMsE,WACa,kBAAnBtE,EAAMsE,WAEN7/B,KAAKw3H,OAAOzyG,IAlBRwW,EAAMsO,QAAU,EAAAriB,aAAaqgC,mBAC5B7nD,KAAKs3H,eACNt3H,KAAKuK,OAAOsJ,YAGZ7T,KAAKs3H,cAAgBvyG,EAChBmE,kBACA6gC,aAAa/pD,KAAKuK,OAAOsJ,eAAWtP,EAAW,SAGxDvE,KAAKy3H,oBAAoB1yG,IAUjC,EAQQ,YAAAyyG,OAAR,SAAezyG,GAAf,WACIA,EAAOE,oBAAmB,SAAAxuB,GACtB,IAAMs+E,GAAU,IAAAqnC,kBAAiB3lH,GAIjC,OAFA,EAAK8gI,SAASxyG,EAAQgwD,IAEf,CACX,GACJ,EAEQ,YAAAwiD,SAAR,SAAiBxyG,EAAiBgwD,GAC1B/0E,KAAKq3H,YAActiD,EACnB/0E,KAAK03H,KAAK3yG,IACF/kB,KAAKq3H,WAAatiD,GAC1B/0E,KAAK23H,KAAK5yG,EAElB,EAEU,YAAA4yG,KAAV,SAAe5yG,GACX/kB,KAAKy3H,oBAAoB1yG,GACzB/kB,KAAKq3H,WAAY,CACrB,EAEQ,YAAAI,oBAAR,SAA4B1yG,GACxB,IAAI1J,EAAO,iFAAiFrb,KAAKo3H,UAAS,KACpG7sH,GAAS,EAAH,8BACLvK,KAAKuK,QAAM,CACdsJ,UAAWkR,EAAOgE,aAAe/oB,KAAKs3H,cAAgBt3H,KAAKuK,OAAOsJ,aAGtE,IAAAsH,eAAcg8G,GAAUh7H,SAAQ,SAAAhE,GACxBoS,EAAOpS,KACPkjB,GAAW87G,EAASh/H,GAAE,KAAKoS,EAAOpS,GAAE,cAE5C,IAEA4sB,EAAOsiB,eAAe6vF,EAAuB77G,EAAM,SACvD,EAEU,YAAAq8G,KAAV,SAAe3yG,GACXA,EAAOsiB,eAAe6vF,EAAuB,MAC7Cl3H,KAAKq3H,WAAY,CACrB,EACJ,EA7IA,GAAa,EAAAlb,gBAAAA,C,wGCVb,4BAAiC1lH,GAC7B,IAAM26B,EAAa36B,EAAMmU,OAAO,GAEhC,QAAInU,EAAMmU,OAAOjU,OAAS,MAEdy6B,GAEuB,aAAxBA,EAAW3mB,YAEmB,GAA9B2mB,EAAWhlB,SAASzV,SAG3By6B,EAAWhlB,SAASkB,MAChB,SAAAnV,GACI,MAAiB,UAAjBA,EAAEoU,aACe,SAAjBpU,EAAEoU,aACe,WAAjBpU,EAAEoU,aACgB,QAAjBpU,EAAEoU,aAAyBpU,EAAEwU,IAH9B,OAQPykB,EAAW7mB,OAAOc,aAAenM,WAAWkyB,EAAW7mB,OAAOc,aAAe,GAC7E+lB,EAAW7mB,OAAOW,YAAchM,WAAWkyB,EAAW7mB,OAAOW,YAAc,IAIrEkmB,EAAWhlB,SAASC,QAAO,SAAAlU,GAAK,MAAiB,MAAjBA,EAAEoU,WAAF,IAAuB5V,QAAU,GAEhF,C,kMClCA,WACA,WAgBA,wBACI87C,EACAmlF,EACAnpE,GAEA,IAOM9nC,EAAyB,CAC3ByrB,SARY,EAAH,kBACT,IAAI,EAAA6oE,YACJ,IAAI,EAAA5a,WACJ,IAAI,EAAA6b,iB,YACA0b,QAAAA,EAAqB,KAAG,GAK5BnpE,aAAY,EACZ76C,qBAAsB,CAClB6K,WAAY,qCACZC,SAAU,OACV7K,UAAW,YAGnB,OAAO,IAAI,EAAAq7C,OAAOzc,EAAY9rB,EAClC,C,qHCvCA,WAAS,8EAAAkxG,YAAY,KACrB,+BACA,+BACA,+BACA,+BACA,+BACA,+BACA,6B,qnBCSA,IAAIC,EAAgB,SAASzlB,EAAGl7G,GAI9B,OAHA2gI,EAAgBlhI,OAAOmhI,gBAClB,CAAEC,UAAW,cAAgBv7H,OAAS,SAAU41G,EAAGl7G,GAAKk7G,EAAE2lB,UAAY7gI,CAAG,GAC1E,SAAUk7G,EAAGl7G,GAAK,IAAK,IAAIiC,KAAKjC,EAAOP,OAAO8F,UAAUtH,eAAewH,KAAKzF,EAAGiC,KAAIi5G,EAAEj5G,GAAKjC,EAAEiC,GAAI,EAC7F0+H,EAAczlB,EAAGl7G,EAC1B,EAEO,SAAS8gI,EAAU5lB,EAAGl7G,GAC3B,GAAiB,mBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAI+gI,UAAU,uBAAyB1zC,OAAOrtF,GAAK,iCAE7D,SAAS6oB,IAAOhgB,KAAK6E,YAAcwtG,CAAG,CADtCylB,EAAczlB,EAAGl7G,GAEjBk7G,EAAE31G,UAAkB,OAANvF,EAAaP,OAAOuhI,OAAOhhI,IAAM6oB,EAAGtjB,UAAYvF,EAAEuF,UAAW,IAAIsjB,EACjF,CAEO,IAAIo4G,EAAW,WAQpB,OAPAA,EAAWxhI,OAAO0gB,QAAU,SAAkBhe,GAC1C,IAAK,IAAI3B,EAAGmB,EAAI,EAAGW,EAAIgB,UAAU9D,OAAQmC,EAAIW,EAAGX,IAE5C,IAAK,IAAIM,KADTzB,EAAI8C,UAAU3B,GACOlC,OAAO8F,UAAUtH,eAAewH,KAAKjF,EAAGyB,KAAIE,EAAEF,GAAKzB,EAAEyB,IAE9E,OAAOE,CACX,EACO8+H,EAAS9tD,MAAMtqE,KAAMvF,UAC9B,EAEO,SAAS49H,EAAO1gI,EAAGqjD,GACxB,IAAI1hD,EAAI,CAAC,EACT,IAAK,IAAIF,KAAKzB,EAAOf,OAAO8F,UAAUtH,eAAewH,KAAKjF,EAAGyB,IAAM4hD,EAAE36C,QAAQjH,GAAK,IAC9EE,EAAEF,GAAKzB,EAAEyB,IACb,GAAS,MAALzB,GAAqD,mBAAjCf,OAAO0hI,sBACtB,KAAIx/H,EAAI,EAAb,IAAgBM,EAAIxC,OAAO0hI,sBAAsB3gI,GAAImB,EAAIM,EAAEzC,OAAQmC,IAC3DkiD,EAAE36C,QAAQjH,EAAEN,IAAM,GAAKlC,OAAO8F,UAAU67H,qBAAqB37H,KAAKjF,EAAGyB,EAAEN,MACvEQ,EAAEF,EAAEN,IAAMnB,EAAEyB,EAAEN,IAF4B,CAItD,OAAOQ,CACT,CAEO,SAASk/H,EAAWC,EAAY9nH,EAAQxb,EAAKujI,GAClD,IAA2HrmB,EAAvHt6G,EAAI0C,UAAU9D,OAAQM,EAAIc,EAAI,EAAI4Y,EAAkB,OAAT+nH,EAAgBA,EAAO9hI,OAAOgO,yBAAyB+L,EAAQxb,GAAOujI,EACrH,GAAuB,iBAAZC,SAAoD,mBAArBA,QAAQC,SAAyB3hI,EAAI0hI,QAAQC,SAASH,EAAY9nH,EAAQxb,EAAKujI,QACpH,IAAK,IAAI5/H,EAAI2/H,EAAW9hI,OAAS,EAAGmC,GAAK,EAAGA,KAASu5G,EAAIomB,EAAW3/H,MAAI7B,GAAKc,EAAI,EAAIs6G,EAAEp7G,GAAKc,EAAI,EAAIs6G,EAAE1hG,EAAQxb,EAAK8B,GAAKo7G,EAAE1hG,EAAQxb,KAAS8B,GAChJ,OAAOc,EAAI,GAAKd,GAAKL,OAAOC,eAAe8Z,EAAQxb,EAAK8B,GAAIA,CAC9D,CAEO,SAAS4hI,EAAQC,EAAYlpH,GAClC,OAAO,SAAUe,EAAQxb,GAAOya,EAAUe,EAAQxb,EAAK2jI,EAAa,CACtE,CAEO,SAASC,EAAaC,EAAMC,EAAcR,EAAYS,EAAWC,EAAcC,GACpF,SAASC,EAAOlgI,GAAK,QAAU,IAANA,GAA6B,mBAANA,EAAkB,MAAM,IAAI++H,UAAU,qBAAsB,OAAO/+H,CAAG,CAKtH,IAJA,IAGI4mB,EAHAi9B,EAAOk8E,EAAUl8E,KAAM7nD,EAAe,WAAT6nD,EAAoB,MAAiB,WAATA,EAAoB,MAAQ,QACrFrsC,GAAUsoH,GAAgBD,EAAOE,EAAkB,OAAIF,EAAOA,EAAKt8H,UAAY,KAC/E48H,EAAaL,IAAiBtoH,EAAS/Z,OAAOgO,yBAAyB+L,EAAQuoH,EAAU16H,MAAQ,CAAC,GAC/F4jG,GAAO,EACLtpG,EAAI2/H,EAAW9hI,OAAS,EAAGmC,GAAK,EAAGA,IAAK,CAC7C,IAAImV,EAAU,CAAC,EACf,IAAK,IAAI7U,KAAK8/H,EAAWjrH,EAAQ7U,GAAW,WAANA,EAAiB,CAAC,EAAI8/H,EAAU9/H,GACtE,IAAK,IAAIA,KAAK8/H,EAAUK,OAAQtrH,EAAQsrH,OAAOngI,GAAK8/H,EAAUK,OAAOngI,GACrE6U,EAAQurH,eAAiB,SAAUrgI,GAAK,GAAIipG,EAAM,MAAM,IAAI81B,UAAU,0DAA2DkB,EAAkB34H,KAAK44H,EAAOlgI,GAAK,MAAQ,EAC5K,IAAI0D,GAAS,EAAI47H,EAAW3/H,IAAa,aAATkkD,EAAsB,CAAEt+C,IAAK46H,EAAW56H,IAAKqoG,IAAKuyB,EAAWvyB,KAAQuyB,EAAWnkI,GAAM8Y,GACtH,GAAa,aAAT+uC,EAAqB,CACrB,QAAe,IAAXngD,EAAmB,SACvB,GAAe,OAAXA,GAAqC,iBAAXA,EAAqB,MAAM,IAAIq7H,UAAU,oBACnEn4G,EAAIs5G,EAAOx8H,EAAO6B,QAAM46H,EAAW56H,IAAMqhB,IACzCA,EAAIs5G,EAAOx8H,EAAOkqG,QAAMuyB,EAAWvyB,IAAMhnF,IACzCA,EAAIs5G,EAAOx8H,EAAO48H,QAAON,EAAax7H,QAAQoiB,EACtD,MACSA,EAAIs5G,EAAOx8H,MACH,UAATmgD,EAAkBm8E,EAAax7H,QAAQoiB,GACtCu5G,EAAWnkI,GAAO4qB,EAE/B,CACIpP,GAAQ/Z,OAAOC,eAAe8Z,EAAQuoH,EAAU16H,KAAM86H,GAC1Dl3B,GAAO,CACT,CAEO,SAASs3B,EAAkBC,EAASR,EAAcriI,GAEvD,IADA,IAAI8iI,EAAWn/H,UAAU9D,OAAS,EACzBmC,EAAI,EAAGA,EAAIqgI,EAAaxiI,OAAQmC,IACrChC,EAAQ8iI,EAAWT,EAAargI,GAAG8D,KAAK+8H,EAAS7iI,GAASqiI,EAAargI,GAAG8D,KAAK+8H,GAEnF,OAAOC,EAAW9iI,OAAQ,CAC5B,CAEO,SAAS+iI,EAAU1hI,GACxB,MAAoB,iBAANA,EAAiBA,EAAI,GAAGkJ,OAAOlJ,EAC/C,CAEO,SAAS2hI,EAAkB3gI,EAAGqF,EAAM6sB,GAEzC,MADoB,iBAAT7sB,IAAmBA,EAAOA,EAAKu7H,YAAc,IAAI14H,OAAO7C,EAAKu7H,YAAa,KAAO,IACrFnjI,OAAOC,eAAesC,EAAG,OAAQ,CAAE6gI,cAAc,EAAMljI,MAAOu0B,EAAS,GAAGhqB,OAAOgqB,EAAQ,IAAK7sB,GAAQA,GAC/G,CAEO,SAASy7H,EAAWpW,EAAaqW,GACtC,GAAuB,iBAAZvB,SAAoD,mBAArBA,QAAQ/sH,SAAyB,OAAO+sH,QAAQ/sH,SAASi4G,EAAaqW,EAClH,CAEO,SAASC,EAAUR,EAASS,EAAYC,EAAGC,GAEhD,OAAO,IAAKD,IAAMA,EAAIn1D,WAAU,SAAUE,EAASm1D,GAC/C,SAASC,EAAU1jI,GAAS,IAAMo0D,EAAKovE,EAAUjuF,KAAKv1C,GAAS,CAAE,MAAOkkD,GAAKu/E,EAAOv/E,EAAI,CAAE,CAC1F,SAASy/E,EAAS3jI,GAAS,IAAMo0D,EAAKovE,EAAiB,MAAExjI,GAAS,CAAE,MAAOkkD,GAAKu/E,EAAOv/E,EAAI,CAAE,CAC7F,SAASkQ,EAAKruD,GAJlB,IAAe/F,EAIa+F,EAAOulG,KAAOh9B,EAAQvoE,EAAO/F,QAJ1CA,EAIyD+F,EAAO/F,MAJhDA,aAAiBujI,EAAIvjI,EAAQ,IAAIujI,GAAE,SAAUj1D,GAAWA,EAAQtuE,EAAQ,KAIjBqlD,KAAKq+E,EAAWC,EAAW,CAC7GvvE,GAAMovE,EAAYA,EAAUhwD,MAAMqvD,EAASS,GAAc,KAAK/tF,OAClE,GACF,CAEO,SAASquF,EAAYf,EAASvhG,GACnC,IAAsGj/B,EAAGf,EAAGkB,EAAGpC,EAA3G6oB,EAAI,CAAEpE,MAAO,EAAGg/G,KAAM,WAAa,GAAW,EAAPrhI,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,EAAI,EAAGshI,KAAM,GAAIC,IAAK,IAChG,OAAO3jI,EAAI,CAAEm1C,KAAMyuF,EAAK,GAAI,MAASA,EAAK,GAAI,OAAUA,EAAK,IAAwB,mBAAXC,SAA0B7jI,EAAE6jI,OAAOh5B,UAAY,WAAa,OAAO/hG,IAAM,GAAI9I,EACvJ,SAAS4jI,EAAKrhI,GAAK,OAAO,SAAU7B,GAAK,OACzC,SAAcojI,GACV,GAAI7hI,EAAG,MAAM,IAAI++H,UAAU,mCAC3B,KAAOhhI,IAAMA,EAAI,EAAG8jI,EAAG,KAAOj7G,EAAI,IAAKA,OACnC,GAAI5mB,EAAI,EAAGf,IAAMkB,EAAY,EAAR0hI,EAAG,GAAS5iI,EAAU,OAAI4iI,EAAG,GAAK5iI,EAAS,SAAOkB,EAAIlB,EAAU,SAAMkB,EAAEsD,KAAKxE,GAAI,GAAKA,EAAEi0C,SAAW/yC,EAAIA,EAAEsD,KAAKxE,EAAG4iI,EAAG,KAAK54B,KAAM,OAAO9oG,EAE3J,OADIlB,EAAI,EAAGkB,IAAG0hI,EAAK,CAAS,EAARA,EAAG,GAAQ1hI,EAAExC,QACzBkkI,EAAG,IACP,KAAK,EAAG,KAAK,EAAG1hI,EAAI0hI,EAAI,MACxB,KAAK,EAAc,OAAXj7G,EAAEpE,QAAgB,CAAE7kB,MAAOkkI,EAAG,GAAI54B,MAAM,GAChD,KAAK,EAAGriF,EAAEpE,QAASvjB,EAAI4iI,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKj7G,EAAE86G,IAAI78H,MAAO+hB,EAAE66G,KAAK58H,MAAO,SACxC,QACI,MAAkB1E,GAAZA,EAAIymB,EAAE66G,MAAYjkI,OAAS,GAAK2C,EAAEA,EAAE3C,OAAS,KAAkB,IAAVqkI,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEj7G,EAAI,EAAG,QAAU,CAC3G,GAAc,IAAVi7G,EAAG,MAAc1hI,GAAM0hI,EAAG,GAAK1hI,EAAE,IAAM0hI,EAAG,GAAK1hI,EAAE,IAAM,CAAEymB,EAAEpE,MAAQq/G,EAAG,GAAI,KAAO,CACrF,GAAc,IAAVA,EAAG,IAAYj7G,EAAEpE,MAAQriB,EAAE,GAAI,CAAEymB,EAAEpE,MAAQriB,EAAE,GAAIA,EAAI0hI,EAAI,KAAO,CACpE,GAAI1hI,GAAKymB,EAAEpE,MAAQriB,EAAE,GAAI,CAAEymB,EAAEpE,MAAQriB,EAAE,GAAIymB,EAAE86G,IAAIp6H,KAAKu6H,GAAK,KAAO,CAC9D1hI,EAAE,IAAIymB,EAAE86G,IAAI78H,MAChB+hB,EAAE66G,KAAK58H,MAAO,SAEtBg9H,EAAK5iG,EAAKx7B,KAAK+8H,EAAS55G,EAC5B,CAAE,MAAOi7B,GAAKggF,EAAK,CAAC,EAAGhgF,GAAI5iD,EAAI,CAAG,CAAE,QAAUe,EAAIG,EAAI,CAAG,CACzD,GAAY,EAAR0hI,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAElkI,MAAOkkI,EAAG,GAAKA,EAAG,QAAK,EAAQ54B,MAAM,EAC9E,CAtBgDl3C,CAAK,CAACzxD,EAAG7B,GAAK,CAAG,CAuBnE,CAEO,IAAIqjI,EAAkBrkI,OAAOuhI,OAAS,SAAU+C,EAAGrhI,EAAG7B,EAAGmjI,QACnD52H,IAAP42H,IAAkBA,EAAKnjI,GAC3B,IAAI0gI,EAAO9hI,OAAOgO,yBAAyB/K,EAAG7B,GACzC0gI,KAAS,QAASA,GAAQ7+H,EAAEuhI,WAAa1C,EAAK2C,UAAY3C,EAAKsB,gBAChEtB,EAAO,CAAE4C,YAAY,EAAM58H,IAAK,WAAa,OAAO7E,EAAE7B,EAAI,IAE9DpB,OAAOC,eAAeqkI,EAAGC,EAAIzC,EAC9B,EAAI,SAAUwC,EAAGrhI,EAAG7B,EAAGmjI,QACX52H,IAAP42H,IAAkBA,EAAKnjI,GAC3BkjI,EAAEC,GAAMthI,EAAE7B,EACX,EAEM,SAASujI,EAAa1hI,EAAGqhI,GAC9B,IAAK,IAAI9hI,KAAKS,EAAa,YAANT,GAAoBxC,OAAO8F,UAAUtH,eAAewH,KAAKs+H,EAAG9hI,IAAI6hI,EAAgBC,EAAGrhI,EAAGT,EAC7G,CAEO,SAASoiI,EAASN,GACvB,IAAIvjI,EAAsB,mBAAXojI,QAAyBA,OAAOh5B,SAAUloG,EAAIlC,GAAKujI,EAAEvjI,GAAImB,EAAI,EAC5E,GAAIe,EAAG,OAAOA,EAAE+C,KAAKs+H,GACrB,GAAIA,GAAyB,iBAAbA,EAAEvkI,OAAqB,MAAO,CAC1C01C,KAAM,WAEF,OADI6uF,GAAKpiI,GAAKoiI,EAAEvkI,SAAQukI,OAAI,GACrB,CAAEpkI,MAAOokI,GAAKA,EAAEpiI,KAAMspG,MAAO84B,EACxC,GAEJ,MAAM,IAAIhD,UAAUvgI,EAAI,0BAA4B,kCACtD,CAEO,SAAS8jI,EAAOP,EAAGzhI,GACxB,IAAII,EAAsB,mBAAXkhI,QAAyBG,EAAEH,OAAOh5B,UACjD,IAAKloG,EAAG,OAAOqhI,EACf,IAAmBjkI,EAAY+jD,EAA3BliD,EAAIe,EAAE+C,KAAKs+H,GAAOQ,EAAK,GAC3B,IACI,WAAc,IAANjiI,GAAgBA,KAAM,MAAQxC,EAAI6B,EAAEuzC,QAAQ+1D,MAAMs5B,EAAGj7H,KAAKxJ,EAAEH,MACxE,CACA,MAAO6kI,GAAS3gF,EAAI,CAAE2gF,MAAOA,EAAS,CACtC,QACI,IACQ1kI,IAAMA,EAAEmrG,OAASvoG,EAAIf,EAAU,SAAIe,EAAE+C,KAAK9D,EAClD,CACA,QAAU,GAAIkiD,EAAG,MAAMA,EAAE2gF,KAAO,CACpC,CACA,OAAOD,CACT,CAGO,SAASE,IACd,IAAK,IAAIF,EAAK,GAAI5iI,EAAI,EAAGA,EAAI2B,UAAU9D,OAAQmC,IAC3C4iI,EAAKA,EAAGr6H,OAAOo6H,EAAOhhI,UAAU3B,KACpC,OAAO4iI,CACT,CAGO,SAASG,IACd,IAAK,IAAIlkI,EAAI,EAAGmB,EAAI,EAAGgjI,EAAKrhI,UAAU9D,OAAQmC,EAAIgjI,EAAIhjI,IAAKnB,GAAK8C,UAAU3B,GAAGnC,OACxE,IAAIM,EAAIwF,MAAM9E,GAAIK,EAAI,EAA3B,IAA8Bc,EAAI,EAAGA,EAAIgjI,EAAIhjI,IACzC,IAAK,IAAImB,EAAIQ,UAAU3B,GAAIiqB,EAAI,EAAGg5G,EAAK9hI,EAAEtD,OAAQosB,EAAIg5G,EAAIh5G,IAAK/qB,IAC1Df,EAAEe,GAAKiC,EAAE8oB,GACjB,OAAO9rB,CACT,CAEO,SAAS+kI,EAAc3+H,EAAID,EAAM6+H,GACtC,GAAIA,GAA6B,IAArBxhI,UAAU9D,OAAc,IAAK,IAA4B+kI,EAAxB5iI,EAAI,EAAG9B,EAAIoG,EAAKzG,OAAYmC,EAAI9B,EAAG8B,KACxE4iI,GAAQ5iI,KAAKsE,IACRs+H,IAAIA,EAAKj/H,MAAMC,UAAUC,MAAMC,KAAKQ,EAAM,EAAGtE,IAClD4iI,EAAG5iI,GAAKsE,EAAKtE,IAGrB,OAAOuE,EAAGgE,OAAOq6H,GAAMj/H,MAAMC,UAAUC,MAAMC,KAAKQ,GACpD,CAEO,SAAS8+H,EAAQtkI,GACtB,OAAOoI,gBAAgBk8H,GAAWl8H,KAAKpI,EAAIA,EAAGoI,MAAQ,IAAIk8H,EAAQtkI,EACpE,CAEO,SAASukI,EAAiBxC,EAASS,EAAYE,GACpD,IAAKS,OAAOqB,cAAe,MAAM,IAAIlE,UAAU,wCAC/C,IAAoDp/H,EAAhD5B,EAAIojI,EAAUhwD,MAAMqvD,EAASS,GAAc,IAAQ/gI,EAAI,GAC3D,OAAOP,EAAI,CAAC,EAAGgiI,EAAK,QAASA,EAAK,SAAUA,EAAK,UAAWhiI,EAAEiiI,OAAOqB,eAAiB,WAAc,OAAOp8H,IAAM,EAAGlH,EACpH,SAASgiI,EAAKrhI,GAASvC,EAAEuC,KAAIX,EAAEW,GAAK,SAAU7B,GAAK,OAAO,IAAIstE,SAAQ,SAAUjrE,EAAG9C,GAAKkC,EAAEoH,KAAK,CAAChH,EAAG7B,EAAGqC,EAAG9C,IAAM,GAAKklI,EAAO5iI,EAAG7B,EAAI,GAAI,EAAG,CACzI,SAASykI,EAAO5iI,EAAG7B,GAAK,KACVX,EADqBC,EAAEuC,GAAG7B,IACnBd,iBAAiBolI,EAAUh3D,QAAQE,QAAQnuE,EAAEH,MAAMc,GAAGukD,KAAKmgF,EAAS/B,GAAUgC,EAAOljI,EAAE,GAAG,GAAIpC,EADtE,CAAE,MAAO+jD,GAAKuhF,EAAOljI,EAAE,GAAG,GAAI2hD,EAAI,CAC/E,IAAc/jD,CADmE,CAEjF,SAASqlI,EAAQxlI,GAASulI,EAAO,OAAQvlI,EAAQ,CACjD,SAASyjI,EAAOzjI,GAASulI,EAAO,QAASvlI,EAAQ,CACjD,SAASylI,EAAOpjI,EAAGvB,GAASuB,EAAEvB,GAAIyB,EAAE0qB,QAAS1qB,EAAE1C,QAAQ0lI,EAAOhjI,EAAE,GAAG,GAAIA,EAAE,GAAG,GAAK,CACnF,CAEO,SAASmjI,EAAiBtB,GAC/B,IAAIpiI,EAAGM,EACP,OAAON,EAAI,CAAC,EAAGgiI,EAAK,QAASA,EAAK,SAAS,SAAU9/E,GAAK,MAAMA,CAAG,IAAI8/E,EAAK,UAAWhiI,EAAEiiI,OAAOh5B,UAAY,WAAc,OAAO/hG,IAAM,EAAGlH,EAC1I,SAASgiI,EAAKrhI,EAAGN,GAAKL,EAAEW,GAAKyhI,EAAEzhI,GAAK,SAAU7B,GAAK,OAAQwB,GAAKA,GAAK,CAAEtC,MAAOolI,EAAQhB,EAAEzhI,GAAG7B,IAAKwqG,MAAM,GAAUjpG,EAAIA,EAAEvB,GAAKA,CAAG,EAAIuB,CAAG,CACvI,CAEO,SAASsjI,EAAcvB,GAC5B,IAAKH,OAAOqB,cAAe,MAAM,IAAIlE,UAAU,wCAC/C,IAAiCp/H,EAA7Be,EAAIqhI,EAAEH,OAAOqB,eACjB,OAAOviI,EAAIA,EAAE+C,KAAKs+H,IAAMA,EAAqCM,EAASN,GAA2BpiI,EAAI,CAAC,EAAGgiI,EAAK,QAASA,EAAK,SAAUA,EAAK,UAAWhiI,EAAEiiI,OAAOqB,eAAiB,WAAc,OAAOp8H,IAAM,EAAGlH,GAC9M,SAASgiI,EAAKrhI,GAAKX,EAAEW,GAAKyhI,EAAEzhI,IAAM,SAAU7B,GAAK,OAAO,IAAIstE,SAAQ,SAAUE,EAASm1D,IACvF,SAAgBn1D,EAASm1D,EAAQloB,EAAGz6G,GAAKstE,QAAQE,QAAQxtE,GAAGukD,MAAK,SAASvkD,GAAKwtE,EAAQ,CAAEtuE,MAAOc,EAAGwqG,KAAMiQ,GAAM,GAAGkoB,EAAS,CADbgC,CAAOn3D,EAASm1D,GAA7B3iI,EAAIsjI,EAAEzhI,GAAG7B,IAA8BwqG,KAAMxqG,EAAEd,MAAQ,GAAI,CAAG,CAEjK,CAEO,SAAS4lI,EAAqBC,EAAQ1/H,GAE3C,OADIrG,OAAOC,eAAkBD,OAAOC,eAAe8lI,EAAQ,MAAO,CAAE7lI,MAAOmG,IAAiB0/H,EAAO1/H,IAAMA,EAClG0/H,CACT,CAEA,IAAIC,EAAqBhmI,OAAOuhI,OAAS,SAAU+C,EAAGtjI,GACpDhB,OAAOC,eAAeqkI,EAAG,UAAW,CAAEI,YAAY,EAAMxkI,MAAOc,GAChE,EAAI,SAASsjI,EAAGtjI,GACfsjI,EAAW,QAAItjI,CACjB,EAEO,SAASilI,EAAaC,GAC3B,GAAIA,GAAOA,EAAI1B,WAAY,OAAO0B,EAClC,IAAIjgI,EAAS,CAAC,EACd,GAAW,MAAPigI,EAAa,IAAK,IAAI9kI,KAAK8kI,EAAe,YAAN9kI,GAAmBpB,OAAO8F,UAAUtH,eAAewH,KAAKkgI,EAAK9kI,IAAIijI,EAAgBp+H,EAAQigI,EAAK9kI,GAEtI,OADA4kI,EAAmB//H,EAAQigI,GACpBjgI,CACT,CAEO,SAASkgI,EAAgBD,GAC9B,OAAQA,GAAOA,EAAI1B,WAAc0B,EAAM,CAAE53H,QAAS43H,EACpD,CAEO,SAASE,EAAuBC,EAAU/0G,EAAO80B,EAAM7jD,GAC5D,GAAa,MAAT6jD,IAAiB7jD,EAAG,MAAM,IAAI++H,UAAU,iDAC5C,GAAqB,mBAAVhwG,EAAuB+0G,IAAa/0G,IAAU/uB,GAAK+uB,EAAM4xB,IAAImjF,GAAW,MAAM,IAAI/E,UAAU,4EACvG,MAAgB,MAATl7E,EAAe7jD,EAAa,MAAT6jD,EAAe7jD,EAAEyD,KAAKqgI,GAAY9jI,EAAIA,EAAErC,MAAQoxB,EAAMxpB,IAAIu+H,EACtF,CAEO,SAASC,EAAuBD,EAAU/0G,EAAOpxB,EAAOkmD,EAAM7jD,GACnE,GAAa,MAAT6jD,EAAc,MAAM,IAAIk7E,UAAU,kCACtC,GAAa,MAATl7E,IAAiB7jD,EAAG,MAAM,IAAI++H,UAAU,iDAC5C,GAAqB,mBAAVhwG,EAAuB+0G,IAAa/0G,IAAU/uB,GAAK+uB,EAAM4xB,IAAImjF,GAAW,MAAM,IAAI/E,UAAU,2EACvG,MAAiB,MAATl7E,EAAe7jD,EAAEyD,KAAKqgI,EAAUnmI,GAASqC,EAAIA,EAAErC,MAAQA,EAAQoxB,EAAM6+E,IAAIk2B,EAAUnmI,GAASA,CACtG,CAEO,SAASqmI,EAAsBj1G,EAAO+0G,GAC3C,GAAiB,OAAbA,GAA0C,iBAAbA,GAA6C,mBAAbA,EAA0B,MAAM,IAAI/E,UAAU,0CAC/G,MAAwB,mBAAVhwG,EAAuB+0G,IAAa/0G,EAAQA,EAAM4xB,IAAImjF,EACtE,CAEA,SACEhF,YACAG,WACAC,SACAG,aACAK,UACAoB,aACAE,YACAO,cACAO,kBACAM,eACAC,WACAC,SACAG,WACAC,iBACAG,gBACAE,UACAC,mBACAK,mBACAC,gBACAC,uBACAG,eACAE,kBACAC,yBACAE,yBACAC,wB,GC9TEC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB/4H,IAAjBg5H,EACH,OAAOA,EAAahoI,QAGrB,IAAID,EAAS8nI,EAAyBE,GAAY,CAGjD/nI,QAAS,CAAC,GAOX,OAHAioI,EAAoBF,GAAUhoI,EAAQA,EAAOC,QAAS8nI,GAG/C/nI,EAAOC,OACf,CCrBA8nI,EAAoBhrB,EAAI,CAAC98G,EAASoxF,KACjC,IAAI,IAAIxxF,KAAOwxF,EACX02C,EAAoBnC,EAAEv0C,EAAYxxF,KAASkoI,EAAoBnC,EAAE3lI,EAASJ,IAC5EyB,OAAOC,eAAetB,EAASJ,EAAK,CAAEmmI,YAAY,EAAM58H,IAAKioF,EAAWxxF,IAE1E,ECNDkoI,EAAoBnC,EAAI,CAACn7H,EAAK09H,IAAU7mI,OAAO8F,UAAUtH,eAAewH,KAAKmD,EAAK09H,GCClFJ,EAAoBpmI,EAAK1B,IACH,oBAAXwlI,QAA0BA,OAAO2C,aAC1C9mI,OAAOC,eAAetB,EAASwlI,OAAO2C,YAAa,CAAE5mI,MAAO,WAE7DF,OAAOC,eAAetB,EAAS,aAAc,CAAEuB,OAAO,GAAO,ECF9D,IAAI6mI,EAAsBN,EAAoB,O","sources":["webpack://roosterjs/./node_modules/color-convert/conversions.js","webpack://roosterjs/./node_modules/color-convert/index.js","webpack://roosterjs/./node_modules/color-convert/route.js","webpack://roosterjs/./node_modules/color-name/index.js","webpack://roosterjs/./node_modules/color-string/index.js","webpack://roosterjs/./node_modules/color/index.js","webpack://roosterjs/./node_modules/is-arrayish/index.js","webpack://roosterjs/./node_modules/simple-swizzle/index.js","webpack://roosterjs/./packages/roosterjs-color-utils/lib/index.ts","webpack://roosterjs/./packages/roosterjs-color-utils/lib/utils/getDarkColor.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/block/setModelAlignment.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/block/setModelDirection.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/block/setModelIndentation.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/block/splitSelectedParagraphByBr.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/block/toggleModelBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/common/adjustIndentation.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/common/clearModelFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/common/queryContentModelBlocks.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/common/reducedModelChildProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/common/wrapBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/entity/insertEntityModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/image/applyImageBorderFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/link/getLinkUrl.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/link/matchLink.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/link/promoteLink.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/list/findListItemsInSameThread.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/list/getListAnnounceData.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/list/setListType.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/list/setModelListStartNumber.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/list/setModelListStyle.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/selection/adjustSegmentSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/selection/adjustTrailingSpaceSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/selection/adjustWordSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/selection/collapseTableSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/alignTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/alignTableCell.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/canMergeCells.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/clearSelectedCells.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/copyPreviousCellSegmentFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/createTableStructure.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/deleteTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/deleteTableColumn.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/deleteTableRow.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/ensureFocusableParagraphForTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/insertTableColumn.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/insertTableRow.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/mergeTableCells.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/mergeTableColumn.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/mergeTableRow.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/splitTableCellHorizontally.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/modelApi/table/splitTableCellVertically.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/block/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/block/setDirection.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/block/setHeadingLevel.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/block/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/block/setParagraphMargin.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/block/setSpacing.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/block/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/entity/insertEntity.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/image/adjustImageSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/image/changeImage.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/image/insertImage.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/image/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/image/setImageBorder.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/image/setImageBoxShadow.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/link/adjustLinkSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/link/insertLink.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/link/removeLink.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/list/setListStartNumber.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/list/setListStyle.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/list/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/list/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/applySegmentFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/changeCapitalization.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/setFontName.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/splitTextSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/toggleCode.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/segment/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/table/applyTableBorderFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/table/setTableCellShade.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/utils/createEditorContextForEntity.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/utils/formatImageWithContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/utils/formatInsertPointWithContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/utils/formatParagraphWithContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/utils/formatSegmentWithContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/utils/formatTableWithContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-api/lib/publicApi/utils/formatTextSegmentBeforeSelectionMarker.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/createModelFromHtml/convertInlineCss.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/createModelFromHtml/createDomToModelContextForSanitizing.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/createModelFromHtml/createModelFromHtml.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/createModelFromHtml/sanitizeElement.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/cutCopy/adjustImageSelectionOnSafari.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/cutCopy/adjustSelectionForCopyCut.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/cutCopy/getContentForCopy.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/cutCopy/preprocessTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/cutCopy/pruneUnselectedModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/exportContent/exportContent.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/paste/cleanHtmlComments.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/paste/createPasteFragment.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/paste/generatePasteOptionFromPlugins.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/paste/mergePasteContent.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/paste/paste.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/paste/retrieveHtmlInfo.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/redo/redo.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/command/undo/undo.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/addUndoSnapshot/addUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/addUndoSnapshot/createSnapshotSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/addUndoSnapshot/getPath.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/announce/announce.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/attachDomEvent/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/coreApiMap.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/createContentModel/createContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/createEditorContext/createEditorContext.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/createEditorContext/getRootComputedStyleForContext.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/focus/focus.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/formatContentModel/formatContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/formatContentModel/scrollCaretIntoView.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/getDOMSelection/getDOMSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/getVisibleViewport/getVisibleViewport.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/restoreUndoSnapshot/getPositionFromPath.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/restoreUndoSnapshot/restoreSnapshotColors.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/restoreUndoSnapshot/restoreSnapshotHTML.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/restoreUndoSnapshot/restoreSnapshotLogicalRoot.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/restoreUndoSnapshot/restoreSnapshotSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/restoreUndoSnapshot/restoreUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setContentModel/setContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setDOMSelection/addRangeToSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setDOMSelection/findLastedCoInMergedCell.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setDOMSelection/findTableCellElement.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setDOMSelection/setDOMSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setDOMSelection/toggleCaret.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setEditorStyle/ensureUniqueId.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setEditorStyle/setEditorStyle.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/setLogicalRoot/setLogicalRoot.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/switchShadowEdit/switchShadowEdit.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/coreApi/triggerEvent/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/cache/CachePlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/cache/ParagraphMapImpl.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/cache/areSameSelections.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/cache/domIndexerImpl.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/cache/textMutationObserver.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/cache/updateCache.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/contextMenu/ContextMenuPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/copyPaste/CopyPastePlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/copyPaste/utils/deleteEmptyList.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/createEditorCorePlugins.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/domEvent/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/entity/EntityPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/entity/adjustSelectionAroundEntity.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/entity/entityDelimiterUtils.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/entity/findAllEntities.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/format/FormatPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/format/applyDefaultFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/format/applyPendingFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/lifecycle/LifecyclePlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/selection/SelectionPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/selection/findCoordinate.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/selection/isSingleImageInSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/selection/normalizePos.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/undo/SnapshotsManagerImpl.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/corePlugin/undo/UndoPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/editor/core/DOMHelperImpl.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/editor/core/DarkColorHandlerImpl.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/editor/core/createEditorCore.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/editor/core/createEditorDefaultSettings.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/override/containerSizeFormatParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/override/listMetadataApplier.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/override/pasteCopyBlockEntityParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/override/pasteDisplayFormatParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/override/pasteEntityProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/override/pasteGeneralProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/override/pasteTextProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/override/pasteWhiteSpaceFormatParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/utils/createAriaLiveElement.ts","webpack://roosterjs/./packages/roosterjs-content-model-core/lib/utils/domCreator.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/config/defaultContentModelFormatMap.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/config/defaultHTMLStyleMap.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/constants/BulletListType.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/constants/ChangeSource.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/constants/EmptySegmentFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/constants/NumberingListType.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/constants/OrderedListStyleMap.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/constants/TableBorderFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/constants/UnorderedListStyleMap.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/context/createDomToModelContext.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/context/defaultProcessors.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/domToContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/blockProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/brProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/childProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/codeProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/delimiterProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/elementProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/entityProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/fontProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/formatContainerProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/generalProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/headingProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/hrProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/imageProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/knownElementProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/linkProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/listItemProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/listProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/pProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/tableProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/textProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/processors/textWithSelectionProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/addSelectionMarker.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/areSameFormats.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/buildSelectionMarker.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/getBoundingClientRect.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/getDefaultStyle.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/getRegularSelectionOffsets.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/parseFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domToModel/utils/stackFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/entityUtils.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/event/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/event/eventUtils.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/event/extractClipboardItems.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/getObjectKeys.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/getRangesByText.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/getSafeIdSelector.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/hiddenProperties/hiddenProperty.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/hiddenProperties/imageState.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/hiddenProperties/paragraphMarker.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/hiddenProperties/undeletableLink.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/isElementOfType.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/isGenericRoleElement.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/isNodeOfType.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/isWhiteSpacePreserved.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/moveChildNodes.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/normalizeRect.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/readFile.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/retrieveDocumentMetadata.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/reuseCachedElement.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/scrollRectIntoView.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/selection/getDOMInsertPointRect.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/selection/getSelectionRootNode.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/stringUtil.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/style/borderValues.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/style/isBold.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/style/normalizeFontFamily.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/style/transformColor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/table/parseTableCells.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/toArray.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/domUtils/wrap.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/directionFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/displayFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/htmlAlignFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/lineHeightFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/marginFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/paddingFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/textAlignFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/textIndentFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/block/whiteSpaceFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/ariaFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/backgroundColorFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/borderBoxFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/borderColorFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/borderFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/boxShadowFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/datasetFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/floatFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/idFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/roleFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/sizeFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/verticalAlignFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/common/wordBreakFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/defaultFormatHandlers.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/entity/entityFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/list/listItemAlignFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/list/listItemThreadFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/list/listLevelThreadFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/list/listStyleFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/boldFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/fontFamilyFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/fontSizeFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/imageStateFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/italicFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/letterSpacingFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/linkFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/strikeFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/superOrSubScriptFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/textColorFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/undeletableLinkFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/segment/underlineFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/table/legacyTableBorderFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/table/tableLayoutFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/table/tableSpacingFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/table/textColorOnTableCellFormatHandler.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/utils/borderKeys.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/utils/color.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/utils/dir.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/utils/parseValueWithUnit.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/formatHandlers/utils/shouldSetValue.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/block/copyFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/block/setParagraphNotImplicit.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/addBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/addDecorators.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/addSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/addTextSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/ensureParagraph.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/hasSpacesOnly.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/isEmpty.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/mergeTextSegments.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/mutate.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/normalizeContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/normalizeParagraph.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/normalizeSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/normalizeSegmentFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/common/unwrapBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createBr.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createContentModelDocument.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createDivider.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createEmptyModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createEntity.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createFormatContainer.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createGeneralBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createGeneralSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createImage.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createListItem.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createListLevel.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createParagraph.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createParagraphDecorator.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createSelectionMarker.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createTableCell.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createTableRow.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/creators/createText.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/applyTableFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/cloneModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/deleteBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/deleteExpandedSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/deleteSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/deleteSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/deleteSingleChar.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/getClosestAncestorBlockGroupIndex.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/getListStyleTypeFromString.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/getSegmentTextFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/mergeModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/normalizeTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/retrieveModelFormatState.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/runEditSteps.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/editing/setTableCellBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/list/getAutoListStyleType.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/list/getOrderedListNumberStr.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/metadata/definitionCreators.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/metadata/updateImageMetadata.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/metadata/updateListMetadata.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/metadata/updateMetadata.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/metadata/updateTableCellMetadata.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/metadata/updateTableMetadata.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/metadata/validate.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/selection/collectSelections.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/selection/getSelectedCells.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/selection/hasSelectionInBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/selection/hasSelectionInBlockGroup.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/selection/hasSelectionInSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/selection/iterateSelections.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/selection/setSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/typeCheck/isBlockGroupOfType.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelApi/typeCheck/isGeneralSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/contentModelToDom.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/context/createModelToDomContext.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/context/defaultContentModelHandlers.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleBlockGroupChildren.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleBr.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleDivider.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleEntity.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleFormatContainer.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleGeneralModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleImage.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleList.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleListItem.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleParagraph.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleSegmentDecorator.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/handlers/handleText.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/optimizers/mergeNode.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/optimizers/optimize.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/optimizers/removeUnnecessarySpan.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/utils/applyMetadata.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/utils/cleanUpRestNodes.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/utils/handleSegmentCommon.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToDom/utils/stackFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-dom/lib/modelToText/contentModelToText.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/constants/headings.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/index.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/appliers/applyLink.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/appliers/applySegmentFormatting.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/appliers/applyTextFormatting.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/convertMarkdownToContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/creators/createBlockGroupFromMarkdown.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/creators/createBlockQuoteFromMarkdown.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/creators/createImageSegment.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/creators/createListFromMarkdown.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/creators/createParagraphFromMarkdown.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/creators/createTableFromMarkdown.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/processor/markdownProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/utils/adjustHeading.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/utils/getHeadingDecorator.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/utils/isMarkdownTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/markdownToModel/utils/splitParagraphSegments.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/modelToMarkdown/convertContentModelToMarkdown.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/modelToMarkdown/creators/createMarkdownBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/modelToMarkdown/creators/createMarkdownBlockGroup.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/modelToMarkdown/creators/createMarkdownParagraph.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/modelToMarkdown/creators/createMarkdownTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-markdown/lib/modelToMarkdown/processor/modelProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/announce/AnnouncePlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/announce/tableSelectionUtils.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/AutoFormatPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/horizontalLine/checkAndInsertHorizontalLine.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/hyphen/transformHyphen.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/link/createLink.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/link/unlink.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/list/convertAlphaToDecimals.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/list/getIndex.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/list/getListTypeStyle.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/list/getNumberingListStyle.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/list/keyboardListTrigger.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/numbers/transformFraction.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/autoFormat/numbers/transformOrdinals.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/contextMenuBase/ContextMenuPluginBase.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/customReplace/CustomReplacePlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteAllSegmentBefore.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteCollapsedSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteEmptyQuote.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteList.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteParagraphStyle.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteWordSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/handleKeyboardEventCommon.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/inputSteps/handleAutoLink.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/inputSteps/handleEnterOnList.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/inputSteps/handleEnterOnParagraph.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/keyboardDelete.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/keyboardEnter.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/keyboardInput.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/keyboardTab.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/tabUtils/handleTabOnList.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/tabUtils/handleTabOnParagraph.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/tabUtils/handleTabOnTable.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/tabUtils/handleTabOnTableCell.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/utils/getLeafSiblingBlock.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/utils/preserveParagraphFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/edit/utils/splitParagraph.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/FindReplacePlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/createFindReplaceContext.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/find.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/moveHighlight.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/replace.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/utils/HighlightHelperImpl.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/utils/constants.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/utils/replaceTextInRange.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/utils/setMarkedIndex.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/utils/sortRanges.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/findReplace/utils/updateHighlight.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/hiddenProperty/HiddenPropertyPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/hiddenProperty/fixupHiddenProperties.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/hyperlink/HyperlinkPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/Cropper/createImageCropper.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/Cropper/cropperContext.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/ImageEditPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/Resizer/createImageResizer.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/Resizer/resizerContext.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/Resizer/updateSideHandlesVisibility.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/Rotator/createImageRotator.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/Rotator/rotatorContext.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/Rotator/updateRotateHandle.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/constants/constants.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/types/ImageEditElementClass.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/applyChange.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/canRegenerateImage.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/checkEditInfoState.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/createImageWrapper.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/doubleCheckResize.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/filterInnerResizerHandles.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/findEditingImage.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/generateDataURL.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/generateImageSize.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/getDropAndDragHelpers.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/getHTMLImageOptions.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/getSelectedImage.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/imageEditUtils.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/normalizeImageSelection.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/updateHandleCursor.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/updateImageEditInfo.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/imageEdit/utils/updateWrapper.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/markdown/MarkdownPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/markdown/utils/setFormat.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/DefaultSanitizers.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/Excel/processPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/PastePlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/PowerPoint/processPastedContentFromPowerPoint.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/WacComponents/constants.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/WacComponents/processPastedContentWacComponents.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/WordDesktop/getStyleMetadata.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/WordDesktop/processPastedContentFromWordDesktop.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/WordDesktop/processWordComments.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/WordDesktop/processWordLists.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/oneNote/processPastedContentFromOneNote.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/adjustPercentileLineHeightParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/blockElementParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/deprecatedColorParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/imageSizeParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/linkParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/listLevelParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/removeNegativeTextIndentParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/tableBorderParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/wordContainerParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/parsers/wordTableParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/constants.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/documentContainWacElements.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/getDocumentSource.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isExcelDesktopDocument.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isExcelNonNativeEvent.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isExcelOnlineDocument.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isGoogleSheetDocument.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isOneNoteDocument.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isPowerPointDesktopDocument.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isWordDesktopDocument.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/shouldConvertToSingleImage.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/processors/pasteButtonProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/utils/addParser.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/utils/chainSanitizerCallback.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/utils/customListUtils.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/utils/getStyles.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/paste/utils/setProcessor.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/picker/PickerHelperImpl.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/picker/PickerPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/picker/getQueryString.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/pluginUtils/CreateElement/createElement.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/pluginUtils/DragAndDrop/DragAndDropHelper.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/pluginUtils/Rect/getIntersectedRect.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/shortcut/ShortcutPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/shortcut/shortcuts.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/shortcut/utils/setShortcutIndentationCommand.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/TableEditPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/editors/TableEditor.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/editors/features/CellResizer.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/editors/features/TableEditFeature.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/editors/features/TableInserter.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/editors/features/TableMover.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/editors/features/TableResizer.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/editors/features/TableRowColumnSelector.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/tableEdit/editors/utils/getTableFromContentModel.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/touch/TouchPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/utils/getNodePositionFromEvent.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/watermark/WatermarkPlugin.ts","webpack://roosterjs/./packages/roosterjs-content-model-plugins/lib/watermark/isModelEmptyFast.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./node_modules/tslib/tslib.es6.mjs","webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/webpack/runtime/define property getters","webpack://roosterjs/webpack/runtime/hasOwnProperty shorthand","webpack://roosterjs/webpack/runtime/make namespace object","webpack://roosterjs/webpack/startup"],"sourcesContent":["/* MIT license */\nvar cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n","var conversions = require('./conversions');\nvar route = require('./route');\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n","var conversions = require('./conversions');\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n","'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n","/* MIT license */\nvar colorNames = require('color-name');\nvar swizzle = require('simple-swizzle');\n\nvar reverseNames = {};\n\n// create a list of reverse color names\nfor (var name in colorNames) {\n\tif (colorNames.hasOwnProperty(name)) {\n\t\treverseNames[colorNames[name]] = name;\n\t}\n}\n\nvar cs = module.exports = {\n\tto: {},\n\tget: {}\n};\n\ncs.get = function (string) {\n\tvar prefix = string.substring(0, 3).toLowerCase();\n\tvar val;\n\tvar model;\n\tswitch (prefix) {\n\t\tcase 'hsl':\n\t\t\tval = cs.get.hsl(string);\n\t\t\tmodel = 'hsl';\n\t\t\tbreak;\n\t\tcase 'hwb':\n\t\t\tval = cs.get.hwb(string);\n\t\t\tmodel = 'hwb';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = cs.get.rgb(string);\n\t\t\tmodel = 'rgb';\n\t\t\tbreak;\n\t}\n\n\tif (!val) {\n\t\treturn null;\n\t}\n\n\treturn {model: model, value: val};\n};\n\ncs.get.rgb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar abbr = /^#([a-f0-9]{3,4})$/i;\n\tvar hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;\n\tvar rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar keyword = /(\\D+)/;\n\n\tvar rgb = [0, 0, 0, 1];\n\tvar match;\n\tvar i;\n\tvar hexAlpha;\n\n\tif (match = string.match(hex)) {\n\t\thexAlpha = match[2];\n\t\tmatch = match[1];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19\n\t\t\tvar i2 = i * 2;\n\t\t\trgb[i] = parseInt(match.slice(i2, i2 + 2), 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = parseInt(hexAlpha, 16) / 255;\n\t\t}\n\t} else if (match = string.match(abbr)) {\n\t\tmatch = match[1];\n\t\thexAlpha = match[3];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i] + match[i], 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;\n\t\t}\n\t} else if (match = string.match(rgba)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i + 1], 0);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\trgb[3] = parseFloat(match[4]);\n\t\t}\n\t} else if (match = string.match(per)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\trgb[3] = parseFloat(match[4]);\n\t\t}\n\t} else if (match = string.match(keyword)) {\n\t\tif (match[1] === 'transparent') {\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\n\t\trgb = colorNames[match[1]];\n\n\t\tif (!rgb) {\n\t\t\treturn null;\n\t\t}\n\n\t\trgb[3] = 1;\n\n\t\treturn rgb;\n\t} else {\n\t\treturn null;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\trgb[i] = clamp(rgb[i], 0, 255);\n\t}\n\trgb[3] = clamp(rgb[3], 0, 1);\n\n\treturn rgb;\n};\n\ncs.get.hsl = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hsl = /^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar match = string.match(hsl);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = (parseFloat(match[1]) + 360) % 360;\n\t\tvar s = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar l = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\n\t\treturn [h, s, l, a];\n\t}\n\n\treturn null;\n};\n\ncs.get.hwb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hwb = /^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar match = string.match(hwb);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar w = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar b = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t\treturn [h, w, b, a];\n\t}\n\n\treturn null;\n};\n\ncs.to.hex = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn (\n\t\t'#' +\n\t\thexDouble(rgba[0]) +\n\t\thexDouble(rgba[1]) +\n\t\thexDouble(rgba[2]) +\n\t\t(rgba[3] < 1\n\t\t\t? (hexDouble(Math.round(rgba[3] * 255)))\n\t\t\t: '')\n\t);\n};\n\ncs.to.rgb = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'\n\t\t: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';\n};\n\ncs.to.rgb.percent = function () {\n\tvar rgba = swizzle(arguments);\n\n\tvar r = Math.round(rgba[0] / 255 * 100);\n\tvar g = Math.round(rgba[1] / 255 * 100);\n\tvar b = Math.round(rgba[2] / 255 * 100);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'\n\t\t: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';\n};\n\ncs.to.hsl = function () {\n\tvar hsla = swizzle(arguments);\n\treturn hsla.length < 4 || hsla[3] === 1\n\t\t? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'\n\t\t: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';\n};\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\ncs.to.hwb = function () {\n\tvar hwba = swizzle(arguments);\n\n\tvar a = '';\n\tif (hwba.length >= 4 && hwba[3] !== 1) {\n\t\ta = ', ' + hwba[3];\n\t}\n\n\treturn 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';\n};\n\ncs.to.keyword = function (rgb) {\n\treturn reverseNames[rgb.slice(0, 3)];\n};\n\n// helpers\nfunction clamp(num, min, max) {\n\treturn Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n\tvar str = num.toString(16).toUpperCase();\n\treturn (str.length < 2) ? '0' + str : str;\n}\n","'use strict';\n\nvar colorString = require('color-string');\nvar convert = require('color-convert');\n\nvar _slice = [].slice;\n\nvar skippedModels = [\n\t// to be honest, I don't really feel like keyword belongs in color convert, but eh.\n\t'keyword',\n\n\t// gray conflicts with some method names, and has its own method defined.\n\t'gray',\n\n\t// shouldn't really be in color-convert either...\n\t'hex'\n];\n\nvar hashedModelKeys = {};\nObject.keys(convert).forEach(function (model) {\n\thashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;\n});\n\nvar limiters = {};\n\nfunction Color(obj, model) {\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj, model);\n\t}\n\n\tif (model && model in skippedModels) {\n\t\tmodel = null;\n\t}\n\n\tif (model && !(model in convert)) {\n\t\tthrow new Error('Unknown model: ' + model);\n\t}\n\n\tvar i;\n\tvar channels;\n\n\tif (obj == null) { // eslint-disable-line no-eq-null,eqeqeq\n\t\tthis.model = 'rgb';\n\t\tthis.color = [0, 0, 0];\n\t\tthis.valpha = 1;\n\t} else if (obj instanceof Color) {\n\t\tthis.model = obj.model;\n\t\tthis.color = obj.color.slice();\n\t\tthis.valpha = obj.valpha;\n\t} else if (typeof obj === 'string') {\n\t\tvar result = colorString.get(obj);\n\t\tif (result === null) {\n\t\t\tthrow new Error('Unable to parse color from string: ' + obj);\n\t\t}\n\n\t\tthis.model = result.model;\n\t\tchannels = convert[this.model].channels;\n\t\tthis.color = result.value.slice(0, channels);\n\t\tthis.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n\t} else if (obj.length) {\n\t\tthis.model = model || 'rgb';\n\t\tchannels = convert[this.model].channels;\n\t\tvar newArr = _slice.call(obj, 0, channels);\n\t\tthis.color = zeroArray(newArr, channels);\n\t\tthis.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;\n\t} else if (typeof obj === 'number') {\n\t\t// this is always RGB - can be converted later on.\n\t\tobj &= 0xFFFFFF;\n\t\tthis.model = 'rgb';\n\t\tthis.color = [\n\t\t\t(obj >> 16) & 0xFF,\n\t\t\t(obj >> 8) & 0xFF,\n\t\t\tobj & 0xFF\n\t\t];\n\t\tthis.valpha = 1;\n\t} else {\n\t\tthis.valpha = 1;\n\n\t\tvar keys = Object.keys(obj);\n\t\tif ('alpha' in obj) {\n\t\t\tkeys.splice(keys.indexOf('alpha'), 1);\n\t\t\tthis.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;\n\t\t}\n\n\t\tvar hashedKeys = keys.sort().join('');\n\t\tif (!(hashedKeys in hashedModelKeys)) {\n\t\t\tthrow new Error('Unable to parse color from object: ' + JSON.stringify(obj));\n\t\t}\n\n\t\tthis.model = hashedModelKeys[hashedKeys];\n\n\t\tvar labels = convert[this.model].labels;\n\t\tvar color = [];\n\t\tfor (i = 0; i < labels.length; i++) {\n\t\t\tcolor.push(obj[labels[i]]);\n\t\t}\n\n\t\tthis.color = zeroArray(color);\n\t}\n\n\t// perform limitations (clamping, etc.)\n\tif (limiters[this.model]) {\n\t\tchannels = convert[this.model].channels;\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tvar limit = limiters[this.model][i];\n\t\t\tif (limit) {\n\t\t\t\tthis.color[i] = limit(this.color[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.valpha = Math.max(0, Math.min(1, this.valpha));\n\n\tif (Object.freeze) {\n\t\tObject.freeze(this);\n\t}\n}\n\nColor.prototype = {\n\ttoString: function () {\n\t\treturn this.string();\n\t},\n\n\ttoJSON: function () {\n\t\treturn this[this.model]();\n\t},\n\n\tstring: function (places) {\n\t\tvar self = this.model in colorString.to ? this : this.rgb();\n\t\tself = self.round(typeof places === 'number' ? places : 1);\n\t\tvar args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to[self.model](args);\n\t},\n\n\tpercentString: function (places) {\n\t\tvar self = this.rgb().round(typeof places === 'number' ? places : 1);\n\t\tvar args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to.rgb.percent(args);\n\t},\n\n\tarray: function () {\n\t\treturn this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);\n\t},\n\n\tobject: function () {\n\t\tvar result = {};\n\t\tvar channels = convert[this.model].channels;\n\t\tvar labels = convert[this.model].labels;\n\n\t\tfor (var i = 0; i < channels; i++) {\n\t\t\tresult[labels[i]] = this.color[i];\n\t\t}\n\n\t\tif (this.valpha !== 1) {\n\t\t\tresult.alpha = this.valpha;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tunitArray: function () {\n\t\tvar rgb = this.rgb().color;\n\t\trgb[0] /= 255;\n\t\trgb[1] /= 255;\n\t\trgb[2] /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.push(this.valpha);\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tunitObject: function () {\n\t\tvar rgb = this.rgb().object();\n\t\trgb.r /= 255;\n\t\trgb.g /= 255;\n\t\trgb.b /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.alpha = this.valpha;\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tround: function (places) {\n\t\tplaces = Math.max(places || 0, 0);\n\t\treturn new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);\n\t},\n\n\talpha: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);\n\t\t}\n\n\t\treturn this.valpha;\n\t},\n\n\t// rgb\n\tred: getset('rgb', 0, maxfn(255)),\n\tgreen: getset('rgb', 1, maxfn(255)),\n\tblue: getset('rgb', 2, maxfn(255)),\n\n\thue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style\n\n\tsaturationl: getset('hsl', 1, maxfn(100)),\n\tlightness: getset('hsl', 2, maxfn(100)),\n\n\tsaturationv: getset('hsv', 1, maxfn(100)),\n\tvalue: getset('hsv', 2, maxfn(100)),\n\n\tchroma: getset('hcg', 1, maxfn(100)),\n\tgray: getset('hcg', 2, maxfn(100)),\n\n\twhite: getset('hwb', 1, maxfn(100)),\n\twblack: getset('hwb', 2, maxfn(100)),\n\n\tcyan: getset('cmyk', 0, maxfn(100)),\n\tmagenta: getset('cmyk', 1, maxfn(100)),\n\tyellow: getset('cmyk', 2, maxfn(100)),\n\tblack: getset('cmyk', 3, maxfn(100)),\n\n\tx: getset('xyz', 0, maxfn(100)),\n\ty: getset('xyz', 1, maxfn(100)),\n\tz: getset('xyz', 2, maxfn(100)),\n\n\tl: getset('lab', 0, maxfn(100)),\n\ta: getset('lab', 1),\n\tb: getset('lab', 2),\n\n\tkeyword: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(val);\n\t\t}\n\n\t\treturn convert[this.model].keyword(this.color);\n\t},\n\n\thex: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(val);\n\t\t}\n\n\t\treturn colorString.to.hex(this.rgb().round().color);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.rgb().color;\n\t\treturn ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.rgb().color;\n\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tisDark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.rgb().color;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tisLight: function () {\n\t\treturn !this.isDark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = this.rgb();\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb.color[i] = 255 - rgb.color[i];\n\t\t}\n\t\treturn rgb;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[2] += hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[2] -= hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[1] += hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[1] -= hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.hwb();\n\t\thwb.color[1] += hwb.color[1] * ratio;\n\t\treturn hwb;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.hwb();\n\t\thwb.color[2] += hwb.color[2] * ratio;\n\t\treturn hwb;\n\t},\n\n\tgrayscale: function () {\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar rgb = this.rgb().color;\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\treturn Color.rgb(val, val, val);\n\t},\n\n\tfade: function (ratio) {\n\t\treturn this.alpha(this.valpha - (this.valpha * ratio));\n\t},\n\n\topaquer: function (ratio) {\n\t\treturn this.alpha(this.valpha + (this.valpha * ratio));\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.hsl();\n\t\tvar hue = hsl.color[0];\n\t\thue = (hue + degrees) % 360;\n\t\thue = hue < 0 ? 360 + hue : hue;\n\t\thsl.color[0] = hue;\n\t\treturn hsl;\n\t},\n\n\tmix: function (mixinColor, weight) {\n\t\t// ported from sass implementation in C\n\t\t// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\tif (!mixinColor || !mixinColor.rgb) {\n\t\t\tthrow new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n\t\t}\n\t\tvar color1 = mixinColor.rgb();\n\t\tvar color2 = this.rgb();\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn Color.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue(),\n\t\t\t\tcolor1.alpha() * p + color2.alpha() * (1 - p));\n\t}\n};\n\n// model conversion methods and static constructors\nObject.keys(convert).forEach(function (model) {\n\tif (skippedModels.indexOf(model) !== -1) {\n\t\treturn;\n\t}\n\n\tvar channels = convert[model].channels;\n\n\t// conversion methods\n\tColor.prototype[model] = function () {\n\t\tif (this.model === model) {\n\t\t\treturn new Color(this);\n\t\t}\n\n\t\tif (arguments.length) {\n\t\t\treturn new Color(arguments, model);\n\t\t}\n\n\t\tvar newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;\n\t\treturn new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);\n\t};\n\n\t// 'static' construction methods\n\tColor[model] = function (color) {\n\t\tif (typeof color === 'number') {\n\t\t\tcolor = zeroArray(_slice.call(arguments), channels);\n\t\t}\n\t\treturn new Color(color, model);\n\t};\n});\n\nfunction roundTo(num, places) {\n\treturn Number(num.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n\treturn function (num) {\n\t\treturn roundTo(num, places);\n\t};\n}\n\nfunction getset(model, channel, modifier) {\n\tmodel = Array.isArray(model) ? model : [model];\n\n\tmodel.forEach(function (m) {\n\t\t(limiters[m] || (limiters[m] = []))[channel] = modifier;\n\t});\n\n\tmodel = model[0];\n\n\treturn function (val) {\n\t\tvar result;\n\n\t\tif (arguments.length) {\n\t\t\tif (modifier) {\n\t\t\t\tval = modifier(val);\n\t\t\t}\n\n\t\t\tresult = this[model]();\n\t\t\tresult.color[channel] = val;\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this[model]().color[channel];\n\t\tif (modifier) {\n\t\t\tresult = modifier(result);\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nfunction maxfn(max) {\n\treturn function (v) {\n\t\treturn Math.max(0, Math.min(max, v));\n\t};\n}\n\nfunction assertArray(val) {\n\treturn Array.isArray(val) ? val : [val];\n}\n\nfunction zeroArray(arr, length) {\n\tfor (var i = 0; i < length; i++) {\n\t\tif (typeof arr[i] !== 'number') {\n\t\t\tarr[i] = 0;\n\t\t}\n\t}\n\n\treturn arr;\n}\n\nmodule.exports = Color;\n","module.exports = function isArrayish(obj) {\n\tif (!obj || typeof obj === 'string') {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && (obj.splice instanceof Function ||\n\t\t\t(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));\n};\n","'use strict';\n\nvar isArrayish = require('is-arrayish');\n\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\n\nvar swizzle = module.exports = function swizzle(args) {\n\tvar results = [];\n\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tvar arg = args[i];\n\n\t\tif (isArrayish(arg)) {\n\t\t\t// http://jsperf.com/javascript-array-concat-vs-push/98\n\t\t\tresults = concat.call(results, slice.call(arg));\n\t\t} else {\n\t\t\tresults.push(arg);\n\t\t}\n\t}\n\n\treturn results;\n};\n\nswizzle.wrap = function (fn) {\n\treturn function () {\n\t\treturn fn(swizzle(arguments));\n\t};\n};\n","export { default as getDarkColor } from './utils/getDarkColor';\n","import * as Color from 'color';\n\nconst DefaultBaseLValue = 21.247; // L-value of #333333\n\n/**\n * Get dark mode color for a given color\n * @param color The color to calculate from\n * @param baseLValue The Light value for base dark color in LAB format. @default the Light value for #333333\n */\nexport default function getDarkColor(\n    color: string,\n    baseLValue: number = DefaultBaseLValue\n): string {\n    try {\n        const computedColor = Color(color || undefined);\n        const colorLab = computedColor.lab().array();\n        const newLValue = (100 - colorLab[0]) * ((100 - baseLValue) / 100) + baseLValue;\n        color = Color.lab(newLValue, colorLab[1], colorLab[2])\n            .rgb()\n            .alpha(computedColor.alpha())\n            .toString();\n    } catch {}\n\n    return color;\n}\n","export { insertTable } from './publicApi/table/insertTable';\nexport { formatTable } from './publicApi/table/formatTable';\nexport { setTableCellShade } from './publicApi/table/setTableCellShade';\nexport { editTable } from './publicApi/table/editTable';\nexport { applyTableBorderFormat } from './publicApi/table/applyTableBorderFormat';\nexport { toggleBullet } from './publicApi/list/toggleBullet';\nexport { toggleNumbering } from './publicApi/list/toggleNumbering';\nexport { toggleBold } from './publicApi/segment/toggleBold';\nexport { toggleItalic } from './publicApi/segment/toggleItalic';\nexport { toggleUnderline } from './publicApi/segment/toggleUnderline';\nexport { toggleStrikethrough } from './publicApi/segment/toggleStrikethrough';\nexport { toggleSubscript } from './publicApi/segment/toggleSubscript';\nexport { toggleSuperscript } from './publicApi/segment/toggleSuperscript';\nexport { setBackgroundColor } from './publicApi/segment/setBackgroundColor';\nexport { setFontName } from './publicApi/segment/setFontName';\nexport { setFontSize } from './publicApi/segment/setFontSize';\nexport { setTextColor } from './publicApi/segment/setTextColor';\nexport { changeFontSize } from './publicApi/segment/changeFontSize';\nexport { applySegmentFormat } from './publicApi/segment/applySegmentFormat';\nexport { changeCapitalization } from './publicApi/segment/changeCapitalization';\nexport { splitTextSegment } from './publicApi/segment/splitTextSegment';\nexport { insertImage } from './publicApi/image/insertImage';\nexport { setListStyle } from './publicApi/list/setListStyle';\nexport { setListStartNumber } from './publicApi/list/setListStartNumber';\nexport { setIndentation } from './publicApi/block/setIndentation';\nexport { setAlignment } from './publicApi/block/setAlignment';\nexport { setDirection } from './publicApi/block/setDirection';\nexport { setHeadingLevel } from './publicApi/block/setHeadingLevel';\nexport { toggleBlockQuote } from './publicApi/block/toggleBlockQuote';\nexport { setSpacing } from './publicApi/block/setSpacing';\nexport { setImageBorder } from './publicApi/image/setImageBorder';\nexport { setImageBoxShadow } from './publicApi/image/setImageBoxShadow';\nexport { changeImage } from './publicApi/image/changeImage';\nexport { getFormatState } from './publicApi/format/getFormatState';\nexport { clearFormat } from './publicApi/format/clearFormat';\nexport { insertLink } from './publicApi/link/insertLink';\nexport { removeLink } from './publicApi/link/removeLink';\nexport { adjustLinkSelection } from './publicApi/link/adjustLinkSelection';\nexport { setImageAltText } from './publicApi/image/setImageAltText';\nexport { adjustImageSelection } from './publicApi/image/adjustImageSelection';\nexport { setParagraphMargin } from './publicApi/block/setParagraphMargin';\nexport { toggleCode } from './publicApi/segment/toggleCode';\nexport { insertEntity } from './publicApi/entity/insertEntity';\nexport { insertTableRow } from './modelApi/table/insertTableRow';\nexport { insertTableColumn } from './modelApi/table/insertTableColumn';\nexport { clearSelectedCells } from './modelApi/table/clearSelectedCells';\n\nexport { createEditorContextForEntity } from './publicApi/utils/createEditorContextForEntity';\nexport { formatTableWithContentModel } from './publicApi/utils/formatTableWithContentModel';\nexport { formatImageWithContentModel } from './publicApi/utils/formatImageWithContentModel';\nexport { formatParagraphWithContentModel } from './publicApi/utils/formatParagraphWithContentModel';\nexport { formatSegmentWithContentModel } from './publicApi/utils/formatSegmentWithContentModel';\nexport { formatTextSegmentBeforeSelectionMarker } from './publicApi/utils/formatTextSegmentBeforeSelectionMarker';\nexport { formatInsertPointWithContentModel } from './publicApi/utils/formatInsertPointWithContentModel';\n\nexport { setListType } from './modelApi/list/setListType';\nexport { setModelListStyle } from './modelApi/list/setModelListStyle';\nexport { setModelListStartNumber } from './modelApi/list/setModelListStartNumber';\nexport { findListItemsInSameThread } from './modelApi/list/findListItemsInSameThread';\nexport { setModelIndentation } from './modelApi/block/setModelIndentation';\nexport { matchLink } from './modelApi/link/matchLink';\nexport { promoteLink, getPromoteLink } from './modelApi/link/promoteLink';\nexport { getListAnnounceData } from './modelApi/list/getListAnnounceData';\nexport { queryContentModelBlocks } from './modelApi/common/queryContentModelBlocks';\nexport { adjustWordSelection } from './modelApi/selection/adjustWordSelection';\n","import { alignTable } from '../table/alignTable';\nimport { getOperationalBlocks, mutateBlock } from 'roosterjs-content-model-dom';\nimport { splitSelectedParagraphByBr } from './splitSelectedParagraphByBr';\nimport type {\n    ContentModelListItem,\n    ReadonlyContentModelDocument,\n    TableAlignOperation,\n} from 'roosterjs-content-model-types';\n\nconst ResultMap: Record<\n    'left' | 'center' | 'right' | 'justify',\n    Record<'ltr' | 'rtl', 'start' | 'center' | 'end' | 'justify'>\n> = {\n    left: {\n        ltr: 'start',\n        rtl: 'end',\n    },\n    center: {\n        ltr: 'center',\n        rtl: 'center',\n    },\n    right: {\n        ltr: 'end',\n        rtl: 'start',\n    },\n    justify: {\n        ltr: 'justify',\n        rtl: 'justify',\n    },\n};\n\nconst TableAlignMap: Record<\n    'left' | 'center' | 'right',\n    Record<'ltr' | 'rtl', TableAlignOperation>\n> = {\n    left: {\n        ltr: 'alignLeft',\n        rtl: 'alignRight',\n    },\n    center: {\n        ltr: 'alignCenter',\n        rtl: 'alignCenter',\n    },\n    right: {\n        ltr: 'alignRight',\n        rtl: 'alignLeft',\n    },\n};\n\n/**\n * @internal\n */\nexport function setModelAlignment(\n    model: ReadonlyContentModelDocument,\n    alignment: 'left' | 'center' | 'right' | 'justify'\n) {\n    splitSelectedParagraphByBr(model);\n\n    const paragraphOrListItemOrTable = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        ['TableCell']\n    );\n\n    paragraphOrListItemOrTable.forEach(({ block: readonlyBlock }) => {\n        const block = mutateBlock(readonlyBlock);\n        const newAlignment = ResultMap[alignment][block.format.direction == 'rtl' ? 'rtl' : 'ltr'];\n\n        if (block.blockType === 'Table' && alignment !== 'justify') {\n            alignTable(\n                block,\n                TableAlignMap[alignment][block.format.direction == 'rtl' ? 'rtl' : 'ltr']\n            );\n        } else if (block) {\n            if (block.blockType === 'BlockGroup' && block.blockGroupType === 'ListItem') {\n                block.blocks.forEach(b => {\n                    const { format } = mutateBlock(b);\n                    format.textAlign = newAlignment;\n                });\n            }\n            const { format } = block;\n            format.textAlign = newAlignment;\n        }\n    });\n\n    return paragraphOrListItemOrTable.length > 0;\n}\n","import { findListItemsInSameThread } from '../list/findListItemsInSameThread';\nimport { splitSelectedParagraphByBr } from './splitSelectedParagraphByBr';\nimport {\n    applyTableFormat,\n    getOperationalBlocks,\n    isBlockGroupOfType,\n    mutateBlock,\n    updateTableCellMetadata,\n} from 'roosterjs-content-model-dom';\nimport type {\n    BorderFormat,\n    ContentModelListItem,\n    MarginFormat,\n    PaddingFormat,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelText,\n} from 'roosterjs-content-model-types';\n\n// Regexes for character direction detection\n// Strongly typed RTL character ranges. Referenced unicode's DerivedBidiClass.txt, excluding things in the 2 bit range.\nconst RTL_CHAR_REGEX = /[\\u0590-\\u05FF\\u0600-\\u08FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFF]/g;\nconst URL_CHAR_REGEX = /http\\S+|www\\S+|https\\S+|<a\\s+(?:[^>]*?\\s+)?href=([\"']).*?\\1.*?>.*?<\\/a>/g;\nconst WHITESPACE_REGEX = /\\s/g;\n\n/**\n * @internal\n */\nexport function setModelDirection(\n    model: ReadonlyContentModelDocument,\n    direction: 'ltr' | 'rtl' | 'auto'\n) {\n    splitSelectedParagraphByBr(model);\n\n    const paragraphOrListItemOrTable = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        ['TableCell']\n    );\n\n    paragraphOrListItemOrTable.forEach(({ block }) => {\n        let calcDirection: 'ltr' | 'rtl';\n        if (direction === 'auto') {\n            calcDirection = determineTextDirection(block);\n        } else {\n            calcDirection = direction;\n        }\n        if (isBlockGroupOfType<ContentModelListItem>(block, 'ListItem')) {\n            const items = findListItemsInSameThread(model, block);\n\n            items.forEach(readonlyItem => {\n                const item = mutateBlock(readonlyItem);\n\n                item.levels.forEach(level => {\n                    level.format.direction = calcDirection;\n                });\n\n                // We already set direction on levels, no need to keep it on list item level\n                delete item.format.direction;\n\n                // Remove textAlign to let it be calculated based on direction change\n                delete item.format.textAlign;\n\n                item.blocks.forEach(block => internalSetDirection(block, calcDirection));\n            });\n        } else if (block) {\n            internalSetDirection(block, calcDirection);\n        }\n    });\n\n    return paragraphOrListItemOrTable.length > 0;\n}\n\nfunction internalSetDirection(block: ReadonlyContentModelBlock, direction: 'ltr' | 'rtl') {\n    const wasRtl = block.format.direction == 'rtl';\n    const isRtl = direction == 'rtl';\n\n    if (wasRtl != isRtl) {\n        const { format } = mutateBlock(block);\n        format.direction = direction;\n\n        // Adjust margin when change direction\n        const marginLeft = format.marginLeft;\n        const paddingLeft = format.paddingLeft;\n\n        setProperty(format, 'marginLeft', format.marginRight);\n        setProperty(format, 'marginRight', marginLeft);\n        setProperty(format, 'paddingLeft', format.paddingRight);\n        setProperty(format, 'paddingRight', paddingLeft);\n\n        // If whole Table direction changed, flip cell side borders\n        if (block && block.blockType == 'Table') {\n            block.rows.forEach(row => {\n                row.cells.forEach(cell => {\n                    // Optimise by skipping cells with unchanged borders\n                    updateTableCellMetadata(mutateBlock(cell), metadata => {\n                        if (metadata?.borderOverride) {\n                            const storeBorderLeft = cell.format.borderLeft;\n                            setProperty(cell.format, 'borderLeft', cell.format.borderRight);\n                            setProperty(cell.format, 'borderRight', storeBorderLeft);\n                        }\n                        return metadata;\n                    });\n                });\n            });\n\n            // Apply changed borders\n            applyTableFormat(block, undefined /* newFormat */, true /* keepCellShade*/);\n        }\n    }\n}\n\nfunction setProperty(\n    format: MarginFormat & PaddingFormat & BorderFormat,\n    key: keyof (MarginFormat & PaddingFormat & BorderFormat),\n    value: string | undefined\n) {\n    if (value) {\n        format[key] = value;\n    } else {\n        delete format[key];\n    }\n}\n\n// Designed to match browser's 'auto' detection, by scanning over the inner text until it hits a strong LTR/RTL character\nfunction determineTextDirection(block: ReadonlyContentModelBlock): 'ltr' | 'rtl' {\n    if (block.blockType === 'Paragraph') {\n        const findTextSegements: ReadonlyContentModelText[] = block.segments.filter(\n            (seg): seg is ReadonlyContentModelText => seg.segmentType === 'Text'\n        );\n        let innerText =\n            findTextSegements.length > 0\n                ? findTextSegements.reduce((prev, seg) => prev + seg.text, '')\n                : undefined;\n        if (!!innerText) {\n            // Remove links\n            innerText = innerText.replace(URL_CHAR_REGEX, '');\n\n            // Remove whitespace\n            innerText = innerText.replace(WHITESPACE_REGEX, '');\n\n            const rtlMatches = innerText.match(RTL_CHAR_REGEX);\n            const rtlCount = rtlMatches ? rtlMatches.length : 0;\n\n            const ltrCount = innerText.length - rtlCount;\n\n            return rtlCount > ltrCount ? 'rtl' : 'ltr';\n        } else {\n            return 'ltr'; // Default to LTR if no text is found\n        }\n    } else {\n        return 'ltr';\n    }\n}\n","import { findListItemsInSameThread } from '../list/findListItemsInSameThread';\nimport { getListAnnounceData } from '../list/getListAnnounceData';\nimport { IndentStepInPixel } from '../common/adjustIndentation';\nimport { splitSelectedParagraphByBr } from './splitSelectedParagraphByBr';\nimport {\n    createListLevel,\n    getOperationalBlocks,\n    isBlockGroupOfType,\n    mutateBlock,\n    normalizeContentModel,\n    parseValueWithUnit,\n    updateListMetadata,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelListItem,\n    ContentModelListLevel,\n    FormatContentModelContext,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * @param model The content model to set indentation\n * @param indentation The indentation type, 'indent' to indent, 'outdent' to outdent\n * @param length The length of indentation in pixel, default value is 40\n * Set indentation for selected list items or paragraphs\n */\nexport function setModelIndentation(\n    model: ReadonlyContentModelDocument,\n    indentation: 'indent' | 'outdent',\n    length: number = IndentStepInPixel,\n    context?: FormatContentModelContext\n) {\n    splitSelectedParagraphByBr(model);\n\n    const paragraphOrListItem = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        ['TableCell']\n    );\n    const isIndent = indentation == 'indent';\n    const modifiedBlocks: ReadonlyContentModelBlock[] = [];\n\n    paragraphOrListItem.forEach(({ block, parent, path }) => {\n        if (isBlockGroupOfType<ContentModelListItem>(block, 'ListItem')) {\n            const thread = findListItemsInSameThread(model, block);\n            const firstItem = thread[0];\n            //if the first item is selected and has only one level, we should add margin to the whole list\n            if (isSelected(firstItem) && firstItem.levels.length == 1) {\n                const level = block.levels[0];\n                const { format } = level;\n                const { marginLeft, marginRight } = format;\n                const newValue = calculateMarginValue(format, isIndent, length);\n                const isRtl = format.direction == 'rtl';\n                const originalValue = parseValueWithUnit(isRtl ? marginRight : marginLeft);\n\n                if (!isIndent && originalValue == 0) {\n                    block.levels.pop();\n                } else if (newValue !== null) {\n                    if (isRtl) {\n                        level.format.marginRight = newValue + 'px';\n                    } else {\n                        level.format.marginLeft = newValue + 'px';\n                    }\n                }\n                //if block has only one level, there is not need to check if it is multilevel selection\n            } else if (block.levels.length == 1 || !isMultilevelSelection(model, block, parent)) {\n                if (isIndent) {\n                    const threadIdx = thread.indexOf(block);\n                    const previousItem = thread[threadIdx - 1];\n                    const nextItem = thread[threadIdx + 1];\n                    const levelLength = block.levels.length;\n                    const lastLevel = block.levels[levelLength - 1];\n                    const newLevel: ContentModelListLevel = createListLevel(\n                        lastLevel?.listType || 'UL',\n                        lastLevel?.format,\n                        previousItem && previousItem.levels.length > levelLength\n                            ? previousItem.levels[levelLength].dataset\n                            : nextItem && nextItem.levels.length > levelLength\n                            ? nextItem.levels[levelLength].dataset\n                            : undefined\n                    );\n\n                    updateListMetadata(newLevel, metadata => {\n                        metadata = metadata || {};\n                        metadata.applyListStyleFromLevel = true;\n                        return metadata;\n                    });\n\n                    // New level is totally new, no need to have these attributes for now\n                    delete newLevel.format.startNumberOverride;\n\n                    block.levels.push(newLevel);\n                } else {\n                    block.levels.pop();\n                }\n\n                if (block.levels.length > 0 && context) {\n                    context.announceData = getListAnnounceData([block, ...path]);\n                }\n            }\n        } else if (block) {\n            let currentBlock: ReadonlyContentModelBlock = block;\n            let currentParent: ReadonlyContentModelBlockGroup = parent;\n\n            while (currentParent && modifiedBlocks.indexOf(currentBlock) < 0) {\n                const index = path.indexOf(currentParent);\n                const { format } = mutateBlock(currentBlock);\n                const newValue = calculateMarginValue(format, isIndent, length);\n\n                if (newValue !== null) {\n                    const isRtl = format.direction == 'rtl';\n\n                    if (isRtl) {\n                        format.marginRight = newValue + 'px';\n                    } else {\n                        format.marginLeft = newValue + 'px';\n                    }\n\n                    modifiedBlocks.push(currentBlock);\n\n                    break;\n                } else if (currentParent.blockGroupType == 'FormatContainer' && index >= 0) {\n                    mutateBlock(currentParent);\n\n                    currentBlock = currentParent;\n                    currentParent = path[index + 1];\n                } else {\n                    break;\n                }\n            }\n        }\n    });\n\n    if (paragraphOrListItem.length > 0) {\n        normalizeContentModel(model);\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isSelected(listItem: ReadonlyContentModelListItem) {\n    return listItem.blocks.some(block => {\n        if (block.blockType == 'Paragraph') {\n            return block.segments.some(segment => segment.isSelected);\n        }\n    });\n}\n\n/*\n * Check if the selection has list items with different levels and the first item of the list is selected, do not create a sub list.\n * Otherwise, the margin of the first item will be changed, and the sub list will be created, creating a unintentional margin difference between the list items.\n */\nfunction isMultilevelSelection(\n    model: ReadonlyContentModelDocument,\n    listItem: ReadonlyContentModelListItem,\n    parent: ReadonlyContentModelBlockGroup\n) {\n    const listIndex = parent.blocks.indexOf(listItem);\n    for (let i = listIndex - 1; i >= 0; i--) {\n        const block = parent.blocks[i];\n        if (\n            isBlockGroupOfType<ContentModelListItem>(block, 'ListItem') &&\n            block.levels.length == 1 &&\n            isSelected(block)\n        ) {\n            const firstItem = findListItemsInSameThread(model, block)[0];\n            return isSelected(firstItem);\n        }\n\n        if (!isBlockGroupOfType<ContentModelListItem>(block, 'ListItem')) {\n            return false;\n        }\n    }\n    return false;\n}\n\nfunction calculateMarginValue(\n    format: Readonly<ContentModelBlockFormat>,\n    isIndent: boolean,\n    length: number = IndentStepInPixel\n): number | null {\n    const { marginLeft, marginRight, direction } = format;\n    const isRtl = direction == 'rtl';\n    const originalValue = parseValueWithUnit(isRtl ? marginRight : marginLeft);\n    let newValue = (isIndent ? Math.ceil : Math.floor)(originalValue / length) * length;\n\n    if (newValue == originalValue) {\n        newValue = Math.max(newValue + length * (isIndent ? 1 : -1), 0);\n    }\n\n    if (newValue == originalValue) {\n        // Return null to let caller know nothing is changed\n        return null;\n    } else {\n        return newValue;\n    }\n}\n","import {\n    createParagraph,\n    getSelectedSegmentsAndParagraphs,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelParagraph,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * For all selected paragraphs, if it has BR in middle of other segments, split the paragraph into multiple paragraphs\n * @param model The model to process\n */\nexport function splitSelectedParagraphByBr(model: ReadonlyContentModelDocument) {\n    const selections = getSelectedSegmentsAndParagraphs(\n        model,\n        false /*includingFormatHolder*/,\n        false /*includingEntity*/\n    );\n\n    for (const [_, para, path] of selections) {\n        if (para?.segments.some(s => s.segmentType == 'Br')) {\n            let currentParagraph = shallowColonParagraph(para);\n            let hasVisibleSegment = false;\n            const newParagraphs: ShallowMutableContentModelParagraph[] = [];\n            const parent = mutateBlock(path[0]);\n            const index = parent.blocks.indexOf(para);\n\n            if (index >= 0) {\n                for (const segment of mutateBlock(para).segments) {\n                    if (segment.segmentType == 'Br') {\n                        if (!hasVisibleSegment) {\n                            currentParagraph.segments.push(segment);\n                        }\n\n                        if (currentParagraph.segments.length > 0) {\n                            newParagraphs.push(currentParagraph);\n                        }\n\n                        currentParagraph = shallowColonParagraph(para);\n                        hasVisibleSegment = false;\n                    } else {\n                        currentParagraph.segments.push(segment);\n\n                        if (segment.segmentType != 'SelectionMarker') {\n                            hasVisibleSegment = true;\n                        }\n                    }\n                }\n\n                if (currentParagraph.segments.length > 0) {\n                    newParagraphs.push(currentParagraph);\n                }\n\n                parent.blocks.splice(index, 1, ...newParagraphs);\n            }\n        }\n    }\n}\n\nfunction shallowColonParagraph(\n    para: ReadonlyContentModelParagraph\n): ShallowMutableContentModelParagraph {\n    return createParagraph(false /*isImplicit*/, para.format, para.segmentFormat, para.decorator);\n}\n","import { splitSelectedParagraphByBr } from './splitSelectedParagraphByBr';\nimport { wrapBlockStep1, wrapBlockStep2 } from '../common/wrapBlock';\nimport {\n    getOperationalBlocks,\n    isBlockGroupOfType,\n    areSameFormats,\n    createFormatContainer,\n    unwrapBlock,\n} from 'roosterjs-content-model-dom';\nimport type { WrapBlockStep1Result } from '../common/wrapBlock';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelFormatContainer,\n    ContentModelFormatContainerFormat,\n    ContentModelListItem,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelFormatContainer,\n    ReadonlyContentModelListItem,\n    ReadonlyOperationalBlocks,\n    ShallowMutableContentModelBlock,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function toggleModelBlockQuote(\n    model: ReadonlyContentModelDocument,\n    formatLtr: ContentModelFormatContainerFormat,\n    formatRtl: ContentModelFormatContainerFormat\n): boolean {\n    splitSelectedParagraphByBr(model);\n\n    const paragraphOfQuote = getOperationalBlocks<\n        ContentModelFormatContainer | ContentModelListItem\n    >(model, ['FormatContainer', 'ListItem'], ['TableCell'], true /*deepFirst*/, block => {\n        return block.blockGroupType == 'FormatContainer' ? block.tagName == 'blockquote' : true;\n    });\n\n    if (areAllBlockQuotes(paragraphOfQuote)) {\n        // All selections are already in quote, we need to unquote them\n        paragraphOfQuote.forEach(({ block, parent }) => {\n            unwrapBlock(parent, block);\n        });\n    } else {\n        const step1Results: WrapBlockStep1Result<ContentModelFormatContainer>[] = [];\n        const creator = (isRtl: boolean) =>\n            createFormatContainer('blockquote', isRtl ? formatRtl : formatLtr);\n        const canMerge = (\n            isRtl: boolean,\n            target: ShallowMutableContentModelBlock,\n            current?: ContentModelFormatContainer\n        ): target is ContentModelFormatContainer =>\n            canMergeQuote(target, current?.format || (isRtl ? formatRtl : formatLtr));\n\n        paragraphOfQuote.forEach(({ block, parent }) => {\n            if (isQuote(block)) {\n                // Already in quote, no op\n            } else {\n                wrapBlockStep1(step1Results, parent, block, creator, canMerge);\n            }\n        });\n\n        wrapBlockStep2(step1Results, canMerge);\n    }\n\n    return paragraphOfQuote.length > 0;\n}\n\nfunction canMergeQuote(\n    target: ShallowMutableContentModelBlock,\n    format: ContentModelFormatContainerFormat\n): target is ContentModelFormatContainer {\n    return isQuote(target) && areSameFormats(format, target.format);\n}\n\nfunction isQuote(block: ReadonlyContentModelBlock): block is ReadonlyContentModelFormatContainer {\n    return (\n        isBlockGroupOfType<ContentModelFormatContainer>(block, 'FormatContainer') &&\n        block.tagName == 'blockquote'\n    );\n}\n\nfunction areAllBlockQuotes(\n    blockAndParents: ReadonlyOperationalBlocks<\n        ReadonlyContentModelFormatContainer | ReadonlyContentModelListItem\n    >[]\n): blockAndParents is {\n    block: ContentModelFormatContainer;\n    parent: ContentModelBlockGroup;\n    path: ContentModelBlockGroup[];\n}[] {\n    return blockAndParents.every(blockAndParent => isQuote(blockAndParent.block));\n}\n","import { mutateSegment } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelTable,\n    InsertPoint,\n    ShallowMutableContentModelListItem,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\nconst EN_SPACE = '\\u2002';\nconst REGULAR_SPACE = '\\u0020';\nconst NON_BREAK_SPACES = '\\u00A0';\n\n/**\n * @internal\n */\nexport const IndentStepInPixel = 40;\n\nfunction countTabsSpaces(text: string) {\n    const spaces = countSpacesBeforeText(text);\n    const tabSpaces = Math.floor(spaces / 4);\n    return tabSpaces;\n}\n\nfunction countSpacesBeforeText(str: string) {\n    let count = 0;\n    for (const char of str) {\n        if (char === EN_SPACE || char === NON_BREAK_SPACES || char == REGULAR_SPACE) {\n            count++;\n        } else {\n            break;\n        }\n    }\n    return count;\n}\n\n/**\n * @internal\n */\nexport function adjustListIndentation(listItem: ShallowMutableContentModelListItem) {\n    const block = listItem.blocks[0];\n    if (\n        block.blockType == 'Paragraph' &&\n        block.segments.length > 0 &&\n        block.segments[0].segmentType == 'Text'\n    ) {\n        const tabSpaces = countTabsSpaces(block.segments[0].text);\n\n        if (tabSpaces > 0) {\n            mutateSegment(block, block.segments[0], textSegment => {\n                textSegment.text = textSegment.text.substring(tabSpaces * 4);\n            });\n            listItem.levels[0].format.marginLeft = tabSpaces * IndentStepInPixel + 'px';\n        }\n    }\n}\n\n/**\n * @internal\n */\nexport function adjustTableIndentation(insertPoint: InsertPoint, table: ContentModelTable) {\n    const { paragraph, marker } = insertPoint;\n    const indentationMargin = getTableIndentation(paragraph);\n\n    if (indentationMargin) {\n        insertPoint.paragraph.segments = [marker];\n        if (insertPoint.paragraph.format.direction == 'rtl') {\n            table.format.marginRight = indentationMargin * IndentStepInPixel + 'px';\n        } else {\n            table.format.marginLeft = indentationMargin * IndentStepInPixel + 'px';\n        }\n    }\n}\n\nconst getTableIndentation = (paragraph: ShallowMutableContentModelParagraph) => {\n    let tabsNumber = 0;\n    const segments = paragraph.segments;\n\n    const isEmptyLine = paragraph.segments.every(\n        s =>\n            (s.segmentType == 'Text' && s.text.trim().length == 0) ||\n            s.segmentType == 'SelectionMarker' ||\n            s.segmentType == 'Br'\n    );\n\n    if (!isEmptyLine) {\n        return;\n    }\n\n    let numberOfSegments = 0;\n    for (const seg of segments) {\n        if (seg.segmentType === 'Text') {\n            tabsNumber = tabsNumber + countTabsSpaces(seg.text);\n            numberOfSegments++;\n        } else {\n            break;\n        }\n    }\n\n    // Text segments must be >= (total segments - 2) to apply margin.\n    // If not, the selection marker is likely between  texts segment, so skip margin adjustment.\n    if (segments.length - 2 <= numberOfSegments) {\n        return tabsNumber;\n    }\n\n    return;\n};\n","import { adjustWordSelection } from '../selection/adjustWordSelection';\nimport {\n    applyTableFormat,\n    createFormatContainer,\n    getClosestAncestorBlockGroupIndex,\n    iterateSelections,\n    mutateBlock,\n    mutateSegments,\n    updateTableCellMetadata,\n    updateTableMetadata,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelSegmentFormat,\n    ContentModelTable,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelFormatContainer,\n    ReadonlyContentModelListItem,\n    ReadonlySelectable,\n    ReadonlyTableSelectionContext,\n    ShallowMutableContentModelBlock,\n    ShallowMutableContentModelFormatContainer,\n    ShallowMutableContentModelSegment,\n    ShallowMutableContentModelTable,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function clearModelFormat(\n    model: ReadonlyContentModelDocument,\n    blocksToClear: [ReadonlyContentModelBlockGroup[], ShallowMutableContentModelBlock][],\n    segmentsToClear: ShallowMutableContentModelSegment[],\n    tablesToClear: [ContentModelTable, boolean][]\n): boolean {\n    let pendingStructureChange = false;\n\n    iterateSelections(\n        model,\n        (path, tableContext, block, segments) => {\n            if (segments) {\n                if (block?.blockType == 'Paragraph') {\n                    const [, mutableSegments] = mutateSegments(block, segments);\n\n                    segmentsToClear.push(...mutableSegments);\n                } else if (\n                    path[0].blockGroupType == 'ListItem' &&\n                    segments.length == 1 &&\n                    path[0].formatHolder == segments[0]\n                ) {\n                    segmentsToClear.push(mutateBlock(path[0]).formatHolder);\n                }\n            }\n\n            if (block) {\n                blocksToClear.push([path, mutateBlock(block)]);\n            } else if (tableContext) {\n                clearTableCellFormat(tableContext, tablesToClear);\n            }\n        },\n        {\n            // When there is a default format to apply, we know how to handle segment format under list.\n            // So no need to clear format of list number.\n            // Otherwise, we will clear all format of selected text. And since they are under LI tag, we\n            // also need to clear the format of LI (format holder) so that the format is really cleared\n            includeListFormatHolder: model.format ? 'never' : 'anySegment',\n        }\n    );\n\n    const marker = segmentsToClear[0];\n\n    // 2. If selection is collapsed, add selection to whole word to clear if any\n    if (\n        blocksToClear.length == 1 &&\n        isOnlySelectionMarkerSelected(blocksToClear[0][1]) &&\n        blocksToClear.length == 1\n    ) {\n        segmentsToClear.splice(0, segmentsToClear.length, ...adjustWordSelection(model, marker));\n        pendingStructureChange = clearListFormat(blocksToClear[0][0]) || pendingStructureChange;\n    } else if (blocksToClear.length > 1 || blocksToClear.some(x => isWholeBlockSelected(x[1]))) {\n        // 2. If a full block or multiple blocks are selected, clear block format\n        for (let i = blocksToClear.length - 1; i >= 0; i--) {\n            const [path, block] = blocksToClear[i];\n\n            clearBlockFormat(path, block);\n            pendingStructureChange = clearListFormat(path) || pendingStructureChange;\n            clearContainerFormat(path, block);\n        }\n    }\n\n    // 3. Finally clear format for segments\n    clearSegmentsFormat(segmentsToClear, model.format);\n\n    // 4. Clear format for table if any\n    createTablesFormat(tablesToClear);\n\n    return pendingStructureChange;\n}\n\nfunction createTablesFormat(tablesToClear: [ContentModelTable, boolean][]) {\n    tablesToClear.forEach(x => {\n        const [table, isWholeTableSelected] = x;\n        if (isWholeTableSelected) {\n            table.format = {\n                useBorderBox: table.format.useBorderBox,\n                borderCollapse: table.format.borderCollapse,\n            };\n            updateTableMetadata(table, () => null);\n        }\n\n        applyTableFormat(table, undefined /*newFormat*/, true);\n    });\n}\n\nfunction clearSegmentsFormat(\n    segmentsToClear: ShallowMutableContentModelSegment[],\n    defaultSegmentFormat: Readonly<ContentModelSegmentFormat> | undefined\n) {\n    segmentsToClear.forEach(x => {\n        x.format = { ...(defaultSegmentFormat || {}) };\n\n        if (x.link) {\n            delete x.link.format.textColor;\n        }\n\n        delete x.code;\n    });\n}\n\nfunction clearTableCellFormat(\n    tableContext: ReadonlyTableSelectionContext | undefined,\n    tablesToClear: [ShallowMutableContentModelTable, boolean][]\n) {\n    if (tableContext) {\n        const { table, colIndex, rowIndex, isWholeTableSelected } = tableContext;\n        const cell = table.rows[rowIndex].cells[colIndex];\n\n        if (cell.isSelected) {\n            const mutableCell = mutateBlock(cell);\n\n            updateTableCellMetadata(mutableCell, () => null);\n            mutableCell.isHeader = false;\n            mutableCell.format = {\n                useBorderBox: cell.format.useBorderBox,\n            };\n        }\n\n        if (!tablesToClear.find(x => x[0] == table)) {\n            tablesToClear.push([mutateBlock(table), isWholeTableSelected]);\n        }\n    }\n}\n\nfunction clearContainerFormat(\n    path: ReadonlyContentModelBlockGroup[],\n    block: ShallowMutableContentModelBlock\n) {\n    const containerPathIndex = getClosestAncestorBlockGroupIndex(\n        path,\n        ['FormatContainer'],\n        ['TableCell']\n    );\n\n    if (containerPathIndex >= 0 && containerPathIndex < path.length - 1) {\n        const container = mutateBlock(\n            path[containerPathIndex] as ReadonlyContentModelFormatContainer\n        );\n        const containerIndex = path[containerPathIndex + 1].blocks.indexOf(container);\n        const blockIndex = container.blocks.indexOf(block);\n\n        if (blockIndex >= 0 && containerIndex >= 0) {\n            const newContainer: ShallowMutableContentModelFormatContainer = createFormatContainer(\n                container.tagName,\n                container.format\n            );\n\n            container.blocks.splice(blockIndex, 1);\n            newContainer.blocks = container.blocks.splice(blockIndex);\n\n            mutateBlock(path[containerPathIndex + 1]).blocks.splice(\n                containerIndex + 1,\n                0,\n                block,\n                newContainer\n            );\n        }\n    }\n}\n\nfunction clearListFormat(path: ReadonlyContentModelBlockGroup[]) {\n    const listItem = path[getClosestAncestorBlockGroupIndex(path, ['ListItem'], ['TableCell'])] as\n        | ReadonlyContentModelListItem\n        | undefined;\n\n    if (listItem) {\n        mutateBlock(listItem).levels = [];\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction clearBlockFormat(\n    path: ReadonlyContentModelBlockGroup[],\n    block: ShallowMutableContentModelBlock\n) {\n    if (block.blockType == 'Divider') {\n        const index = path[0].blocks.indexOf(block);\n\n        if (index >= 0) {\n            mutateBlock(path[0]).blocks.splice(index, 1);\n        }\n    } else if (block.blockType == 'Paragraph') {\n        block.format = {};\n        delete block.decorator;\n    }\n}\n\nfunction isOnlySelectionMarkerSelected(block: ReadonlyContentModelBlock) {\n    const segments = block.blockType == 'Paragraph' ? block.segments.filter(x => x.isSelected) : [];\n\n    return segments.length == 1 && segments[0].segmentType == 'SelectionMarker';\n}\n\nfunction isWholeBlockSelected(block: ReadonlyContentModelBlock) {\n    return (\n        (block as ReadonlySelectable).isSelected ||\n        (block.blockType == 'Paragraph' && block.segments.every(x => x.isSelected))\n    );\n}\n","import { createDomToModelContext, domToContentModel } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlockType,\n    ContentModelEntity,\n    EditorContext,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockBase,\n    ReadonlyContentModelBlockGroup,\n} from 'roosterjs-content-model-types';\n\n/**\n * Query content model blocks\n * @param group The block group to query\n * @param type The type of block to query\n * @param filter Optional selector to filter the blocks\n * @param findFirstOnly True to return the first block only, false to return all blocks\n * @param shouldExpandEntity Optional function to determine if an entity's children should be recursively queried, should return a EditorContext if the entity should be expanded, or null if not\n */\nexport function queryContentModelBlocks<T extends ReadonlyContentModelBlock>(\n    group: ReadonlyContentModelBlockGroup,\n    type: T extends ReadonlyContentModelBlockBase<infer U> ? U : never,\n    filter?: (element: T) => element is T,\n    findFirstOnly?: boolean,\n    shouldExpandEntity?: (entity: ContentModelEntity) => EditorContext | null\n): T[] {\n    const elements: T[] = [];\n    for (let i = 0; i < group.blocks.length; i++) {\n        if (findFirstOnly && elements.length > 0) {\n            return elements;\n        }\n        const block = group.blocks[i];\n\n        switch (block.blockType) {\n            case 'Paragraph':\n            case 'Divider':\n            case 'Entity':\n                if (isExpectedBlockType(block, type, filter)) {\n                    elements.push(block);\n                }\n                if (block.blockType == 'Entity' && shouldExpandEntity) {\n                    const editorContext = shouldExpandEntity(block);\n                    if (editorContext) {\n                        const context = createDomToModelContext(editorContext);\n                        const model = domToContentModel(block.wrapper, context);\n                        const results = queryContentModelBlocks<T>(\n                            model,\n                            type,\n                            filter,\n                            findFirstOnly,\n                            shouldExpandEntity\n                        );\n                        elements.push(...results);\n                    }\n                }\n                break;\n            case 'BlockGroup':\n                if (isExpectedBlockType(block, type, filter)) {\n                    elements.push(block);\n                }\n                const results = queryContentModelBlocks<T>(\n                    block,\n                    type,\n                    filter,\n                    findFirstOnly,\n                    shouldExpandEntity\n                );\n                elements.push(...results);\n                break;\n            case 'Table':\n                if (isExpectedBlockType(block, type, filter)) {\n                    elements.push(block);\n                }\n                for (const row of block.rows) {\n                    for (const cell of row.cells) {\n                        const results = queryContentModelBlocks<T>(\n                            cell,\n                            type,\n                            filter,\n                            findFirstOnly,\n                            shouldExpandEntity\n                        );\n                        elements.push(...results);\n                    }\n                }\n                break;\n        }\n    }\n    return elements;\n}\n\nfunction isExpectedBlockType<T extends ReadonlyContentModelBlock>(\n    block: ReadonlyContentModelBlock,\n    type: ContentModelBlockType,\n    filter?: (element: T) => element is T\n): block is T {\n    return isBlockType<T>(block, type) && (!filter || filter(block));\n}\n\nfunction isBlockType<T extends ReadonlyContentModelBlock>(\n    block: ReadonlyContentModelBlock,\n    type: ContentModelBlockType\n): block is T {\n    return block.blockType == type;\n}\n","import {\n    getRegularSelectionOffsets,\n    getSelectionRootNode,\n    handleRegularSelection,\n    isNodeOfType,\n    processChildNode,\n} from 'roosterjs-content-model-dom';\nimport type { ContentModelBlockGroup, DomToModelContext } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\ninterface FormatStateContext extends DomToModelContext {\n    /**\n     * An optional stack of parent elements to process. When provided, the child nodes of current parent element will be ignored,\n     * but use the top element in this stack instead in childProcessor.\n     */\n    nodeStack?: Node[];\n}\n\n/**\n * @internal\n * In order to get format, we can still use the regular child processor. However, to improve performance, we don't need to create\n * content model for the whole doc, instead we only need to traverse the tree path that can arrive current selected node.\n * This \"reduced\" child processor will first create a node stack that stores DOM node from root to current common ancestor node of selection,\n * then use this stack as a faked DOM tree to create a reduced content model which we can use to retrieve format state\n */\nexport function reducedModelChildProcessor(\n    group: ContentModelBlockGroup,\n    parent: ParentNode,\n    context: FormatStateContext\n) {\n    if (!context.nodeStack) {\n        const selectionRootNode = getSelectionRootNode(context.selection);\n        context.nodeStack = selectionRootNode ? createNodeStack(parent, selectionRootNode) : [];\n    }\n\n    const stackChild = context.nodeStack.pop();\n\n    if (stackChild) {\n        const [nodeStartOffset, nodeEndOffset] = getRegularSelectionOffsets(context, parent);\n\n        // If selection is not on this node, skip getting node index to save some time since we don't need it here\n        const index =\n            nodeStartOffset >= 0 || nodeEndOffset >= 0 ? getChildIndex(parent, stackChild) : -1;\n\n        if (index >= 0) {\n            handleRegularSelection(index, context, group, nodeStartOffset, nodeEndOffset);\n        }\n\n        processChildNode(group, stackChild, context);\n\n        if (index >= 0) {\n            handleRegularSelection(index + 1, context, group, nodeStartOffset, nodeEndOffset);\n        }\n    } else {\n        // No child node from node stack, that means we have reached the deepest node of selection.\n        // Now we can use default child processor to perform full sub tree scanning for content model,\n        // So that all selected node will be included.\n        context.defaultElementProcessors.child(group, parent, context);\n    }\n}\n\nfunction createNodeStack(root: Node, startNode: Node): Node[] {\n    const result: Node[] = [];\n    let node: Node | null = startNode;\n\n    while (node && root != node && root.contains(node)) {\n        if (isNodeOfType(node, 'ELEMENT_NODE') && node.tagName == 'TABLE') {\n            // For table, we can't do a reduced model creation since we need to handle their cells and indexes,\n            // so clean up whatever we already have, and just put table into the stack\n            result.splice(0, result.length, node);\n        } else {\n            result.push(node);\n        }\n\n        node = node.parentNode;\n    }\n\n    return result;\n}\n\nfunction getChildIndex(parent: ParentNode, stackChild: Node) {\n    let index = 0;\n    let child = parent.firstChild;\n\n    while (child && child != stackChild) {\n        index++;\n        child = child.nextSibling;\n    }\n    return index;\n}\n","import { addBlock, mutateBlock, setParagraphNotImplicit } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ShallowMutableContentModelBlock,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport interface WrapBlockStep1Result<T extends ContentModelBlockGroup & ContentModelBlock> {\n    parent: ReadonlyContentModelBlockGroup;\n    wrapper: T;\n}\n\n/**\n * @internal\n */\nexport function wrapBlockStep1<T extends ContentModelBlockGroup & ContentModelBlock>(\n    step1Result: WrapBlockStep1Result<T>[],\n    readonlyParent: ReadonlyContentModelBlockGroup | null,\n    readonlyBlockToWrap: ReadonlyContentModelBlock,\n    creator: (isRtl: boolean) => T,\n    canMerge: (isRtl: boolean, target: ShallowMutableContentModelBlock) => target is T\n) {\n    const parent = readonlyParent ? mutateBlock(readonlyParent) : null;\n    const blockToWrap = mutateBlock(readonlyBlockToWrap);\n    const index = parent?.blocks.indexOf(blockToWrap) ?? -1;\n\n    if (parent && index >= 0) {\n        parent.blocks.splice(index, 1);\n\n        const readonlyPrevBlock: ReadonlyContentModelBlock = parent.blocks[index - 1];\n        const prevBlock = readonlyPrevBlock ? mutateBlock(readonlyPrevBlock) : null;\n        const isRtl = blockToWrap.format.direction == 'rtl';\n        const wrapper =\n            prevBlock && canMerge(isRtl, prevBlock)\n                ? prevBlock\n                : createAndAdd(parent, index, creator, isRtl);\n\n        setParagraphNotImplicit(blockToWrap);\n        addBlock(wrapper, blockToWrap);\n\n        // Use reverse order, so that we can merge from last to first to avoid modifying unmerged quotes\n        step1Result.unshift({ parent, wrapper });\n    }\n}\n\n/**\n * @internal\n */\nexport function wrapBlockStep2<T extends ContentModelBlockGroup & ContentModelBlock>(\n    step1Result: WrapBlockStep1Result<T>[],\n    canMerge: (isRtl: boolean, target: ShallowMutableContentModelBlock, current: T) => target is T\n) {\n    step1Result.forEach(({ parent, wrapper }) => {\n        const index = parent.blocks.indexOf(wrapper);\n        const readonlyNextBlock = parent.blocks[index + 1];\n        const nextBlock = readonlyNextBlock ? mutateBlock(readonlyNextBlock) : null;\n        const isRtl = wrapper.format.direction == 'rtl';\n\n        if (index >= 0 && nextBlock && canMerge(isRtl, nextBlock, wrapper)) {\n            wrapper.blocks.forEach(setParagraphNotImplicit);\n            wrapper.blocks.push(...nextBlock.blocks);\n            mutateBlock(parent).blocks.splice(index + 1, 1);\n        }\n    });\n}\n\nfunction createAndAdd<T extends ContentModelBlockGroup & ContentModelBlock>(\n    parent: ReadonlyContentModelBlockGroup,\n    index: number,\n    creator: (isRtl: boolean) => T,\n    isRtl: boolean\n): T {\n    const block = creator(isRtl);\n\n    mutateBlock(parent).blocks.splice(index, 0, block);\n\n    return block;\n}\n","import {\n    createBr,\n    createParagraph,\n    createSelectionMarker,\n    normalizeContentModel,\n    deleteSelection,\n    getClosestAncestorBlockGroupIndex,\n    setSelection,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelEntity,\n    FormatContentModelContext,\n    InsertEntityPosition,\n    InsertPoint,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n    ShallowMutableContentModelBlock,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function insertEntityModel(\n    model: ReadonlyContentModelDocument,\n    entityModel: ContentModelEntity,\n    position: InsertEntityPosition,\n    isBlock: boolean,\n    focusAfterEntity?: boolean,\n    context?: FormatContentModelContext,\n    insertPointOverride?: InsertPoint\n) {\n    let blockParent: ReadonlyContentModelBlockGroup | undefined;\n    let blockIndex = -1;\n    let insertPoint: InsertPoint | null;\n\n    if (position == 'begin' || position == 'end') {\n        blockParent = model;\n        blockIndex = position == 'begin' ? 0 : model.blocks.length;\n\n        if (!isBlock) {\n            Object.assign(entityModel.format, model.format);\n        }\n    } else if ((insertPoint = getInsertPoint(model, insertPointOverride, context))) {\n        const { marker, paragraph, path } = insertPoint;\n\n        if (!isBlock) {\n            const index = paragraph.segments.indexOf(marker);\n\n            Object.assign(entityModel.format, marker.format);\n\n            if (index >= 0) {\n                paragraph.segments.splice(focusAfterEntity ? index : index + 1, 0, entityModel);\n            }\n        } else {\n            const pathIndex =\n                position == 'root'\n                    ? getClosestAncestorBlockGroupIndex(path, ['TableCell', 'Document'])\n                    : 0;\n            blockParent = mutateBlock(path[pathIndex]);\n\n            const child = path[pathIndex - 1];\n            const directChild: ReadonlyContentModelBlock =\n                child?.blockGroupType == 'FormatContainer' ||\n                child?.blockGroupType == 'General' ||\n                child?.blockGroupType == 'ListItem'\n                    ? child\n                    : paragraph;\n            const childIndex = blockParent.blocks.indexOf(directChild);\n            blockIndex = childIndex >= 0 ? childIndex + 1 : -1;\n        }\n    }\n\n    if (blockIndex >= 0 && blockParent) {\n        const blocksToInsert: ShallowMutableContentModelBlock[] = [];\n        let nextParagraph: ShallowMutableContentModelParagraph | undefined;\n\n        if (isBlock) {\n            const nextBlock = blockParent.blocks[blockIndex];\n\n            blocksToInsert.push(entityModel);\n\n            if (nextBlock?.blockType == 'Paragraph') {\n                nextParagraph = mutateBlock(nextBlock);\n            } else if (!nextBlock || nextBlock.blockType == 'Entity' || focusAfterEntity) {\n                nextParagraph = createParagraph(false /*isImplicit*/, {}, model.format);\n                nextParagraph.segments.push(createBr(model.format));\n                blocksToInsert.push(nextParagraph);\n            }\n        } else {\n            nextParagraph = createParagraph(\n                false /*isImplicit*/,\n                undefined /*format*/,\n                model.format\n            );\n\n            nextParagraph.segments.push(entityModel);\n            blocksToInsert.push(nextParagraph);\n        }\n\n        mutateBlock(blockParent).blocks.splice(blockIndex, 0, ...blocksToInsert);\n\n        if (focusAfterEntity && nextParagraph) {\n            const marker = createSelectionMarker(nextParagraph.segments[0]?.format || model.format);\n            const segments = nextParagraph.segments;\n\n            isBlock ? segments.unshift(marker) : segments.push(marker);\n            setSelection(model, marker, marker);\n        }\n    }\n}\n\nfunction getInsertPoint(\n    model: ReadonlyContentModelDocument,\n    insertPointOverride?: InsertPoint,\n    context?: FormatContentModelContext\n): InsertPoint | null {\n    if (insertPointOverride) {\n        const { paragraph, marker, tableContext, path } = insertPointOverride;\n        const index = paragraph.segments.indexOf(marker);\n        const previousSegment = index > 0 ? paragraph.segments[index - 1] : null;\n\n        // It is possible that the real selection is right before the override selection marker.\n        // This happens when:\n        // [Override marker][Entity node to wrap][Real marker]\n        // Then we will move the entity node into entity wrapper, causes the override marker and real marker are at the same place\n        // And recreating content model causes real marker to appear before override marker.\n        // Once that happens, we need to use the real marker instead so that after insert entity, real marker can be placed\n        // after new entity (if insertPointOverride==true)\n        return previousSegment?.segmentType == 'SelectionMarker' && previousSegment.isSelected\n            ? {\n                  marker: previousSegment,\n                  paragraph,\n                  tableContext,\n                  path,\n              }\n            : insertPointOverride;\n    } else {\n        const deleteResult = deleteSelection(model, [], context);\n        const insertPoint = deleteResult.insertPoint;\n\n        if (deleteResult.deleteResult == 'range') {\n            normalizeContentModel(model);\n        }\n\n        return insertPoint;\n    }\n}\n","import { extractBorderValues, parseValueWithUnit } from 'roosterjs-content-model-dom';\nimport type { Border, ContentModelImage } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function applyImageBorderFormat(\n    image: ContentModelImage,\n    border: Border | null,\n    borderRadius?: string\n) {\n    if (border) {\n        const format = image.format;\n        const { width, style, color } = border;\n        const borderKey = 'borderTop';\n        const extractedBorder = extractBorderValues(format[borderKey]);\n        const borderColor = extractedBorder.color;\n        const borderWidth = extractedBorder.width;\n        const borderStyle = extractedBorder.style;\n        let borderFormat = '';\n\n        if (width) {\n            borderFormat = parseValueWithUnit(width) + 'px';\n        } else if (borderWidth) {\n            borderFormat = borderWidth;\n        } else {\n            borderFormat = '1px';\n        }\n\n        if (style) {\n            borderFormat = `${borderFormat} ${style}`;\n        } else if (borderStyle) {\n            borderFormat = `${borderFormat} ${borderStyle}`;\n        } else {\n            borderFormat = `${borderFormat} solid`;\n        }\n\n        if (color) {\n            borderFormat = `${borderFormat} ${color}`;\n        } else if (borderColor) {\n            borderFormat = `${borderFormat} ${borderColor}`;\n        }\n        image.format.borderLeft = borderFormat;\n        image.format.borderTop = borderFormat;\n        image.format.borderBottom = borderFormat;\n        image.format.borderRight = borderFormat;\n    } else {\n        delete image.format.borderLeft;\n        delete image.format.borderTop;\n        delete image.format.borderBottom;\n        delete image.format.borderRight;\n    }\n\n    if (borderRadius) {\n        image.format.borderRadius = borderRadius;\n    }\n}\n","import { matchLink } from './matchLink';\nimport type { AutoLinkOptions } from 'roosterjs-content-model-types';\n\nconst COMMON_REGEX = `[\\s]*[a-zA-Z0-9+][\\s]*`;\nconst TELEPHONE_REGEX = `(T|t)el:${COMMON_REGEX}`;\nconst MAILTO_REGEX = `(M|m)ailto:${COMMON_REGEX}`;\n\n/**\n * @internal\n */\nexport function getLinkUrl(text: string, autoLinkOptions?: AutoLinkOptions): string | undefined {\n    const { autoLink, autoMailto, autoTel } = autoLinkOptions ?? {};\n    const mailtoMatch = matchMailTo(text);\n    if (mailtoMatch && !autoMailto) {\n        return undefined;\n    }\n    const linkMatch = autoLink ? matchLink(text)?.normalizedUrl : undefined;\n    const telMatch = autoTel ? matchTel(text) : undefined;\n\n    return linkMatch || telMatch || mailtoMatch;\n}\n\nfunction matchTel(text: string) {\n    return text.match(TELEPHONE_REGEX) ? text.toLocaleLowerCase() : undefined;\n}\n\nfunction matchMailTo(text: string) {\n    return text.match(MAILTO_REGEX) ? text.toLocaleLowerCase() : undefined;\n}\n","import { getObjectKeys } from 'roosterjs-content-model-dom';\nimport type { LinkData } from 'roosterjs-content-model-types';\n\ninterface LinkMatchRule {\n    match: RegExp;\n    except?: RegExp;\n    normalizeUrl?: (url: string) => string;\n}\n\n// http exclude matching regex\n// invalid URL example (in particular on IE and Edge):\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\n// - http://www.bing.com%1, %1 is invalid\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\n// All above % cases if they're after ? (question mark) is then considered valid again\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\n// - http://www.bing.com?@name, is also valid since it is after ? (question mark)\n// The regex below is essentially a break down of:\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\n// ^[^?]+%$ => to exclude URL like www.bing.com%\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\n// , => to exclude url like www.bing,,com\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\n\n// via https://tools.ietf.org/html/rfc1035 Page 7\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexps below so don't bother including A-Z\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\n\nconst linkMatchRules: Record<string, LinkMatchRule> = {\n    http: {\n        match: new RegExp(\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\n            'i'\n        ),\n        except: httpExcludeRegEx,\n        normalizeUrl: url =>\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\n    },\n    https: {\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\n        except: httpExcludeRegEx,\n    },\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\n    ftp: {\n        match: new RegExp(\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\n            'i'\n        ),\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\n    },\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\n};\n\n/**\n * Try to match a given string with link match rules, return matched link\n * @param url Input url to match\n * @param option Link match option, exact or partial. If it is exact match, we need\n * to check the length of matched link and url\n * @param rules Optional link match rules, if not passed, only the default link match\n * rules will be applied\n * @returns The matched link data, or null if no match found.\n * The link data includes an original url and a normalized url\n */\nexport function matchLink(url: string): LinkData | null {\n    if (url) {\n        for (const schema of getObjectKeys(linkMatchRules)) {\n            const rule = linkMatchRules[schema];\n            const matches = url.match(rule.match);\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\n                return {\n                    scheme: schema,\n                    originalUrl: url,\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\n                };\n            }\n        }\n    }\n\n    return null;\n}\n","import { getLinkUrl } from './getLinkUrl';\nimport { splitTextSegment } from '../../publicApi/segment/splitTextSegment';\nimport type {\n    AutoLinkOptions,\n    ContentModelText,\n    PromotedLink,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * Promote the given text segment to a hyper link when the segment text is ending with a valid link format.\n * When the whole text segment if of a link, promote the whole segment.\n * When the text segment ends with a link format, split the segment and promote the second part\n * When link is in middle of the text segment, no action.\n * This is mainly used for doing auto link when there is a link before cursor\n * @param segment The text segment to search link text from\n * @param paragraph Parent paragraph of the segment\n * @param options Options of auto link\n * @returns If a link is promoted, return this segment. Otherwise return null\n */\nexport function promoteLink(\n    segment: ContentModelText,\n    paragraph: ShallowMutableContentModelParagraph,\n    autoLinkOptions: AutoLinkOptions\n): ContentModelText | null {\n    if (segment.link) {\n        return null;\n    }\n\n    const promotedLink = getPromoteLink(segment, autoLinkOptions);\n\n    if (promotedLink) {\n        const linkSegment = splitTextSegment(\n            segment,\n            paragraph,\n            segment.text.length - promotedLink.label.trimLeft().length,\n            segment.text.trimRight().length\n        );\n        linkSegment.link = {\n            format: {\n                href: promotedLink.href,\n                underline: true,\n            },\n            dataset: {},\n        };\n\n        return linkSegment;\n    }\n\n    return null;\n}\n\n/**\n * Verify if the link can be promoted\n * @param segment The text segment to search link text from\n * @param options Options of auto link\n * @returns if a link can be promoted\n */\nexport function getPromoteLink(\n    segment: ContentModelText,\n    autoLinkOptions: AutoLinkOptions\n): PromotedLink | undefined {\n    const link = segment.text.split(' ').pop();\n    const url = link?.trim();\n    let linkUrl: string | undefined = undefined;\n    if (url && link && (linkUrl = getLinkUrl(url, autoLinkOptions))) {\n        return {\n            label: link,\n            href: linkUrl,\n        };\n    }\n    return undefined;\n}\n","import type {\n    ContentModelBlockGroup,\n    ContentModelListItem,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * Search for all list items in the same thread as the current list item\n * @param model The content model\n * @param currentItem The current list item\n */\nexport function findListItemsInSameThread(\n    group: ContentModelBlockGroup,\n    currentItem: ContentModelListItem\n): ContentModelListItem[];\n\n/**\n * Search for all list items in the same thread as the current list item (Readonly)\n * @param model The content model\n * @param currentItem The current list item\n */\nexport function findListItemsInSameThread(\n    group: ReadonlyContentModelBlockGroup,\n    currentItem: ReadonlyContentModelListItem\n): ReadonlyContentModelListItem[];\n\nexport function findListItemsInSameThread(\n    group: ReadonlyContentModelBlockGroup,\n    currentItem: ReadonlyContentModelListItem\n): ReadonlyContentModelListItem[] {\n    const items: (ContentModelListItem | null)[] = [];\n\n    findListItems(group, items);\n\n    return filterListItems(items, currentItem);\n}\n\nfunction findListItems(\n    group: ReadonlyContentModelBlockGroup,\n    result: (ReadonlyContentModelListItem | null)[]\n) {\n    group.blocks.forEach(block => {\n        switch (block.blockType) {\n            case 'BlockGroup':\n                if (block.blockGroupType == 'ListItem') {\n                    result.push(block);\n                } else {\n                    pushNullIfNecessary(result);\n                    findListItems(block, result);\n                    pushNullIfNecessary(result);\n                }\n                break;\n\n            case 'Paragraph':\n                pushNullIfNecessary(result);\n\n                block.segments.forEach(segment => {\n                    if (segment.segmentType == 'General') {\n                        findListItems(segment, result);\n                    }\n                });\n\n                pushNullIfNecessary(result);\n                break;\n\n            case 'Table':\n                pushNullIfNecessary(result);\n\n                block.rows.forEach(row =>\n                    row.cells.forEach(cell => {\n                        findListItems(cell, result);\n                    })\n                );\n                pushNullIfNecessary(result);\n\n                break;\n        }\n    });\n}\n\nfunction pushNullIfNecessary(result: (ReadonlyContentModelListItem | null)[]) {\n    const last = result[result.length - 1];\n\n    if (!last || last !== null) {\n        result.push(null);\n    }\n}\n\nfunction filterListItems(\n    items: (ReadonlyContentModelListItem | null)[],\n    currentItem: ReadonlyContentModelListItem\n) {\n    const result: ReadonlyContentModelListItem[] = [];\n    const currentIndex = items.indexOf(currentItem);\n    const levelLength = currentItem.levels.length;\n    const isOrderedList = currentItem.levels[levelLength - 1]?.listType == 'OL';\n\n    if (currentIndex >= 0) {\n        for (let i = currentIndex; i >= 0; i--) {\n            const item = items[i];\n\n            if (!item) {\n                if (isOrderedList) {\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            const startNumberOverride = hasStartNumberOverride(item, levelLength);\n\n            if (areListTypesCompatible(items, currentIndex, i)) {\n                result.unshift(item);\n\n                if (isOrderedList && startNumberOverride) {\n                    break;\n                }\n            } else if (\n                !isOrderedList ||\n                startNumberOverride ||\n                item.levels.length < currentItem.levels.length\n            ) {\n                break;\n            }\n        }\n\n        for (let i = currentIndex + 1; i < items.length; i++) {\n            const item = items[i];\n\n            if (!item) {\n                if (isOrderedList) {\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            const startNumberOverride = hasStartNumberOverride(item, levelLength);\n\n            if (areListTypesCompatible(items, currentIndex, i) && !startNumberOverride) {\n                result.push(item);\n            } else if (\n                !isOrderedList ||\n                startNumberOverride ||\n                item.levels.length < currentItem.levels.length\n            ) {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction areListTypesCompatible(\n    listItems: (ReadonlyContentModelListItem | null)[],\n    currentIndex: number,\n    compareToIndex: number\n): boolean {\n    const currentLevels = listItems[currentIndex]!.levels;\n    const compareToLevels = listItems[compareToIndex]!.levels;\n\n    return (\n        currentLevels.length <= compareToLevels.length &&\n        currentLevels.every(\n            (currentLevel, i) => currentLevel.listType == compareToLevels[i].listType\n        )\n    );\n}\n\nfunction hasStartNumberOverride(item: ReadonlyContentModelListItem, levelLength: number): boolean {\n    return item.levels\n        .slice(0, levelLength)\n        .some(level => level.format.startNumberOverride !== undefined);\n}\n","import { findListItemsInSameThread } from './findListItemsInSameThread';\nimport {\n    getAutoListStyleType,\n    getClosestAncestorBlockGroupIndex,\n    getListMetadata,\n    getOrderedListNumberStr,\n} from 'roosterjs-content-model-dom';\nimport type {\n    AnnounceData,\n    ContentModelListItem,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * Get announce data for list item\n * @param path Content model path that include the list item\n * @returns Announce data of current list item if any, or null\n */\nexport function getListAnnounceData(path: ReadonlyContentModelBlockGroup[]): AnnounceData | null {\n    const index = getClosestAncestorBlockGroupIndex(path, ['ListItem'], ['TableCell']);\n\n    if (index >= 0) {\n        const listItem = path[index] as ContentModelListItem;\n        const level = listItem.levels[listItem.levels.length - 1];\n\n        if (!level || level.format.displayForDummyItem) {\n            return null;\n        } else if (level.listType == 'OL') {\n            const listNumber = getListNumber(path, listItem);\n            const metadata = getListMetadata(level);\n            const listStyle = getAutoListStyleType(\n                'OL',\n                metadata ?? {},\n                listItem.levels.length - 1,\n                level.format.listStyleType\n            );\n\n            return listStyle === undefined\n                ? null\n                : {\n                      defaultStrings: 'announceListItemNumbering',\n                      formatStrings: [getOrderedListNumberStr(listStyle, listNumber)],\n                  };\n        } else {\n            return {\n                defaultStrings: 'announceListItemBullet',\n            };\n        }\n    } else {\n        return null;\n    }\n}\n\nfunction getListNumber(\n    path: ReadonlyContentModelBlockGroup[],\n    listItem: ReadonlyContentModelListItem\n) {\n    const items = findListItemsInSameThread(path[path.length - 1], listItem);\n    let listNumber = 0;\n\n    for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n\n        if (listNumber == 0 && item.levels.length == listItem.levels.length) {\n            listNumber = item.levels[item.levels.length - 1]?.format.startNumberOverride ?? 1;\n        }\n\n        if (item == listItem) {\n            // Found current item, so break and return\n            break;\n        } else if (item.levels.length < listItem.levels.length) {\n            // Found upper level item, reset list number\n            listNumber = 0;\n        } else if (item.levels.length > listItem.levels.length) {\n            // Found deeper level item, skip\n            continue;\n        } else if (!item.levels[item.levels.length - 1].format.displayForDummyItem) {\n            // Save level, and is not dummy, number plus one\n            listNumber++;\n        }\n    }\n    return listNumber;\n}\n","import { adjustListIndentation } from '../common/adjustIndentation';\nimport { splitSelectedParagraphByBr } from '../block/splitSelectedParagraphByBr';\nimport {\n    copyFormat,\n    createListItem,\n    createListLevel,\n    getOperationalBlocks,\n    isBlockGroupOfType,\n    ListFormats,\n    ListFormatsToKeep,\n    ListFormatsToMove,\n    mutateBlock,\n    normalizeContentModel,\n    setParagraphNotImplicit,\n    updateListMetadata,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlockFormat,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelListItem,\n    ShallowMutableContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * Set a list type to content model\n * @param model the model document\n * @param listType the list type OL | UL\n * @param removeMargins true to remove margins, false to keep margins @default false\n */\nexport function setListType(\n    model: ReadonlyContentModelDocument,\n    listType: 'OL' | 'UL',\n    removeMargins: boolean = false\n) {\n    splitSelectedParagraphByBr(model);\n\n    const paragraphOrListItems = getOperationalBlocks<ReadonlyContentModelListItem>(\n        model,\n        ['ListItem'],\n        [] // Set stop types to be empty so we can find list items even cross the boundary of table, then we can always operation on the list item if any\n    );\n    const alreadyInExpectedType = paragraphOrListItems.every(({ block }) =>\n        isBlockGroupOfType<ReadonlyContentModelListItem>(block, 'ListItem')\n            ? block.levels[block.levels.length - 1]?.listType == listType\n            : shouldIgnoreBlock(block)\n    );\n    let existingListItems: ReadonlyContentModelListItem[] = [];\n\n    paragraphOrListItems.forEach(({ block, parent }, itemIndex) => {\n        if (isBlockGroupOfType<ReadonlyContentModelListItem>(block, 'ListItem')) {\n            const mutableBlock = mutateBlock(block);\n            const level = mutableBlock.levels.pop();\n\n            if (!alreadyInExpectedType && level) {\n                level.listType = listType;\n\n                updateListMetadata(level, metadata =>\n                    Object.assign({}, metadata, {\n                        applyListStyleFromLevel: true,\n                    })\n                );\n\n                mutableBlock.levels.push(level);\n            } else if (block.blocks.length == 1) {\n                setParagraphNotImplicit(block.blocks[0]);\n            }\n\n            if (alreadyInExpectedType) {\n                // if the list item has margins or textAlign, we need to apply them to the block to preserve the indention and alignment\n                block.blocks.forEach(x => {\n                    copyFormat<ContentModelBlockFormat>(x.format, block.format, ListFormats);\n                });\n            }\n        } else {\n            const index = parent.blocks.indexOf(block);\n            const isInsideTableCell = parent.blockGroupType == 'TableCell';\n\n            if (index >= 0) {\n                if (\n                    paragraphOrListItems.length == 1 ||\n                    !shouldIgnoreBlock(block) ||\n                    isInsideTableCell\n                ) {\n                    const prevBlock = parent.blocks[index - 1];\n                    const segmentFormat =\n                        (block.blockType == 'Paragraph' && block.segments[0]?.format) || {};\n                    const newListItem: ShallowMutableContentModelListItem = createListItem(\n                        [\n                            createListLevel(listType, {\n                                startNumberOverride:\n                                    isInsideTableCell ||\n                                    itemIndex > 0 ||\n                                    (prevBlock?.blockType == 'BlockGroup' &&\n                                        prevBlock.blockGroupType == 'ListItem' &&\n                                        prevBlock.levels[0]?.listType == 'OL')\n                                        ? undefined\n                                        : 1,\n                                direction: block.format.direction,\n                                textAlign: block.format.textAlign,\n                                marginBottom: removeMargins ? '0px' : undefined,\n                                marginTop: removeMargins ? '0px' : undefined,\n                            }),\n                        ],\n                        // For list bullet, we only want to carry over these formats from segments:\n                        {\n                            fontFamily: segmentFormat.fontFamily,\n                            fontSize: segmentFormat.fontSize,\n                            textColor: segmentFormat.textColor,\n                        }\n                    );\n\n                    if (block.blockType == 'Paragraph') {\n                        setParagraphNotImplicit(block);\n                    }\n\n                    const mutableBlock = mutateBlock(block);\n\n                    newListItem.blocks.push(mutableBlock);\n\n                    adjustListIndentation(newListItem);\n\n                    copyFormat<ContentModelBlockFormat>(\n                        newListItem.format,\n                        mutableBlock.format,\n                        ListFormatsToMove,\n                        true /*deleteOriginalFormat*/\n                    );\n                    copyFormat<ContentModelBlockFormat>(\n                        newListItem.format,\n                        mutableBlock.format,\n                        ListFormatsToKeep\n                    );\n\n                    mutateBlock(parent).blocks.splice(index, 1, newListItem);\n                    existingListItems.push(newListItem);\n\n                    const levelIndex = newListItem.levels.length - 1;\n                    const level = mutateBlock(newListItem).levels[levelIndex];\n\n                    if (level) {\n                        updateListMetadata(level, metadata =>\n                            Object.assign({}, metadata, {\n                                applyListStyleFromLevel: true,\n                            })\n                        );\n                    }\n                } else {\n                    existingListItems.forEach(\n                        x => (mutateBlock(x).levels[0].format.marginBottom = '0px')\n                    );\n                    existingListItems = [];\n                }\n            }\n        }\n    });\n\n    normalizeContentModel(model);\n\n    return paragraphOrListItems.length > 0;\n}\n\nfunction shouldIgnoreBlock(block: ReadonlyContentModelBlock) {\n    switch (block.blockType) {\n        case 'Table':\n            return false;\n        case 'Paragraph':\n            return block.segments.every(\n                x => x.segmentType == 'Br' || x.segmentType == 'SelectionMarker'\n            );\n        default:\n            return true;\n    }\n}\n","import { getFirstSelectedListItem, mutateBlock } from 'roosterjs-content-model-dom';\nimport type { ReadonlyContentModelDocument } from 'roosterjs-content-model-types';\n\n/**\n * Set start number of a list item\n * @param model The model document\n * @param value The number to set to, must be equal or greater than 1\n */\nexport function setModelListStartNumber(model: ReadonlyContentModelDocument, value: number) {\n    const listItem = getFirstSelectedListItem(model);\n    const level = listItem ? mutateBlock(listItem).levels[listItem?.levels.length - 1] : null;\n\n    if (level) {\n        level.format.startNumberOverride = value;\n\n        return true;\n    } else {\n        return false;\n    }\n}\n","import { findListItemsInSameThread } from './findListItemsInSameThread';\nimport {\n    getFirstSelectedListItem,\n    mutateBlock,\n    updateListMetadata,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ListMetadataFormat,\n    ReadonlyContentModelDocument,\n} from 'roosterjs-content-model-types';\n\n/**\n * Set style of list items with in same thread of current item\n * @param model The model document\n * @param style The style to set\n */\nexport function setModelListStyle(model: ReadonlyContentModelDocument, style: ListMetadataFormat) {\n    const listItem = getFirstSelectedListItem(model);\n\n    if (listItem) {\n        const listItems = findListItemsInSameThread(model, listItem);\n        const levelIndex = listItem.levels.length - 1;\n\n        listItems.forEach(listItem => {\n            const level = mutateBlock(listItem).levels[levelIndex];\n\n            if (level) {\n                updateListMetadata(level, metadata => Object.assign({}, metadata, style));\n            }\n        });\n    }\n    return !!listItem;\n}\n","import { getSelectedParagraphs, setSelection } from 'roosterjs-content-model-dom';\nimport type {\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function adjustSegmentSelection(\n    model: ReadonlyContentModelDocument,\n    firstMatcher: (\n        target: ReadonlyContentModelSegment,\n        paragraph: ReadonlyContentModelParagraph\n    ) => boolean,\n    siblingMatcher: (\n        target: ReadonlyContentModelSegment,\n        ref: ReadonlyContentModelSegment,\n        paragraph: ReadonlyContentModelParagraph\n    ) => boolean\n): boolean {\n    const paragraphs = getSelectedParagraphs(model);\n    let first: ReadonlyContentModelSegment | undefined;\n    let last: ReadonlyContentModelSegment | undefined;\n    let changed = false;\n\n    paragraphs.forEach(p => {\n        const index = first ? 0 : p.segments.findIndex(x => firstMatcher(x, p));\n        const segments = p.segments;\n\n        if (!first) {\n            first = segments[index];\n\n            for (let i = index; i > 0; i--) {\n                if (siblingMatcher(segments[i - 1], first, p)) {\n                    first = segments[i - 1];\n                    changed = changed || !segments[i - 1].isSelected;\n                } else {\n                    changed = changed || !!segments[i - 1].isSelected;\n                    break;\n                }\n            }\n        }\n\n        if (first) {\n            for (let i = index; i < p.segments.length; i++) {\n                if (i == index || siblingMatcher(segments[i], last || segments[index], p)) {\n                    last = segments[i];\n                    changed = changed || !segments[i].isSelected;\n                } else {\n                    changed = changed || !!segments[i].isSelected;\n                    break;\n                }\n            }\n        }\n    });\n\n    if (first && last) {\n        setSelection(model, first, last);\n    }\n\n    return changed;\n}\n","import { createText, iterateSelections, mutateSegment } from 'roosterjs-content-model-dom';\nimport type {\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelText,\n} from 'roosterjs-content-model-types';\n\n/**\n * If a format cannot be applied to be applied to a trailing space, split the trailing space into a separate segment\n * @internal\n */\nexport function adjustTrailingSpaceSelection(model: ReadonlyContentModelDocument) {\n    iterateSelections(model, (_, __, block, segments) => {\n        if (block?.blockType === 'Paragraph' && segments && segments.length > 0) {\n            if (\n                segments.length === 1 &&\n                segments[0].segmentType === 'Text' &&\n                shouldSplitTrailingSpace(segments[0])\n            ) {\n                splitTextSegment(block, segments[0]);\n            } else {\n                const lastTextSegment =\n                    segments[segments.length - 1].segmentType === 'SelectionMarker'\n                        ? segments[segments.length - 2]\n                        : segments[segments.length - 1];\n                if (\n                    lastTextSegment &&\n                    lastTextSegment.segmentType === 'Text' &&\n                    shouldSplitTrailingSpace(lastTextSegment)\n                ) {\n                    splitTextSegment(block, lastTextSegment);\n                }\n            }\n        }\n\n        return false;\n    });\n}\n\nfunction shouldSplitTrailingSpace(segment: ReadonlyContentModelText) {\n    return segment.isSelected && hasTrailingSpace(segment.text) && !isTrailingSpace(segment.text);\n}\n\nfunction hasTrailingSpace(text: string) {\n    return text.trimRight() !== text;\n}\n\nfunction isTrailingSpace(text: string) {\n    return text.trimRight().length == 0;\n}\n\nfunction splitTextSegment(\n    readonlyBlock: ReadonlyContentModelParagraph,\n    readonlyTextSegment: ReadonlyContentModelText\n) {\n    mutateSegment(readonlyBlock, readonlyTextSegment, (textSegment, block) => {\n        const text = textSegment.text.trimRight();\n        const trailingSpace = textSegment.text.substring(text.length);\n        const newText = createText(text, textSegment.format, textSegment.link, textSegment.code);\n        newText.isSelected = true;\n        const trailingSpaceLink = textSegment.link\n            ? {\n                  ...textSegment.link,\n                  format: {\n                      ...textSegment.link?.format,\n                      underline: false, // Remove underline for trailing space link\n                  },\n              }\n            : undefined;\n        const trailingSpaceSegment = createText(\n            trailingSpace,\n            undefined,\n            trailingSpaceLink,\n            textSegment.code\n        );\n        trailingSpaceSegment.isSelected = true;\n        const index = block.segments.indexOf(textSegment);\n        block.segments.splice(index, 1, newText, trailingSpaceSegment);\n    });\n}\n","import {\n    createText,\n    isPunctuation,\n    isSpace,\n    iterateSelections,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelText,\n    ReadonlyContentModelDocument,\n    ShallowMutableContentModelParagraph,\n    ShallowMutableContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * Return specific word segment where the selection marker is located\n * @param model The model document\n * @param marker The selection marker\n * @returns An array of segments that form the word where the selection marker is located\n */\nexport function adjustWordSelection(\n    model: ReadonlyContentModelDocument,\n    marker: ShallowMutableContentModelSegment\n): ShallowMutableContentModelSegment[] {\n    let markerBlock: ShallowMutableContentModelParagraph | undefined;\n\n    iterateSelections(model, (_, __, block, segments) => {\n        //Find the block with the selection marker\n        if (block?.blockType == 'Paragraph' && segments?.length == 1 && segments[0] == marker) {\n            markerBlock = mutateBlock(block);\n        }\n        return true;\n    });\n\n    const tempSegments = markerBlock ? [...markerBlock.segments] : undefined;\n\n    if (tempSegments && markerBlock) {\n        const segments: ShallowMutableContentModelSegment[] = [];\n        let markerSelectionIndex = tempSegments.indexOf(marker);\n        for (let i = markerSelectionIndex - 1; i >= 0; i--) {\n            const currentSegment = tempSegments[i];\n            if (currentSegment.segmentType == 'Text') {\n                const found = findDelimiter(currentSegment, false /*moveRightward*/);\n                if (found > -1) {\n                    if (found == currentSegment.text.length) {\n                        break;\n                    }\n\n                    splitTextSegment(tempSegments, currentSegment, i, found);\n\n                    segments.push(tempSegments[i + 1]);\n\n                    break;\n                } else {\n                    segments.push(tempSegments[i]);\n                }\n            } else {\n                break;\n            }\n        }\n\n        markerSelectionIndex = tempSegments.indexOf(marker);\n        segments.push(marker);\n\n        // Marker is at start of word\n        if (segments.length <= 1) {\n            return segments;\n        }\n\n        for (let i = markerSelectionIndex + 1; i < tempSegments.length; i++) {\n            const currentSegment = tempSegments[i];\n            if (currentSegment.segmentType == 'Text') {\n                const found = findDelimiter(currentSegment, true /*moveRightward*/);\n                if (found > -1) {\n                    if (found == 0) {\n                        break;\n                    }\n                    splitTextSegment(tempSegments, currentSegment, i, found);\n                    segments.push(tempSegments[i]);\n                    break;\n                } else {\n                    segments.push(tempSegments[i]);\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Marker is at end of word\n        if (segments[segments.length - 1] == marker) {\n            return [marker];\n        }\n\n        markerBlock.segments = tempSegments;\n        return segments;\n    } else {\n        return [marker];\n    }\n}\n\n/*\n// These are unicode characters mostly from the Category Space Separator (Zs)\nhttps://unicode.org/Public/UNIDATA/Scripts.txt\n\n\\u2000 = EN QUAD\n\\u2009 = THIN SPACE\n\\u200a = HAIR SPACE\n\\u200b = ZERO WIDTH SPACE\n\\u202f = NARROW NO-BREAK SPACE\n\\u205f = MEDIUM MATHEMATICAL SPACE\n\\u3000 = IDEOGRAPHIC SPACE\n*/\nfunction findDelimiter(segment: ContentModelText, moveRightward: boolean): number {\n    const word = segment.text;\n    let offset = -1;\n    if (moveRightward) {\n        for (let i = 0; i < word.length; i++) {\n            const char = word[i];\n\n            if (isPunctuation(char) || isSpace(char)) {\n                offset = i;\n                break;\n            }\n        }\n    } else {\n        for (let i = word.length - 1; i >= 0; i--) {\n            const char = word[i];\n\n            if (isPunctuation(char) || isSpace(char)) {\n                offset = i + 1;\n                break;\n            }\n        }\n    }\n    return offset;\n}\n\nfunction splitTextSegment(\n    segments: ShallowMutableContentModelSegment[],\n    textSegment: Readonly<ContentModelText>,\n    index: number,\n    found: number\n) {\n    const text = textSegment.text;\n    const newSegmentLeft = createText(\n        text.substring(0, found),\n        textSegment.format,\n        textSegment.link,\n        textSegment.code\n    );\n    const newSegmentRight = createText(\n        text.substring(found, text.length),\n        textSegment.format,\n        textSegment.link,\n        textSegment.code\n    );\n    segments.splice(index, 1, newSegmentLeft, newSegmentRight);\n}\n","import { addSegment, createSelectionMarker, mutateBlock } from 'roosterjs-content-model-dom';\nimport type {\n    ShallowMutableContentModelTableRow,\n    TableSelectionCoordinates,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function collapseTableSelection(\n    rows: ShallowMutableContentModelTableRow[],\n    selection: TableSelectionCoordinates\n) {\n    const { firstColumn, firstRow } = selection;\n    const cell = rows[firstRow]?.cells[firstColumn];\n    if (cell) {\n        addSegment(mutateBlock(cell), createSelectionMarker());\n    }\n}\n","import type {\n    ShallowMutableContentModelTable,\n    TableAlignOperation,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function alignTable(table: ShallowMutableContentModelTable, operation: TableAlignOperation) {\n    table.format.marginLeft = operation == 'alignLeft' ? '' : 'auto';\n    table.format.marginRight = operation == 'alignRight' ? '' : 'auto';\n}\n","import {\n    getSelectedCells,\n    mutateBlock,\n    updateTableCellMetadata,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ShallowMutableContentModelTable,\n    ShallowMutableContentModelTableCell,\n    TableCellHorizontalAlignOperation,\n    TableCellVerticalAlignOperation,\n} from 'roosterjs-content-model-types';\n\nconst TextAlignValueMap: Record<\n    TableCellHorizontalAlignOperation,\n    Partial<Record<'ltr' | 'rtl', 'start' | 'center' | 'end'>>\n> = {\n    alignCellLeft: {\n        ltr: 'start',\n        rtl: 'end',\n    },\n    alignCellCenter: {\n        ltr: 'center',\n        rtl: 'center',\n    },\n    alignCellRight: {\n        ltr: 'end',\n        rtl: 'start',\n    },\n};\n\nconst VerticalAlignValueMap: Partial<Record<\n    TableCellVerticalAlignOperation,\n    'top' | 'middle' | 'bottom'\n>> = {\n    alignCellTop: 'top',\n    alignCellMiddle: 'middle',\n    alignCellBottom: 'bottom',\n};\n\n/**\n * @internal\n */\nexport function alignTableCellHorizontally(\n    table: ShallowMutableContentModelTable,\n    operation: TableCellHorizontalAlignOperation\n) {\n    alignTableCellInternal(table, cell => {\n        cell.format.textAlign =\n            TextAlignValueMap[operation][cell.format.direction == 'rtl' ? 'rtl' : 'ltr'];\n    });\n}\n\n/**\n * @internal\n */\nexport function alignTableCellVertically(\n    table: ShallowMutableContentModelTable,\n    operation: TableCellVerticalAlignOperation\n) {\n    alignTableCellInternal(table, cell => {\n        cell.format.verticalAlign = VerticalAlignValueMap[operation];\n\n        updateTableCellMetadata(cell, metadata => {\n            metadata = metadata || {};\n            metadata.vAlignOverride = true;\n            return metadata;\n        });\n    });\n}\n\nfunction alignTableCellInternal(\n    table: ShallowMutableContentModelTable,\n    callback: (cell: ShallowMutableContentModelTableCell) => void\n) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n            for (let colIndex = sel.firstColumn; colIndex <= sel.lastColumn; colIndex++) {\n                const cell = table.rows[rowIndex]?.cells[colIndex];\n                const format = cell?.format;\n\n                if (format) {\n                    callback(mutateBlock(cell));\n\n                    cell.blocks.forEach(block => {\n                        if (block.blockType === 'Paragraph' && block.format.textAlign) {\n                            delete mutateBlock(block).format.textAlign;\n                        }\n                    });\n                }\n            }\n        }\n    }\n}\n","import type { ReadonlyContentModelTableRow } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function canMergeCells(\n    rows: ReadonlyContentModelTableRow[],\n    firstRow: number,\n    firstCol: number,\n    lastRow: number,\n    lastCol: number\n): boolean {\n    const noSpanAbove =\n        firstCol == lastCol ||\n        rows[firstRow].cells.every(\n            (cell, colIndex) => colIndex < firstCol || colIndex > lastCol || !cell.spanAbove\n        );\n    const noSpanLeft =\n        firstRow == lastRow ||\n        rows.every(\n            (row, rowIndex) =>\n                rowIndex < firstRow || rowIndex > lastRow || !row.cells[firstCol].spanLeft\n        );\n\n    const noDifferentBelowSpan = rows[lastRow].cells\n        .map((_, colIndex) =>\n            colIndex >= firstCol && colIndex <= lastCol\n                ? getBelowSpanCount(rows, lastRow, colIndex)\n                : -1\n        )\n        .every((x, _, a) => x < 0 || x == a[firstCol]);\n    const noDifferentRightSpan = rows\n        .map((_, rowIndex) =>\n            rowIndex >= firstRow && rowIndex <= lastRow\n                ? getRightSpanCount(rows, rowIndex, lastCol)\n                : -1\n        )\n        .every((x, _, a) => x < 0 || x == a[firstRow]);\n\n    return noSpanAbove && noSpanLeft && noDifferentBelowSpan && noDifferentRightSpan;\n}\n\nfunction getBelowSpanCount(\n    rows: ReadonlyContentModelTableRow[],\n    rowIndex: number,\n    colIndex: number\n) {\n    let spanCount = 0;\n\n    for (let row = rowIndex + 1; row < rows.length; row++) {\n        if (rows[row]?.cells[colIndex]?.spanAbove) {\n            spanCount++;\n        } else {\n            break;\n        }\n    }\n\n    return spanCount;\n}\n\nfunction getRightSpanCount(\n    rows: ReadonlyContentModelTableRow[],\n    rowIndex: number,\n    colIndex: number\n) {\n    let spanCount = 0;\n\n    for (let col = colIndex + 1; col < rows[rowIndex]?.cells.length; col++) {\n        if (rows[rowIndex]?.cells[col]?.spanLeft) {\n            spanCount++;\n        } else {\n            break;\n        }\n    }\n\n    return spanCount;\n}\n","import { mutateBlock, setSelection } from 'roosterjs-content-model-dom';\nimport type {\n    ReadonlyContentModelTable,\n    TableSelectionCoordinates,\n} from 'roosterjs-content-model-types';\n\n/**\n * Clear selection of a table.\n * @param table The table model where the selection is to be cleared\n * @param sel The selection coordinates to be cleared\n */\nexport function clearSelectedCells(\n    table: ReadonlyContentModelTable,\n    sel: TableSelectionCoordinates\n) {\n    if (\n        sel.firstColumn >= 0 &&\n        sel.firstRow >= 0 &&\n        sel.lastRow < table.rows.length &&\n        sel.lastColumn < table.rows[sel.lastRow].cells.length\n    ) {\n        for (let i = sel.firstRow; i <= sel.lastRow; i++) {\n            const row = table.rows[i];\n\n            for (let j = sel.firstColumn; j <= sel.lastColumn; j++) {\n                const cell = row.cells[j];\n\n                if (cell) {\n                    if (cell.isSelected) {\n                        mutateBlock(cell).isSelected = false;\n                    }\n\n                    setSelection(cell);\n                }\n            }\n        }\n    }\n}\n","import { createBr, createParagraph, mutateBlock } from 'roosterjs-content-model-dom';\nimport type { ReadonlyContentModelTableCell } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function copyPreviousCellSegmentFormat(\n    cell: ReadonlyContentModelTableCell,\n    newCell: ReadonlyContentModelTableCell\n) {\n    const block = cell.blocks[0];\n    if (block && block?.blockType == 'Paragraph') {\n        const firstSegment = block.segments[0];\n        if (\n            firstSegment &&\n            (firstSegment.segmentType == 'Text' ||\n                firstSegment.segmentType == 'Br' ||\n                firstSegment.segmentType == 'SelectionMarker')\n        ) {\n            const newCellParagraph = createParagraph(\n                false /* isImplicit */,\n                block.format,\n                block.segmentFormat\n            );\n            const br = createBr(firstSegment.format);\n            newCellParagraph.segments.push(br);\n            mutateBlock(newCell).blocks.push(newCellParagraph);\n        }\n    }\n}\n","import { addBlock, createTable, createTableCell } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelTable,\n    ContentModelTableCellFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function createTableStructure(\n    parent: ContentModelBlockGroup,\n    columns: number,\n    rows: number,\n    cellFormat?: ContentModelTableCellFormat\n): ContentModelTable {\n    const table = createTable(rows);\n\n    addBlock(parent, table);\n\n    table.rows.forEach(row => {\n        for (let i = 0; i < columns; i++) {\n            const cell = createTableCell(\n                undefined /*spanLeftOrColSpan */,\n                undefined /*spanAboveOrRowSpan */,\n                undefined /* isHeader */,\n                cellFormat\n            );\n\n            row.cells.push(cell);\n        }\n    });\n\n    return table;\n}\n","import type { ShallowMutableContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function deleteTable(table: ShallowMutableContentModelTable) {\n    table.rows = [];\n}\n","import { collapseTableSelection } from '../selection/collapseTableSelection';\nimport { getSelectedCells, mutateBlock } from 'roosterjs-content-model-dom';\nimport type { ShallowMutableContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function deleteTableColumn(table: ShallowMutableContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        for (let rowIndex = 0; rowIndex < table.rows.length; rowIndex++) {\n            const cellInNextCol = table.rows[rowIndex].cells[sel.lastColumn + 1];\n\n            if (cellInNextCol) {\n                mutateBlock(cellInNextCol).spanLeft =\n                    cellInNextCol.spanLeft && table.rows[rowIndex].cells[sel.firstColumn].spanLeft;\n            }\n\n            table.rows[rowIndex].cells.splice(\n                sel.firstColumn,\n                sel.lastColumn - sel.firstColumn + 1\n            );\n        }\n\n        table.widths.splice(sel.firstColumn, sel.lastColumn - sel.firstColumn + 1);\n        collapseTableSelection(table.rows, sel);\n    }\n}\n","import { collapseTableSelection } from '../selection/collapseTableSelection';\nimport { getSelectedCells, mutateBlock } from 'roosterjs-content-model-dom';\nimport type { ShallowMutableContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function deleteTableRow(table: ShallowMutableContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        table.rows[sel.firstRow].cells.forEach((cell, colIndex) => {\n            const cellInNextCell = table.rows[sel.lastRow + 1]?.cells[colIndex];\n\n            if (cellInNextCell) {\n                mutateBlock(cellInNextCell).spanAbove = cellInNextCell.spanAbove && cell.spanAbove;\n            }\n        });\n\n        table.rows.splice(sel.firstRow, sel.lastRow - sel.firstRow + 1);\n\n        collapseTableSelection(table.rows, sel);\n    }\n}\n","import { createBr, createParagraph, mutateBlock } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelParagraph,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelTable,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * After edit table, it maybe in a abnormal state, e.g. selected table cell is removed, or all rows are removed causes no place to put cursor.\n * We need to make sure table is in normal state, and there is a place to put cursor.\n * @returns a new paragraph that can but put focus in, or undefined if not needed\n */\nexport function ensureFocusableParagraphForTable(\n    model: ReadonlyContentModelDocument,\n    path: ReadonlyContentModelBlockGroup[],\n    table: ReadonlyContentModelTable\n): ContentModelParagraph | undefined {\n    let paragraph: ContentModelParagraph | undefined;\n    const firstCell = table.rows.filter(row => row.cells.length > 0)[0]?.cells[0];\n\n    if (firstCell) {\n        // When there is a valid cell to put focus, use it\n        paragraph = firstCell.blocks.filter(\n            (block): block is ContentModelParagraph => block.blockType == 'Paragraph'\n        )[0];\n\n        if (!paragraph) {\n            // If there is not a paragraph under this cell, create one\n            paragraph = createEmptyParagraph(model);\n            mutateBlock(firstCell).blocks.push(paragraph);\n        }\n    } else {\n        // No table cell at all, which means the whole table is deleted. So we need to remove it from content model.\n        let block: ReadonlyContentModelBlock = table;\n        let parent: ReadonlyContentModelBlockGroup | undefined;\n        paragraph = createEmptyParagraph(model);\n\n        // If the table is the only block of its parent and parent is a FormatContainer, remove the parent as well.\n        // We need to do this in a loop in case there are multiple layer of FormatContainer that match this case\n        while ((parent = path.shift())) {\n            const index = parent.blocks.indexOf(block) ?? -1;\n\n            if (parent && index >= 0) {\n                mutateBlock(parent).blocks.splice(index, 1, paragraph);\n            }\n\n            if (\n                parent.blockGroupType == 'FormatContainer' &&\n                parent.blocks.length == 1 &&\n                parent.blocks[0] == paragraph\n            ) {\n                // If the new paragraph is the only child of parent format container, unwrap parent as well\n                block = parent;\n            } else {\n                // Otherwise, just stop here and keep processing the new paragraph\n                break;\n            }\n        }\n    }\n\n    return paragraph;\n}\n\nfunction createEmptyParagraph(model: ReadonlyContentModelDocument) {\n    const newPara = createParagraph(false /*isImplicit*/, undefined /*blockFormat*/, model.format);\n    const br = createBr(model.format);\n\n    newPara.segments.push(br);\n\n    return newPara;\n}\n","import { clearSelectedCells } from './clearSelectedCells';\nimport { copyPreviousCellSegmentFormat } from './copyPreviousCellSegmentFormat';\nimport { createTableCell, getSelectedCells } from 'roosterjs-content-model-dom';\nimport type {\n    ShallowMutableContentModelTable,\n    TableHorizontalInsertOperation,\n} from 'roosterjs-content-model-types';\n\n/**\n * Insert a column to the table\n * @param table The table model where the column is to be inserted\n * @param operation The operation to be performed\n */\nexport function insertTableColumn(\n    table: ShallowMutableContentModelTable,\n    operation: TableHorizontalInsertOperation\n) {\n    const sel = getSelectedCells(table);\n    const insertLeft = operation == 'insertLeft';\n\n    if (sel) {\n        clearSelectedCells(table, sel);\n        for (let i = sel?.firstColumn; i <= sel.lastColumn; i++) {\n            table.rows.forEach(row => {\n                const cell = row.cells[insertLeft ? sel.firstColumn : sel.lastColumn];\n\n                const newCell = createTableCell(\n                    cell.spanLeft,\n                    cell.spanAbove,\n                    cell.isHeader,\n                    cell.format,\n                    cell.dataset\n                );\n                copyPreviousCellSegmentFormat(cell, newCell);\n                newCell.isSelected = true;\n\n                row.cells.splice(insertLeft ? sel.firstColumn : sel.lastColumn + 1, 0, newCell);\n            });\n            table.widths.splice(\n                insertLeft ? sel.firstColumn : sel.lastColumn + 1,\n                0,\n                table.widths[insertLeft ? sel.firstColumn : sel.lastColumn]\n            );\n        }\n    }\n}\n","import { clearSelectedCells } from './clearSelectedCells';\nimport { copyPreviousCellSegmentFormat } from './copyPreviousCellSegmentFormat';\nimport { createTableCell, getSelectedCells } from 'roosterjs-content-model-dom';\nimport type {\n    ShallowMutableContentModelTable,\n    TableVerticalInsertOperation,\n} from 'roosterjs-content-model-types';\n\n/**\n * Insert a row to the table\n * @param table The table model where the row is to be inserted\n * @param operation The operation to be performed\n */\nexport function insertTableRow(\n    table: ShallowMutableContentModelTable,\n    operation: TableVerticalInsertOperation\n) {\n    const sel = getSelectedCells(table);\n    const insertAbove = operation == 'insertAbove';\n\n    if (sel) {\n        clearSelectedCells(table, sel);\n\n        for (let i = sel.firstRow; i <= sel.lastRow; i++) {\n            const sourceRow = table.rows[insertAbove ? sel.firstRow : sel.lastRow];\n\n            table.rows.splice(insertAbove ? sel.firstRow : sel.lastRow + 1, 0, {\n                format: { ...sourceRow.format },\n                cells: sourceRow.cells.map(cell => {\n                    const newCell = createTableCell(\n                        cell.spanLeft,\n                        cell.spanAbove,\n                        cell.isHeader,\n                        cell.format,\n                        cell.dataset\n                    );\n                    copyPreviousCellSegmentFormat(cell, newCell);\n                    newCell.isSelected = true;\n                    return newCell;\n                }),\n                height: sourceRow.height,\n            });\n        }\n    }\n}\n","import { canMergeCells } from './canMergeCells';\nimport { getSelectedCells, mutateBlock } from 'roosterjs-content-model-dom';\nimport type { ShallowMutableContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function mergeTableCells(table: ShallowMutableContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (\n        sel &&\n        canMergeCells(table.rows, sel.firstRow, sel.firstColumn, sel.lastRow, sel.lastColumn)\n    ) {\n        for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n            for (let colIndex = sel.firstColumn; colIndex <= sel.lastColumn; colIndex++) {\n                const cell = table.rows[rowIndex].cells[colIndex];\n\n                if (cell) {\n                    const mutableCell = mutateBlock(cell);\n\n                    mutableCell.spanLeft = colIndex > sel.firstColumn;\n                    mutableCell.spanAbove = rowIndex > sel.firstRow;\n                }\n            }\n        }\n    }\n}\n","import { canMergeCells } from './canMergeCells';\nimport { getSelectedCells, mutateBlock } from 'roosterjs-content-model-dom';\nimport type {\n    ShallowMutableContentModelTable,\n    TableHorizontalMergeOperation,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function mergeTableColumn(\n    table: ShallowMutableContentModelTable,\n    operation: TableHorizontalMergeOperation\n) {\n    const sel = getSelectedCells(table);\n    const mergeLeft = operation == 'mergeLeft';\n\n    if (sel) {\n        const mergingColIndex = mergeLeft ? sel.firstColumn : sel.lastColumn + 1;\n\n        if (mergingColIndex > 0 && mergingColIndex < table.rows[0].cells.length) {\n            for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n                const cell = table.rows[rowIndex]?.cells[mergingColIndex];\n\n                if (\n                    cell &&\n                    canMergeCells(\n                        table.rows,\n                        rowIndex,\n                        mergingColIndex - 1,\n                        rowIndex,\n                        mergingColIndex\n                    )\n                ) {\n                    mutateBlock(cell).spanLeft = true;\n\n                    let newSelectedCol = mergingColIndex;\n\n                    while (table.rows[rowIndex]?.cells[newSelectedCol]?.spanLeft) {\n                        mutateBlock(table.rows[rowIndex].cells[newSelectedCol]);\n                        newSelectedCol--;\n                    }\n\n                    const newCell = table.rows[rowIndex]?.cells[newSelectedCol];\n                    if (newCell) {\n                        mutateBlock(newCell).isSelected = true;\n                    }\n                }\n            }\n        }\n    }\n}\n","import { canMergeCells } from './canMergeCells';\nimport { getSelectedCells, mutateBlock } from 'roosterjs-content-model-dom';\nimport type {\n    ShallowMutableContentModelTable,\n    TableVerticalMergeOperation,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function mergeTableRow(\n    table: ShallowMutableContentModelTable,\n    operation: TableVerticalMergeOperation\n) {\n    const sel = getSelectedCells(table);\n    const mergeAbove = operation == 'mergeAbove';\n\n    if (sel) {\n        const mergingRowIndex = mergeAbove ? sel.firstRow : sel.lastRow + 1;\n\n        if (mergingRowIndex > 0 && mergingRowIndex < table.rows.length) {\n            for (let colIndex = sel.firstColumn; colIndex <= sel.lastColumn; colIndex++) {\n                const cell = table.rows[mergingRowIndex].cells[colIndex];\n\n                if (\n                    cell &&\n                    canMergeCells(\n                        table.rows,\n                        mergingRowIndex - 1,\n                        colIndex,\n                        mergingRowIndex,\n                        colIndex\n                    )\n                ) {\n                    mutateBlock(cell).spanAbove = true;\n\n                    let newSelectedRow = mergingRowIndex;\n\n                    while (table.rows[newSelectedRow]?.cells[colIndex]?.spanAbove) {\n                        mutateBlock(table.rows[newSelectedRow].cells[colIndex]);\n                        newSelectedRow--;\n                    }\n\n                    const newCell = table.rows[newSelectedRow]?.cells[colIndex];\n\n                    if (newCell) {\n                        mutateBlock(newCell).isSelected = true;\n                    }\n                }\n            }\n        }\n    }\n}\n","import { createTableCell, getSelectedCells, mutateBlock } from 'roosterjs-content-model-dom';\nimport type { ShallowMutableContentModelTable } from 'roosterjs-content-model-types';\n\nconst MIN_WIDTH = 30;\n\n/**\n * @internal\n */\nexport function splitTableCellHorizontally(table: ShallowMutableContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        for (let colIndex = sel.lastColumn; colIndex >= sel.firstColumn; colIndex--) {\n            if (\n                table.rows.every(\n                    (row, rowIndex) =>\n                        rowIndex < sel.firstRow ||\n                        rowIndex > sel.lastRow ||\n                        row.cells[colIndex + 1]?.spanLeft\n                )\n            ) {\n                table.rows.forEach((row, rowIndex) => {\n                    mutateBlock(row.cells[colIndex]);\n\n                    if (rowIndex >= sel.firstRow && rowIndex <= sel.lastRow) {\n                        mutateBlock(row.cells[colIndex + 1]).spanLeft = false;\n                    }\n                });\n            } else {\n                table.rows.forEach((row, rowIndex) => {\n                    const cell = row.cells[colIndex];\n                    if (cell) {\n                        const mutableCell = mutateBlock(cell);\n\n                        delete mutableCell.format.width;\n\n                        const newCell = createTableCell(\n                            cell.spanLeft,\n                            cell.spanAbove,\n                            cell.isHeader,\n                            mutableCell.format\n                        );\n\n                        newCell.dataset = { ...cell.dataset };\n\n                        if (rowIndex < sel.firstRow || rowIndex > sel.lastRow) {\n                            newCell.spanLeft = true;\n                        } else {\n                            newCell.isSelected = cell.isSelected;\n                        }\n                        row.cells.splice(colIndex + 1, 0, newCell);\n\n                        mutateBlock(row.cells[colIndex]);\n                    }\n                });\n\n                const newWidth = Math.max(table.widths[colIndex] / 2, MIN_WIDTH);\n\n                table.widths.splice(colIndex, 1, newWidth, newWidth);\n            }\n        }\n    }\n}\n","import { createTableCell, getSelectedCells, mutateBlock } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelTableRow,\n    ShallowMutableContentModelTable,\n} from 'roosterjs-content-model-types';\n\nconst MIN_HEIGHT = 22;\n\n/**\n * @internal\n */\nexport function splitTableCellVertically(table: ShallowMutableContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        for (let rowIndex = sel.lastRow; rowIndex >= sel.firstRow; rowIndex--) {\n            const row = table.rows[rowIndex];\n            const belowRow = table.rows[rowIndex + 1];\n\n            row.cells.forEach(mutateBlock);\n\n            if (\n                belowRow?.cells.every(\n                    (belowCell, colIndex) =>\n                        colIndex < sel.firstColumn ||\n                        colIndex > sel.lastColumn ||\n                        belowCell.spanAbove\n                )\n            ) {\n                belowRow.cells.forEach((belowCell, colIndex) => {\n                    if (colIndex >= sel.firstColumn && colIndex <= sel.lastColumn) {\n                        mutateBlock(belowCell).spanAbove = false;\n                    }\n                });\n            } else {\n                const newHeight = Math.max((row.height /= 2), MIN_HEIGHT);\n                const newRow: ContentModelTableRow = {\n                    format: { ...row.format },\n                    height: newHeight,\n                    cells: row.cells.map((cell, colIndex) => {\n                        const mutableCell = mutateBlock(cell);\n\n                        delete mutableCell.format.height;\n\n                        const newCell = createTableCell(\n                            cell.spanLeft,\n                            cell.spanAbove,\n                            cell.isHeader,\n                            mutableCell.format\n                        );\n\n                        newCell.dataset = { ...cell.dataset };\n\n                        if (colIndex < sel.firstColumn || colIndex > sel.lastColumn) {\n                            newCell.spanAbove = true;\n                        } else {\n                            newCell.isSelected = cell.isSelected;\n                        }\n\n                        return newCell;\n                    }),\n                };\n\n                row.height = newHeight;\n                table.rows.splice(rowIndex + 1, 0, newRow);\n            }\n        }\n    }\n}\n","import { setModelAlignment } from '../../modelApi/block/setModelAlignment';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set text alignment of selected paragraphs\n * @param editor The editor to set alignment\n * @param alignment Alignment value: left, center or right\n */\nexport function setAlignment(editor: IEditor, alignment: 'left' | 'center' | 'right' | 'justify') {\n    editor.focus();\n\n    editor.formatContentModel(model => setModelAlignment(model, alignment), {\n        apiName: 'setAlignment',\n    });\n}\n","import { setModelDirection } from '../../modelApi/block/setModelDirection';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set text direction of selected paragraphs (Left to right or Right to left)\n * @param editor The editor to set alignment\n * @param direction Direction value: ltr (Left to right) or rtl (Right to left), or 'auto' (Based on the first characters of the document, set the direction automatically)\n */\nexport function setDirection(editor: IEditor, direction: 'ltr' | 'rtl' | 'auto') {\n    editor.focus();\n\n    editor.formatContentModel(model => setModelDirection(model, direction), {\n        apiName: 'setDirection',\n    });\n}\n","import { formatParagraphWithContentModel } from '../utils/formatParagraphWithContentModel';\nimport type { ContentModelParagraphDecorator, IEditor } from 'roosterjs-content-model-types';\n\ntype HeadingLevelTags = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n\nconst HeaderFontSizes: Record<HeadingLevelTags, string> = {\n    h1: '2em',\n    h2: '1.5em',\n    h3: '1.17em',\n    h4: '1em',\n    h5: '0.83em',\n    h6: '0.67em',\n};\n\n/**\n * Set heading level of selected paragraphs\n * @param editor The editor to set heading level to\n * @param headingLevel Level of heading, from 1 to 6. Set to 0 means set it back to a regular paragraph\n */\nexport function setHeadingLevel(editor: IEditor, headingLevel: 0 | 1 | 2 | 3 | 4 | 5 | 6) {\n    editor.focus();\n\n    formatParagraphWithContentModel(editor, 'setHeadingLevel', para => {\n        const tagName =\n            headingLevel > 0\n                ? (('h' + headingLevel) as HeadingLevelTags | null)\n                : getExistingHeadingTag(para.decorator);\n\n        if (headingLevel > 0) {\n            para.decorator = {\n                tagName: tagName!,\n                format: tagName\n                    ? {\n                          fontWeight: 'bold',\n                          fontSize: HeaderFontSizes[tagName],\n                      }\n                    : {},\n            };\n\n            // Remove existing formats since tags have default font size and weight\n            para.segments.forEach(segment => {\n                delete segment.format.fontSize;\n                delete segment.format.fontWeight;\n            });\n        } else if (tagName) {\n            delete para.decorator;\n        }\n    });\n}\n\nfunction getExistingHeadingTag(\n    decorator?: ContentModelParagraphDecorator\n): HeadingLevelTags | null {\n    const tag = decorator?.tagName || '';\n    const level = parseInt(tag.substring(1));\n\n    return level >= 1 && level <= 6 ? (tag as HeadingLevelTags) : null;\n}\n","import { setModelIndentation } from '../../modelApi/block/setModelIndentation';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Indent or outdent to selected paragraphs\n * @param editor The editor to operate on\n * @param indentation Whether indent or outdent\n * @param length The length of pixel to indent/outdent @default 40\n */\nexport function setIndentation(\n    editor: IEditor,\n    indentation: 'indent' | 'outdent',\n    length?: number\n) {\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            const result = setModelIndentation(model, indentation, length);\n\n            context.newPendingFormat = 'preserve';\n\n            return result;\n        },\n        {\n            apiName: 'setIndentation',\n        }\n    );\n}\n","import { createParagraphDecorator } from 'roosterjs-content-model-dom';\nimport { formatParagraphWithContentModel } from '../utils/formatParagraphWithContentModel';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggles the current block(s) margin properties.\n * null deletes any existing value, undefined is ignored\n * @param editor The editor to operate on\n * @param marginTop value for top margin\n * @param marginBottom value for bottom margin\n */\nexport function setParagraphMargin(\n    editor: IEditor,\n    marginTop?: string | null,\n    marginBottom?: string | null\n) {\n    editor.focus();\n\n    formatParagraphWithContentModel(editor, 'setParagraphMargin', para => {\n        if (!para.decorator) {\n            para.decorator = createParagraphDecorator('p');\n        }\n\n        if (marginTop) {\n            para.format.marginTop = marginTop;\n        } else if (marginTop === null) {\n            delete para.format.marginTop;\n        }\n\n        if (marginBottom) {\n            para.format.marginBottom = marginBottom;\n        } else if (marginBottom === null) {\n            delete para.format.marginBottom;\n        }\n    });\n}\n","import { formatParagraphWithContentModel } from '../utils/formatParagraphWithContentModel';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Sets current selected block(s) line-height property and wipes such property from child segments\n * @param editor The editor to operate on\n * @param spacing Unitless/px value to set line height\n */\nexport function setSpacing(editor: IEditor, spacing: number | string) {\n    editor.focus();\n\n    formatParagraphWithContentModel(editor, 'setSpacing', paragraph => {\n        paragraph.format.lineHeight = spacing.toString();\n        paragraph.segments.forEach(segment => {\n            if (segment.format.lineHeight) {\n                delete segment.format.lineHeight;\n            }\n        });\n    });\n}\n","import { toggleModelBlockQuote } from '../../modelApi/block/toggleModelBlockQuote';\nimport type { ContentModelFormatContainerFormat, IEditor } from 'roosterjs-content-model-types';\n\nconst DefaultQuoteFormatLtr: ContentModelFormatContainerFormat = {\n    borderLeft: '3px solid rgb(200, 200, 200)',\n    textColor: 'rgb(102, 102, 102)',\n};\nconst DefaultQuoteFormatRtl: ContentModelFormatContainerFormat = {\n    borderRight: '3px solid rgb(200, 200, 200)',\n    textColor: 'rgb(102, 102, 102)',\n};\nconst BuildInQuoteFormat: ContentModelFormatContainerFormat = {\n    marginTop: '1em',\n    marginBottom: '1em',\n    marginLeft: '40px',\n    marginRight: '40px',\n};\n\n/**\n * Toggle BLOCKQUOTE state of selected paragraphs.\n * If any selected paragraph is not under a BLOCKQUOTE, wrap them into a BLOCKQUOTE.\n * Otherwise, unwrap all related BLOCKQUOTEs.\n * @param editor The editor object to toggle BLOCKQUOTE onto\n * @param quoteFormat @optional Block format for the new quote object\n */\nexport function toggleBlockQuote(\n    editor: IEditor,\n    quoteFormat?: ContentModelFormatContainerFormat,\n    quoteFormatRtl?: ContentModelFormatContainerFormat\n) {\n    const fullQuoteFormatLtr: ContentModelFormatContainerFormat = {\n        ...BuildInQuoteFormat,\n        paddingLeft: '10px',\n        ...(quoteFormat ?? DefaultQuoteFormatLtr),\n    };\n    const fullQuoteFormatRtl: ContentModelFormatContainerFormat = {\n        ...BuildInQuoteFormat,\n        paddingRight: '10px',\n        direction: 'rtl',\n        ...(quoteFormatRtl ?? quoteFormat ?? DefaultQuoteFormatRtl),\n    };\n\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            context.newPendingFormat = 'preserve';\n\n            return toggleModelBlockQuote(model, fullQuoteFormatLtr, fullQuoteFormatRtl);\n        },\n        {\n            apiName: 'toggleBlockQuote',\n        }\n    );\n}\n","import { formatInsertPointWithContentModel } from '../utils/formatInsertPointWithContentModel';\nimport { insertEntityModel } from '../../modelApi/entity/insertEntityModel';\nimport {\n    ChangeSource,\n    createEntity,\n    normalizeContentModel,\n    parseEntityFormat,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelEntity,\n    InsertEntityPosition,\n    InsertEntityOptions,\n    IEditor,\n    EntityState,\n    DOMInsertPoint,\n    FormatContentModelOptions,\n    FormatContentModelContext,\n    InsertPoint,\n    ShallowMutableContentModelDocument,\n} from 'roosterjs-content-model-types';\n\nconst BlockEntityTag = 'div';\nconst InlineEntityTag = 'span';\n\n/**\n * Insert an entity into editor\n * @param editor The editor object\n * @param type Type of entity\n * @param isBlock True to insert a block entity, false to insert an inline entity\n * @param position Position of the entity to insert. It can be\n * Value of InsertEntityPosition: see InsertEntityPosition\n * selectionRangeEx: Use this range instead of current focus position to insert. After insert, focus will be moved to\n * the beginning of this range (when focusAfterEntity is not set to true) or after the new entity (when focusAfterEntity is set to true)\n * @param options Move options to insert. See InsertEntityOptions\n */\nexport function insertEntity(\n    editor: IEditor,\n    type: string,\n    isBlock: boolean,\n    position: 'focus' | 'begin' | 'end' | DOMInsertPoint,\n    options?: InsertEntityOptions\n): ContentModelEntity | null;\n\n/**\n * Insert a block entity into editor\n * @param editor The editor object\n * @param type Type of entity\n * @param isBlock Must be true for a block entity\n * @param position Position of the entity to insert. It can be\n * Value of InsertEntityPosition: see InsertEntityPosition\n * selectionRangeEx: Use this range instead of current focus position to insert. After insert, focus will be moved to\n * the beginning of this range (when focusAfterEntity is not set to true) or after the new entity (when focusAfterEntity is set to true)\n * @param options Move options to insert. See InsertEntityOptions\n */\nexport function insertEntity(\n    editor: IEditor,\n    type: string,\n    isBlock: true,\n    position: InsertEntityPosition | DOMInsertPoint,\n    options?: InsertEntityOptions\n): ContentModelEntity | null;\n\nexport function insertEntity(\n    editor: IEditor,\n    type: string,\n    isBlock: boolean,\n    position?: InsertEntityPosition | DOMInsertPoint,\n    options?: InsertEntityOptions\n): ContentModelEntity | null {\n    const { contentNode, focusAfterEntity, wrapperDisplay, skipUndoSnapshot, initialEntityState } =\n        options || {};\n    const document = editor.getDocument();\n    const wrapper = document.createElement(isBlock ? BlockEntityTag : InlineEntityTag);\n    const display = wrapperDisplay ?? (isBlock ? undefined : 'inline-block');\n\n    wrapper.style.setProperty('display', display || null);\n\n    if (display == undefined && isBlock) {\n        wrapper.style.setProperty('width', '100%');\n        wrapper.style.setProperty('display', 'inline-block');\n    }\n\n    if (contentNode) {\n        wrapper.appendChild(contentNode);\n    }\n\n    const entityModel = createEntity(wrapper, true /* isReadonly */, undefined /*format*/, type);\n\n    if (!skipUndoSnapshot) {\n        editor.takeSnapshot();\n    }\n\n    const formatOptions: FormatContentModelOptions = {\n        changeSource: ChangeSource.InsertEntity,\n        getChangeData: () => ({\n            wrapper,\n            type,\n            id: '',\n            isReadonly: true,\n        }),\n        apiName: 'insertEntity',\n    };\n\n    const callback = (\n        model: ShallowMutableContentModelDocument,\n        context: FormatContentModelContext,\n        insertPoint?: InsertPoint\n    ) => {\n        insertEntityModel(\n            model,\n            entityModel,\n            typeof position == 'string' ? position : 'focus',\n            isBlock,\n            focusAfterEntity,\n            context,\n            insertPoint\n        );\n\n        normalizeContentModel(model);\n\n        context.skipUndoSnapshot = true;\n        context.newEntities.push(entityModel);\n\n        return true;\n    };\n\n    if (typeof position == 'object') {\n        formatInsertPointWithContentModel(editor, position, callback, formatOptions);\n    } else {\n        editor.formatContentModel(callback, formatOptions);\n    }\n\n    if (!skipUndoSnapshot) {\n        let entityState: EntityState | undefined;\n\n        if (initialEntityState) {\n            const format = parseEntityFormat(wrapper);\n            const { id, entityType } = format;\n\n            entityState =\n                id && entityType\n                    ? {\n                          id: id,\n                          type: entityType,\n                          state: initialEntityState,\n                      }\n                    : undefined;\n        }\n\n        editor.takeSnapshot(entityState);\n    }\n\n    return entityModel;\n}\n","import { clearModelFormat } from '../../modelApi/common/clearModelFormat';\nimport { normalizeContentModel } from 'roosterjs-content-model-dom';\nimport type {\n    IEditor,\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelSegment,\n    ContentModelTable,\n} from 'roosterjs-content-model-types';\n\nconst MAX_TRY = 3;\n\n/**\n * Clear format of selection\n * @param editor The editor to clear format from\n */\nexport function clearFormat(editor: IEditor) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            let changed = false;\n            let needtoRun = true;\n            let triedTimes = 0;\n\n            while (needtoRun && triedTimes++ < MAX_TRY) {\n                const blocksToClear: [ContentModelBlockGroup[], ContentModelBlock][] = [];\n                const segmentsToClear: ContentModelSegment[] = [];\n                const tablesToClear: [ContentModelTable, boolean][] = [];\n\n                needtoRun = clearModelFormat(model, blocksToClear, segmentsToClear, tablesToClear);\n\n                normalizeContentModel(model);\n\n                changed =\n                    changed ||\n                    blocksToClear.length > 0 ||\n                    segmentsToClear.length > 0 ||\n                    tablesToClear.length > 0;\n            }\n\n            return changed;\n        },\n        {\n            apiName: 'clearFormat',\n        }\n    );\n}\n","import { reducedModelChildProcessor } from '../../modelApi/common/reducedModelChildProcessor';\nimport { retrieveModelFormatState } from 'roosterjs-content-model-dom';\nimport type {\n    IEditor,\n    ContentModelFormatState,\n    ConflictFormatSolution,\n} from 'roosterjs-content-model-types';\n\n/**\n * Get current format state\n * @param editor The editor to get format from\n * @param conflictSolution The strategy for handling format conflicts\n */\nexport function getFormatState(\n    editor: IEditor,\n    conflictSolution: ConflictFormatSolution = 'remove'\n): ContentModelFormatState {\n    const pendingFormat = editor.getPendingFormat();\n    const manager = editor.getSnapshotsManager();\n    const result: ContentModelFormatState = {\n        canUndo: manager.hasNewContent || manager.canMove(-1),\n        canRedo: manager.canMove(1),\n        isDarkMode: editor.isDarkMode(),\n    };\n\n    editor.formatContentModel(\n        model => {\n            retrieveModelFormatState(\n                model,\n                pendingFormat,\n                result,\n                conflictSolution,\n                editor.getDOMHelper(),\n                editor.isDarkMode(),\n                editor.getColorManager()\n            );\n\n            return false;\n        },\n        undefined /*options*/,\n        {\n            processorOverride: {\n                child: reducedModelChildProcessor,\n            },\n            tryGetFromCache: true,\n        }\n    );\n\n    return result;\n}\n","import { adjustSegmentSelection } from '../../modelApi/selection/adjustSegmentSelection';\nimport { mutateSegment } from 'roosterjs-content-model-dom';\nimport type { ContentModelImage, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Adjust selection to make sure select an image if any\n * @return Content Model Image object if an image is select, or null\n */\nexport function adjustImageSelection(editor: IEditor): ContentModelImage | null {\n    let image: ContentModelImage | null = null;\n\n    editor.formatContentModel(\n        model =>\n            adjustSegmentSelection(\n                model,\n                (target, paragraph) => {\n                    if (target.isSelected && target.segmentType == 'Image') {\n                        mutateSegment(paragraph, target, segment => {\n                            image = segment;\n                        });\n                        return true;\n                    } else {\n                        return false;\n                    }\n                },\n                (target, ref) => target == ref\n            ),\n        {\n            apiName: 'adjustImageSelection',\n        }\n    );\n\n    return image;\n}\n","import { formatImageWithContentModel } from '../utils/formatImageWithContentModel';\nimport { getImageMetadata, readFile } from 'roosterjs-content-model-dom';\nimport type { ContentModelImage, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Change the selected image src\n * @param editor The editor instance\n * @param file The image file\n */\nexport function changeImage(editor: IEditor, file: File) {\n    editor.focus();\n\n    const selection = editor.getDOMSelection();\n    readFile(file, dataUrl => {\n        if (dataUrl && !editor.isDisposed() && selection?.type === 'image') {\n            formatImageWithContentModel(editor, 'changeImage', (image: ContentModelImage) => {\n                const originalSrc = getImageMetadata(image)?.src ?? '';\n                const previousSrc = image.src;\n\n                image.src = dataUrl;\n                image.dataset = {};\n                image.format.width = '';\n                image.format.height = '';\n                image.alt = '';\n\n                editor.triggerEvent('editImage', {\n                    image: selection.image,\n                    previousSrc,\n                    newSrc: dataUrl,\n                    originalSrc,\n                });\n            });\n        }\n    });\n}\n","import {\n    mergeModel,\n    readFile,\n    addSegment,\n    createContentModelDocument,\n    createImage,\n    setSelection,\n} from 'roosterjs-content-model-dom';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Insert an image into current selected position\n * @param editor The editor to operate on\n * @param file Image Blob file or source string\n */\nexport function insertImage(editor: IEditor, imageFileOrSrc: File | string) {\n    editor.focus();\n\n    if (typeof imageFileOrSrc == 'string') {\n        insertImageWithSrc(editor, imageFileOrSrc);\n    } else {\n        readFile(imageFileOrSrc, dataUrl => {\n            if (dataUrl && !editor.isDisposed()) {\n                insertImageWithSrc(editor, dataUrl);\n            }\n        });\n    }\n}\n\nfunction insertImageWithSrc(editor: IEditor, src: string) {\n    editor.formatContentModel(\n        (model, context) => {\n            const image = createImage(src, { backgroundColor: '' });\n            const doc = createContentModelDocument();\n\n            addSegment(doc, image);\n            mergeModel(model, doc, context, {\n                mergeFormat: 'mergeAll',\n            });\n            image.isSelected = true;\n            setSelection(model, image);\n\n            return true;\n        },\n        {\n            apiName: 'insertImage',\n        }\n    );\n}\n","import { formatImageWithContentModel } from '../utils/formatImageWithContentModel';\nimport type { ContentModelImage, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set image alt text for all selected images at selection. If no images is contained\n * in selection, do nothing.\n * @param editor The editor instance\n * @param altText The image alt text\n */\nexport function setImageAltText(editor: IEditor, altText: string) {\n    editor.focus();\n\n    formatImageWithContentModel(editor, 'setImageAltText', (image: ContentModelImage) => {\n        image.alt = altText;\n    });\n}\n","import { applyImageBorderFormat } from '../../modelApi/image/applyImageBorderFormat';\nimport { formatImageWithContentModel } from '../utils/formatImageWithContentModel';\nimport type { Border, ContentModelImage, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set image border style for all selected images at selection.\n * @param editor The editor instance\n * @param border the border format object. Ex: { color: 'red', width: '10px', style: 'solid'}, if one of the value in object is undefined\n * its value will not be changed. Passing null instead of an object will remove the border\n * @param borderRadius the border radius value, if undefined, the border radius will keep the actual value\n */\nexport function setImageBorder(editor: IEditor, border: Border | null, borderRadius?: string) {\n    editor.focus();\n\n    formatImageWithContentModel(editor, 'setImageBorder', (image: ContentModelImage) => {\n        applyImageBorderFormat(image, border, borderRadius);\n    });\n}\n","import { formatImageWithContentModel } from '../utils/formatImageWithContentModel';\nimport type { ContentModelImage, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set image box shadow for all selected images at selection.\n * @param editor The editor instance\n * @param boxShadow The image box boxShadow\n * @param margin The image margin for all sides (eg. \"4px\"), null to remove margin\n */\nexport function setImageBoxShadow(editor: IEditor, boxShadow: string, margin?: string | null) {\n    editor.focus();\n\n    formatImageWithContentModel(editor, 'setImageBoxShadow', (image: ContentModelImage) => {\n        image.format.boxShadow = boxShadow;\n        if (margin) {\n            image.format.marginBottom = margin;\n            image.format.marginLeft = margin;\n            image.format.marginRight = margin;\n            image.format.marginTop = margin;\n        } else if (margin === null) {\n            delete image.format.marginBottom;\n            delete image.format.marginLeft;\n            delete image.format.marginRight;\n            delete image.format.marginTop;\n        }\n    });\n}\n","import { adjustSegmentSelection } from '../../modelApi/selection/adjustSegmentSelection';\nimport { adjustWordSelection } from '../../modelApi/selection/adjustWordSelection';\nimport { getSelectedSegments, setSelection } from 'roosterjs-content-model-dom';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Adjust selection to make sure select a hyperlink if any, or a word if original selection is collapsed\n * @return A combination of existing link display text and url if any. If there is no existing link, return selected text and null\n */\nexport function adjustLinkSelection(editor: IEditor): [string, string | null] {\n    let text = '';\n    let url: string | null = null;\n\n    editor.formatContentModel(\n        model => {\n            let changed = adjustSegmentSelection(\n                model,\n                target => !!target.isSelected && !!target.link,\n                (target, ref) => !!target.link && target.link.format.href == ref.link!.format.href\n            );\n            let segments = getSelectedSegments(\n                model,\n                false /*includingFormatHolder*/,\n                true /*mutate*/\n            );\n            const firstSegment = segments[0];\n\n            if (segments.length == 1 && firstSegment.segmentType == 'SelectionMarker') {\n                segments = adjustWordSelection(model, firstSegment);\n\n                if (segments.length > 1) {\n                    changed = true;\n                    setSelection(model, segments[0], segments[segments.length - 1]);\n                }\n            }\n\n            text = segments.map(x => (x.segmentType == 'Text' ? x.text : '')).join('');\n            url = segments[0]?.link?.format.href || null;\n\n            return changed;\n        },\n        {\n            apiName: 'adjustLinkSelection',\n        }\n    );\n\n    return [text, url];\n}\n","import { adjustTrailingSpaceSelection } from '../../modelApi/selection/adjustTrailingSpaceSelection';\nimport { matchLink } from '../../modelApi/link/matchLink';\nimport {\n    addLink,\n    addSegment,\n    ChangeSource,\n    createContentModelDocument,\n    createText,\n    getSelectedSegments,\n    mergeModel,\n} from 'roosterjs-content-model-dom';\nimport type { ContentModelLink, IEditor } from 'roosterjs-content-model-types';\n\n// Regex matching Uri scheme\nconst URI_REGEX = /^[a-zA-Z]+:/i;\n// Regex matching begin of email address\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\nconst FTP_REGEX = /^ftp\\./i;\n\n/**\n * Insert a hyperlink at cursor.\n * When there is a selection, hyperlink will be applied to the selection,\n * otherwise a hyperlink will be inserted to the cursor position.\n * @param editor Editor object\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\n * When protocol is not specified, a best matched protocol will be predicted.\n * @param anchorTitle Optional alt text of the link, will be shown when hover on the link\n * @param displayText Optional display text for the link.\n * @param target Optional display target for the link (\"_blank\"|\"_self\"|\"_parent\"|\"_top\"|\"{framename}\")\n * If specified, the display text of link will be replaced with this text.\n * If not specified and there wasn't a link, the link url will be used as display text.\n */\nexport function insertLink(\n    editor: IEditor,\n    link: string,\n    anchorTitle?: string,\n    displayText?: string,\n    target?: string\n) {\n    editor.focus();\n\n    const url = (checkXss(link) || '').trim();\n    if (url) {\n        const linkData = matchLink(url);\n        const linkUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\n        const links: ContentModelLink[] = [];\n        let anchorNode: Node | undefined;\n\n        editor.formatContentModel(\n            (model, context) => {\n                const segments = getSelectedSegments(\n                    model,\n                    false /*includingFormatHolder*/,\n                    true /*mutate*/\n                );\n\n                const originalText = segments\n                    .map(x => (x.segmentType == 'Text' ? x.text : ''))\n                    .join('');\n                const text = displayText || originalText || '';\n\n                if (\n                    (segments.some(x => x.segmentType != 'SelectionMarker') &&\n                        originalText == text) ||\n                    (segments.length == 1 && segments[0].segmentType == 'Image')\n                ) {\n                    segments.forEach(x => {\n                        const link = createLink(\n                            linkUrl,\n                            anchorTitle,\n                            target,\n                            x.segmentType == 'Text'\n                        );\n                        addLink(x, link);\n                        if (x.link) {\n                            links.push(x.link);\n                        }\n                    });\n                } else if (\n                    segments.every(x => x.segmentType == 'SelectionMarker') ||\n                    (!!text && text != originalText)\n                ) {\n                    const segment = createText(text || (linkData ? linkData.originalUrl : url), {\n                        ...segments[0]?.format,\n                        ...editor.getPendingFormat(),\n                    });\n                    const doc = createContentModelDocument();\n                    const link = createLink(linkUrl, anchorTitle, target);\n\n                    addLink(segment, link);\n                    addSegment(doc, segment);\n\n                    if (segment.link) {\n                        links.push(segment.link);\n                    }\n\n                    mergeModel(model, doc, context, {\n                        mergeFormat: 'mergeAll',\n                    });\n                }\n\n                adjustTrailingSpaceSelection(model);\n                return segments.length > 0;\n            },\n            {\n                changeSource: ChangeSource.CreateLink,\n                onNodeCreated: (modelElement, node) => {\n                    if (!anchorNode && links.indexOf(modelElement as ContentModelLink) >= 0) {\n                        anchorNode = node;\n                    }\n                },\n                getChangeData: () => anchorNode,\n                apiName: 'insertLink',\n            }\n        );\n    }\n}\n\nconst createLink = (\n    url: string,\n    anchorTitle?: string,\n    target?: string,\n    underline: boolean = true\n): ContentModelLink => {\n    return {\n        dataset: {},\n        format: {\n            href: url,\n            anchorTitle,\n            target,\n            underline: underline,\n        },\n    };\n};\n\nfunction applyLinkPrefix(url: string): string {\n    if (!url) {\n        return url;\n    }\n\n    // Add link prefix per rule:\n    // (a) if the url always starts with a URI scheme, leave it as it is\n    // (b) if the url is an email address, xxx@... add mailto: prefix\n    // (c) if the url starts with ftp., add ftp:// prefix\n    // (d) rest, add http:// prefix\n    let prefix = '';\n    if (url.search(URI_REGEX) < 0) {\n        if (url.search(MAILTO_REGEX) == 0) {\n            prefix = 'mailto:';\n        } else if (url.search(FTP_REGEX) == 0) {\n            prefix = 'ftp://';\n        } else {\n            // fallback to http://\n            prefix = 'http://';\n        }\n    }\n\n    return prefix + url;\n}\n\nfunction checkXss(link: string): string {\n    return link.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) ? '' : link;\n}\n","import { adjustSegmentSelection } from '../../modelApi/selection/adjustSegmentSelection';\nimport { getSelectedSegments } from 'roosterjs-content-model-dom';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Remove link at selection. If no links at selection, do nothing.\n * If selection contains multiple links, all of the link styles will be removed.\n * If only part of a link is selected, the whole link style will be removed.\n * @param editor The editor instance\n */\nexport function removeLink(editor: IEditor) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            adjustSegmentSelection(\n                model,\n                target => !!target.isSelected && !!target.link,\n                (target, ref) =>\n                    target.isSelected || // Expand the selection to any link that is involved. So we can remove multiple links together\n                    (!!target.link && target.link.format.href == ref.link!.format.href)\n            );\n\n            const segments = getSelectedSegments(\n                model,\n                false /*includingFormatHolder*/,\n                true /*mutate*/\n            );\n            let isChanged = false;\n\n            segments.forEach(segment => {\n                if (segment.link) {\n                    isChanged = true;\n\n                    delete segment.link;\n                }\n            });\n\n            return isChanged;\n        },\n        {\n            apiName: 'removeLink',\n        }\n    );\n}\n","import { setModelListStartNumber } from '../../modelApi/list/setModelListStartNumber';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set start number of a list item\n * @param editor The editor to operate on\n * @param value The number to set to, must be equal or greater than 1\n */\nexport function setListStartNumber(editor: IEditor, value: number) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            return setModelListStartNumber(model, value);\n        },\n        {\n            apiName: 'setListStartNumber',\n        }\n    );\n}\n","import { setModelListStyle } from '../../modelApi/list/setModelListStyle';\nimport type { IEditor, ListMetadataFormat } from 'roosterjs-content-model-types';\n\n/**\n * Set style of list items with in same thread of current item\n * @param editor The editor to operate on\n * @param style The target list item style to set\n */\nexport function setListStyle(editor: IEditor, style: ListMetadataFormat) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            return setModelListStyle(model, style);\n        },\n        {\n            apiName: 'setListStyle',\n        }\n    );\n}\n","import { setListType } from '../../modelApi/list/setListType';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle bullet list type\n * - When there are some blocks not in bullet list, set all blocks to the given type\n * - When all blocks are already in bullet list, turn off / outdent there list type\n * @param editor The editor to operate on\n * @param removeMargins true to remove margins, false to keep margins @default false\n */\nexport function toggleBullet(editor: IEditor, removeMargins: boolean = false) {\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            context.newPendingFormat = 'preserve';\n\n            return setListType(model, 'UL', removeMargins);\n        },\n        {\n            apiName: 'toggleBullet',\n        }\n    );\n}\n","import { setListType } from '../../modelApi/list/setListType';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle numbering list type\n * - When there are some blocks not in numbering list, set all blocks to the given type\n * - When all blocks are already in numbering list, turn off / outdent there list type\n * @param editor The editor to operate on\n * @param removeMargins true to remove margins, false to keep margins @default false\n */\nexport function toggleNumbering(editor: IEditor, removeMargins: boolean = false) {\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            context.newPendingFormat = 'preserve';\n\n            return setListType(model, 'OL', removeMargins);\n        },\n        {\n            apiName: 'toggleNumbering',\n        }\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { ContentModelSegmentFormat, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Bulk apply segment format to all selected content. This is usually used for format painter.\n * @param editor The editor to operate on\n * @param newFormat The segment format to apply\n */\nexport function applySegmentFormat(\n    editor: IEditor,\n    newFormat: Readonly<ContentModelSegmentFormat>\n) {\n    formatSegmentWithContentModel(\n        editor,\n        'applySegmentFormat',\n        format => {\n            format.backgroundColor = newFormat.backgroundColor;\n            format.fontFamily = newFormat.fontFamily;\n            format.fontSize = newFormat.fontSize;\n            format.fontWeight = newFormat.fontWeight;\n            format.italic = newFormat.italic;\n            format.strikethrough = newFormat.strikethrough;\n            format.superOrSubScriptSequence = newFormat.superOrSubScriptSequence;\n            format.textColor = newFormat.textColor;\n            format.underline = newFormat.underline;\n        },\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Change the capitalization of text in the selection\n * @param editor The editor instance\n * @param capitalization The case option\n * @param language Optional parameter for language string that should comply to \"IETF BCP 47 Tags for\n * Identifying Languages\". For example: 'en' or 'en-US' for English, 'tr' for Turkish.\n * Default is the host environments current locale.\n */\nexport function changeCapitalization(\n    editor: IEditor,\n    capitalization: 'sentence' | 'lowerCase' | 'upperCase' | 'capitalize',\n    language?: string\n) {\n    editor.focus();\n\n    formatSegmentWithContentModel(editor, 'changeCapitalization', (_, __, segment) => {\n        if (segment?.segmentType == 'Text') {\n            switch (capitalization) {\n                case 'lowerCase':\n                    segment.text = segment.text.toLocaleLowerCase(language);\n                    break;\n\n                case 'upperCase':\n                    segment.text = segment.text.toLocaleUpperCase(language);\n                    break;\n\n                case 'capitalize':\n                    const wordArray = segment.text.toLocaleLowerCase(language).split(' ');\n\n                    for (let i = 0; i < wordArray.length; i++) {\n                        wordArray[i] =\n                            wordArray[i].charAt(0).toLocaleUpperCase(language) +\n                            wordArray[i].slice(1);\n                    }\n\n                    segment.text = wordArray.join(' ');\n                    break;\n\n                case 'sentence':\n                    const punctuationMarks = '[\\\\.\\\\!\\\\?]';\n                    // Find a match of a word character either:\n                    // - At the beginning of a string with or without preceding whitespace, for\n                    // example: '  hello world' and 'hello world' strings would both match 'h'.\n                    // - Or preceded by a punctuation mark and at least one whitespace, for\n                    // example 'yes. hello world' would match 'y' and 'h'.\n                    const regex = new RegExp('^\\\\s*\\\\w|' + punctuationMarks + '\\\\s+\\\\w', 'g');\n\n                    segment.text = segment.text\n                        .toLocaleLowerCase(language)\n                        .replace(regex, match => match.toLocaleUpperCase(language));\n                    break;\n            }\n        }\n    });\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport { parseValueWithUnit } from 'roosterjs-content-model-dom';\nimport { setFontSizeInternal } from './setFontSize';\nimport type {\n    ContentModelSegmentFormat,\n    IEditor,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\n */\nconst FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\nconst MIN_FONT_SIZE = 1;\nconst MAX_FONT_SIZE = 1000;\n\n/**\n * Increase or decrease font size in selection\n * @param editor The editor instance\n * @param change Whether increase or decrease font size\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\n */\nexport function changeFontSize(\n    editor: IEditor,\n    change: 'increase' | 'decrease',\n    fontSizes: number[] = FONT_SIZES\n) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'changeFontSize',\n        (format, _, __, paragraph) => changeFontSizeInternal(change, format, paragraph, fontSizes),\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n\nfunction changeFontSizeInternal(\n    change: 'increase' | 'decrease',\n    format: ContentModelSegmentFormat,\n    paragraph: ShallowMutableContentModelParagraph | null,\n    fontSizes: number[]\n) {\n    if (format.fontSize) {\n        const sizeInPt = parseValueWithUnit(format.fontSize, undefined /*element*/, 'pt');\n\n        if (sizeInPt > 0) {\n            const newSize = getNewFontSize(sizeInPt, change == 'increase' ? 1 : -1, fontSizes);\n\n            setFontSizeInternal(newSize + 'pt', format, paragraph);\n        }\n    }\n}\n\nfunction getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\n    const last = fontSizes[fontSizes.length - 1];\n    if (pt <= fontSizes[0]) {\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\n    } else if (pt > last || (pt == last && changeBase == 1)) {\n        pt = pt / 10;\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\n    } else if (changeBase == 1) {\n        for (let i = 0; i < fontSizes.length; i++) {\n            if (pt < fontSizes[i]) {\n                pt = fontSizes[i];\n                break;\n            }\n        }\n    } else {\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\n            if (pt > fontSizes[i]) {\n                pt = fontSizes[i];\n                break;\n            }\n        }\n    }\n    return pt;\n}\n","import { createSelectionMarker, setSelection } from 'roosterjs-content-model-dom';\nimport { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IEditor, ShallowMutableContentModelParagraph } from 'roosterjs-content-model-types';\n\n/**\n * Set background color\n * @param editor The editor to operate on\n * @param backgroundColor The color to set. Pass null to remove existing color.\n */\nexport function setBackgroundColor(editor: IEditor, backgroundColor: string | null) {\n    editor.focus();\n\n    let lastParagraph: ShallowMutableContentModelParagraph | null = null;\n    let lastSegmentIndex: number = -1;\n\n    formatSegmentWithContentModel(\n        editor,\n        'setBackgroundColor',\n        (format, _, segment, paragraph) => {\n            if (backgroundColor === null) {\n                delete format.backgroundColor;\n            } else {\n                format.backgroundColor = backgroundColor;\n            }\n\n            if (segment && paragraph && segment.segmentType != 'SelectionMarker') {\n                lastParagraph = paragraph;\n                lastSegmentIndex = lastParagraph.segments.indexOf(segment);\n            }\n        },\n        undefined /*segmentHasStyleCallback*/,\n        undefined /*includingFormatHolder*/,\n        model => {\n            if (lastParagraph && lastSegmentIndex >= 0) {\n                const marker = createSelectionMarker(\n                    lastParagraph.segments[lastSegmentIndex]?.format\n                );\n\n                lastParagraph.segments.splice(lastSegmentIndex + 1, 0, marker);\n                setSelection(model, marker, marker);\n            }\n        }\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set font name\n * @param editor The editor to operate on\n * @param fontName The font name to set\n */\nexport function setFontName(editor: IEditor, fontName: string) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'setFontName',\n        (format, _, segment) => {\n            format.fontFamily = fontName;\n\n            if (segment?.code) {\n                segment.code.format.fontFamily = fontName;\n            }\n        },\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type {\n    ContentModelSegmentFormat,\n    IEditor,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * Set font size\n * @param editor The editor to operate on\n * @param fontSize The font size to set\n */\nexport function setFontSize(editor: IEditor, fontSize: string) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'setFontSize',\n        (format, _, __, paragraph) => setFontSizeInternal(fontSize, format, paragraph),\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n\n/**\n * @internal\n * Internal set font function shared by setFontSize and changeFontSize\n */\nexport function setFontSizeInternal(\n    fontSize: string,\n    format: ContentModelSegmentFormat,\n    paragraph: ShallowMutableContentModelParagraph | null\n) {\n    format.fontSize = fontSize;\n\n    // Since we have set font size to segment, it can be smaller than the one in paragraph format, so delete font size from paragraph\n    if (paragraph?.segmentFormat?.fontSize) {\n        const size = paragraph.segmentFormat.fontSize;\n\n        paragraph.segments.forEach(segment => {\n            if (!segment.format.fontSize) {\n                segment.format.fontSize = size;\n            }\n        });\n\n        delete paragraph.segmentFormat.fontSize;\n    }\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set text color\n * @param editor The editor to operate on\n * @param textColor The text color to set. Pass null to remove existing color.\n */\nexport function setTextColor(editor: IEditor, textColor: string | null) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'setTextColor',\n        textColor === null\n            ? (format, _, segment) => {\n                  delete format.textColor;\n\n                  if (segment?.link) {\n                      delete segment.link.format.textColor;\n                  }\n              }\n            : (format, _, segment) => {\n                  format.textColor = textColor;\n\n                  if (segment?.link) {\n                      segment.link.format.textColor = textColor;\n                  }\n              },\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n","import { createText } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelText,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * Split given text segments from the given range\n * @param textSegment segment to split\n * @param parent parent paragraph the text segment exist in\n * @param start starting point of the split\n * @param end ending point of the split\n * @returns text segment from the indicated split.\n */\nexport function splitTextSegment(\n    textSegment: ContentModelText,\n    parent: ShallowMutableContentModelParagraph,\n    start: number,\n    end: number\n): ContentModelText {\n    const text = textSegment.text;\n    const index = parent.segments.indexOf(textSegment);\n    const middleSegment = createText(\n        text.substring(start, end),\n        textSegment.format,\n        textSegment.link,\n        textSegment.code\n    );\n\n    const newSegments: ContentModelText[] = [middleSegment];\n    if (start > 0) {\n        newSegments.unshift(\n            createText(\n                text.substring(0, start),\n                textSegment.format,\n                textSegment.link,\n                textSegment.code\n            )\n        );\n    }\n    if (end < text.length) {\n        newSegments.push(\n            createText(text.substring(end), textSegment.format, textSegment.link, textSegment.code)\n        );\n    }\n\n    newSegments.forEach(segment => (segment.isSelected = textSegment.isSelected));\n    parent.segments.splice(index, 1, ...newSegments);\n\n    return middleSegment;\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport { isBold } from 'roosterjs-content-model-dom';\nimport type { AnnouncingOption, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle bold style\n * @param editor The editor to operate on\n */\nexport function toggleBold(editor: IEditor, options?: AnnouncingOption) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleBold',\n        (format, isTurningOn) => {\n            format.fontWeight = isTurningOn ? 'bold' : 'normal';\n        },\n        (format, _, paragraph) =>\n            isBold(\n                typeof format.fontWeight == 'undefined'\n                    ? paragraph?.decorator?.format.fontWeight\n                    : format.fontWeight\n            ),\n        undefined /* includeFormatHolder */,\n        (_model, isTurningOff, context) => {\n            if (options?.announceFormatChange) {\n                context.announceData = {\n                    defaultStrings: isTurningOff ? 'announceBoldOff' : 'announceBoldOn',\n                };\n            }\n        }\n    );\n}\n","import { addCode } from 'roosterjs-content-model-dom';\nimport { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { ContentModelCode, IEditor } from 'roosterjs-content-model-types';\n\nconst DefaultCode: ContentModelCode = {\n    format: {\n        fontFamily: 'monospace',\n    },\n};\n\n/**\n * Toggle italic style\n * @param editor The editor to operate on\n */\nexport function toggleCode(editor: IEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleCode',\n        (_, isTurningOn, segment) => {\n            if (segment) {\n                if (isTurningOn) {\n                    addCode(segment, DefaultCode);\n                } else {\n                    delete segment.code;\n                }\n            }\n        },\n        (_, segment) => !!segment?.code\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { AnnouncingOption, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle italic style\n * @param editor The editor to operate on\n */\nexport function toggleItalic(editor: IEditor, options?: AnnouncingOption) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleItalic',\n        (format, isTurningOn) => {\n            format.italic = !!isTurningOn;\n        },\n        format => !!format.italic,\n        undefined /* includingFormatHolder */,\n        (_model, isTurningOff, context) => {\n            if (options?.announceFormatChange) {\n                context.announceData = {\n                    defaultStrings: isTurningOff ? 'announceItalicOff' : 'announceItalicOn',\n                };\n            }\n        }\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle strikethrough style\n * @param editor The editor to operate on\n */\nexport function toggleStrikethrough(editor: IEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleStrikethrough',\n        (format, isTurningOn) => {\n            format.strikethrough = !!isTurningOn;\n        },\n        format => !!format.strikethrough\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle subscript style\n * @param editor The editor to operate on\n */\nexport function toggleSubscript(editor: IEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleSubscript',\n        (format, isTurningOn) => {\n            format.superOrSubScriptSequence = isTurningOn ? 'sub' : '';\n        },\n        format => format.superOrSubScriptSequence?.split(' ').pop() == 'sub'\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle superscript style\n * @param editor The editor to operate on\n */\nexport function toggleSuperscript(editor: IEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleSuperscript',\n        (format, isTurningOn) => {\n            format.superOrSubScriptSequence = isTurningOn ? 'super' : '';\n        },\n        format => format.superOrSubScriptSequence?.split(' ').pop() == 'super'\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { AnnouncingOption, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle underline style\n * @param editor The editor to operate on\n */\nexport function toggleUnderline(editor: IEditor, options?: AnnouncingOption) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleUnderline',\n        (format, isTurningOn, segment) => {\n            format.underline = !!isTurningOn;\n\n            if (segment?.link) {\n                segment.link.format.underline = !!isTurningOn;\n            }\n        },\n        (format, segment) => !!format.underline || !!segment?.link?.format?.underline,\n        false /*includingFormatHolder*/,\n        (_model, isTurningOff, context) => {\n            if (options?.announceFormatChange) {\n                context.announceData = {\n                    defaultStrings: isTurningOff ? 'announceUnderlineOff' : 'announceUnderlineOn',\n                };\n            }\n        }\n    );\n}\n","import {\n    extractBorderValues,\n    getFirstSelectedTable,\n    getSelectedCells,\n    mutateBlock,\n    getTableMetadata,\n    parseValueWithUnit,\n    setFirstColumnFormatBorders,\n    updateTableCellMetadata,\n} from 'roosterjs-content-model-dom';\nimport type {\n    IEditor,\n    Border,\n    BorderOperations,\n    TableSelectionCoordinates,\n    ReadonlyContentModelTableCell,\n    ReadonlyContentModelTable,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Border positions\n */\ntype BorderPositions = 'borderTop' | 'borderBottom' | 'borderLeft' | 'borderRight';\n\n/**\n * @internal\n * Perimeter of the table selection\n * Used to determine where to apply border to the cells adjacent to the selection.\n */\ntype Perimeter = {\n    Top: boolean;\n    Bottom: boolean;\n    Left: boolean;\n    Right: boolean;\n};\n\n/**\n * Operations to apply border\n * @param editor The editor instance\n * @param border The border to apply\n * @param operation The operation to apply\n */\nexport function applyTableBorderFormat(\n    editor: IEditor,\n    border: Border,\n    operation: BorderOperations\n) {\n    editor.formatContentModel(\n        model => {\n            const [tableModel] = getFirstSelectedTable(model);\n\n            if (tableModel) {\n                const sel = getSelectedCells(tableModel);\n                const perimeter: Perimeter = {\n                    Top: false,\n                    Bottom: false,\n                    Left: false,\n                    Right: false,\n                };\n\n                // Create border format with table format as backup\n                let borderFormat = '';\n                const format = tableModel.format;\n                const { width, style, color } = border;\n                const extractedBorder = extractBorderValues(format.borderTop);\n                const borderColor = extractedBorder.color;\n                const borderWidth = extractedBorder.width;\n                const borderStyle = extractedBorder.style;\n\n                if (width) {\n                    borderFormat = parseValueWithUnit(width) + 'px';\n                } else if (borderWidth) {\n                    borderFormat = borderWidth;\n                } else {\n                    borderFormat = '1px';\n                }\n\n                if (style) {\n                    borderFormat = `${borderFormat} ${style}`;\n                } else if (borderStyle) {\n                    borderFormat = `${borderFormat} ${borderStyle}`;\n                } else {\n                    borderFormat = `${borderFormat} solid`;\n                }\n\n                if (color) {\n                    borderFormat = `${borderFormat} ${color}`;\n                } else if (borderColor) {\n                    borderFormat = `${borderFormat} ${borderColor}`;\n                }\n\n                // undefined is treated as Left to Right\n                const isRtl = tableModel.format.direction == 'rtl';\n\n                if (sel) {\n                    const operations: BorderOperations[] = [operation];\n                    while (operations.length) {\n                        switch (operations.pop()) {\n                            case 'noBorders':\n                                // Do All borders but with empty border format\n                                borderFormat = '';\n                                operations.push('allBorders');\n                                break;\n                            case 'allBorders':\n                                const allBorders: BorderPositions[] = [\n                                    'borderTop',\n                                    'borderBottom',\n                                    'borderLeft',\n                                    'borderRight',\n                                ];\n                                for (\n                                    let rowIndex = sel.firstRow;\n                                    rowIndex <= sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    for (\n                                        let colIndex = sel.firstColumn;\n                                        colIndex <= sel.lastColumn;\n                                        colIndex++\n                                    ) {\n                                        const cell = tableModel.rows[rowIndex].cells[colIndex];\n                                        // Format cells - All borders\n                                        applyBorderFormat(cell, borderFormat, allBorders);\n                                    }\n                                }\n\n                                // Format perimeter\n                                perimeter.Top = true;\n                                perimeter.Bottom = true;\n                                perimeter.Left = true;\n                                perimeter.Right = true;\n                                break;\n                            case 'leftBorders':\n                                const leftBorder: BorderPositions[] = ['borderLeft'];\n                                for (\n                                    let rowIndex = sel.firstRow;\n                                    rowIndex <= sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    const cell =\n                                        tableModel.rows[rowIndex].cells[\n                                            isRtl ? sel.lastColumn : sel.firstColumn\n                                        ];\n                                    // Format cells - Left border\n                                    applyBorderFormat(cell, borderFormat, leftBorder);\n                                }\n\n                                // Format perimeter\n                                isRtl ? (perimeter.Right = true) : (perimeter.Left = true);\n                                break;\n                            case 'rightBorders':\n                                const rightBorder: BorderPositions[] = ['borderRight'];\n                                for (\n                                    let rowIndex = sel.firstRow;\n                                    rowIndex <= sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    const cell =\n                                        tableModel.rows[rowIndex].cells[\n                                            isRtl ? sel.firstColumn : sel.lastColumn\n                                        ];\n                                    // Format cells - Right border\n                                    applyBorderFormat(cell, borderFormat, rightBorder);\n                                }\n\n                                // Format perimeter\n                                isRtl ? (perimeter.Left = true) : (perimeter.Right = true);\n                                break;\n                            case 'topBorders':\n                                const topBorder: BorderPositions[] = ['borderTop'];\n                                for (\n                                    let colIndex = sel.firstColumn;\n                                    colIndex <= sel.lastColumn;\n                                    colIndex++\n                                ) {\n                                    const cell = tableModel.rows[sel.firstRow].cells[colIndex];\n                                    // Format cells - Top border\n                                    applyBorderFormat(cell, borderFormat, topBorder);\n                                }\n\n                                // Format perimeter\n                                perimeter.Top = true;\n                                break;\n                            case 'bottomBorders':\n                                const bottomBorder: BorderPositions[] = ['borderBottom'];\n                                for (\n                                    let colIndex = sel.firstColumn;\n                                    colIndex <= sel.lastColumn;\n                                    colIndex++\n                                ) {\n                                    const cell = tableModel.rows[sel.lastRow].cells[colIndex];\n                                    // Format cells - Bottom border\n                                    applyBorderFormat(cell, borderFormat, bottomBorder);\n                                }\n\n                                // Format perimeter\n                                perimeter.Bottom = true;\n                                break;\n                            case 'insideBorders':\n                                // Format cells - Inside borders\n                                const singleCol = sel.lastColumn == sel.firstColumn;\n                                const singleRow = sel.lastRow == sel.firstRow;\n                                // Single cell selection\n                                if (singleCol && singleRow) {\n                                    break;\n                                }\n                                // Single column selection\n                                if (singleCol) {\n                                    applyBorderFormat(\n                                        tableModel.rows[sel.firstRow].cells[sel.firstColumn],\n                                        borderFormat,\n                                        ['borderBottom']\n                                    );\n                                    for (\n                                        let rowIndex = sel.firstRow + 1;\n                                        rowIndex <= sel.lastRow - 1;\n                                        rowIndex++\n                                    ) {\n                                        const cell =\n                                            tableModel.rows[rowIndex].cells[sel.firstColumn];\n                                        applyBorderFormat(cell, borderFormat, [\n                                            'borderTop',\n                                            'borderBottom',\n                                        ]);\n                                    }\n                                    applyBorderFormat(\n                                        tableModel.rows[sel.lastRow].cells[sel.firstColumn],\n                                        borderFormat,\n                                        ['borderTop']\n                                    );\n                                    break;\n                                }\n                                // Single row selection\n                                if (singleRow) {\n                                    applyBorderFormat(\n                                        tableModel.rows[sel.firstRow].cells[\n                                            isRtl ? sel.lastColumn : sel.firstColumn\n                                        ],\n                                        borderFormat,\n                                        ['borderRight']\n                                    );\n                                    for (\n                                        let colIndex = sel.firstColumn + 1;\n                                        colIndex <= sel.lastColumn - 1;\n                                        colIndex++\n                                    ) {\n                                        const cell = tableModel.rows[sel.firstRow].cells[colIndex];\n                                        applyBorderFormat(cell, borderFormat, [\n                                            'borderLeft',\n                                            'borderRight',\n                                        ]);\n                                    }\n                                    applyBorderFormat(\n                                        tableModel.rows[sel.firstRow].cells[\n                                            isRtl ? sel.firstColumn : sel.lastColumn\n                                        ],\n                                        borderFormat,\n                                        ['borderLeft']\n                                    );\n                                    break;\n                                }\n\n                                // For multiple rows and columns selections\n                                // Top left cell\n                                applyBorderFormat(\n                                    tableModel.rows[sel.firstRow].cells[\n                                        isRtl ? sel.lastColumn : sel.firstColumn\n                                    ],\n                                    borderFormat,\n                                    ['borderBottom', 'borderRight']\n                                );\n                                // Top right cell\n                                applyBorderFormat(\n                                    tableModel.rows[sel.firstRow].cells[\n                                        isRtl ? sel.firstColumn : sel.lastColumn\n                                    ],\n                                    borderFormat,\n                                    ['borderBottom', 'borderLeft']\n                                );\n                                // Bottom left cell\n                                applyBorderFormat(\n                                    tableModel.rows[sel.lastRow].cells[\n                                        isRtl ? sel.lastColumn : sel.firstColumn\n                                    ],\n                                    borderFormat,\n                                    ['borderTop', 'borderRight']\n                                );\n                                // Bottom right cell\n                                applyBorderFormat(\n                                    tableModel.rows[sel.lastRow].cells[\n                                        isRtl ? sel.firstColumn : sel.lastColumn\n                                    ],\n                                    borderFormat,\n                                    ['borderTop', 'borderLeft']\n                                );\n                                // First row\n                                for (\n                                    let colIndex = sel.firstColumn + 1;\n                                    colIndex < sel.lastColumn;\n                                    colIndex++\n                                ) {\n                                    const cell = tableModel.rows[sel.firstRow].cells[colIndex];\n                                    applyBorderFormat(cell, borderFormat, [\n                                        'borderBottom',\n                                        'borderLeft',\n                                        'borderRight',\n                                    ]);\n                                }\n                                // Last row\n                                for (\n                                    let colIndex = sel.firstColumn + 1;\n                                    colIndex < sel.lastColumn;\n                                    colIndex++\n                                ) {\n                                    const cell = tableModel.rows[sel.lastRow].cells[colIndex];\n                                    applyBorderFormat(cell, borderFormat, [\n                                        'borderTop',\n                                        'borderLeft',\n                                        'borderRight',\n                                    ]);\n                                }\n                                // First column\n                                for (\n                                    let rowIndex = sel.firstRow + 1;\n                                    rowIndex < sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    const cell = tableModel.rows[rowIndex].cells[sel.firstColumn];\n                                    applyBorderFormat(cell, borderFormat, [\n                                        'borderTop',\n                                        'borderBottom',\n                                        isRtl ? 'borderLeft' : 'borderRight',\n                                    ]);\n                                }\n                                // Last column\n                                for (\n                                    let rowIndex = sel.firstRow + 1;\n                                    rowIndex < sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    const cell = tableModel.rows[rowIndex].cells[sel.lastColumn];\n                                    applyBorderFormat(cell, borderFormat, [\n                                        'borderTop',\n                                        'borderBottom',\n                                        isRtl ? 'borderRight' : 'borderLeft',\n                                    ]);\n                                }\n                                // Inner cells\n                                sel.firstColumn++;\n                                sel.firstRow++;\n                                sel.lastColumn--;\n                                sel.lastRow--;\n                                operations.push('allBorders');\n                                break;\n                            case 'outsideBorders':\n                                // Format cells - Outside borders\n                                operations.push('topBorders');\n                                operations.push('bottomBorders');\n                                operations.push('leftBorders');\n                                operations.push('rightBorders');\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n\n                    //Format perimeter if necessary or possible\n                    modifyPerimeter(tableModel, sel, borderFormat, perimeter, isRtl);\n                }\n\n                const tableMeta = getTableMetadata(tableModel);\n                if (tableMeta) {\n                    // Enforce first column format if necessary\n                    setFirstColumnFormatBorders(mutateBlock(tableModel).rows, tableMeta);\n                }\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'tableBorder',\n        }\n    );\n}\n\n/**\n * @internal\n * Apply border format to a cell\n * @param cell The cell to apply border format\n * @param borderFormat The border format to apply\n * @param positions The positions to apply\n */\nfunction applyBorderFormat(\n    cell: ReadonlyContentModelTableCell,\n    borderFormat: string,\n    positions: BorderPositions[]\n) {\n    const mutableCell = mutateBlock(cell);\n\n    positions.forEach(pos => {\n        mutableCell.format[pos] = borderFormat;\n    });\n\n    updateTableCellMetadata(mutableCell, metadata => {\n        metadata = metadata || {};\n        metadata.borderOverride = true;\n        return metadata;\n    });\n}\n\n/**\n * @internal\n * Modify the perimeter of the table selection\n * @param tableModel The table model\n * @param sel The table selection\n * @param borderFormat The border format to apply\n * If borderFormat is empty, the border will be removed\n * @param perimeter Where in the perimeter to apply\n */\nfunction modifyPerimeter(\n    tableModel: ReadonlyContentModelTable,\n    sel: TableSelectionCoordinates,\n    borderFormat: string,\n    perimeter: Perimeter,\n    isRtl: boolean\n) {\n    // Top of selection\n    if (perimeter.Top && sel.firstRow - 1 >= 0) {\n        for (let colIndex = sel.firstColumn; colIndex <= sel.lastColumn; colIndex++) {\n            const cell = tableModel.rows[sel.firstRow - 1].cells[colIndex];\n            applyBorderFormat(cell, borderFormat, ['borderBottom']);\n        }\n    }\n    // Bottom of selection\n    if (perimeter.Bottom && sel.lastRow + 1 < tableModel.rows.length) {\n        for (let colIndex = sel.firstColumn; colIndex <= sel.lastColumn; colIndex++) {\n            const cell = tableModel.rows[sel.lastRow + 1].cells[colIndex];\n            applyBorderFormat(cell, borderFormat, ['borderTop']);\n        }\n    }\n    // Left of selection\n    if (perimeter.Left && sel.firstColumn - 1 >= 0) {\n        for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n            const cell = tableModel.rows[rowIndex].cells[sel.firstColumn - 1];\n            applyBorderFormat(cell, borderFormat, [isRtl ? 'borderLeft' : 'borderRight']);\n        }\n    }\n    // Right of selection\n    if (perimeter.Right && sel.lastColumn + 1 < tableModel.rows[0].cells.length) {\n        for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n            const cell = tableModel.rows[rowIndex].cells[sel.lastColumn + 1];\n            applyBorderFormat(cell, borderFormat, [isRtl ? 'borderRight' : 'borderLeft']);\n        }\n    }\n}\n","import { alignTable } from '../../modelApi/table/alignTable';\nimport { deleteTable } from '../../modelApi/table/deleteTable';\nimport { deleteTableColumn } from '../../modelApi/table/deleteTableColumn';\nimport { deleteTableRow } from '../../modelApi/table/deleteTableRow';\nimport { formatTableWithContentModel } from '../utils/formatTableWithContentModel';\nimport { insertTableColumn } from '../../modelApi/table/insertTableColumn';\nimport { insertTableRow } from '../../modelApi/table/insertTableRow';\nimport { mergeTableCells } from '../../modelApi/table/mergeTableCells';\nimport { mergeTableColumn } from '../../modelApi/table/mergeTableColumn';\nimport { mergeTableRow } from '../../modelApi/table/mergeTableRow';\nimport { splitTableCellHorizontally } from '../../modelApi/table/splitTableCellHorizontally';\nimport { splitTableCellVertically } from '../../modelApi/table/splitTableCellVertically';\nimport type { TableOperation, IEditor } from 'roosterjs-content-model-types';\nimport {\n    alignTableCellHorizontally,\n    alignTableCellVertically,\n} from '../../modelApi/table/alignTableCell';\n\n/**\n * Format current focused table with the given format\n * @param editor The editor instance\n * @param operation The table operation to apply\n */\nexport function editTable(editor: IEditor, operation: TableOperation) {\n    editor.focus();\n\n    fixUpSafariSelection(editor);\n\n    formatTableWithContentModel(editor, 'editTable', tableModel => {\n        switch (operation) {\n            case 'alignCellLeft':\n            case 'alignCellCenter':\n            case 'alignCellRight':\n                alignTableCellHorizontally(tableModel, operation);\n                break;\n            case 'alignCellTop':\n            case 'alignCellMiddle':\n            case 'alignCellBottom':\n                alignTableCellVertically(tableModel, operation);\n                break;\n            case 'alignCenter':\n            case 'alignLeft':\n            case 'alignRight':\n                alignTable(tableModel, operation);\n                break;\n\n            case 'deleteColumn':\n                deleteTableColumn(tableModel);\n                break;\n\n            case 'deleteRow':\n                deleteTableRow(tableModel);\n                break;\n\n            case 'deleteTable':\n                deleteTable(tableModel);\n                break;\n\n            case 'insertAbove':\n            case 'insertBelow':\n                insertTableRow(tableModel, operation);\n                break;\n\n            case 'insertLeft':\n            case 'insertRight':\n                insertTableColumn(tableModel, operation);\n                break;\n\n            case 'mergeAbove':\n            case 'mergeBelow':\n                mergeTableRow(tableModel, operation);\n                break;\n\n            case 'mergeCells':\n                mergeTableCells(tableModel);\n                break;\n\n            case 'mergeLeft':\n            case 'mergeRight':\n                mergeTableColumn(tableModel, operation);\n                break;\n\n            case 'splitHorizontally':\n                splitTableCellHorizontally(tableModel);\n                break;\n\n            case 'splitVertically':\n                splitTableCellVertically(tableModel);\n                break;\n        }\n    });\n}\n\n// In safari, when open context menu under a table, it may expand the range selection to the beginning of next table cell.\n// So we make a workaround here to collapse the selection when need, to avoid unexpected table editing behavior\n// (e.g. insert two columns but actually need one only)\nfunction fixUpSafariSelection(editor: IEditor) {\n    if (editor.getEnvironment().isSafari) {\n        const selection = editor.getDOMSelection();\n\n        if (selection?.type == 'range' && !selection.range.collapsed) {\n            selection.range.collapse(true /*toStart*/);\n            editor.setDOMSelection({\n                type: 'range',\n                range: selection.range,\n                isReverted: false,\n            });\n        }\n    }\n}\n","import {\n    applyTableFormat,\n    getFirstSelectedTable,\n    mutateBlock,\n    updateTableCellMetadata,\n} from 'roosterjs-content-model-dom';\nimport type { IEditor, TableMetadataFormat } from 'roosterjs-content-model-types';\n\n/**\n * Format current focused table with the given format\n * @param editor The editor instance\n * @param format The table format to apply\n * @param keepCellShade Whether keep existing shade color when apply format if there is a manually set shade color\n */\nexport function formatTable(editor: IEditor, format: TableMetadataFormat, keepCellShade?: boolean) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            const [tableModel] = getFirstSelectedTable(model);\n\n            if (tableModel) {\n                // Wipe border metadata\n                tableModel.rows.forEach(row => {\n                    row.cells.forEach(cell => {\n                        updateTableCellMetadata(mutateBlock(cell), metadata => {\n                            if (metadata) {\n                                delete metadata.borderOverride;\n                            }\n                            return metadata;\n                        });\n                    });\n                });\n                applyTableFormat(tableModel, format, keepCellShade);\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'formatTable',\n        }\n    );\n}\n","import { adjustTableIndentation } from '../../modelApi/common/adjustIndentation';\nimport { createTableStructure } from '../../modelApi/table/createTableStructure';\nimport {\n    createContentModelDocument,\n    createSelectionMarker,\n    applyTableFormat,\n    deleteSelection,\n    mergeModel,\n    normalizeTable,\n    setSelection,\n    MIN_ALLOWED_TABLE_CELL_WIDTH,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelTable,\n    ContentModelTableFormat,\n    IEditor,\n    TableMetadataFormat,\n    ContentModelTableCellFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Insert table into editor at current selection\n * @param editor The editor instance\n * @param columns Number of columns in table, it also controls the default table cell width:\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\n * @param rows Number of rows in table\n * @param tableMetadataFormat (Optional) The table format that are stored as metadata. If not passed, the default format will be applied: background color: #FFF; border color: #ABABAB\n * @param format (Optional) The table format used for style attributes\n * @param cellFormat (Optional) custom format for table cells, except for borders styles, for borders use tableMetadataFormat\n */\nexport function insertTable(\n    editor: IEditor,\n    columns: number,\n    rows: number,\n    tableMetadataFormat?: Partial<TableMetadataFormat>,\n    format?: ContentModelTableFormat,\n    customCellFormat?: ContentModelTableCellFormat\n) {\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            const insertPosition = deleteSelection(model, [], context).insertPoint;\n\n            if (insertPosition) {\n                const doc = createContentModelDocument();\n                const table = createTableStructure(doc, columns, rows, customCellFormat);\n                if (format) {\n                    table.format = { ...format };\n                }\n\n                normalizeTable(table, editor.getPendingFormat() || insertPosition.marker.format);\n                initCellWidth(table);\n\n                adjustTableIndentation(insertPosition, table);\n\n                // Assign default vertical align\n                tableMetadataFormat = tableMetadataFormat || { verticalAlign: 'top' };\n                applyTableFormat(table, tableMetadataFormat);\n                mergeModel(model, doc, context, {\n                    insertPosition,\n                    mergeFormat: 'mergeAll',\n                });\n\n                const firstBlock = table.rows[0]?.cells[0]?.blocks[0];\n\n                if (firstBlock?.blockType == 'Paragraph') {\n                    const marker = createSelectionMarker(firstBlock.segments[0]?.format);\n                    firstBlock.segments.unshift(marker);\n                    setSelection(model, marker);\n                }\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'insertTable',\n        }\n    );\n}\n\nfunction initCellWidth(table: ContentModelTable) {\n    const columns = Math.max(...table.rows.map(row => row.cells.length));\n\n    for (let i = 0; i < columns; i++) {\n        if (table.widths[i] === undefined) {\n            table.widths[i] = getTableCellWidth(columns);\n        } else if (table.widths[i] < MIN_ALLOWED_TABLE_CELL_WIDTH) {\n            table.widths[i] = MIN_ALLOWED_TABLE_CELL_WIDTH;\n        }\n    }\n}\n\nfunction getTableCellWidth(columns: number): number {\n    if (columns <= 4) {\n        return 120;\n    } else if (columns <= 6) {\n        return 100;\n    } else {\n        return 70;\n    }\n}\n","import {\n    hasSelectionInBlockGroup,\n    getFirstSelectedTable,\n    setTableCellBackgroundColor,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set table cell shade color\n * @param editor The editor instance\n * @param color The color to set. Pass null to remove existing shade color\n */\nexport function setTableCellShade(editor: IEditor, color: string | null) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            const [table] = getFirstSelectedTable(model);\n\n            if (table) {\n                table.rows.forEach(row =>\n                    row.cells.forEach(cell => {\n                        if (hasSelectionInBlockGroup(cell)) {\n                            setTableCellBackgroundColor(\n                                mutateBlock(cell),\n                                color,\n                                true /*isColorOverride*/\n                            );\n                        }\n                    })\n                );\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'setTableCellShade',\n        }\n    );\n}\n","import type { ContentModelEntity, EditorContext, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Create an EditorContext for an entity\n * @param editor The editor object\n * @param entity The entity to create the context for\n * @returns The generated EditorContext for the entity\n */\nexport function createEditorContextForEntity(\n    editor: IEditor,\n    entity: ContentModelEntity\n): EditorContext {\n    const domHelper = editor.getDOMHelper();\n    const context: EditorContext = {\n        isDarkMode: editor.isDarkMode(),\n        defaultFormat: { ...entity.format },\n        darkColorHandler: editor.getColorManager(),\n        addDelimiterForEntity: false,\n        allowCacheElement: false,\n        domIndexer: undefined,\n        zoomScale: domHelper.calculateZoomScale(),\n        experimentalFeatures: [],\n    };\n\n    if (editor.getDocument().defaultView?.getComputedStyle(entity.wrapper).direction == 'rtl') {\n        context.isRootRtl = true;\n    }\n\n    return context;\n}\n","import { formatSegmentWithContentModel } from './formatSegmentWithContentModel';\nimport type { ContentModelImage, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Invoke a callback to format the selected image using Content Model\n * @param editor The editor object\n * @param apiName Name of API this calling this function. This is mostly for logging.\n * @param callback The callback to format the image. It will be called with current selected table. If no table is selected, it will not be called.\n */\nexport function formatImageWithContentModel(\n    editor: IEditor,\n    apiName: string,\n    callback: (segment: ContentModelImage) => void\n) {\n    formatSegmentWithContentModel(\n        editor,\n        apiName,\n        (_, __, segment) => {\n            if (segment?.segmentType == 'Image') {\n                callback(segment);\n            }\n        },\n        undefined /** segmentHasStyleCallback **/,\n        undefined /** includingFormatHolder */\n    );\n}\n","import {\n    addSegment,\n    addTextSegment,\n    buildSelectionMarker,\n    getRegularSelectionOffsets,\n    mutateBlock,\n    processChildNode,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ElementProcessor,\n    DOMInsertPoint,\n    FormatContentModelOptions,\n    IEditor,\n    InsertPoint,\n    DomToModelContext,\n    ContentModelBlockGroup,\n    FormatContentModelContext,\n    ShallowMutableContentModelDocument,\n} from 'roosterjs-content-model-types';\n\n/**\n * Invoke a callback to format the content in a specific position  using Content Model\n * @param editor The editor object\n * @param insertPoint The insert position.\n * @param callback The callback to insert the format.\n * @param options More options, @see FormatContentModelOptions\n */\nexport function formatInsertPointWithContentModel(\n    editor: IEditor,\n    insertPoint: DOMInsertPoint,\n    callback: (\n        model: ShallowMutableContentModelDocument,\n        context: FormatContentModelContext,\n        insertPoint?: InsertPoint\n    ) => void,\n    options?: FormatContentModelOptions\n) {\n    const bundle: InsertPointBundle = {\n        input: insertPoint,\n    };\n\n    editor.formatContentModel(\n        (model, context) => {\n            callback(model, context, bundle.result);\n\n            if (bundle?.result) {\n                const { paragraph, marker } = bundle.result;\n                const index = paragraph.segments.indexOf(marker);\n\n                if (index >= 0) {\n                    mutateBlock(paragraph).segments.splice(index, 1);\n                }\n            }\n            return true;\n        },\n        options,\n        {\n            processorOverride: {\n                child: getShadowChildProcessor(bundle),\n                textWithSelection: getShadowTextProcessor(bundle),\n            },\n            tryGetFromCache: false,\n        }\n    );\n}\n\ninterface InsertPointBundle {\n    input: DOMInsertPoint;\n    result?: InsertPoint;\n}\n\ninterface DomToModelContextWithPath extends DomToModelContext {\n    /**\n     * Block group path of this insert point, from direct parent group to the root group\n     */\n    path?: ContentModelBlockGroup[];\n}\n\nfunction getShadowChildProcessor(bundle: InsertPointBundle): ElementProcessor<ParentNode> {\n    return (group, parent, context) => {\n        const contextWithPath = context as DomToModelContextWithPath;\n\n        contextWithPath.path = contextWithPath.path || [];\n\n        let shouldShiftPath = false;\n        if (contextWithPath.path[0] != group) {\n            contextWithPath.path.unshift(group);\n            shouldShiftPath = true;\n        }\n\n        const offsets = getShadowSelectionOffsets(context, bundle, parent);\n        let index = 0;\n\n        for (let child = parent.firstChild; child; child = child.nextSibling) {\n            handleElementShadowSelection(bundle, index, context, group, offsets, parent);\n\n            processChildNode(group, child, context);\n\n            index++;\n        }\n\n        handleElementShadowSelection(bundle, index, context, group, offsets, parent);\n\n        if (shouldShiftPath) {\n            contextWithPath.path.shift();\n        }\n    };\n}\n\nfunction handleElementShadowSelection(\n    bundle: InsertPointBundle,\n    index: number,\n    context: DomToModelContext,\n    group: ContentModelBlockGroup,\n    offsets: [number, number, number],\n    container?: Node\n) {\n    if (\n        index == offsets[2] &&\n        (index <= offsets[0] || offsets[0] < 0) &&\n        (index < offsets[1] || offsets[1] < 0)\n    ) {\n        addSelectionMarker(group, context, container, index, bundle);\n        offsets[2] = -1;\n    }\n\n    if (index == offsets[0]) {\n        context.isInSelection = true;\n        addSelectionMarker(group, context, container, index);\n    }\n\n    if (index == offsets[2] && (index < offsets[1] || offsets[1] < 0)) {\n        addSelectionMarker(group, context, container, index, bundle);\n        offsets[2] = -1;\n    }\n\n    if (index == offsets[1]) {\n        addSelectionMarker(group, context, container, index);\n        context.isInSelection = false;\n    }\n\n    if (index == offsets[2]) {\n        addSelectionMarker(group, context, container, index, bundle);\n    }\n}\n\nconst getShadowTextProcessor = (bundle: InsertPointBundle): ElementProcessor<Text> => (\n    group,\n    textNode,\n    context\n) => {\n    let txt = textNode.nodeValue || '';\n    const offsets = getShadowSelectionOffsets(context, bundle, textNode);\n    const [start, end, shadow] = offsets;\n\n    const handleTextSelection = (\n        subtract: number,\n        originalOffset: number,\n        bundle?: InsertPointBundle\n    ) => {\n        addTextSegment(group, txt.substring(0, subtract), context);\n        addSelectionMarker(group, context, textNode, originalOffset, bundle);\n\n        offsets[0] -= subtract;\n        offsets[1] -= subtract;\n        offsets[2] = bundle ? -1 : offsets[2] - subtract;\n\n        txt = txt.substring(subtract);\n    };\n\n    if (\n        offsets[2] >= 0 &&\n        (offsets[2] <= offsets[0] || offsets[0] < 0) &&\n        (offsets[2] < offsets[1] || offsets[1] < 0)\n    ) {\n        handleTextSelection(offsets[2], shadow, bundle);\n    }\n\n    if (offsets[0] >= 0) {\n        handleTextSelection(offsets[0], start);\n\n        context.isInSelection = true;\n    }\n\n    if (offsets[2] >= 0 && offsets[2] > offsets[0] && (offsets[2] < offsets[1] || offsets[1] < 0)) {\n        handleTextSelection(offsets[2], shadow, bundle);\n    }\n\n    if (offsets[1] >= 0) {\n        handleTextSelection(offsets[1], end);\n\n        context.isInSelection = false;\n    }\n\n    if (offsets[2] >= 0 && offsets[2] >= offsets[1]) {\n        handleTextSelection(offsets[2], shadow, bundle);\n    }\n\n    addTextSegment(group, txt, context);\n};\n\nfunction addSelectionMarker(\n    group: ContentModelBlockGroup,\n    context: DomToModelContextWithPath,\n    container?: Node,\n    offset?: number,\n    bundle?: InsertPointBundle\n) {\n    const marker = buildSelectionMarker(group, context, container, offset);\n\n    marker.isSelected = !bundle;\n\n    const para = addSegment(group, marker, context.blockFormat, marker.format);\n\n    if (bundle && context.path) {\n        bundle.result = {\n            path: [...context.path],\n            paragraph: para,\n            marker,\n        };\n    }\n}\n\nfunction getShadowSelectionOffsets(\n    context: DomToModelContext,\n    bundle: InsertPointBundle,\n    currentContainer: Node\n): [number, number, number] {\n    const [start, end] = getRegularSelectionOffsets(context, currentContainer);\n    const shadow = bundle.input.node == currentContainer ? bundle.input.offset : -1;\n\n    return [start, end, shadow];\n}\n","import { getSelectedParagraphs } from 'roosterjs-content-model-dom';\nimport { splitSelectedParagraphByBr } from '../../modelApi/block/splitSelectedParagraphByBr';\nimport type { IEditor, ShallowMutableContentModelParagraph } from 'roosterjs-content-model-types';\n\n/**\n * Invoke a callback to format the selected paragraph using Content Model\n * @param editor The editor object\n * @param apiName Name of API this calling this function. This is mostly for logging.\n * @param setStyleCallback The callback to format the paragraph. It will be called with current selected table. If no table is selected, it will not be called.\n */\nexport function formatParagraphWithContentModel(\n    editor: IEditor,\n    apiName: string,\n    setStyleCallback: (paragraph: ShallowMutableContentModelParagraph) => void\n) {\n    editor.formatContentModel(\n        (model, context) => {\n            splitSelectedParagraphByBr(model);\n\n            const paragraphs = getSelectedParagraphs(model, true /*mutate*/);\n\n            paragraphs.forEach(setStyleCallback);\n            context.newPendingFormat = 'preserve';\n\n            return paragraphs.length > 0;\n        },\n        {\n            apiName,\n        }\n    );\n}\n","import { adjustWordSelection } from '../../modelApi/selection/adjustWordSelection';\nimport { createEditorContextForEntity } from './createEditorContextForEntity';\nimport {\n    contentModelToDom,\n    createDomToModelContext,\n    createModelToDomContext,\n    domToContentModel,\n    getSelectedSegmentsAndParagraphs,\n    mergeTextSegments,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelDocument,\n    ContentModelEntity,\n    ContentModelSegmentFormat,\n    FormatContentModelContext,\n    FormattableRoot,\n    IEditor,\n    PluginEventData,\n    ReadonlyContentModelDocument,\n    ShallowMutableContentModelParagraph,\n    ShallowMutableContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * Invoke a callback to format the selected segment using Content Model\n * @param editor The editor object\n * @param apiName Name of API this calling this function. This is mostly for logging.\n * @param toggleStyleCallback The callback to format the segment. It will be called with current selected table. If no table is selected, it will not be called.\n * @param segmentHasStyleCallback The callback used for checking if the given segment already has required format\n * @param includingFormatHolder True to also include format holder of list item when search selected segments\n * @param afterFormatCallback A callback to invoke after format is applied to all selected segments and before the change is applied to DOM tree\n */\nexport function formatSegmentWithContentModel(\n    editor: IEditor,\n    apiName: string,\n    toggleStyleCallback: (\n        format: ContentModelSegmentFormat,\n        isTuringOn: boolean,\n        segment: ShallowMutableContentModelSegment | null,\n        paragraph: ShallowMutableContentModelParagraph | null\n    ) => void,\n    segmentHasStyleCallback?: (\n        format: ContentModelSegmentFormat,\n        segment: ShallowMutableContentModelSegment | null,\n        paragraph: ShallowMutableContentModelParagraph | null\n    ) => boolean,\n    includingFormatHolder?: boolean,\n    afterFormatCallback?: (\n        model: ReadonlyContentModelDocument,\n        isTurningOff: boolean,\n        context: FormatContentModelContext\n    ) => void\n) {\n    editor.formatContentModel(\n        (model, context) => {\n            let segmentAndParagraphs = getSelectedSegmentsAndParagraphs(\n                model,\n                !!includingFormatHolder,\n                true /*includingEntity*/,\n                true /*mutate*/\n            );\n            let isCollapsedSelection =\n                segmentAndParagraphs.length >= 1 &&\n                segmentAndParagraphs.every(x => x[0].segmentType == 'SelectionMarker');\n\n            // 1. adjust selection to a word if selection is collapsed\n            if (isCollapsedSelection) {\n                const para = segmentAndParagraphs[0][1];\n                const path = segmentAndParagraphs[0][2];\n\n                segmentAndParagraphs = adjustWordSelection(\n                    model,\n                    segmentAndParagraphs[0][0]\n                ).map(x => [x, para, path]);\n\n                if (segmentAndParagraphs.length > 1) {\n                    isCollapsedSelection = false;\n                }\n            }\n\n            // 2. expand selection for entities if any\n            const formatsAndSegments: [\n                ContentModelSegmentFormat,\n                ShallowMutableContentModelSegment | null,\n                ShallowMutableContentModelParagraph | null\n            ][] = [];\n            const modelsFromEntities: [\n                ContentModelEntity,\n                FormattableRoot,\n                ContentModelDocument\n            ][] = [];\n\n            segmentAndParagraphs.forEach(item => {\n                if (item[0].segmentType == 'Entity') {\n                    expandEntitySelections(\n                        editor,\n                        item[0],\n                        formatsAndSegments,\n                        modelsFromEntities,\n                        item[1]\n                    );\n                } else {\n                    formatsAndSegments.push([item[0].format, item[0], item[1]]);\n                }\n            });\n\n            // 3. check if we should turn format on (when not all selection has the required format already)\n            // or off (all selections already have the required format)\n            const isTurningOff = segmentHasStyleCallback\n                ? formatsAndSegments.every(([format, segment, paragraph]) =>\n                      segmentHasStyleCallback(format, segment, paragraph)\n                  )\n                : false;\n\n            // 4. invoke the callback function to apply the format\n            formatsAndSegments.forEach(([format, segment, paragraph]) => {\n                toggleStyleCallback(format, !isTurningOff, segment, paragraph);\n            });\n\n            // 5. after format is applied to all selections, invoke another callback to do some clean up before write the change back\n            afterFormatCallback?.(model, isTurningOff, context);\n\n            // 6. finally merge segments if possible, to avoid fragmentation\n            formatsAndSegments.forEach(([_, __, paragraph]) => {\n                if (paragraph) {\n                    mergeTextSegments(paragraph);\n                }\n            });\n\n            // 7. Write back models that we got from entities (if any)\n            writeBackEntities(editor, modelsFromEntities);\n\n            // 8. if the selection is still collapsed, it means we didn't actually applied format, set a pending format so it can be applied when user type\n            // otherwise, write back to editor\n            if (isCollapsedSelection) {\n                context.newPendingFormat = segmentAndParagraphs[0][0].format;\n                editor.focus();\n                return false;\n            } else {\n                return formatsAndSegments.length > 0;\n            }\n        },\n        {\n            apiName,\n        }\n    );\n}\n\nfunction expandEntitySelections(\n    editor: IEditor,\n    entity: ContentModelEntity,\n    formatsAndSegments: [\n        ContentModelSegmentFormat,\n        ShallowMutableContentModelSegment | null,\n        ShallowMutableContentModelParagraph | null\n    ][],\n    modelsFromEntities: [ContentModelEntity, FormattableRoot, ContentModelDocument][],\n    paragraph: ShallowMutableContentModelParagraph | null\n) {\n    const { id, entityType: type, isReadonly } = entity.entityFormat;\n\n    if (id && type) {\n        const formattableRoots: FormattableRoot[] = [];\n        const entityOperationEventData: PluginEventData<'entityOperation'> = {\n            entity: { id, type, isReadonly: !!isReadonly, wrapper: entity.wrapper },\n            operation: 'beforeFormat',\n            formattableRoots,\n        };\n\n        editor.triggerEvent('entityOperation', entityOperationEventData);\n\n        formattableRoots.forEach(root => {\n            if (entity.wrapper.contains(root.element)) {\n                const editorContext = createEditorContextForEntity(editor, entity);\n                const context = createDomToModelContext(editorContext, root.domToModelOptions);\n\n                // Treat everything as selected since the parent entity is selected\n                context.isInSelection = true;\n\n                const model = domToContentModel(root.element, context);\n                const selections = getSelectedSegmentsAndParagraphs(\n                    model,\n                    false /*includingFormatHolder*/,\n                    false /*includingEntity*/,\n                    true /*mutate*/\n                );\n\n                selections.forEach(item => {\n                    formatsAndSegments.push([item[0].format, item[0], item[1]]);\n                });\n\n                modelsFromEntities.push([entity, root, model]);\n            }\n        });\n        if (formattableRoots.length > 0) {\n            formatsAndSegments.push([entity.format, entity, paragraph]);\n        }\n    }\n}\n\nfunction writeBackEntities(\n    editor: IEditor,\n    modelsFromEntities: [ContentModelEntity, FormattableRoot, ContentModelDocument][]\n) {\n    modelsFromEntities.forEach(([entity, root, model]) => {\n        const editorContext = createEditorContextForEntity(editor, entity);\n        const modelToDomContext = createModelToDomContext(editorContext, root.modelToDomOptions);\n\n        contentModelToDom(editor.getDocument(), root.element, model, modelToDomContext);\n    });\n}\n","import { ensureFocusableParagraphForTable } from '../../modelApi/table/ensureFocusableParagraphForTable';\nimport {\n    createSelectionMarker,\n    hasMetadata,\n    setParagraphNotImplicit,\n    hasSelectionInBlock,\n    applyTableFormat,\n    getFirstSelectedTable,\n    normalizeTable,\n    setSelection,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    IEditor,\n    ShallowMutableContentModelTable,\n    TableSelection,\n} from 'roosterjs-content-model-types';\n\n/**\n * Invoke a callback to format the selected table using Content Model\n * @param editor The editor object\n * @param apiName Name of API this calling this function. This is mostly for logging.\n * @param callback The callback to format the table. It will be called with current selected table. If no table is selected, it will not be called.\n * @param selectionOverride Override the current selection. If we want to format a table even currently it is not selected, we can use this parameter to override current selection\n */\nexport function formatTableWithContentModel(\n    editor: IEditor,\n    apiName: string,\n    callback: (tableModel: ShallowMutableContentModelTable) => void,\n    selectionOverride?: TableSelection\n) {\n    editor.focus();\n    editor.formatContentModel(\n        model => {\n            const [readonlyTableModel, path] = getFirstSelectedTable(model);\n\n            if (readonlyTableModel) {\n                const tableModel = mutateBlock(readonlyTableModel);\n\n                callback(tableModel);\n\n                if (!hasSelectionInBlock(tableModel)) {\n                    const paragraph = ensureFocusableParagraphForTable(model, path, tableModel);\n\n                    if (paragraph) {\n                        const marker = createSelectionMarker(model.format);\n\n                        paragraph.segments.unshift(marker);\n                        setParagraphNotImplicit(paragraph);\n                        setSelection(model, marker);\n                    }\n                }\n\n                normalizeTable(tableModel, model.format);\n\n                if (hasMetadata(tableModel)) {\n                    applyTableFormat(tableModel, undefined /*newFormat*/, true /*keepCellShade*/);\n                }\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName,\n            selectionOverride,\n        },\n        {\n            recalculateTableSize: 'selected',\n        }\n    );\n}\n","import { getSelectedSegmentsAndParagraphs, mutateSegment } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelSegmentFormat,\n    ContentModelText,\n    FormatContentModelContext,\n    FormatContentModelOptions,\n    IEditor,\n    ShallowMutableContentModelDocument,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * Invoke a callback to format the text segment before the selection marker using Content Model\n * @param editor The editor object\n * @param callback The callback to format the text segment.\n * @returns True if the segment before cursor is found and callback is called, otherwise false\n */\nexport function formatTextSegmentBeforeSelectionMarker(\n    editor: IEditor,\n    callback: (\n        model: ShallowMutableContentModelDocument,\n        previousSegment: ContentModelText,\n        paragraph: ShallowMutableContentModelParagraph,\n        markerFormat: ContentModelSegmentFormat,\n        context: FormatContentModelContext\n    ) => boolean,\n    options?: FormatContentModelOptions\n): boolean {\n    let result = false;\n\n    editor.formatContentModel((model, context) => {\n        const selectedSegmentsAndParagraphs = getSelectedSegmentsAndParagraphs(\n            model,\n            false /*includeFormatHolder*/\n        );\n        let rewrite = false;\n\n        if (\n            selectedSegmentsAndParagraphs.length > 0 &&\n            selectedSegmentsAndParagraphs[0][0].segmentType == 'SelectionMarker' &&\n            selectedSegmentsAndParagraphs[0][1]\n        ) {\n            mutateSegment(\n                selectedSegmentsAndParagraphs[0][1],\n                selectedSegmentsAndParagraphs[0][0],\n                (marker, paragraph, markerIndex) => {\n                    const previousSegment = paragraph.segments[markerIndex - 1];\n\n                    if (previousSegment && previousSegment.segmentType === 'Text') {\n                        result = true;\n\n                        // Preserve pending format if any when format text segment, so if there is pending format (e.g. from paste)\n                        // and some auto action happens after paste, the pending format will still take effect\n                        context.newPendingFormat = 'preserve';\n\n                        rewrite = callback(\n                            model,\n                            previousSegment,\n                            paragraph,\n                            marker.format,\n                            context\n                        );\n                    }\n                }\n            );\n        }\n\n        return rewrite;\n    }, options);\n\n    return result;\n}\n","import { toArray } from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n */\nexport interface CssRule {\n    selectors: string[];\n    text: string;\n}\n\n/**\n * @internal\n *\n * Splits CSS selectors, avoiding splits within parentheses\n * @param selectorText The CSS selector string\n * @return Array of trimmed selectors\n */\nfunction splitSelectors(selectorText: string) {\n    const regex = /(?![^(]*\\)),/;\n    return selectorText.split(regex).map(s => s.trim());\n}\n\n/**\n * @internal\n */\nexport function retrieveCssRules(doc: Document): CssRule[] {\n    const styles = toArray(doc.querySelectorAll('style'));\n    const result: CssRule[] = [];\n\n    styles.forEach(styleNode => {\n        const sheet = styleNode.sheet;\n\n        if (sheet) {\n            for (let ruleIndex = 0; ruleIndex < sheet.cssRules.length; ruleIndex++) {\n                const rule = sheet.cssRules[ruleIndex] as CSSStyleRule;\n\n                if (rule.type == CSSRule.STYLE_RULE && rule.selectorText) {\n                    result.push({\n                        selectors: splitSelectors(rule.selectorText),\n                        text: rule.style.cssText,\n                    });\n                }\n            }\n        }\n\n        styleNode.parentNode?.removeChild(styleNode);\n    });\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function convertInlineCss(root: ParentNode, cssRules: CssRule[]) {\n    for (let i = cssRules.length - 1; i >= 0; i--) {\n        const { selectors, text } = cssRules[i];\n\n        for (const selector of selectors) {\n            if (!selector || !selector.trim()) {\n                continue;\n            }\n\n            const nodes = toArray(root.querySelectorAll(selector));\n\n            // Always put existing styles after so that they have higher priority\n            // Which means if both global style and inline style apply to the same element,\n            // inline style will have higher priority\n            nodes.forEach(node =>\n                node.setAttribute('style', text + (node.getAttribute('style') || ''))\n            );\n        }\n    }\n}\n","import { containerSizeFormatParser } from '../../override/containerSizeFormatParser';\nimport { createDomToModelContext } from 'roosterjs-content-model-dom';\nimport { createPasteEntityProcessor } from '../../override/pasteEntityProcessor';\nimport { createPasteGeneralProcessor } from '../../override/pasteGeneralProcessor';\nimport { getRootComputedStyleForContext } from '../../coreApi/createEditorContext/getRootComputedStyleForContext';\nimport { pasteBlockEntityParser } from '../../override/pasteCopyBlockEntityParser';\nimport { pasteDisplayFormatParser } from '../../override/pasteDisplayFormatParser';\nimport { pasteTextProcessor } from '../../override/pasteTextProcessor';\nimport { pasteWhiteSpaceFormatParser } from '../../override/pasteWhiteSpaceFormatParser';\nimport type {\n    ContentModelSegmentFormat,\n    DOMHelper,\n    DomToModelContext,\n    DomToModelOption,\n    DomToModelOptionForSanitizing,\n} from 'roosterjs-content-model-types';\n\nconst DefaultSanitizingOption: DomToModelOptionForSanitizing = {\n    processorOverride: {},\n    formatParserOverride: {},\n    additionalFormatParsers: {},\n    additionalAllowedTags: [],\n    additionalDisallowedTags: [],\n    styleSanitizers: {},\n    attributeSanitizers: {},\n    processNonVisibleElements: false,\n};\n\n/**\n * @internal\n */\nexport function createDomToModelContextForSanitizing(\n    document: Document,\n    defaultFormat?: ContentModelSegmentFormat,\n    defaultOption?: DomToModelOption,\n    additionalSanitizingOption?: Partial<DomToModelOptionForSanitizing>,\n    domHelper?: DOMHelper\n): DomToModelContext {\n    const sanitizingOption: DomToModelOptionForSanitizing = {\n        ...DefaultSanitizingOption,\n        ...additionalSanitizingOption,\n    };\n\n    return createDomToModelContext(\n        {\n            defaultFormat,\n            ...getRootComputedStyleForContext(document),\n            experimentalFeatures: [],\n            editorViewWidth: domHelper?.getClientWidth(),\n        },\n        defaultOption,\n        {\n            processorOverride: {\n                '#text': pasteTextProcessor,\n                entity: createPasteEntityProcessor(sanitizingOption),\n                '*': createPasteGeneralProcessor(sanitizingOption),\n            },\n            formatParserOverride: {\n                display: pasteDisplayFormatParser,\n                whiteSpace: pasteWhiteSpaceFormatParser,\n            },\n            additionalFormatParsers: {\n                container: [containerSizeFormatParser],\n                entity: [pasteBlockEntityParser],\n            },\n        },\n        sanitizingOption\n    );\n}\n","import { convertInlineCss, retrieveCssRules } from './convertInlineCss';\nimport { createDOMCreator } from '../../utils/domCreator';\nimport { createDomToModelContextForSanitizing } from './createDomToModelContextForSanitizing';\nimport { createEmptyModel, domToContentModel, parseFormat } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelDocument,\n    ContentModelSegmentFormat,\n    DomToModelOptionForSanitizing,\n    TrustedHTMLHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create Content Model from HTML string\n * @param html The source HTML string\n * @param options Options for DOM to Content Model conversion\n * @param trustedHTMLHandler A string handler to convert string to trusted string\n * @returns A Content Model Document object that contains the Content Model from the give HTML, or undefined if failed to parse the source HTML\n */\nexport function createModelFromHtml(\n    html: string,\n    options?: Partial<DomToModelOptionForSanitizing>,\n    trustedHTMLHandler?: TrustedHTMLHandler,\n    defaultSegmentFormat?: ContentModelSegmentFormat\n): ContentModelDocument {\n    const doc = html ? createDOMCreator(trustedHTMLHandler).htmlToDOM(html) : null;\n\n    if (doc?.body) {\n        const context = createDomToModelContextForSanitizing(\n            doc,\n            defaultSegmentFormat,\n            undefined /*defaultOptions*/,\n            options\n        );\n        const cssRules = doc ? retrieveCssRules(doc) : [];\n\n        convertInlineCss(doc, cssRules);\n        parseFormat(doc.body, context.formatParsers.segmentOnBlock, context.segmentFormat, context);\n\n        return domToContentModel(doc.body, context);\n    } else {\n        return createEmptyModel(defaultSegmentFormat);\n    }\n}\n","import { isNodeOfType } from 'roosterjs-content-model-dom';\nimport type { ValueSanitizer } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const AllowedTags: ReadonlyArray<string> = [\n    'a',\n    'abbr',\n    'address',\n    'area',\n    'article',\n    'aside',\n    'b',\n    'bdi',\n    'bdo',\n    'blockquote',\n    'body',\n    'br',\n    'button',\n    'canvas',\n    'caption',\n    'center',\n    'cite',\n    'code',\n    'col',\n    'colgroup',\n    'data',\n    'datalist',\n    'dd',\n    'del',\n    'details',\n    'dfn',\n    'dialog',\n    'dir',\n    'div',\n    'dl',\n    'dt',\n    'em',\n    'fieldset',\n    'figcaption',\n    'figure',\n    'font',\n    'footer',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'head',\n    'header',\n    'hgroup',\n    'hr',\n    'html',\n    'i',\n    'img',\n    'input',\n    'ins',\n    'kbd',\n    'label',\n    'legend',\n    'li',\n    'main',\n    'map',\n    'mark',\n    'menu',\n    'menuitem',\n    'meter',\n    'nav',\n    'ol',\n    'optgroup',\n    'option',\n    'output',\n    'p',\n    'picture',\n    'pre',\n    'progress',\n    'q',\n    'rp',\n    'rt',\n    'ruby',\n    's',\n    'samp',\n    'section',\n    'select',\n    'small',\n    'span',\n    'strike',\n    'strong',\n    'sub',\n    'summary',\n    'sup',\n    'table',\n    'tbody',\n    'td',\n    'textarea',\n    'tfoot',\n    'th',\n    'thead',\n    'time',\n    'tr',\n    'tt',\n    'u',\n    'ul',\n    'var',\n    'wbr',\n    'xmp',\n];\n\n/**\n * @internal\n */\nexport const DisallowedTags: ReadonlyArray<string> = [\n    'applet',\n    'audio',\n    'base',\n    'basefont',\n    'embed',\n    'frame',\n    'frameset',\n    'iframe',\n    'link',\n    'meta',\n    'noscript',\n    'object',\n    'param',\n    'script',\n    'slot',\n    'source',\n    'style',\n    'template',\n    'title',\n    'track',\n    'video',\n];\n\nconst VARIABLE_REGEX = /^\\s*var\\(\\s*[a-zA-Z0-9-_]+\\s*(,\\s*(.*))?\\)\\s*$/;\nconst VARIABLE_PREFIX = 'var(';\n\nconst AllowedAttributes = [\n    'accept',\n    'align',\n    'alt',\n    'checked',\n    'cite',\n    'class',\n    'color',\n    'cols',\n    'colspan',\n    'contextmenu',\n    'coords',\n    'datetime',\n    'default',\n    'dir',\n    'dirname',\n    'disabled',\n    'download',\n    'face',\n    'headers',\n    'height',\n    'hidden',\n    'high',\n    'href',\n    'hreflang',\n    'ismap',\n    'kind',\n    'label',\n    'lang',\n    'list',\n    'low',\n    'max',\n    'maxlength',\n    'media',\n    'min',\n    'multiple',\n    'open',\n    'optimum',\n    'pattern',\n    'placeholder',\n    'readonly',\n    'rel',\n    'required',\n    'reversed',\n    'rows',\n    'rowspan',\n    'scope',\n    'selected',\n    'shape',\n    'size',\n    'sizes',\n    'span',\n    'spellcheck',\n    'src',\n    'srclang',\n    'srcset',\n    'start',\n    'step',\n    'style',\n    'tabindex',\n    'target',\n    'title',\n    'translate',\n    'type',\n    'usemap',\n    'valign',\n    'value',\n    'width',\n    'wrap',\n    'bgColor',\n];\n\nconst DefaultStyleValue: { [name: string]: string } = {\n    'background-color': 'transparent',\n    'border-bottom-color': 'rgb(0, 0, 0)',\n    'border-bottom-style': 'none',\n    'border-bottom-width': '0px',\n    'border-image-outset': '0',\n    'border-image-repeat': 'stretch',\n    'border-image-slice': '100%',\n    'border-image-source': 'none',\n    'border-image-width': '1',\n    'border-left-color': 'rgb(0, 0, 0)',\n    'border-left-style': 'none',\n    'border-left-width': '0px',\n    'border-right-color': 'rgb(0, 0, 0)',\n    'border-right-style': 'none',\n    'border-right-width': '0px',\n    'border-top-color': 'rgb(0, 0, 0)',\n    'border-top-style': 'none',\n    'border-top-width': '0px',\n    'outline-color': 'transparent',\n    'outline-style': 'none',\n    'outline-width': '0px',\n    overflow: 'visible',\n    '-webkit-text-stroke-width': '0px',\n    'word-wrap': 'break-word',\n    'margin-left': '0px',\n    'margin-right': '0px',\n    padding: '0px',\n    'padding-top': '0px',\n    'padding-left': '0px',\n    'padding-right': '0px',\n    'padding-bottom': '0px',\n    border: '0px',\n    'border-top': '0px',\n    'border-left': '0px',\n    'border-right': '0px',\n    'border-bottom': '0px',\n    'vertical-align': 'baseline',\n    float: 'none',\n    'font-style': 'normal',\n    'font-variant-ligatures': 'normal',\n    'font-variant-caps': 'normal',\n    'font-weight': '400',\n    'letter-spacing': 'normal',\n    orphans: '2',\n    'text-align': 'start',\n    'text-indent': '0px',\n    'text-transform': 'none',\n    widows: '2',\n    'word-spacing': '0px',\n    'white-space': 'normal',\n};\n\n/**\n * @internal\n */\nexport function sanitizeElement(\n    element: HTMLElement,\n    allowedTags: ReadonlyArray<string>,\n    disallowedTags: ReadonlyArray<string>,\n    styleSanitizers?: Readonly<Record<string, ValueSanitizer>>,\n    attributeSanitizers?: Readonly<Record<string, ValueSanitizer>>\n): HTMLElement | null {\n    const tag = element.tagName.toLowerCase();\n    const sanitizedElement =\n        disallowedTags.indexOf(tag) >= 0\n            ? null\n            : createSanitizedElement(\n                  element.ownerDocument,\n                  allowedTags.indexOf(tag) >= 0 ? tag : 'span',\n                  element.attributes,\n                  styleSanitizers,\n                  attributeSanitizers\n              );\n\n    if (sanitizedElement) {\n        for (let child = element.firstChild; child; child = child.nextSibling) {\n            const newChild = isNodeOfType(child, 'ELEMENT_NODE')\n                ? sanitizeElement(\n                      child,\n                      allowedTags,\n                      disallowedTags,\n                      styleSanitizers,\n                      attributeSanitizers\n                  )\n                : isNodeOfType(child, 'TEXT_NODE')\n                ? child.cloneNode()\n                : null;\n\n            if (newChild) {\n                sanitizedElement?.appendChild(newChild);\n            }\n        }\n    }\n\n    return sanitizedElement;\n}\n\n/**\n * @internal\n */\nexport function createSanitizedElement(\n    doc: Document,\n    tag: string,\n    attributes: NamedNodeMap,\n    styleSanitizers?: Readonly<Record<string, ValueSanitizer>>,\n    attributeSanitizers?: Readonly<Record<string, ValueSanitizer>>\n): HTMLElement {\n    const element = doc.createElement(tag);\n\n    for (let i = 0; i < attributes.length; i++) {\n        const attribute = attributes[i];\n        const name = attribute.name.toLowerCase().trim();\n        const value = attribute.value;\n\n        const sanitizer = attributeSanitizers?.[name];\n        const newValue =\n            name == 'style'\n                ? processStyles(tag, value, styleSanitizers)\n                : typeof sanitizer == 'function'\n                ? sanitizer(value, tag)\n                : typeof sanitizer === 'boolean'\n                ? sanitizer\n                    ? value\n                    : null\n                : AllowedAttributes.indexOf(name) >= 0 || name.indexOf('data-') == 0\n                ? value\n                : null;\n\n        if (\n            newValue !== null &&\n            newValue !== undefined &&\n            !newValue.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\n        ) {\n            element.setAttribute(name, newValue);\n        }\n    }\n\n    return element;\n}\n\nfunction processStyles(\n    tagName: string,\n    value: string,\n    styleSanitizers?: Readonly<Record<string, ValueSanitizer>>\n) {\n    const pairs = value.split(';');\n    const result: string[] = [];\n\n    pairs.forEach(pair => {\n        const valueIndex = pair.indexOf(':');\n        const name = pair.slice(0, valueIndex).trim();\n        let value: string = pair.slice(valueIndex + 1).trim();\n\n        if (name && value) {\n            if (isCssVariable(value)) {\n                value = processCssVariable(value);\n            }\n\n            const sanitizer = styleSanitizers?.[name];\n            const sanitizedValue =\n                typeof sanitizer == 'function'\n                    ? sanitizer(value, tagName)\n                    : sanitizer === false\n                    ? null\n                    : value;\n\n            if (\n                !!sanitizedValue &&\n                sanitizedValue != 'inherit' &&\n                sanitizedValue != 'initial' &&\n                sanitizedValue.indexOf('expression') < 0 &&\n                !name.startsWith('-') &&\n                DefaultStyleValue[name] != sanitizedValue\n            ) {\n                result.push(`${name}:${sanitizedValue}`);\n            }\n        }\n    });\n\n    return result.join(';');\n}\n\nfunction processCssVariable(value: string): string {\n    const match = VARIABLE_REGEX.exec(value);\n    return match?.[2] || ''; // Without fallback value, we don't know what does the original value mean, so ignore it\n}\n\nfunction isCssVariable(value: string): boolean {\n    return value.indexOf(VARIABLE_PREFIX) == 0;\n}\n","import type { IEditor, DOMSelection } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Adjust Image selection, so the copy by keyboard does not remove image selection.\n */\nexport function adjustImageSelectionOnSafari(editor: IEditor, selection: DOMSelection | null) {\n    if (editor.getEnvironment().isSafari && selection?.type == 'image') {\n        const range = new Range();\n        range.setStartBefore(selection.image);\n        range.setEndAfter(selection.image);\n        editor.setDOMSelection({\n            range,\n            type: 'range',\n            isReverted: false,\n        });\n    }\n}\n","import { iterateSelections } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelDocument,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ReadonlyTableSelectionContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function adjustSelectionForCopyCut(pasteModel: ContentModelDocument) {\n    let selectionMarker: ContentModelSegment | undefined;\n    let firstBlock: ContentModelParagraph | undefined;\n    let tableContext: ReadonlyTableSelectionContext | undefined;\n\n    iterateSelections(pasteModel, (_, tableCtxt, block, segments) => {\n        if (selectionMarker) {\n            if (tableCtxt != tableContext && firstBlock?.segments.includes(selectionMarker)) {\n                firstBlock.segments.splice(firstBlock.segments.indexOf(selectionMarker), 1);\n            }\n            return true;\n        }\n\n        const marker = segments?.find(segment => segment.segmentType == 'SelectionMarker');\n        if (!selectionMarker && marker) {\n            tableContext = tableCtxt;\n            firstBlock = block?.blockType == 'Paragraph' ? block : undefined;\n            selectionMarker = marker;\n        }\n\n        return false;\n    });\n}\n","import { adjustImageSelectionOnSafari } from './adjustImageSelectionOnSafari';\nimport { adjustSelectionForCopyCut } from './adjustSelectionForCopyCut';\nimport { onCreateCopyEntityNode } from '../../override/pasteCopyBlockEntityParser';\nimport { preprocessTable } from './preprocessTable';\nimport { pruneUnselectedModel } from './pruneUnselectedModel';\nimport type {\n    DOMSelection,\n    IEditor,\n    OnNodeCreated,\n    TextAndHtmlContentForCopy,\n} from 'roosterjs-content-model-types';\nimport {\n    contentModelToDom,\n    contentModelToText,\n    createModelToDomContext,\n    isElementOfType,\n    isNodeOfType,\n    iterateSelections,\n    wrap,\n} from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n * Exported only for unit testing\n */\nexport const onNodeCreated: OnNodeCreated = (modelElement, node): void => {\n    if (isNodeOfType(node, 'ELEMENT_NODE') && isElementOfType(node, 'table')) {\n        wrap(node.ownerDocument, node, 'div');\n    }\n    if (isNodeOfType(node, 'ELEMENT_NODE') && !node.isContentEditable) {\n        node.removeAttribute('contenteditable');\n    }\n    onCreateCopyEntityNode(modelElement, node);\n};\n\n/**\n * Get the content for the copy event\n * @param editor The editor object\n * @param isCut if the event cut the content.\n * @param event the clipboard event that triggered the copy/cut\n * @returns\n */\nexport function getContentForCopy(\n    editor: IEditor,\n    isCut: boolean,\n    event: ClipboardEvent\n): TextAndHtmlContentForCopy | null {\n    const selection = editor.getDOMSelection();\n    adjustImageSelectionOnSafari(editor, selection);\n    if (selection && (selection.type != 'range' || !selection.range.collapsed)) {\n        const pasteModel = editor.getContentModelCopy('disconnected');\n        pruneUnselectedModel(pasteModel);\n\n        if (selection.type === 'table') {\n            iterateSelections(pasteModel, (_, tableContext) => {\n                if (tableContext?.table) {\n                    preprocessTable(tableContext.table);\n\n                    return true;\n                }\n                return false;\n            });\n        } else if (selection.type === 'range') {\n            adjustSelectionForCopyCut(pasteModel);\n        }\n        const context = createModelToDomContext();\n\n        context.onNodeCreated = onNodeCreated;\n        const doc = editor.getDocument();\n        const tempDiv = doc.createElement('div');\n\n        const selectionForCopy = contentModelToDom(doc, tempDiv, pasteModel, context);\n        const newRange = selectionForCopy ? domSelectionToRange(doc, selectionForCopy) : null;\n        if (newRange) {\n            const { clonedRoot } = editor.triggerEvent('beforeCutCopy', {\n                clonedRoot: tempDiv,\n                range: newRange,\n                rawEvent: event,\n                isCut,\n            });\n\n            return {\n                htmlContent: clonedRoot,\n                textContent: contentModelToText(pasteModel),\n            };\n        }\n    }\n    return null;\n}\n\nfunction domSelectionToRange(doc: Document, selection: DOMSelection): Range | null {\n    let newRange: Range | null = null;\n\n    if (selection.type === 'table') {\n        const table = selection.table;\n        const elementToSelect =\n            table.parentElement?.childElementCount == 1 ? table.parentElement : table;\n\n        newRange = doc.createRange();\n        newRange.selectNode(elementToSelect);\n    } else if (selection.type === 'image') {\n        newRange = doc.createRange();\n        newRange.selectNode(selection.image);\n    } else {\n        newRange = selection.range;\n    }\n\n    return newRange;\n}\n","import { getSelectedCells } from 'roosterjs-content-model-dom';\nimport type { ContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function preprocessTable(table: ContentModelTable) {\n    const sel = getSelectedCells(table);\n    table.rows = table.rows\n        .map(row => {\n            return {\n                ...row,\n                cells: row.cells.filter(cell => cell.isSelected),\n            };\n        })\n        .filter(row => row.cells.length > 0);\n\n    delete table.format.width;\n\n    table.widths = sel\n        ? table.widths.filter((_, index) => index >= sel?.firstColumn && index <= sel?.lastColumn)\n        : [];\n}\n","import type {\n    ContentModelBlockGroupBase,\n    ContentModelBlockGroupType,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelTableCell,\n    ContentModelTableRow,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function pruneUnselectedModel(\n    model: ContentModelBlockGroupBase<ContentModelBlockGroupType, HTMLElement>\n) {\n    pruneUnselectedModelInternal(model, false /* isSelectionAfterElement */);\n\n    unwrap(model);\n}\n\nfunction pruneUnselectedModelInternal(\n    model: ContentModelBlockGroupBase<ContentModelBlockGroupType, HTMLElement>,\n    isSelectionAfterElement: boolean\n) {\n    for (let index = model.blocks.length - 1; index >= 0; index--) {\n        const block = model.blocks[index];\n\n        switch (block.blockType) {\n            case 'BlockGroup':\n                pruneUnselectedModelInternal(block, isSelectionAfterElement);\n                if (\n                    block.blockGroupType == 'General'\n                        ? block.blocks.length == 0 && !block.isSelected\n                        : block.blocks.length == 0\n                ) {\n                    model.blocks.splice(index, 1);\n                }\n                break;\n            case 'Divider':\n            case 'Entity':\n                if (!block.isSelected) {\n                    model.blocks.splice(index, 1);\n                } else {\n                    isSelectionAfterElement = true;\n                }\n                break;\n            case 'Paragraph':\n                const newSegments: ContentModelSegment[] = [];\n                for (const segment of block.segments) {\n                    if (segment.segmentType == 'General') {\n                        pruneUnselectedModel(segment);\n                        if (segment.blocks.length > 0 || segment.isSelected) {\n                            newSegments.push(segment);\n                        }\n                    } else if (segment.isSelected && segment.segmentType != 'SelectionMarker') {\n                        newSegments.push(segment);\n                    }\n                }\n                block.segments = newSegments;\n                if (block.segments.length == 0) {\n                    model.blocks.splice(index, 1);\n                } else {\n                    isSelectionAfterElement = true;\n                }\n                break;\n            case 'Table':\n                const filteredRows: ContentModelTableRow[] = [];\n                for (let i = 0; i < block.rows.length; i++) {\n                    const row = block.rows[i];\n                    for (let j = 0; j < row.cells.length; j++) {\n                        const cell = row.cells[j];\n                        if (!cell.isSelected) {\n                            pruneUnselectedModelInternal(cell, isSelectionAfterElement);\n                        } else {\n                            isSelectionAfterElement = true;\n                        }\n                    }\n\n                    const newCells: ContentModelTableCell[] = [];\n                    for (let k = 0; k < row.cells.length; k++) {\n                        const cell = row.cells[k];\n                        if (cell.isSelected || cell.blocks.length > 0) {\n                            newCells.push(cell);\n                        }\n                    }\n                    row.cells = newCells;\n\n                    if (row.cells.length > 0) {\n                        filteredRows.push(row);\n                    }\n                }\n\n                if (\n                    !isSelectionAfterElement &&\n                    filteredRows.length == 1 &&\n                    filteredRows[0].cells.length == 1 &&\n                    !filteredRows[0].cells[0].isSelected\n                ) {\n                    const cell = filteredRows[0].cells[0];\n                    model.blocks.splice(index, 1, ...cell.blocks);\n                } else if (filteredRows.length == 0) {\n                    model.blocks.splice(index, 1);\n                } else {\n                    block.rows = filteredRows;\n                }\n                break;\n        }\n    }\n    return isSelectionAfterElement;\n}\n\nfunction unwrap(model: ContentModelBlockGroupBase<ContentModelBlockGroupType, HTMLElement>) {\n    let block = model.blocks[0];\n    if (model.blocks.length == 1) {\n        while (block.blockType == 'BlockGroup') {\n            model.blocks = block.blocks;\n            block = model.blocks[0];\n\n            if (model.blocks.length > 1) {\n                return;\n            }\n        }\n\n        if (block.blockType == 'Paragraph') {\n            block.isImplicit = true;\n            block.format = {};\n            inheritSegmentFormatToChildren(block);\n        }\n    }\n}\n\nfunction inheritSegmentFormatToChildren(parent: ContentModelParagraph) {\n    const value = parent.segmentFormat;\n    if (value !== undefined) {\n        for (let index = 0; index < parent.segments.length; index++) {\n            const segment = parent.segments[index];\n            segment.format = {\n                ...parent.segmentFormat,\n                ...segment.format,\n            };\n        }\n    }\n}\n","import {\n    contentModelToDom,\n    contentModelToText,\n    createModelToDomContext,\n    transformColor,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelDocument,\n    ExportContentMode,\n    IEditor,\n    ModelToDomOption,\n    ModelToTextCallbacks,\n} from 'roosterjs-content-model-types';\n\n/**\n * Export HTML content. If there are entities, this will cause EntityOperation event with option = 'replaceTemporaryContent' to get a dehydrated entity\n * @param editor The editor to get content from\n * @param mode Specify HTML to get HTML. This is the default option\n * @param options @optional Options for Model to DOM conversion\n */\nexport function exportContent(editor: IEditor, mode?: 'HTML', options?: ModelToDomOption): string;\n\n/**\n * Export HTML content. If there are entities, this will cause EntityOperation event with option = 'replaceTemporaryContent' to get a dehydrated entity.\n * This is a fast version, it retrieve HTML content directly from editor without going through content model conversion.\n * @param editor The editor to get content from\n * @param mode Specify HTMLFast to get HTML result.\n */\nexport function exportContent(editor: IEditor, mode: 'HTMLFast'): string;\n\n/**\n * Export plain text content\n * @param editor The editor to get content from\n * @param mode Specify PlainText to get plain text result\n * @param callbacks @optional Callbacks to customize conversion behavior\n */\nexport function exportContent(\n    editor: IEditor,\n    mode: 'PlainText',\n    callbacks?: ModelToTextCallbacks\n): string;\n\n/**\n * Export plain text using editor's textContent property directly\n * @param editor The editor to get content from\n * @param mode Specify PlainTextFast to get plain text result using textContent property\n * @param options @optional Options for Model to DOM conversion\n */\nexport function exportContent(editor: IEditor, mode: 'PlainTextFast'): string;\n\n// Here I didn't add 'HTMLFast' to ExportContentMode type because it will make this a breaking change and EditorAdapter will see build time error without bumping version\n// Once we are confident that 'HTMLFast' is stable, we can fully switch 'HTML' to use the 'HTMLFast' approach\nexport function exportContent(\n    editor: IEditor,\n    mode: ExportContentMode | 'HTMLFast' = 'HTML',\n    optionsOrCallbacks?: ModelToDomOption | ModelToTextCallbacks\n): string {\n    let model: ContentModelDocument;\n\n    switch (mode) {\n        case 'PlainTextFast':\n            return editor.getDOMHelper().getTextContent();\n        case 'PlainText':\n            model = editor.getContentModelCopy('clean');\n\n            return contentModelToText(\n                model,\n                undefined /*separator*/,\n                optionsOrCallbacks as ModelToTextCallbacks\n            );\n\n        case 'HTMLFast':\n            const clonedRoot = editor.getDOMHelper().getClonedRoot();\n\n            if (editor.isDarkMode()) {\n                transformColor(\n                    clonedRoot,\n                    false /*includeSelf*/,\n                    'darkToLight',\n                    editor.getColorManager(),\n                    {\n                        tableBorders: editor.isExperimentalFeatureEnabled(\n                            'TransformTableBorderColors'\n                        ),\n                    }\n                );\n            }\n\n            return getHTMLFromDOM(editor, clonedRoot);\n\n        case 'HTML':\n        default:\n            model = editor.getContentModelCopy('clean');\n\n            const doc = editor.getDocument();\n            const div = doc.createElement('div');\n\n            contentModelToDom(\n                doc,\n                div,\n                model,\n                createModelToDomContext(\n                    undefined /*editorContext*/,\n                    optionsOrCallbacks as ModelToDomOption\n                )\n            );\n\n            return getHTMLFromDOM(editor, div);\n    }\n}\n\nfunction getHTMLFromDOM(editor: IEditor, root: HTMLElement): string {\n    editor.triggerEvent('extractContentWithDom', { clonedRoot: root }, true /*broadcast*/);\n\n    return root.innerHTML;\n}\n","const HtmlCommentStart = '\\x3C!--';\nconst HtmlCommentStart2 = '<!--';\nconst HtmlCommentEnd = '-->';\nconst styleTag = '<style';\nconst styleClosingTag = '</style>';\nconst nonWordCharacterRegex = /\\W/;\n\n/**\n * @internal\n * Exported only for unit test\n */\nexport function cleanHtmlComments(html: string) {\n    let { styleIndex, styleEndIndex } = extractHtmlIndexes(html);\n\n    while (styleIndex > -1) {\n        html = removeCommentsFromHtml(html, HtmlCommentStart, styleEndIndex, styleIndex);\n        html = removeCommentsFromHtml(html, HtmlCommentStart2, styleEndIndex, styleIndex);\n        html = removeCommentsFromHtml(html, HtmlCommentEnd, styleEndIndex, styleIndex);\n\n        ({ styleIndex, styleEndIndex } = extractHtmlIndexes(html, styleEndIndex + 1));\n    }\n\n    return html;\n}\n\nfunction extractHtmlIndexes(html: string, startIndex: number = 0) {\n    const htmlLowercase = html.toLowerCase();\n    let styleIndex = htmlLowercase.indexOf(styleTag, startIndex);\n    let currentIndex = styleIndex + styleTag.length;\n    let nextChar = html.substring(currentIndex, currentIndex + 1);\n\n    while (!nonWordCharacterRegex.test(nextChar) && styleIndex > -1) {\n        styleIndex = htmlLowercase.indexOf(styleTag, styleIndex + 1);\n        currentIndex = styleIndex + styleTag.length;\n        nextChar = html.substring(currentIndex, currentIndex + 1);\n    }\n\n    const styleEndIndex = htmlLowercase.indexOf(styleClosingTag, startIndex);\n    return { styleIndex, styleEndIndex };\n}\n\nfunction removeCommentsFromHtml(\n    html: string,\n    marker: string,\n    endId: number,\n    startId: number\n): string {\n    let id = html.indexOf(marker, startId);\n    while (id > -1 && id < endId) {\n        html = html.substring(0, id) + html.substring(id + marker.length);\n        id = html.indexOf(marker, id + 1);\n    }\n    return html;\n}\n","import { moveChildNodes, wrap } from 'roosterjs-content-model-dom';\nimport type { ClipboardData, PasteType } from 'roosterjs-content-model-types';\n\nconst NBSP_HTML = '\\u00A0';\nconst ENSP_HTML = '\\u2002';\nconst TAB_SPACES = 6;\n\n/**\n * @internal\n */\nexport function createPasteFragment(\n    document: Document,\n    clipboardData: ClipboardData,\n    pasteType: PasteType,\n    root: HTMLElement | undefined\n): DocumentFragment {\n    if (!clipboardData.text && pasteType === 'asPlainText' && root) {\n        clipboardData.text = root.textContent || clipboardData.text;\n    }\n\n    const { imageDataUri, text } = clipboardData;\n    const fragment = document.createDocumentFragment();\n\n    if (\n        (pasteType == 'asImage' && imageDataUri) ||\n        (pasteType != 'asPlainText' && !text && imageDataUri)\n    ) {\n        // Paste image\n        const img = document.createElement('img');\n        img.style.maxWidth = '100%';\n        img.src = imageDataUri;\n        fragment.appendChild(img);\n    } else if (pasteType != 'asPlainText' && root) {\n        moveChildNodes(fragment, root);\n    } else if (text) {\n        text.split('\\n').forEach((line, index, lines) => {\n            line = line\n                .replace(/^ /g, NBSP_HTML)\n                .replace(/ $/g, NBSP_HTML)\n                .replace(/\\r/g, '')\n                .replace(/ {2}/g, ' ' + NBSP_HTML);\n\n            if (line.includes('\\t')) {\n                line = transformTabCharacters(line);\n            }\n\n            const textNode = document.createTextNode(line);\n\n            // There are 3 scenarios:\n            // 1. Single line: Paste as it is\n            // 2. Two lines: Add <br> between the lines\n            // 3. 3 or More lines, For first and last line, paste as it is. For middle lines, wrap with DIV, and add BR if it is empty line\n            if (lines.length == 2 && index == 0) {\n                // 1 of 2 lines scenario, add BR\n                fragment.appendChild(textNode);\n                fragment.appendChild(document.createElement('br'));\n            } else if (index > 0 && index < lines.length - 1) {\n                // Middle line of >=3 lines scenario, wrap with DIV\n                fragment.appendChild(\n                    wrap(document, line == '' ? document.createElement('br') : textNode, 'div')\n                );\n            } else {\n                // All others, paste as it is\n                fragment.appendChild(textNode);\n            }\n        });\n    }\n\n    return fragment;\n}\n\n/**\n * Transform \\t characters into EN SPACE characters\n * @param input string NOT containing \\n characters\n * @example t(\"\\thello\", 2) => \"&ensp;&ensp;&ensp;&ensp;hello\"\n */\nfunction transformTabCharacters(input: string, initialOffset: number = 0) {\n    let line = input;\n    let tIndex: number;\n    while ((tIndex = line.indexOf('\\t')) != -1) {\n        const lineBefore = line.slice(0, tIndex);\n        const lineAfter = line.slice(tIndex + 1);\n        const tabCount = TAB_SPACES - ((lineBefore.length + initialOffset) % TAB_SPACES);\n        const tabStr = Array(tabCount).fill(ENSP_HTML).join('');\n        line = lineBefore + tabStr + lineAfter;\n    }\n    return line;\n}\n","import type { HtmlFromClipboard } from './retrieveHtmlInfo';\nimport type {\n    BeforePasteEvent,\n    ClipboardData,\n    DomToModelOptionForSanitizing,\n    PasteType,\n    IEditor,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function generatePasteOptionFromPlugins(\n    editor: IEditor,\n    clipboardData: ClipboardData,\n    fragment: DocumentFragment,\n    htmlFromClipboard: HtmlFromClipboard,\n    pasteType: PasteType\n): BeforePasteEvent {\n    const domToModelOption: DomToModelOptionForSanitizing = {\n        additionalAllowedTags: [],\n        additionalDisallowedTags: [],\n        additionalFormatParsers: {},\n        formatParserOverride: {},\n        processorOverride: {},\n        styleSanitizers: {},\n        attributeSanitizers: {},\n        processNonVisibleElements: !!editor.getEnvironment().domToModelSettings.customized\n            .processNonVisibleElements,\n    };\n\n    const event: BeforePasteEvent = {\n        eventType: 'beforePaste',\n        clipboardData,\n        fragment,\n        htmlBefore: htmlFromClipboard.htmlBefore ?? '',\n        htmlAfter: htmlFromClipboard.htmlAfter ?? '',\n        htmlAttributes: htmlFromClipboard.metadata,\n        pasteType: pasteType,\n        domToModelOption,\n        containsBlockElements: !!htmlFromClipboard.containsBlockElements,\n    };\n\n    return editor.triggerEvent('beforePaste', event, true /* broadcast */);\n}\n","import { createDomToModelContextForSanitizing } from '../createModelFromHtml/createDomToModelContextForSanitizing';\nimport {\n    ChangeSource,\n    EmptySegmentFormat,\n    cloneModel,\n    domToContentModel,\n    getSegmentTextFormat,\n    getSelectedSegments,\n    mergeModel,\n} from 'roosterjs-content-model-dom';\nimport type {\n    BeforePasteEvent,\n    CloneModelOptions,\n    ContentModelDocument,\n    ContentModelSegmentFormat,\n    IEditor,\n    MergeModelOption,\n    PasteType,\n    ReadonlyContentModelDocument,\n    ShallowMutableContentModelDocument,\n} from 'roosterjs-content-model-types';\n\nconst BlackColor = 'rgb(0,0,0)';\n\nconst CloneOption: CloneModelOptions = {\n    includeCachedElement: (node, type) => (type == 'cache' ? undefined : node),\n};\n\n/**\n * @internal\n */\nexport function cloneModelForPaste(model: ReadonlyContentModelDocument) {\n    return cloneModel(model, CloneOption);\n}\n\n/**\n * @internal\n */\nexport function mergePasteContent(\n    editor: IEditor,\n    eventResult: BeforePasteEvent,\n    isFirstPaste: boolean\n) {\n    const {\n        fragment,\n        domToModelOption,\n        customizedMerge,\n        pasteType,\n        clipboardData,\n        containsBlockElements,\n    } = eventResult;\n\n    editor.formatContentModel(\n        (model, context) => {\n            if (!isFirstPaste && clipboardData.modelBeforePaste) {\n                const clonedModel = cloneModelForPaste(clipboardData.modelBeforePaste);\n                model.blocks = clonedModel.blocks;\n            }\n\n            const domToModelContext = createDomToModelContextForSanitizing(\n                editor.getDocument(),\n                undefined /*defaultFormat*/,\n                editor.getEnvironment().domToModelSettings.customized,\n                domToModelOption,\n                editor.getDOMHelper()\n            );\n\n            domToModelContext.segmentFormat = getSegmentFormatForPaste(model, pasteType);\n\n            const pasteModel = domToContentModel(fragment, domToModelContext);\n            const mergeOption: MergeModelOption = {\n                mergeFormat: pasteType == 'mergeFormat' ? 'keepSourceEmphasisFormat' : 'none',\n                mergeTable: shouldMergeTable(pasteModel),\n                addParagraphAfterMergedContent: containsBlockElements,\n            };\n\n            const insertPoint = customizedMerge\n                ? customizedMerge(model, pasteModel)\n                : mergeModel(model, pasteModel, context, mergeOption);\n\n            if (insertPoint) {\n                context.newPendingFormat = {\n                    ...EmptySegmentFormat,\n                    ...model.format,\n                    ...(pasteType == 'normal' && !containsBlockElements\n                        ? getLastSegmentFormat(pasteModel)\n                        : insertPoint.marker.format),\n                };\n            }\n\n            return true;\n        },\n        {\n            changeSource: ChangeSource.Paste,\n            getChangeData: () => clipboardData,\n            scrollCaretIntoView: true,\n            apiName: 'paste',\n        }\n    );\n}\n\nfunction getSegmentFormatForPaste(\n    model: ShallowMutableContentModelDocument,\n    pasteType: PasteType\n): ContentModelSegmentFormat {\n    const selectedSegment = getSelectedSegments(model, true /*includeFormatHolder*/)[0];\n\n    if (selectedSegment) {\n        const result = getSegmentTextFormat(selectedSegment);\n        if (pasteType == 'normal') {\n            // When using normal paste (Keep source formatting) set the default text color to black when creating the\n            // Model from the clipboard content, so the elements that do not contain any text color in their style\n            // Are set to black. Otherwise, These segments would get the selected segments format or the default text set in the content.\n            result.textColor = BlackColor;\n        }\n\n        return result;\n    }\n\n    return {};\n}\n\nfunction shouldMergeTable(pasteModel: ContentModelDocument): boolean | undefined {\n    // If model contains a table and a paragraph element after the table with a single BR segment, remove the Paragraph after the table\n    if (\n        pasteModel.blocks.length == 2 &&\n        pasteModel.blocks[0].blockType === 'Table' &&\n        pasteModel.blocks[1].blockType === 'Paragraph' &&\n        pasteModel.blocks[1].segments.length === 1 &&\n        pasteModel.blocks[1].segments[0].segmentType === 'Br'\n    ) {\n        pasteModel.blocks.splice(1);\n    }\n    // Only merge table when the document contain a single table.\n    return pasteModel.blocks.length === 1 && pasteModel.blocks[0].blockType === 'Table';\n}\n\nfunction getLastSegmentFormat(pasteModel: ContentModelDocument): ContentModelSegmentFormat {\n    if (pasteModel.blocks.length == 1) {\n        const [firstBlock] = pasteModel.blocks;\n\n        if (firstBlock.blockType == 'Paragraph') {\n            const segment = firstBlock.segments[firstBlock.segments.length - 1];\n\n            return {\n                ...segment.format,\n            };\n        }\n    }\n\n    return {};\n}\n","import { cleanHtmlComments } from './cleanHtmlComments';\nimport { cloneModelForPaste, mergePasteContent } from './mergePasteContent';\nimport { convertInlineCss } from '../createModelFromHtml/convertInlineCss';\nimport { createPasteFragment } from './createPasteFragment';\nimport { generatePasteOptionFromPlugins } from './generatePasteOptionFromPlugins';\nimport { retrieveHtmlInfo } from './retrieveHtmlInfo';\nimport type {\n    PasteTypeOrGetter,\n    ClipboardData,\n    IEditor,\n    DOMCreator,\n} from 'roosterjs-content-model-types';\n\n/**\n * Paste into editor using a clipboardData object\n * @param editor The Editor object.\n * @param clipboardData Clipboard data retrieved from clipboard\n * @param pasteTypeOrGetter Type of content to paste or function that returns the Paste Type to use based on the document and the clipboard Data. @default normal\n */\nexport function paste(\n    editor: IEditor,\n    clipboardData: ClipboardData,\n    pasteTypeOrGetter: PasteTypeOrGetter = 'normal'\n) {\n    editor.focus();\n    let isFirstPaste = false;\n\n    if (!clipboardData.modelBeforePaste) {\n        isFirstPaste = true;\n\n        editor.formatContentModel(model => {\n            clipboardData.modelBeforePaste = cloneModelForPaste(model);\n\n            return false;\n        });\n    }\n\n    // 1. Prepare variables\n    const domCreator = editor.getDOMCreator();\n    if (!domCreator.isBypassed && clipboardData.rawHtml) {\n        clipboardData.rawHtml = cleanHtmlComments(clipboardData.rawHtml);\n    }\n    const doc = createDOMFromHtml(clipboardData.rawHtml, domCreator);\n    const pasteType =\n        typeof pasteTypeOrGetter == 'function'\n            ? pasteTypeOrGetter(doc, clipboardData)\n            : pasteTypeOrGetter;\n\n    // 2. Handle HTML from clipboard\n    const htmlFromClipboard = retrieveHtmlInfo(doc, clipboardData);\n\n    // 3. Create target fragment\n    const sourceFragment = createPasteFragment(\n        editor.getDocument(),\n        clipboardData,\n        pasteType,\n        (clipboardData.rawHtml == clipboardData.html\n            ? doc\n            : createDOMFromHtml(clipboardData.html, domCreator)\n        )?.body\n    );\n\n    // 4. Trigger BeforePaste event to allow plugins modify the fragment\n    const eventResult = generatePasteOptionFromPlugins(\n        editor,\n        clipboardData,\n        sourceFragment,\n        htmlFromClipboard,\n        pasteType\n    );\n\n    // 5. Convert global CSS to inline CSS\n    convertInlineCss(eventResult.fragment, htmlFromClipboard.globalCssRules);\n\n    // 6. Merge pasted content into main Content Model\n    mergePasteContent(editor, eventResult, isFirstPaste);\n}\n\nfunction createDOMFromHtml(\n    html: string | null | undefined,\n    domCreator: DOMCreator\n): Document | null {\n    return html ? domCreator.htmlToDOM(html) : null;\n}\n","import { retrieveCssRules } from '../createModelFromHtml/convertInlineCss';\nimport {\n    isBlockElement,\n    isNodeOfType,\n    retrieveDocumentMetadata,\n    toArray,\n} from 'roosterjs-content-model-dom';\nimport type { ClipboardData } from 'roosterjs-content-model-types';\nimport type { CssRule } from '../createModelFromHtml/convertInlineCss';\n\nconst START_FRAGMENT = '<!--StartFragment-->';\nconst END_FRAGMENT = '<!--EndFragment-->';\n\n/**\n * @internal\n */\nexport interface HtmlFromClipboard {\n    metadata: Record<string, string>;\n    globalCssRules: CssRule[];\n    htmlBefore?: string;\n    htmlAfter?: string;\n    containsBlockElements?: boolean;\n}\n\n/**\n * @internal\n */\nexport function retrieveHtmlInfo(\n    doc: Document | null,\n    clipboardData: Partial<ClipboardData>\n): HtmlFromClipboard {\n    let result: HtmlFromClipboard = {\n        metadata: {},\n        globalCssRules: [],\n    };\n\n    if (doc) {\n        result = {\n            ...retrieveHtmlStrings(clipboardData),\n            globalCssRules: retrieveCssRules(doc),\n            metadata: retrieveDocumentMetadata(doc),\n            containsBlockElements: checkBlockElements(doc),\n        };\n\n        clipboardData.htmlFirstLevelChildTags = retrieveTopLevelTags(doc);\n    }\n\n    return result;\n}\n\nfunction retrieveTopLevelTags(doc: Document): string[] {\n    const topLevelTags: string[] = [];\n\n    for (let child = doc.body.firstChild; child; child = child.nextSibling) {\n        if (isNodeOfType(child, 'TEXT_NODE')) {\n            const trimmedString = child.nodeValue?.replace(/(\\r\\n|\\r|\\n)/gm, '').trim();\n\n            if (trimmedString) {\n                topLevelTags.push(''); // Push an empty string as tag for text node\n            }\n        } else if (isNodeOfType(child, 'ELEMENT_NODE')) {\n            topLevelTags.push(child.tagName);\n        }\n    }\n\n    return topLevelTags;\n}\n\nfunction retrieveHtmlStrings(\n    clipboardData: Partial<ClipboardData>\n): {\n    htmlBefore: string;\n    htmlAfter: string;\n} {\n    const rawHtml = clipboardData.rawHtml ?? '';\n    const startIndex = rawHtml.indexOf(START_FRAGMENT);\n    const endIndex = rawHtml.lastIndexOf(END_FRAGMENT);\n    let htmlBefore = '';\n    let htmlAfter = '';\n\n    if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\n        htmlBefore = rawHtml.substring(0, startIndex);\n        htmlAfter = rawHtml.substring(endIndex + END_FRAGMENT.length);\n        clipboardData.html = rawHtml.substring(startIndex + START_FRAGMENT.length, endIndex);\n    } else {\n        clipboardData.html = rawHtml;\n    }\n\n    return { htmlBefore, htmlAfter };\n}\n\nfunction checkBlockElements(doc: Document): boolean {\n    const elements = toArray(doc.body.querySelectorAll('*'));\n\n    return elements.some(el => isNodeOfType(el, 'ELEMENT_NODE') && isBlockElement(el));\n}\n","import type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Redo to next undo snapshot\n * @param editor The editor to undo with\n */\nexport function redo(editor: IEditor): void {\n    editor.focus();\n\n    const manager = editor.getSnapshotsManager();\n    const snapshot = manager.move(1);\n\n    if (snapshot) {\n        editor.restoreSnapshot(snapshot);\n    }\n}\n","import type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Undo to last undo snapshot\n * @param editor The editor to undo with\n */\nexport function undo(editor: IEditor): void {\n    editor.focus();\n\n    const manager = editor.getSnapshotsManager();\n\n    if (manager.hasNewContent) {\n        editor.takeSnapshot();\n    }\n\n    const snapshot = manager.move(-1);\n\n    if (snapshot) {\n        editor.restoreSnapshot(snapshot);\n    }\n}\n","import { findClosestEntityWrapper, parseEntityFormat } from 'roosterjs-content-model-dom';\nimport type {\n    AddUndoSnapshot,\n    EntityOperationEvent,\n    Snapshot,\n    BeforeAddUndoSnapshotEvent,\n} from 'roosterjs-content-model-types';\nimport { createSnapshotSelection } from './createSnapshotSelection';\nimport { getPath } from './getPath';\n\n/**\n * @internal\n * Add an undo snapshot to current undo snapshot stack\n * @param core The EditorCore object\n * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).\n * @param entityStates @optional Entity states related to this snapshot.\n * Each entity state will cause an EntityOperation event with operation = EntityOperation.UpdateEntityState\n * when undo/redo to this snapshot\n */\nexport const addUndoSnapshot: AddUndoSnapshot = (core, canUndoByBackspace, entityStates) => {\n    const { lifecycle, physicalRoot, logicalRoot, undo } = core;\n    let snapshot: Snapshot | null = null;\n\n    if (!lifecycle.shadowEditFragment) {\n        // Give plugins the chance to add additional state to the snapshot\n        const beforeAddUndoSnapshotEvent: BeforeAddUndoSnapshotEvent = {\n            eventType: 'beforeAddUndoSnapshot',\n            additionalState: {},\n        };\n        core.api.triggerEvent(core, beforeAddUndoSnapshotEvent, false);\n\n        // Need to create snapshot selection before retrieve innerHTML since HTML can be changed during creating selection when normalize table\n        const selection = createSnapshotSelection(core);\n        const html = physicalRoot.innerHTML;\n\n        // Give plugins the chance to share entity states to include in the snapshot if the logical root is in an entity\n        if (logicalRoot !== physicalRoot) {\n            const entityWrapper = findClosestEntityWrapper(logicalRoot, core.domHelper);\n            if (!entityStates && entityWrapper) {\n                const entityFormat = parseEntityFormat(entityWrapper);\n                if (entityFormat.entityType && entityFormat.id) {\n                    const event = <EntityOperationEvent>{\n                        eventType: 'entityOperation',\n                        operation: 'snapshotEntityState',\n                        entity: {\n                            type: entityFormat.entityType,\n                            id: entityFormat.id,\n                            wrapper: entityWrapper,\n                            isReadonly: entityFormat.isReadonly,\n                        },\n                        state: undefined,\n                    };\n\n                    core.api.triggerEvent(core, event, false);\n\n                    // Copy out any entity states from the plugins\n                    if (event.state) {\n                        entityStates = [\n                            {\n                                type: entityFormat.entityType,\n                                id: entityFormat.id,\n                                state: event.state,\n                            },\n                        ];\n                    }\n                }\n            }\n        }\n\n        snapshot = {\n            html,\n            additionalState: beforeAddUndoSnapshotEvent.additionalState,\n            entityStates,\n            isDarkMode: !!lifecycle.isDarkMode,\n            selection,\n        };\n\n        if (logicalRoot !== physicalRoot) {\n            snapshot.logicalRootPath = getPath(logicalRoot, 0, physicalRoot);\n        }\n\n        undo.snapshotsManager.addSnapshot(snapshot, !!canUndoByBackspace);\n        undo.snapshotsManager.hasNewContent = false;\n    }\n\n    return snapshot;\n};\n","import { isElementOfType, isNodeOfType, moveChildNodes } from 'roosterjs-content-model-dom';\nimport type { EditorCore, SnapshotSelection } from 'roosterjs-content-model-types';\nimport { getPath } from './getPath';\n\n/**\n * @internal\n */\nexport function createSnapshotSelection(core: EditorCore): SnapshotSelection {\n    const { physicalRoot, api } = core;\n    const selection = api.getDOMSelection(core);\n\n    // Normalize tables to ensure they have TBODY element between TABLE and TR so that the selection path will include correct values\n    if (selection?.type == 'range') {\n        const { startContainer, startOffset, endContainer, endOffset } = selection.range;\n        let isDOMChanged = normalizeTableTree(startContainer, physicalRoot);\n\n        if (endContainer != startContainer) {\n            isDOMChanged = normalizeTableTree(endContainer, physicalRoot) || isDOMChanged;\n        }\n\n        if (isDOMChanged) {\n            const newRange = physicalRoot.ownerDocument.createRange();\n\n            newRange.setStart(startContainer, startOffset);\n            newRange.setEnd(endContainer, endOffset);\n            api.setDOMSelection(\n                core,\n                {\n                    type: 'range',\n                    range: newRange,\n                    isReverted: !!selection.isReverted,\n                },\n                true /*skipSelectionChangedEvent*/\n            );\n        }\n    }\n\n    switch (selection?.type) {\n        case 'image':\n            return {\n                type: 'image',\n                imageId: selection.image.id,\n            };\n\n        case 'table':\n            return {\n                type: 'table',\n                tableId: selection.table.id,\n                firstColumn: selection.firstColumn,\n                lastColumn: selection.lastColumn,\n                firstRow: selection.firstRow,\n                lastRow: selection.lastRow,\n            };\n\n        case 'range':\n            const range = selection.range;\n\n            return {\n                type: 'range',\n                start: getPath(range.startContainer, range.startOffset, physicalRoot),\n                end: getPath(range.endContainer, range.endOffset, physicalRoot),\n                isReverted: !!selection.isReverted,\n            };\n\n        default:\n            return {\n                type: 'range',\n                start: [],\n                end: [],\n                isReverted: false,\n            };\n    }\n}\n\nfunction normalizeTableTree(startNode: Node, root: Node) {\n    let node: Node | null = startNode;\n    let isDOMChanged = false;\n\n    while (node && root.contains(node)) {\n        if (isNodeOfType(node, 'ELEMENT_NODE') && isElementOfType(node, 'table')) {\n            isDOMChanged = normalizeTable(node) || isDOMChanged;\n        }\n\n        node = node.parentNode;\n    }\n\n    return isDOMChanged;\n}\n\nfunction normalizeTable(table: HTMLTableElement): boolean {\n    let isDOMChanged = false;\n    let tbody: HTMLTableSectionElement | null = null;\n\n    for (let child = table.firstChild; child; child = child.nextSibling) {\n        const tag = isNodeOfType(child, 'ELEMENT_NODE') ? child.tagName : null;\n\n        switch (tag) {\n            case 'TR':\n                if (!tbody) {\n                    tbody = table.ownerDocument.createElement('tbody');\n                    table.insertBefore(tbody, child);\n                }\n\n                tbody.appendChild(child);\n                child = tbody;\n                isDOMChanged = true;\n\n                break;\n            case 'TBODY':\n                if (tbody) {\n                    moveChildNodes(tbody, child, true /*keepExistingChildren*/);\n                    child.parentNode?.removeChild(child);\n                    child = tbody;\n                    isDOMChanged = true;\n                } else {\n                    tbody = child as HTMLTableSectionElement;\n                }\n                break;\n            default:\n                tbody = null;\n                break;\n        }\n    }\n\n    const colgroups = table.querySelectorAll('colgroup');\n    const thead = table.querySelector('thead');\n\n    if (thead) {\n        colgroups.forEach(colgroup => {\n            if (!thead.contains(colgroup)) {\n                thead.appendChild(colgroup);\n            }\n        });\n    }\n\n    return isDOMChanged;\n}\n","import { isNodeOfType } from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n *\n * Get the path of the node relative to rootNode.\n * The path of the node is an array of integer indices into the childNodes of the given node.\n *\n * The node path will be what the node path will be on a _normalized_ dom\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\n *\n * @param rootNode the node the path will be relative to\n * @param position the position to get indexes from. Follows the same semantics\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\n * If node is of type Element, it is the index of a child in that Element node.)\n */\nexport function getPath(node: Node | null, offset: number, rootNode: Node): number[] {\n    const result: number[] = [];\n    let parent: Node | null;\n\n    if (!node || !rootNode.contains(node)) {\n        return result;\n    }\n\n    if (isNodeOfType(node, 'TEXT_NODE')) {\n        parent = node.parentNode;\n\n        while (node.previousSibling && isNodeOfType(node.previousSibling, 'TEXT_NODE')) {\n            offset += node.previousSibling.nodeValue?.length || 0;\n            node = node.previousSibling;\n        }\n\n        result.unshift(offset);\n    } else {\n        parent = node;\n        node = node.childNodes[offset];\n    }\n\n    do {\n        offset = 0;\n        let isPreviousText = false;\n\n        for (let c: Node | null = parent?.firstChild || null; c && c != node; c = c.nextSibling) {\n            if (isNodeOfType(c, 'TEXT_NODE')) {\n                if (c.nodeValue?.length === 0 || isPreviousText) {\n                    continue;\n                }\n\n                isPreviousText = true;\n            } else {\n                isPreviousText = false;\n            }\n\n            offset++;\n        }\n\n        result.unshift(offset);\n        node = parent;\n        parent = parent?.parentNode || null;\n    } while (node && node != rootNode);\n\n    return result;\n}\n","import { createAriaLiveElement } from '../../utils/createAriaLiveElement';\nimport type { Announce } from 'roosterjs-content-model-types';\n\nconst DOT_STRING = '.';\n\n/**\n * @internal\n * Announce the given data\n * @param core The EditorCore object\n * @param announceData Data to announce\n */\nexport const announce: Announce = (core, announceData) => {\n    const { text, defaultStrings, formatStrings = [], ariaLiveMode = 'assertive' } = announceData;\n    const { announcerStringGetter } = core.lifecycle;\n    const template = defaultStrings && announcerStringGetter?.(defaultStrings);\n    let textToAnnounce = formatString(template || text, formatStrings);\n\n    if (!core.lifecycle.announceContainer) {\n        core.lifecycle.announceContainer = createAriaLiveElement(core.physicalRoot.ownerDocument);\n    }\n\n    if (textToAnnounce && core.lifecycle.announceContainer) {\n        const { announceContainer } = core.lifecycle;\n        if (announceContainer.ariaLive != ariaLiveMode) {\n            announceContainer.ariaLive = ariaLiveMode;\n        }\n\n        if (textToAnnounce == announceContainer.textContent) {\n            textToAnnounce += DOT_STRING;\n        }\n\n        if (announceContainer) {\n            announceContainer.textContent = textToAnnounce;\n        }\n    }\n};\n\nfunction formatString(text: string | undefined, formatStrings: string[]) {\n    if (text == undefined) {\n        return text;\n    }\n\n    text = text.replace(/\\{(\\d+)\\}/g, (_, sub: string) => {\n        const index = parseInt(sub);\n        const replace = formatStrings[index];\n        return replace ?? '';\n    });\n\n    return text;\n}\n","import { getObjectKeys } from 'roosterjs-content-model-dom';\nimport type { AttachDomEvent, PluginEvent } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Attach a DOM event to the editor content DIV\n * @param core The EditorCore object\n * @param eventName The DOM event name\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\n */\nexport const attachDomEvent: AttachDomEvent = (core, eventMap) => {\n    const disposers = getObjectKeys(eventMap || {}).map(key => {\n        const { pluginEventType, beforeDispatch, capture } = eventMap[key];\n        const eventName = key as keyof HTMLElementEventMap;\n        const onEvent = (event: HTMLElementEventMap[typeof eventName]) => {\n            if (beforeDispatch) {\n                beforeDispatch(event);\n            }\n\n            if (pluginEventType != null) {\n                core.api.triggerEvent(\n                    core,\n                    <PluginEvent>{\n                        eventType: pluginEventType,\n                        rawEvent: event,\n                    },\n                    false /*broadcast*/\n                );\n            }\n        };\n\n        core.logicalRoot.addEventListener(eventName, onEvent, { capture });\n\n        return () => {\n            core.logicalRoot.removeEventListener(eventName, onEvent, {\n                capture,\n            });\n        };\n    });\n\n    return () => disposers.forEach(disposers => disposers());\n};\n","import { addUndoSnapshot } from './addUndoSnapshot/addUndoSnapshot';\nimport { announce } from './announce/announce';\nimport { attachDomEvent } from './attachDomEvent/attachDomEvent';\nimport { createContentModel } from './createContentModel/createContentModel';\nimport { createEditorContext } from './createEditorContext/createEditorContext';\nimport { focus } from './focus/focus';\nimport { formatContentModel } from './formatContentModel/formatContentModel';\nimport { getDOMSelection } from './getDOMSelection/getDOMSelection';\nimport { getVisibleViewport } from './getVisibleViewport/getVisibleViewport';\nimport { restoreUndoSnapshot } from './restoreUndoSnapshot/restoreUndoSnapshot';\nimport { setContentModel } from './setContentModel/setContentModel';\nimport { setDOMSelection } from './setDOMSelection/setDOMSelection';\nimport { setEditorStyle } from './setEditorStyle/setEditorStyle';\nimport { setLogicalRoot } from './setLogicalRoot/setLogicalRoot';\nimport { switchShadowEdit } from './switchShadowEdit/switchShadowEdit';\nimport { triggerEvent } from './triggerEvent/triggerEvent';\nimport type { CoreApiMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Core API map for Editor\n */\nexport const coreApiMap: CoreApiMap = {\n    createContentModel: createContentModel,\n    createEditorContext: createEditorContext,\n    formatContentModel: formatContentModel,\n    setContentModel: setContentModel,\n    setLogicalRoot: setLogicalRoot,\n\n    getDOMSelection: getDOMSelection,\n    setDOMSelection: setDOMSelection,\n    focus: focus,\n\n    addUndoSnapshot: addUndoSnapshot,\n    restoreUndoSnapshot: restoreUndoSnapshot,\n\n    attachDomEvent: attachDomEvent,\n    triggerEvent: triggerEvent,\n\n    switchShadowEdit: switchShadowEdit,\n    getVisibleViewport: getVisibleViewport,\n    setEditorStyle: setEditorStyle,\n\n    announce: announce,\n};\n","import { updateCache } from '../../corePlugin/cache/updateCache';\nimport {\n    cloneModel,\n    createDomToModelContext,\n    createDomToModelContextWithConfig,\n    domToContentModel,\n} from 'roosterjs-content-model-dom';\nimport type { CreateContentModel } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create Content Model from DOM tree in this editor\n * @param core The editor core object\n * @param option The option to customize the behavior of DOM to Content Model conversion\n * @param selectionOverride When passed, use this selection range instead of current selection in editor\n */\nexport const createContentModel: CreateContentModel = (core, option, selectionOverride) => {\n    // Flush all mutations if any, so that we can get an up-to-date Content Model\n    core.cache.textMutationObserver?.flushMutations();\n    const tryGetFromCache =\n        !option || (option.tryGetFromCache && typeof option.recalculateTableSize === 'undefined');\n\n    if (!selectionOverride && tryGetFromCache) {\n        const cachedModel = core.cache.cachedModel;\n\n        if (cachedModel) {\n            // When in shadow edit, use a cloned model so we won't pollute the cached one\n            return core.lifecycle.shadowEditFragment\n                ? cloneModel(cachedModel, { includeCachedElement: true })\n                : cachedModel;\n        }\n    }\n\n    const selection =\n        selectionOverride == 'none'\n            ? undefined\n            : selectionOverride || core.api.getDOMSelection(core) || undefined;\n    const saveIndex = !option && !selectionOverride;\n    const editorContext = core.api.createEditorContext(core, saveIndex);\n\n    editorContext.recalculateTableSize = option?.recalculateTableSize;\n\n    const settings = core.environment.domToModelSettings;\n    const domToModelContext = option\n        ? createDomToModelContext(editorContext, settings.builtIn, settings.customized, option)\n        : createDomToModelContextWithConfig(settings.calculated, editorContext);\n\n    if (selection) {\n        domToModelContext.selection = selection;\n    }\n\n    const model = domToContentModel(core.logicalRoot, domToModelContext);\n\n    if (saveIndex) {\n        updateCache(core.cache, model, selection);\n    }\n\n    return model;\n};\n","import { getRootComputedStyleForContext } from './getRootComputedStyleForContext';\nimport type { EditorContext, CreateEditorContext } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create a EditorContext object used by ContentModel API\n */\nexport const createEditorContext: CreateEditorContext = (core, saveIndex) => {\n    const { lifecycle, format, darkColorHandler, logicalRoot, cache, domHelper } = core;\n\n    saveIndex = saveIndex && !core.lifecycle.shadowEditFragment;\n\n    const context: EditorContext = {\n        isDarkMode: lifecycle.isDarkMode,\n        defaultFormat: format.defaultFormat,\n        pendingFormat: format.pendingFormat ?? undefined,\n        darkColorHandler: darkColorHandler,\n        addDelimiterForEntity: true,\n        allowCacheElement: true,\n        allowCacheListItem: !!core.experimentalFeatures?.includes('CacheList'),\n        domIndexer: saveIndex ? cache.domIndexer : undefined,\n        zoomScale: domHelper.calculateZoomScale(),\n        experimentalFeatures: core.experimentalFeatures ?? [],\n        paragraphMap: core.cache.paragraphMap,\n        editorViewWidth: domHelper.getClientWidth(),\n        ...getRootComputedStyleForContext(logicalRoot.ownerDocument),\n    };\n\n    if (core.domHelper.isRightToLeft()) {\n        context.isRootRtl = true;\n    }\n\n    return context;\n};\n","import { parseValueWithUnit } from 'roosterjs-content-model-dom';\nimport type { EditorContext } from 'roosterjs-content-model-types';\n\nconst DefaultRootFontSize = 16;\n\n/**\n * @internal\n */\nexport function getRootComputedStyleForContext(\n    document: Document\n): Pick<EditorContext, 'rootFontSize'> {\n    const rootComputedStyle = document.defaultView?.getComputedStyle(document.documentElement);\n    return { rootFontSize: parseValueWithUnit(rootComputedStyle?.fontSize) || DefaultRootFontSize };\n}\n","import type { Focus } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Focus to editor. If there is a cached selection range, use it as current selection\n * @param core The EditorCore object\n */\nexport const focus: Focus = core => {\n    if (!core.lifecycle.shadowEditFragment) {\n        const { api, domHelper, selection } = core;\n\n        if (!domHelper.hasFocus() && selection.selection?.type == 'range') {\n            api.setDOMSelection(core, selection.selection, true /*skipSelectionChangedEvent*/);\n        }\n\n        // fallback, in case editor still have no focus\n        if (!domHelper.hasFocus()) {\n            core.logicalRoot.focus();\n        }\n    }\n};\n","import { ChangeSource } from 'roosterjs-content-model-dom';\nimport { scrollCaretIntoView } from './scrollCaretIntoView';\nimport type {\n    ChangedEntity,\n    ContentChangedEvent,\n    DOMSelection,\n    FormatContentModel,\n    FormatContentModelContext,\n    EditorCore,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * The general API to do format change with Content Model\n * It will grab a Content Model for current editor content, and invoke a callback function\n * to do format change. Then according to the return value, write back the modified content model into editor.\n * If there is cached model, it will be used and updated.\n * @param core The EditorCore object\n * @param formatter Formatter function, see ContentModelFormatter\n * @param options More options, see FormatContentModelOptions\n */\nexport const formatContentModel: FormatContentModel = (\n    core,\n    formatter,\n    options,\n    domToModelOptions\n) => {\n    const { onNodeCreated, rawEvent, selectionOverride, scrollCaretIntoView: scroll } =\n        options || {};\n    const model = core.api.createContentModel(core, domToModelOptions, selectionOverride);\n    const context: FormatContentModelContext = {\n        newEntities: [],\n        deletedEntities: [],\n        rawEvent,\n        newImages: [],\n        paragraphIndexer: core.cache.paragraphMap,\n    };\n\n    const hasFocus = core.domHelper.hasFocus();\n\n    const changed = formatter(model, context);\n    const { skipUndoSnapshot, clearModelCache, entityStates, canUndoByBackspace } = context;\n\n    if (changed) {\n        const isNested = core.undo.isNested;\n        const shouldAddSnapshot =\n            (!skipUndoSnapshot || skipUndoSnapshot == 'DoNotSkip') && !isNested;\n        const shouldMarkNewContent =\n            (skipUndoSnapshot === true || skipUndoSnapshot == 'MarkNewContent') && !isNested;\n        let selection: DOMSelection | undefined;\n\n        if (shouldAddSnapshot) {\n            core.undo.isNested = true;\n\n            core.api.addUndoSnapshot(core, !!canUndoByBackspace, entityStates);\n        }\n\n        try {\n            handleImages(core, context);\n\n            selection =\n                core.api.setContentModel(\n                    core,\n                    model,\n                    hasFocus ? undefined : { ignoreSelection: true }, // If editor did not have focus before format, do not set focus after format\n                    onNodeCreated\n                ) ?? undefined;\n\n            handlePendingFormat(core, context, selection);\n\n            if (scroll && (selection?.type == 'range' || selection?.type == 'image')) {\n                scrollCaretIntoView(core, selection);\n            }\n\n            const eventData: ContentChangedEvent = {\n                eventType: 'contentChanged',\n                contentModel: clearModelCache ? undefined : model,\n                selection: clearModelCache ? undefined : selection,\n                source: options?.changeSource || ChangeSource.Format,\n                data: options?.getChangeData?.(),\n                formatApiName: options?.apiName,\n                changedEntities: getChangedEntities(context, rawEvent),\n                skipUndo:\n                    !(shouldMarkNewContent || shouldAddSnapshot) ||\n                    options?.changeSource == ChangeSource.Keyboard, // Keyboard changes will be handled separately in undo plugin, so we need to skip handling it again\n            };\n\n            core.api.triggerEvent(core, eventData, true /*broadcast*/);\n\n            if (canUndoByBackspace && selection?.type == 'range') {\n                core.undo.autoCompleteInsertPoint = {\n                    node: selection.range.startContainer,\n                    offset: selection.range.startOffset,\n                };\n            }\n\n            if (shouldAddSnapshot) {\n                core.api.addUndoSnapshot(core, false /*canUndoByBackspace*/, entityStates);\n            }\n\n            if (shouldMarkNewContent) {\n                core.undo.snapshotsManager.hasNewContent = true;\n            }\n        } finally {\n            if (!isNested) {\n                core.undo.isNested = false;\n            }\n        }\n    } else {\n        if (clearModelCache) {\n            core.cache.cachedModel = undefined;\n            core.cache.cachedSelection = undefined;\n        }\n\n        handlePendingFormat(core, context, core.api.getDOMSelection(core));\n    }\n\n    if (context.announceData) {\n        core.api.announce(core, context.announceData);\n    }\n};\n\nfunction handleImages(core: EditorCore, context: FormatContentModelContext) {\n    if (context.newImages.length > 0) {\n        const width = core.domHelper.getClientWidth();\n        const minMaxImageSize = 10;\n        const maxWidth = Math.max(width, minMaxImageSize);\n        context.newImages.forEach(image => {\n            image.format.maxWidth = `${maxWidth}px`;\n        });\n    }\n}\n\nfunction handlePendingFormat(\n    core: EditorCore,\n    context: FormatContentModelContext,\n    selection?: DOMSelection | null\n) {\n    const pendingFormat =\n        context.newPendingFormat == 'preserve'\n            ? core.format.pendingFormat?.format\n            : context.newPendingFormat;\n    const pendingParagraphFormat =\n        context.newPendingParagraphFormat == 'preserve'\n            ? core.format.pendingFormat?.paragraphFormat\n            : context.newPendingParagraphFormat;\n\n    if (\n        (pendingFormat || pendingParagraphFormat) &&\n        selection?.type == 'range' &&\n        selection.range.collapsed\n    ) {\n        core.format.pendingFormat = {\n            format: pendingFormat ? { ...pendingFormat } : undefined,\n            paragraphFormat: pendingParagraphFormat ? { ...pendingParagraphFormat } : undefined,\n            insertPoint: {\n                node: selection.range.startContainer,\n                offset: selection.range.startOffset,\n            },\n        };\n    }\n}\n\nfunction getChangedEntities(\n    context: FormatContentModelContext,\n    rawEvent?: Event\n): ChangedEntity[] | undefined {\n    return context.autoDetectChangedEntities\n        ? undefined\n        : context.newEntities\n              .map(\n                  (entity): ChangedEntity => ({\n                      entity,\n                      operation: 'newEntity',\n                      rawEvent,\n                  })\n              )\n              .concat(\n                  context.deletedEntities.map(entry => ({\n                      entity: entry.entity,\n                      operation: entry.operation,\n                      rawEvent,\n                  }))\n              );\n}\n","import { getDOMInsertPointRect, scrollRectIntoView } from 'roosterjs-content-model-dom';\nimport type { EditorCore, ImageSelection, RangeSelection } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function scrollCaretIntoView(core: EditorCore, selection: RangeSelection | ImageSelection) {\n    const rect = getDOMInsertPointRect(\n        core.physicalRoot.ownerDocument,\n        selection.type == 'image'\n            ? {\n                  node: selection.image,\n                  offset: 0,\n              }\n            : selection.isReverted\n            ? {\n                  node: selection.range.startContainer,\n                  offset: selection.range.startOffset,\n              }\n            : {\n                  node: selection.range.endContainer,\n                  offset: selection.range.endOffset,\n              }\n    );\n    const visibleRect = core.api.getVisibleViewport(core);\n    const scrollContainer = core.domEvent.scrollContainer;\n\n    if (rect && visibleRect) {\n        scrollRectIntoView(scrollContainer, visibleRect, core.domHelper, rect);\n    }\n}\n","import type { DOMSelection, GetDOMSelection, EditorCore } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const getDOMSelection: GetDOMSelection = core => {\n    if (core.lifecycle.shadowEditFragment) {\n        return null;\n    } else {\n        const selection = core.selection.selection;\n\n        return selection && (selection.type != 'range' || !core.domHelper.hasFocus())\n            ? selection\n            : getNewSelection(core);\n    }\n};\n\nfunction getNewSelection(core: EditorCore): DOMSelection | null {\n    const selection = core.logicalRoot.ownerDocument.defaultView?.getSelection();\n    const range = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;\n\n    return selection && range && core.logicalRoot.contains(range.commonAncestorContainer)\n        ? {\n              type: 'range',\n              range,\n              isReverted:\n                  selection.focusNode != range.endContainer ||\n                  selection.focusOffset != range.endOffset,\n          }\n        : null;\n}\n","import { normalizeRect } from 'roosterjs-content-model-dom';\nimport type { GetVisibleViewport, Rect } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Retrieves the rect of the visible viewport of the editor.\n * @param core The EditorCore object\n */\nexport const getVisibleViewport: GetVisibleViewport = core => {\n    const scrollContainer = core.domEvent.scrollContainer;\n\n    return getIntersectedRect(\n        scrollContainer == core.physicalRoot\n            ? [scrollContainer]\n            : [scrollContainer, core.physicalRoot]\n    );\n};\n\n/**\n * Get the intersected Rect of elements provided\n *\n * @example\n * The result of the following Elements Rects would be:\n    {\n        top: Element2.top,\n        bottom: Element1.bottom,\n        left: Element2.left,\n        right: Element2.right\n    }\n    +-------------------------+\n    | Element 1               |\n    |   +-----------------+   |\n    |   | Element2        |   |\n    |   |                 |   |\n    |   |                 |   |\n    +-------------------------+\n        |                 |\n        +-----------------+\n\n * @param elements Elements to use.\n * @param additionalRects additional rects to use\n * @returns If the Rect is valid return the rect, if not, return null.\n */\nfunction getIntersectedRect(elements: HTMLElement[], additionalRects: Rect[] = []): Rect | null {\n    const rects = elements\n        .map(element => normalizeRect(element.getBoundingClientRect()))\n        .concat(additionalRects)\n        .filter((rect: Rect | null): rect is Rect => !!rect);\n\n    const result: Rect = {\n        top: Math.max(...rects.map(r => r.top)),\n        bottom: Math.min(...rects.map(r => r.bottom)),\n        left: Math.max(...rects.map(r => r.left)),\n        right: Math.min(...rects.map(r => r.right)),\n    };\n\n    return result.top < result.bottom && result.left < result.right ? result : null;\n}\n","import { isNodeOfType } from 'roosterjs-content-model-dom';\nimport type { DOMInsertPoint } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n *\n * Use with paths generated by `getPath`.\n */\nexport function getPositionFromPath(node: Node, path: number[]): DOMInsertPoint {\n    // Iterate with a for loop to avoid mutating the passed in element path stack\n    // or needing to copy it.\n    let offset: number = 0;\n\n    for (let i = 0; i < path.length; i++) {\n        offset = path[i];\n\n        if (\n            i < path.length - 1 &&\n            node &&\n            isNodeOfType(node, 'ELEMENT_NODE') &&\n            node.childNodes.length > offset\n        ) {\n            node = node.childNodes[offset];\n        } else {\n            break;\n        }\n    }\n\n    return { node, offset };\n}\n","import { transformColor } from 'roosterjs-content-model-dom';\nimport type { EditorCore, Snapshot } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function restoreSnapshotColors(core: EditorCore, snapshot: Snapshot) {\n    const isDarkMode = core.lifecycle.isDarkMode;\n\n    core.darkColorHandler.updateKnownColor(isDarkMode); // Pass no parameter to force update all colors\n\n    if (!!snapshot.isDarkMode != !!isDarkMode) {\n        transformColor(\n            core.physicalRoot,\n            false /*includeSelf*/,\n            isDarkMode ? 'lightToDark' : 'darkToLight',\n            core.darkColorHandler,\n            {\n                tableBorders: core.experimentalFeatures.indexOf('TransformTableBorderColors') > -1,\n            }\n        );\n    }\n}\n","import {\n    getAllEntityWrappers,\n    isBlockEntityContainer,\n    isEntityDelimiter,\n    isEntityElement,\n    isNodeOfType,\n    parseEntityFormat,\n    reuseCachedElement,\n} from 'roosterjs-content-model-dom';\nimport type { Snapshot, EditorCore, KnownEntityItem } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function restoreSnapshotHTML(core: EditorCore, snapshot: Snapshot) {\n    const {\n        physicalRoot,\n        entity: { entityMap },\n    } = core;\n    let refNode: Node | null = physicalRoot.firstChild;\n\n    const body = core.domCreator.htmlToDOM(snapshot.html).body;\n\n    for (let currentNode = body.firstChild; currentNode; ) {\n        const next = currentNode.nextSibling;\n        const originalEntityElement = tryGetEntityElement(entityMap, currentNode);\n\n        if (originalEntityElement) {\n            // After restoring the snapshot, we need to clear the delimiter indexes since cached model will be cleared\n            if (isBlockEntityContainer(originalEntityElement)) {\n                for (let node = originalEntityElement.firstChild; node; node = node.nextSibling) {\n                    if (isNodeOfType(node, 'ELEMENT_NODE') && isEntityDelimiter(node)) {\n                        core.cache.domIndexer?.clearIndex(node);\n                    }\n                }\n            }\n\n            refNode = reuseCachedElement(physicalRoot, originalEntityElement, refNode);\n        } else {\n            physicalRoot.insertBefore(currentNode, refNode);\n\n            if (isNodeOfType(currentNode, 'ELEMENT_NODE')) {\n                const childEntities = getAllEntityWrappers(currentNode);\n\n                childEntities.forEach(element => {\n                    const wrapper = tryGetEntityElement(entityMap, element);\n\n                    if (wrapper) {\n                        if (wrapper == refNode) {\n                            // In case the node we are moving is just the ref node,\n                            // We create a temporary clone and insert it before the refNode, and use this cloned node as refNode\n                            // After replaceChild(), the original refNode will be moved away\n                            const markerNode = wrapper.cloneNode();\n\n                            physicalRoot.insertBefore(markerNode, refNode);\n                            refNode = markerNode;\n                        }\n\n                        element.parentNode?.replaceChild(wrapper, element);\n                    }\n                });\n            }\n        }\n        currentNode = next;\n    }\n\n    while (refNode) {\n        const next = refNode.nextSibling;\n\n        refNode.parentNode?.removeChild(refNode);\n        refNode = next;\n    }\n}\n\nfunction tryGetEntityElement(\n    entityMap: Record<string, KnownEntityItem>,\n    node: Node\n): HTMLElement | null {\n    let result: HTMLElement | null = null;\n\n    if (isNodeOfType(node, 'ELEMENT_NODE')) {\n        if (isEntityElement(node)) {\n            const format = parseEntityFormat(node);\n\n            result = getEntityWrapperForReuse(entityMap, format.id);\n        } else if (isBlockEntityContainer(node)) {\n            result = tryGetEntityFromContainer(node, entityMap);\n        }\n    }\n\n    return result;\n}\n\nfunction tryGetEntityFromContainer(\n    element: HTMLElement,\n    entityMap: Record<string, KnownEntityItem>\n): HTMLElement | null {\n    for (let node = element.firstChild; node; node = node.nextSibling) {\n        if (isEntityElement(node) && isNodeOfType(node, 'ELEMENT_NODE')) {\n            const format = parseEntityFormat(node);\n            const parent = getEntityWrapperForReuse(entityMap, format.id)?.parentElement;\n\n            return isNodeOfType(parent, 'ELEMENT_NODE') && isBlockEntityContainer(parent)\n                ? parent\n                : null;\n        }\n    }\n\n    return null;\n}\n\nfunction getEntityWrapperForReuse(\n    entityMap: Record<string, KnownEntityItem>,\n    entityId: string | undefined\n): HTMLElement | null {\n    const entry = entityId ? entityMap[entityId] : undefined;\n\n    return entry?.canPersist ? entry.element : null;\n}\n","import type { EditorCore, Snapshot } from 'roosterjs-content-model-types';\nimport { getPositionFromPath } from './getPositionFromPath';\n\n/**\n * @internal\n */\nexport function restoreSnapshotLogicalRoot(core: EditorCore, snapshot: Snapshot) {\n    if (snapshot.logicalRootPath && snapshot.logicalRootPath.length > 0) {\n        const restoredLogicalRoot = getPositionFromPath(core.physicalRoot, snapshot.logicalRootPath)\n            .node as HTMLDivElement;\n        if (restoredLogicalRoot !== core.logicalRoot) {\n            core.api.setLogicalRoot(core, restoredLogicalRoot);\n        }\n    }\n}\n","import { getPositionFromPath } from './getPositionFromPath';\nimport { getSafeIdSelector } from 'roosterjs-content-model-dom';\nimport type { DOMSelection, EditorCore, Snapshot } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function restoreSnapshotSelection(core: EditorCore, snapshot: Snapshot) {\n    const snapshotSelection = snapshot.selection;\n    const { physicalRoot } = core;\n    let domSelection: DOMSelection | null = null;\n\n    try {\n        // might fail if the selection is not present, but we do not want to crash\n        if (snapshotSelection) {\n            switch (snapshotSelection.type) {\n                case 'range':\n                    const startPos = getPositionFromPath(physicalRoot, snapshotSelection.start);\n                    const endPos = getPositionFromPath(physicalRoot, snapshotSelection.end);\n                    const range = physicalRoot.ownerDocument.createRange();\n\n                    range.setStart(startPos.node, startPos.offset);\n                    range.setEnd(endPos.node, endPos.offset);\n\n                    domSelection = {\n                        type: 'range',\n                        range,\n                        isReverted: snapshotSelection.isReverted,\n                    };\n                    break;\n                case 'table':\n                    const table = physicalRoot.querySelector(\n                        getSafeIdSelector(snapshotSelection.tableId)\n                    ) as HTMLTableElement;\n\n                    if (table) {\n                        domSelection = {\n                            type: 'table',\n                            table: table,\n                            firstColumn: snapshotSelection.firstColumn,\n                            firstRow: snapshotSelection.firstRow,\n                            lastColumn: snapshotSelection.lastColumn,\n                            lastRow: snapshotSelection.lastRow,\n                        };\n                    }\n                    break;\n                case 'image':\n                    const image = physicalRoot.querySelector(\n                        getSafeIdSelector(snapshotSelection.imageId)\n                    ) as HTMLImageElement;\n\n                    if (image) {\n                        domSelection = {\n                            type: 'image',\n                            image: image,\n                        };\n                    }\n                    break;\n            }\n        }\n\n        if (domSelection) {\n            core.api.setDOMSelection(core, domSelection);\n        }\n    } catch {}\n}\n","import { ChangeSource } from 'roosterjs-content-model-dom';\nimport { restoreSnapshotColors } from './restoreSnapshotColors';\nimport { restoreSnapshotHTML } from './restoreSnapshotHTML';\nimport { restoreSnapshotLogicalRoot } from './restoreSnapshotLogicalRoot';\nimport { restoreSnapshotSelection } from './restoreSnapshotSelection';\nimport type { ContentChangedEvent, RestoreUndoSnapshot } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Restore an undo snapshot into editor\n * @param core The editor core object\n * @param step Steps to move, can be 0, positive or negative\n */\nexport const restoreUndoSnapshot: RestoreUndoSnapshot = (core, snapshot) => {\n    core.api.triggerEvent(\n        core,\n        {\n            eventType: 'beforeSetContent',\n            newContent: snapshot.html,\n        },\n        true /*broadcast*/\n    );\n\n    try {\n        core.undo.isRestoring = true;\n\n        // Force clear logical root before restoring snapshot, so the whole editor is editable.\n        // Without changing logical root, browser may want to maintain the scroll position of current logical root,\n        // which may cause the editor to scroll to a wrong position after content is changed.\n        core.api.setLogicalRoot(core, null /* logicalRoot */);\n\n        restoreSnapshotHTML(core, snapshot);\n        restoreSnapshotLogicalRoot(core, snapshot);\n        restoreSnapshotSelection(core, snapshot);\n        restoreSnapshotColors(core, snapshot);\n\n        const event: ContentChangedEvent = {\n            eventType: 'contentChanged',\n            additionalState: snapshot.additionalState,\n            entityStates: snapshot.entityStates,\n            source: ChangeSource.SetContent,\n        };\n\n        core.api.triggerEvent(core, event, false /*broadcast*/);\n    } finally {\n        core.undo.isRestoring = false;\n    }\n};\n","import { updateCache } from '../../corePlugin/cache/updateCache';\nimport {\n    contentModelToDom,\n    createModelToDomContext,\n    createModelToDomContextWithConfig,\n} from 'roosterjs-content-model-dom';\nimport type { SetContentModel } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Set content with content model\n * @param core The editor core object\n * @param model The content model to set\n * @param option Additional options to customize the behavior of Content Model to DOM conversion\n * @param onNodeCreated An optional callback that will be called when a DOM node is created\n * @param isInitializing True means editor is being initialized then it will save modification nodes onto\n * lifecycleState instead of triggering events, false means other cases\n */\nexport const setContentModel: SetContentModel = (\n    core,\n    model,\n    option,\n    onNodeCreated,\n    isInitializing\n) => {\n    const editorContext = core.api.createEditorContext(core, true /*saveIndex*/);\n    const modelToDomContext = option\n        ? createModelToDomContext(\n              editorContext,\n              core.environment.modelToDomSettings.builtIn,\n              core.environment.modelToDomSettings.customized,\n              option\n          )\n        : createModelToDomContextWithConfig(\n              core.environment.modelToDomSettings.calculated,\n              editorContext\n          );\n\n    modelToDomContext.onNodeCreated = onNodeCreated;\n\n    core.onFixUpModel?.(model);\n\n    const selection = contentModelToDom(\n        core.logicalRoot.ownerDocument,\n        core.logicalRoot,\n        model,\n        modelToDomContext\n    );\n\n    if (!core.lifecycle.shadowEditFragment) {\n        // Clear pending mutations since we will use our latest model object to replace existing cache\n        core.cache.textMutationObserver?.flushMutations(true /*ignoreMutations*/);\n\n        updateCache(core.cache, model, selection);\n\n        if (!option?.ignoreSelection && selection) {\n            core.api.setDOMSelection(core, selection);\n        } else {\n            core.selection.selection = selection;\n        }\n    }\n\n    if (isInitializing) {\n        // When initialize, we should not trigger event until all plugins are initialized, so put these node in lifecycle state temporarily\n        core.lifecycle.rewriteFromModel = modelToDomContext.rewriteFromModel;\n    } else {\n        // Otherwise, trigger RewriteFromModel event immediately\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: 'rewriteFromModel',\n                ...modelToDomContext.rewriteFromModel,\n            },\n            true /*broadcast*/\n        );\n    }\n\n    return selection;\n};\n","import { areSameRanges } from '../../corePlugin/cache/areSameSelections';\n\n/**\n * @internal\n */\nexport function addRangeToSelection(doc: Document, range: Range, isReverted: boolean = false) {\n    const selection = doc.defaultView?.getSelection();\n\n    if (selection) {\n        const currentRange = selection.rangeCount > 0 && selection.getRangeAt(0);\n        if (currentRange && areSameRanges(currentRange, range)) {\n            return;\n        }\n        selection.removeAllRanges();\n\n        if (!isReverted) {\n            selection.addRange(range);\n        } else {\n            selection.setBaseAndExtent(\n                range.endContainer,\n                range.endOffset,\n                range.startContainer,\n                range.startOffset\n            );\n        }\n    }\n}\n","import type { ParsedTable, TableCellCoordinate } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Try to find the last logic cell of a merged table cell\n * @param parsedTable The parsed table\n * @param row Row index\n * @param col Column index\n */\nexport function findLastedCoInMergedCell(\n    parsedTable: ParsedTable,\n    coordinate: TableCellCoordinate\n): TableCellCoordinate | null {\n    let { row, col } = coordinate;\n\n    while (\n        row >= 0 &&\n        col >= 0 &&\n        row < parsedTable.length &&\n        col < (parsedTable[row]?.length ?? 0)\n    ) {\n        const right = parsedTable[row]?.[col + 1];\n        const below = parsedTable[row + 1]?.[col];\n\n        if (right == 'spanLeft' || right == 'spanBoth') {\n            col++;\n        } else if (below == 'spanTop' || below == 'spanBoth') {\n            row++;\n        } else {\n            return { row, col };\n        }\n    }\n    return null;\n}\n","import type { ParsedTable, TableCellCoordinate } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport interface TableCellCoordinateWithCell extends TableCellCoordinate {\n    cell: HTMLTableCellElement;\n}\n\n/**\n * @internal\n * Try to find a TD/TH element from the given row and col number from the given parsed table\n * @param parsedTable The parsed table\n * @param row Row index\n * @param col Column index\n * @param findLast True to find last merged cell instead of the first cell\n */\nexport function findTableCellElement(\n    parsedTable: ParsedTable,\n    coordinate: TableCellCoordinate\n): TableCellCoordinateWithCell | null {\n    let { row, col } = coordinate;\n\n    while (\n        row >= 0 &&\n        col >= 0 &&\n        row < parsedTable.length &&\n        col < (parsedTable[row]?.length ?? 0)\n    ) {\n        const cell = parsedTable[row]?.[col];\n\n        if (!cell) {\n            break;\n        } else if (typeof cell == 'object') {\n            return { cell, row, col };\n        } else if (cell == 'spanLeft' || cell == 'spanBoth') {\n            col--;\n        } else {\n            row--;\n        }\n    }\n    return null;\n}\n","import { addRangeToSelection } from './addRangeToSelection';\nimport { areSameSelections } from '../../corePlugin/cache/areSameSelections';\nimport { ensureUniqueId } from '../setEditorStyle/ensureUniqueId';\nimport { findLastedCoInMergedCell } from './findLastedCoInMergedCell';\nimport { findTableCellElement } from './findTableCellElement';\nimport { toggleCaret } from './toggleCaret';\nimport {\n    getSafeIdSelector,\n    isNodeOfType,\n    parseTableCells,\n    toArray,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ParsedTable,\n    SelectionChangedEvent,\n    SetDOMSelection,\n    TableCellCoordinate,\n} from 'roosterjs-content-model-types';\n\nconst DOM_SELECTION_CSS_KEY = '_DOMSelection';\nconst HIDE_SELECTION_CSS_KEY = '_DOMSelectionHideSelection';\nconst IMAGE_ID = 'image';\nconst TABLE_ID = 'table';\nconst TRANSPARENT_SELECTION_CSS_RULE = 'background-color: transparent !important;';\nconst SELECTION_SELECTOR = '*::selection';\nconst DEFAULT_SELECTION_BORDER_COLOR = '#DB626C';\n\n/**\n * @internal\n */\nexport const setDOMSelection: SetDOMSelection = (core, selection, skipSelectionChangedEvent) => {\n    const existingSelection = core.api.getDOMSelection(core);\n\n    if (existingSelection && selection && areSameSelections(existingSelection, selection)) {\n        return;\n    }\n\n    // We are applying a new selection, so we don't need to apply cached selection in DOMEventPlugin.\n    // Set skipReselectOnFocus to skip this behavior\n    const skipReselectOnFocus = core.selection.skipReselectOnFocus;\n\n    const doc = core.physicalRoot.ownerDocument;\n    const isDarkMode = core.lifecycle.isDarkMode;\n    core.selection.skipReselectOnFocus = true;\n    core.api.setEditorStyle(core, DOM_SELECTION_CSS_KEY, null /*cssRule*/);\n    core.api.setEditorStyle(core, HIDE_SELECTION_CSS_KEY, null /*cssRule*/);\n\n    toggleCaret(core, false /* hide */);\n\n    try {\n        switch (selection?.type) {\n            case 'image':\n                const image = selection.image;\n\n                core.selection.selection = selection;\n\n                const imageSelectionColor = isDarkMode\n                    ? core.selection.imageSelectionBorderColorDark\n                    : core.selection.imageSelectionBorderColor;\n\n                core.api.setEditorStyle(\n                    core,\n                    DOM_SELECTION_CSS_KEY,\n                    `outline-style:solid!important; outline-color:${\n                        imageSelectionColor || DEFAULT_SELECTION_BORDER_COLOR\n                    }!important;`,\n                    [getSafeIdSelector(ensureUniqueId(image, IMAGE_ID))]\n                );\n                core.api.setEditorStyle(\n                    core,\n                    HIDE_SELECTION_CSS_KEY,\n                    TRANSPARENT_SELECTION_CSS_RULE,\n                    [SELECTION_SELECTOR]\n                );\n\n                setRangeSelection(doc, image, false /* collapse */);\n                break;\n            case 'table':\n                const { table, firstColumn, firstRow, lastColumn, lastRow } = selection;\n                const parsedTable = parseTableCells(selection.table);\n                let firstCell = {\n                    row: Math.min(firstRow, lastRow),\n                    col: Math.min(firstColumn, lastColumn),\n                    cell: <HTMLTableCellElement | null>null,\n                };\n                let lastCell = {\n                    row: Math.max(firstRow, lastRow),\n                    col: Math.max(firstColumn, lastColumn),\n                };\n\n                firstCell = findTableCellElement(parsedTable, firstCell) || firstCell;\n                lastCell = findLastedCoInMergedCell(parsedTable, lastCell) || lastCell;\n\n                if (\n                    isNaN(firstCell.row) ||\n                    isNaN(firstCell.col) ||\n                    isNaN(lastCell.row) ||\n                    isNaN(lastCell.col)\n                ) {\n                    return;\n                }\n\n                selection = {\n                    type: 'table',\n                    table,\n                    firstRow: firstCell.row,\n                    firstColumn: firstCell.col,\n                    lastRow: lastCell.row,\n                    lastColumn: lastCell.col,\n                    tableSelectionInfo: selection.tableSelectionInfo,\n                };\n\n                const tableId = ensureUniqueId(table, TABLE_ID);\n                const tableSelector = getSafeIdSelector(tableId);\n\n                const tableSelectors =\n                    firstCell.row == 0 &&\n                    firstCell.col == 0 &&\n                    lastCell.row == parsedTable.length - 1 &&\n                    lastCell.col == (parsedTable[lastCell.row]?.length ?? 0) - 1\n                        ? [tableSelector, `${tableSelector} *`]\n                        : handleTableSelected(\n                              parsedTable,\n                              tableSelector,\n                              table,\n                              firstCell,\n                              lastCell\n                          );\n\n                core.selection.selection = selection;\n\n                const tableSelectionColor = isDarkMode\n                    ? core.selection.tableCellSelectionBackgroundColorDark\n                    : core.selection.tableCellSelectionBackgroundColor;\n                core.api.setEditorStyle(\n                    core,\n                    DOM_SELECTION_CSS_KEY,\n                    `background-color:${tableSelectionColor}!important;`,\n                    tableSelectors\n                );\n                core.api.setEditorStyle(\n                    core,\n                    HIDE_SELECTION_CSS_KEY,\n                    TRANSPARENT_SELECTION_CSS_RULE,\n                    [SELECTION_SELECTOR]\n                );\n\n                toggleCaret(core, true /* hide */);\n\n                const nodeToSelect = firstCell.cell?.firstElementChild || firstCell.cell;\n\n                if (nodeToSelect) {\n                    setRangeSelection(\n                        doc,\n                        (nodeToSelect as HTMLElement) || undefined,\n                        true /* collapse */\n                    );\n                }\n\n                break;\n            case 'range':\n                addRangeToSelection(doc, selection.range, selection.isReverted);\n\n                core.selection.selection = core.domHelper.hasFocus() ? null : selection;\n                break;\n\n            default:\n                core.selection.selection = null;\n                break;\n        }\n    } finally {\n        core.selection.skipReselectOnFocus = skipReselectOnFocus;\n    }\n\n    if (!skipSelectionChangedEvent) {\n        const eventData: SelectionChangedEvent = {\n            eventType: 'selectionChanged',\n            newSelection: selection,\n        };\n\n        core.api.triggerEvent(core, eventData, true /*broadcast*/);\n    }\n};\n\nfunction handleTableSelected(\n    parsedTable: ParsedTable,\n    tableSelector: string,\n    table: HTMLTableElement,\n    firstCell: TableCellCoordinate,\n    lastCell: TableCellCoordinate\n) {\n    const selectors: string[] = [];\n\n    // Get whether table has thead, tbody or tfoot, then Set the start and end of each of the table children,\n    // so we can build the selector according the element between the table and the row.\n    let cont = 0;\n    const indexes = toArray(table.childNodes)\n        .filter(\n            (node): node is HTMLTableSectionElement =>\n                ['THEAD', 'TBODY', 'TFOOT'].indexOf(\n                    isNodeOfType(node, 'ELEMENT_NODE') ? node.tagName : ''\n                ) > -1\n        )\n        .map(node => {\n            const result = {\n                el: node.tagName,\n                start: cont,\n                end: node.childNodes.length + cont,\n            };\n\n            cont = result.end;\n            return result;\n        });\n\n    parsedTable.forEach((row, rowIndex) => {\n        let tdCount = 0;\n\n        //Get current TBODY/THEAD/TFOOT\n        const midElement = indexes.filter(ind => ind.start <= rowIndex && ind.end > rowIndex)[0];\n        const middleElSelector = midElement ? '>' + midElement.el + '>' : '>';\n        const currentRow =\n            midElement && rowIndex + 1 >= midElement.start\n                ? rowIndex + 1 - midElement.start\n                : rowIndex + 1;\n\n        for (let cellIndex = 0; cellIndex < row.length; cellIndex++) {\n            const cell = row[cellIndex];\n\n            if (typeof cell == 'object') {\n                tdCount++;\n\n                if (\n                    rowIndex >= firstCell.row &&\n                    rowIndex <= lastCell.row &&\n                    cellIndex >= firstCell.col &&\n                    cellIndex <= lastCell.col\n                ) {\n                    const selector = `${tableSelector}${middleElSelector} tr:nth-child(${currentRow})>${cell.tagName}:nth-child(${tdCount})`;\n\n                    selectors.push(selector, selector + ' *');\n                }\n            }\n        }\n    });\n\n    return selectors;\n}\n\nfunction setRangeSelection(doc: Document, element: HTMLElement | undefined, collapse: boolean) {\n    if (element && doc.contains(element)) {\n        const range = doc.createRange();\n        let isReverted: boolean | undefined = undefined;\n\n        range.selectNode(element);\n        if (collapse) {\n            range.collapse();\n        } else {\n            const selection = doc.defaultView?.getSelection();\n            const range = selection && selection.rangeCount > 0 && selection.getRangeAt(0);\n            if (selection && range) {\n                isReverted =\n                    selection.focusNode != range.endContainer ||\n                    selection.focusOffset != range.endOffset;\n            }\n        }\n\n        addRangeToSelection(doc, range, isReverted);\n    }\n}\n","import type { EditorCore } from 'roosterjs-content-model-types';\n\nconst CARET_CSS_RULE = 'caret-color: transparent';\nconst HIDE_CURSOR_CSS_KEY = '_DOMSelectionHideCursor';\n\n/**\n * @internal Show/Hide caret in editor\n * @param core The editor core\n * @param isHiding True to hide caret, false to show caret\n */\nexport function toggleCaret(core: EditorCore, isHiding: boolean) {\n    core.api.setEditorStyle(core, HIDE_CURSOR_CSS_KEY, isHiding ? CARET_CSS_RULE : null);\n}\n","import { getSafeIdSelector } from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n */\nexport function ensureUniqueId(element: HTMLElement, idPrefix: string): string {\n    idPrefix = element.id || idPrefix;\n\n    const doc = element.ownerDocument;\n    let i = 0;\n\n    while (!element.id || doc.querySelectorAll(getSafeIdSelector(element.id)).length > 1) {\n        element.id = idPrefix + '_' + i++;\n    }\n\n    return element.id;\n}\n","import { ensureUniqueId } from './ensureUniqueId';\nimport { getSafeIdSelector } from 'roosterjs-content-model-dom';\nimport type { SetEditorStyle } from 'roosterjs-content-model-types';\n\nconst MAX_RULE_SELECTOR_LENGTH = 9000;\nconst CONTENT_DIV_ID = 'contentDiv';\n\n/**\n * @internal\n */\nexport const setEditorStyle: SetEditorStyle = (\n    core,\n    key,\n    cssRule,\n    subSelectors,\n    maxRuleLength = MAX_RULE_SELECTOR_LENGTH\n) => {\n    let styleElement = core.lifecycle.styleElements[key];\n\n    if (!styleElement && cssRule) {\n        const doc = core.physicalRoot.ownerDocument;\n\n        styleElement = doc.createElement('style');\n        doc.head.appendChild(styleElement);\n\n        styleElement.dataset.roosterjsStyleKey = key;\n        core.lifecycle.styleElements[key] = styleElement;\n    }\n\n    const sheet = styleElement?.sheet;\n\n    if (sheet) {\n        for (let i = sheet.cssRules.length - 1; i >= 0; i--) {\n            sheet.deleteRule(i);\n        }\n\n        if (cssRule) {\n            const rootSelector = getSafeIdSelector(\n                ensureUniqueId(core.physicalRoot, CONTENT_DIV_ID)\n            );\n            const selectors = !subSelectors\n                ? [rootSelector]\n                : typeof subSelectors === 'string'\n                ? [`${rootSelector}::${subSelectors}`]\n                : buildSelectors(\n                      rootSelector,\n                      subSelectors,\n                      maxRuleLength - cssRule.length - 3 // minus 3 for \" {}\"\n                  );\n\n            selectors.forEach(selector => {\n                sheet.insertRule(`${selector} {${cssRule}}`);\n            });\n        }\n    }\n};\n\nfunction buildSelectors(rootSelector: string, subSelectors: string[], maxLen: number): string[] {\n    const result: string[] = [];\n\n    let stringBuilder: string[] = [];\n    let len = 0;\n\n    subSelectors.forEach(subSelector => {\n        if (len >= maxLen) {\n            result.push(stringBuilder.join(','));\n            stringBuilder = [];\n            len = 0;\n        }\n\n        const selector = `${rootSelector} ${subSelector}`;\n\n        len += selector.length + 1; // Add 1 for potential \",\" between selectors\n        stringBuilder.push(selector);\n    });\n\n    result.push(stringBuilder.join(','));\n\n    return result;\n}\n","import type {\n    BeforeLogicalRootChangeEvent,\n    LogicalRootChangedEvent,\n    SetLogicalRoot,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Change which node is the current logical root\n * @param core The StandaloneEditorCore object\n * @param logicalRoot The new logical root (has to be child of physicalRoot), pass null to use physicalRoot as logical root\n */\nexport const setLogicalRoot: SetLogicalRoot = (core, logicalRoot) => {\n    // make sure we either want to reset to physical root or the logical root is a child of physical root\n    if (!logicalRoot || core.physicalRoot.contains(logicalRoot)) {\n        // if null, reset to physical root\n        if (!logicalRoot) {\n            logicalRoot = core.physicalRoot;\n        }\n\n        // if the logical root changed\n        if (logicalRoot !== core.logicalRoot) {\n            // tell plugins that the logical root is about to change, so they can clean up listeners or caches\n            const beforeLogicalRootEvent: BeforeLogicalRootChangeEvent = {\n                eventType: 'beforeLogicalRootChange',\n                logicalRoot: core.logicalRoot,\n            };\n            core.api.triggerEvent(core, beforeLogicalRootEvent, false /*broadcast*/);\n\n            // make sure the old logical root is not content editable and the new one is\n            core.logicalRoot.contentEditable = 'false';\n            logicalRoot.contentEditable = 'true';\n\n            // update the logical root\n            core.logicalRoot = logicalRoot;\n\n            // clear internal caches\n            core.selection.selection = null;\n            core.cache.cachedModel = undefined;\n            core.cache.cachedSelection = undefined;\n\n            // tell plugins in case they need to clear their caches\n            const event: LogicalRootChangedEvent = {\n                eventType: 'logicalRootChanged',\n                logicalRoot,\n            };\n            core.api.triggerEvent(core, event, false /*broadcast*/);\n        }\n    } else {\n        return null;\n    }\n};\n","import { iterateSelections, moveChildNodes } from 'roosterjs-content-model-dom';\nimport { toggleCaret } from '../setDOMSelection/toggleCaret';\nimport type { SwitchShadowEdit } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Switch the Shadow Edit mode of editor On/Off\n * @param editorCore The EditorCore object\n * @param isOn True to switch On, False to switch Off\n */\nexport const switchShadowEdit: SwitchShadowEdit = (editorCore, isOn): void => {\n    const core = editorCore;\n\n    if (isOn != !!core.lifecycle.shadowEditFragment) {\n        if (isOn) {\n            const model = !core.cache.cachedModel ? core.api.createContentModel(core) : null;\n            const fragment = core.logicalRoot.ownerDocument.createDocumentFragment();\n            const clonedRoot = core.logicalRoot.cloneNode(true /*deep*/);\n\n            moveChildNodes(fragment, clonedRoot);\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: 'enteredShadowEdit',\n                },\n                false /*broadcast*/\n            );\n\n            // This need to be done after EnteredShadowEdit event is triggered since EnteredShadowEdit event will cause a SelectionChanged event\n            // if current selection is table selection or image selection\n            if (!core.cache.cachedModel && model) {\n                core.cache.cachedModel = model;\n            }\n\n            toggleCaret(core, true /* hide */);\n\n            core.lifecycle.shadowEditFragment = fragment;\n        } else {\n            core.lifecycle.shadowEditFragment = null;\n\n            toggleCaret(core, false /* hide */);\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: 'leavingShadowEdit',\n                },\n                false /*broadcast*/\n            );\n\n            if (core.cache.cachedModel) {\n                // Force clear cached element from selected block\n                iterateSelections(core.cache.cachedModel, () => {});\n\n                core.api.setContentModel(core, core.cache.cachedModel, {\n                    ignoreSelection: true, // Do not set focus and selection when quit shadow edit, focus may remain in UI control (picker, ...)\n                });\n            }\n        }\n    }\n};\n","import type {\n    EditorPlugin,\n    PluginEvent,\n    PluginEventType,\n    TriggerEvent,\n} from 'roosterjs-content-model-types';\n\nconst allowedEventsInShadowEdit: PluginEventType[] = [\n    'editorReady',\n    'beforeDispose',\n    'extractContentWithDom',\n    'zoomChanged',\n];\n\n/**\n * @internal\n * Trigger a plugin event\n * @param core The EditorCore object\n * @param pluginEvent The event object to trigger\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\n */\nexport const triggerEvent: TriggerEvent = (core, pluginEvent, broadcast) => {\n    if (\n        (!core.lifecycle.shadowEditFragment ||\n            allowedEventsInShadowEdit.indexOf(pluginEvent.eventType as PluginEventType) >= 0) &&\n        (broadcast || !core.plugins.some(plugin => handledExclusively(pluginEvent, plugin)))\n    ) {\n        core.plugins.forEach(plugin => {\n            if (plugin.onPluginEvent) {\n                plugin.onPluginEvent(pluginEvent);\n            }\n        });\n    }\n};\n\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\n    if (plugin.onPluginEvent && plugin.willHandleEventExclusively?.(event)) {\n        plugin.onPluginEvent(event);\n        return true;\n    }\n\n    return false;\n}\n","import { areSameSelections } from './areSameSelections';\nimport { createParagraphMap } from './ParagraphMapImpl';\nimport { createTextMutationObserver } from './textMutationObserver';\nimport { DomIndexerImpl } from './domIndexerImpl';\nimport { updateCache } from './updateCache';\nimport type { Mutation } from './MutationType';\nimport type {\n    CachePluginState,\n    IEditor,\n    PluginEvent,\n    PluginWithState,\n    EditorOptions,\n} from 'roosterjs-content-model-types';\n\n/**\n * ContentModel cache plugin manages cached Content Model, and refresh the cache when necessary\n */\nclass CachePlugin implements PluginWithState<CachePluginState> {\n    private editor: IEditor | null = null;\n    private state: CachePluginState;\n\n    /**\n     * Construct a new instance of CachePlugin class\n     * @param option The editor option\n     * @param contentDiv The editor content DIV\n     */\n    constructor(option: EditorOptions, contentDiv: HTMLDivElement) {\n        this.state = {\n            domIndexer: new DomIndexerImpl(\n                option.experimentalFeatures &&\n                    option.experimentalFeatures.indexOf(\n                        'KeepSelectionMarkerWhenEnteringTextNode'\n                    ) >= 0\n            ),\n            textMutationObserver: createTextMutationObserver(contentDiv, this.onMutation),\n        };\n\n        if (option.enableParagraphMap) {\n            this.state.paragraphMap = createParagraphMap();\n        }\n    }\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'Cache';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.editor.getDocument().addEventListener('selectionchange', this.onNativeSelectionChange);\n\n        this.state.textMutationObserver.startObserving();\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.state.textMutationObserver.stopObserving();\n\n        if (this.editor) {\n            this.editor\n                .getDocument()\n                .removeEventListener('selectionchange', this.onNativeSelectionChange);\n            this.editor = null;\n        }\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState(): CachePluginState {\n        return this.state;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case 'logicalRootChanged':\n                this.invalidateCache();\n\n                this.state.textMutationObserver.stopObserving();\n                this.state.textMutationObserver = createTextMutationObserver(\n                    event.logicalRoot,\n                    this.onMutation\n                );\n                this.state.textMutationObserver.startObserving();\n                break;\n\n            case 'selectionChanged':\n                this.updateCachedModel(this.editor);\n                break;\n\n            case 'contentChanged':\n                const { contentModel, selection } = event;\n\n                if (contentModel) {\n                    updateCache(this.state, contentModel, selection);\n                } else {\n                    this.invalidateCache();\n                }\n\n                break;\n        }\n    }\n\n    private onMutation = (mutation: Mutation) => {\n        if (this.editor) {\n            switch (mutation.type) {\n                case 'childList':\n                    if (\n                        !this.state.domIndexer.reconcileChildList(\n                            mutation.addedNodes,\n                            mutation.removedNodes\n                        )\n                    ) {\n                        this.invalidateCache();\n                    }\n                    break;\n\n                case 'text':\n                    this.updateCachedModel(this.editor, true /*forceUpdate*/);\n                    break;\n\n                case 'elementId':\n                    const element = mutation.element;\n\n                    if (!this.state.domIndexer.reconcileElementId(element)) {\n                        this.invalidateCache();\n                    }\n\n                    break;\n\n                case 'unknown':\n                    this.invalidateCache();\n                    break;\n            }\n        }\n    };\n\n    private onNativeSelectionChange = () => {\n        if (this.editor?.hasFocus()) {\n            this.updateCachedModel(this.editor);\n        }\n    };\n\n    private invalidateCache() {\n        if (!this.editor?.isInShadowEdit()) {\n            this.state.cachedModel = undefined;\n            this.state.cachedSelection = undefined;\n\n            // Clear paragraph indexer to prevent stale references to old paragraphs\n            // It will be rebuild next time when we create a new Content Model\n            this.state.paragraphMap?.clear();\n        }\n    }\n\n    private updateCachedModel(editor: IEditor, forceUpdate?: boolean) {\n        if (editor.isInShadowEdit()) {\n            return;\n        }\n\n        const cachedSelection = this.state.cachedSelection;\n        this.state.cachedSelection = undefined; // Clear it to force getDOMSelection() retrieve the latest selection range\n\n        const newRangeEx = editor.getDOMSelection() || undefined;\n        const model = this.state.cachedModel;\n        const isSelectionChanged =\n            forceUpdate ||\n            !cachedSelection ||\n            !newRangeEx ||\n            !areSameSelections(newRangeEx, cachedSelection);\n\n        if (isSelectionChanged) {\n            if (\n                !model ||\n                !newRangeEx ||\n                !this.state.domIndexer.reconcileSelection(model, newRangeEx, cachedSelection)\n            ) {\n                this.invalidateCache();\n            } else {\n                updateCache(this.state, model, newRangeEx);\n            }\n        } else {\n            this.state.cachedSelection = cachedSelection;\n        }\n    }\n}\n\n/**\n * @internal\n * Create a new instance of CachePlugin class.\n * @param option The editor option\n * @param contentDiv The editor content DIV\n */\nexport function createCachePlugin(\n    option: EditorOptions,\n    contentDiv: HTMLDivElement\n): PluginWithState<CachePluginState> {\n    return new CachePlugin(option, contentDiv);\n}\n","import { getParagraphMarker, setParagraphMarker } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelParagraph,\n    ContentModelParagraphCommon,\n    ParagraphIndexer,\n    ParagraphMap,\n    ReadonlyContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\ninterface ParagraphWithMarker extends ContentModelParagraphCommon {\n    _marker?: string;\n}\n\n/**\n * @internal, used by test code only\n */\nexport interface ParagraphMapReset {\n    _reset(): void;\n    _getMap(): { [key: string]: ReadonlyContentModelParagraph };\n}\n\nconst idPrefix = 'paragraph';\n\nclass ParagraphMapImpl implements ParagraphMap, ParagraphIndexer, ParagraphMapReset {\n    private static prefixNum = 0;\n    private nextId = 0;\n    private paragraphMap: { [key: string]: ReadonlyContentModelParagraph } = {};\n\n    constructor() {\n        ParagraphMapImpl.prefixNum++;\n    }\n\n    assignMarkerToModel(element: HTMLElement, paragraph: ContentModelParagraph): void {\n        const marker = getParagraphMarker(element);\n        const paragraphWithMarker = paragraph as ParagraphWithMarker;\n\n        if (marker) {\n            paragraphWithMarker._marker = marker;\n\n            this.paragraphMap[marker] = paragraph;\n        } else {\n            paragraphWithMarker._marker = this.generateId();\n\n            this.applyMarkerToDom(element, paragraph);\n        }\n    }\n\n    applyMarkerToDom(element: HTMLElement, paragraph: ContentModelParagraph): void {\n        const paragraphWithMarker = paragraph as ParagraphWithMarker;\n\n        if (!paragraphWithMarker._marker) {\n            paragraphWithMarker._marker = this.generateId();\n        }\n\n        const marker = paragraphWithMarker._marker;\n\n        if (marker) {\n            setParagraphMarker(element, marker);\n\n            this.paragraphMap[marker] = paragraph;\n        }\n    }\n\n    /**\n     * Get paragraph using a previously marked paragraph\n     * @param markedParagraph The previously marked paragraph to get\n     */\n    getParagraphFromMarker(\n        markerParagraph: ReadonlyContentModelParagraph\n    ): ReadonlyContentModelParagraph | null {\n        const marker = (markerParagraph as ParagraphWithMarker)._marker;\n\n        return marker ? this.paragraphMap[marker] || null : null;\n    }\n\n    clear() {\n        this.paragraphMap = {};\n    }\n\n    //#region For test code only\n    _reset() {\n        ParagraphMapImpl.prefixNum = 0;\n        this.nextId = 0;\n    }\n\n    _getMap() {\n        return this.paragraphMap;\n    }\n    //#endregion\n\n    private generateId() {\n        return `${idPrefix}_${ParagraphMapImpl.prefixNum}_${this.nextId++}`;\n    }\n}\n\n/**\n * @internal\n */\nexport function createParagraphMap(): ParagraphMap & ParagraphIndexer {\n    return new ParagraphMapImpl();\n}\n","import type {\n    CacheSelection,\n    DOMSelection,\n    RangeSelection,\n    RangeSelectionForCache,\n    TableSelection,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Check if the given selections are the same\n */\nexport function areSameSelections(\n    sel1: DOMSelection,\n    sel2: DOMSelection | CacheSelection\n): boolean {\n    if (sel1 == sel2) {\n        return true;\n    }\n\n    switch (sel1.type) {\n        case 'image':\n            return sel2.type == 'image' && sel2.image == sel1.image;\n\n        case 'table':\n            return sel2.type == 'table' && areSameTableSelections(sel1, sel2);\n\n        case 'range':\n        default:\n            if (sel2.type == 'range') {\n                const range1 = sel1.range;\n\n                if (isCacheSelection(sel2)) {\n                    const { start, end } = sel2;\n\n                    return (\n                        range1.startContainer == start.node &&\n                        range1.endContainer == end.node &&\n                        range1.startOffset == start.offset &&\n                        range1.endOffset == end.offset\n                    );\n                } else {\n                    return areSameRanges(range1, sel2.range);\n                }\n            } else {\n                return false;\n            }\n    }\n}\n\nfunction areSame<O>(o1: O, o2: O, keys: (keyof O)[]) {\n    return keys.every(k => o1[k] == o2[k]);\n}\n\nconst TableSelectionKeys: (keyof TableSelection)[] = [\n    'table',\n    'firstColumn',\n    'lastColumn',\n    'firstRow',\n    'lastRow',\n];\nconst RangeKeys: (keyof Range)[] = ['startContainer', 'endContainer', 'startOffset', 'endOffset'];\n\n/**\n * @internal\n */\nexport function areSameTableSelections(t1: TableSelection, t2: TableSelection): boolean {\n    return areSame(t1, t2, TableSelectionKeys);\n}\n\n/**\n * @internal\n */\nexport function areSameRanges(r1: Range, r2: Range): boolean {\n    return areSame(r1, r2, RangeKeys);\n}\n\nfunction isCacheSelection(\n    sel: RangeSelectionForCache | RangeSelection\n): sel is RangeSelectionForCache {\n    return !!(sel as RangeSelectionForCache).start;\n}\n","import {\n    EmptySegmentFormat,\n    addCode,\n    addLink,\n    createParagraph,\n    createSelectionMarker,\n    createText,\n    getObjectKeys,\n    isElementOfType,\n    isEntityDelimiter,\n    isNodeOfType,\n    setSelection,\n} from 'roosterjs-content-model-dom';\nimport type {\n    CacheSelection,\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelEntity,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelSegmentFormat,\n    ContentModelSelectionMarker,\n    ContentModelTable,\n    ContentModelText,\n    DomIndexer,\n    DOMSelection,\n    RangeSelectionForCache,\n    Selectable,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal Export for test only\n */\nexport interface SegmentItem {\n    paragraph: ContentModelParagraph;\n    segments: ContentModelSegment[];\n}\n\n/**\n * @internal Export for test only\n */\nexport interface TableItem {\n    table: ContentModelTable;\n}\n\n/**\n * @internal Export for test only\n */\nexport interface BlockEntityDelimiterItem {\n    entity: ContentModelEntity;\n    parent: ContentModelBlockGroup;\n}\n\n/**\n * @internal Export for test only\n */\nexport interface IndexedSegmentNode extends Node {\n    __roosterjsContentModel: SegmentItem;\n}\n\n/**\n * @internal Export for test only\n */\nexport interface IndexedTableElement extends HTMLTableElement {\n    __roosterjsContentModel: TableItem;\n}\n\n/**\n * @internal Export for test only\n */\nexport interface IndexedEntityDelimiter extends Text {\n    __roosterjsContentModel: BlockEntityDelimiterItem;\n}\n\n/**\n * Context object used by DomIndexer when reconcile mutations with child list\n */\ninterface ReconcileChildListContext {\n    /**\n     * Index of segment in current paragraph\n     */\n    segIndex: number;\n\n    /**\n     * The current paragraph that we are handling\n     */\n    paragraph?: ContentModelParagraph;\n\n    /**\n     * Text node that is added from mutation but has not been handled. This can happen when we first see an added node then later we see a removed one.\n     * e.g. Type text in an empty paragraph (&lt;div&gt;&lt;br&gt;&lt;/div&gt;), so a text node will be added and &lt;BR&gt; will be removed.\n     * Set to a valid text node means we need to handle it later. If it is finally not handled, that means we need to clear cache\n     * Set to undefined (initial value) means no pending text node is hit yet (valid case)\n     * Set to null means there was a pending text node which is already handled, so if we see another pending text node,\n     * we should clear cache since we don't know how to handle it\n     */\n    pendingTextNode?: Text | null;\n\n    /**\n     * Format of the removed segment, this will be used as the format for newly created segment\n     */\n    format?: ContentModelSegmentFormat;\n}\n\nfunction isIndexedSegment(node: Node): node is IndexedSegmentNode {\n    const { paragraph, segments } = (node as IndexedSegmentNode).__roosterjsContentModel ?? {};\n\n    return (\n        paragraph &&\n        paragraph.blockType == 'Paragraph' &&\n        Array.isArray(paragraph.segments) &&\n        Array.isArray(segments) &&\n        segments.every(segment => paragraph.segments.includes(segment))\n    );\n}\n\nfunction isIndexedDelimiter(node: Node): node is IndexedEntityDelimiter {\n    const { entity, parent } = (node as IndexedEntityDelimiter).__roosterjsContentModel ?? {};\n\n    return (\n        entity?.blockType == 'Entity' &&\n        entity.wrapper &&\n        parent?.blockGroupType &&\n        Array.isArray(parent.blocks)\n    );\n}\n\nfunction getIndexedSegmentItem(node: Node | null): SegmentItem | null {\n    return node && isIndexedSegment(node) ? node.__roosterjsContentModel : null;\n}\n\nfunction getIndexedTableItem(element: HTMLTableElement): TableItem | null {\n    const index = (element as IndexedTableElement).__roosterjsContentModel;\n    const table = index?.table;\n\n    if (\n        table?.blockType == 'Table' &&\n        Array.isArray(table.rows) &&\n        table.rows.every(\n            x => Array.isArray(x?.cells) && x.cells.every(y => y?.blockGroupType == 'TableCell')\n        )\n    ) {\n        return index;\n    } else {\n        return null;\n    }\n}\n\n// Make a node not indexed. Do not export this function since we should not let code outside here know this detail\nfunction unindex(node: Partial<IndexedSegmentNode>) {\n    delete node.__roosterjsContentModel;\n}\n\n/**\n * @internal\n * Implementation of DomIndexer\n */\nexport class DomIndexerImpl implements DomIndexer {\n    constructor(private readonly keepSelectionMarkerWhenEnteringTextNode?: boolean) {}\n\n    onSegment(segmentNode: Node, paragraph: ContentModelParagraph, segment: ContentModelSegment[]) {\n        const indexedText = segmentNode as IndexedSegmentNode;\n        indexedText.__roosterjsContentModel = {\n            paragraph,\n            segments: segment,\n        };\n    }\n\n    onParagraph(paragraphElement: HTMLElement) {\n        let previousText: Text | null = null;\n\n        for (let child = paragraphElement.firstChild; child; child = child.nextSibling) {\n            if (isNodeOfType(child, 'TEXT_NODE')) {\n                if (!previousText) {\n                    previousText = child;\n                } else {\n                    const item = getIndexedSegmentItem(previousText);\n\n                    if (item && isIndexedSegment(child)) {\n                        item.segments = item.segments.concat(\n                            child.__roosterjsContentModel.segments\n                        );\n                        child.__roosterjsContentModel.segments = [];\n                    }\n                }\n            } else if (isNodeOfType(child, 'ELEMENT_NODE')) {\n                previousText = null;\n\n                this.onParagraph(child);\n            } else {\n                previousText = null;\n            }\n        }\n    }\n\n    onTable(tableElement: HTMLTableElement, table: ContentModelTable) {\n        const indexedTable = tableElement as IndexedTableElement;\n        indexedTable.__roosterjsContentModel = { table };\n    }\n\n    onBlockEntity(entity: ContentModelEntity, group: ContentModelBlockGroup) {\n        this.onBlockEntityDelimiter(entity.wrapper.previousSibling, entity, group);\n        this.onBlockEntityDelimiter(entity.wrapper.nextSibling, entity, group);\n    }\n\n    onMergeText(targetText: Text, sourceText: Text) {\n        if (isIndexedSegment(targetText) && isIndexedSegment(sourceText)) {\n            if (targetText.nextSibling == sourceText) {\n                targetText.__roosterjsContentModel.segments.push(\n                    ...sourceText.__roosterjsContentModel.segments\n                );\n\n                unindex(sourceText);\n            }\n        } else {\n            unindex(sourceText);\n            unindex(targetText);\n        }\n    }\n\n    clearIndex(container: Node) {\n        internalClearIndex(container);\n    }\n\n    reconcileSelection(\n        model: ContentModelDocument,\n        newSelection: DOMSelection,\n        oldSelection?: CacheSelection\n    ): boolean {\n        let selectionMarker: ContentModelSelectionMarker | undefined;\n        if (oldSelection) {\n            let startNode: Node | undefined;\n\n            if (\n                oldSelection.type == 'range' &&\n                this.isCollapsed(oldSelection) &&\n                (startNode = oldSelection.start.node) &&\n                isNodeOfType(startNode, 'TEXT_NODE') &&\n                isIndexedSegment(startNode) &&\n                startNode.__roosterjsContentModel.segments.length > 0\n            ) {\n                this.reconcileTextSelection(startNode);\n            } else {\n                selectionMarker = this.selectionMarkerToKeepWhenEnteringTextNode(\n                    oldSelection,\n                    newSelection\n                );\n\n                setSelection(model);\n            }\n        }\n\n        switch (newSelection.type) {\n            case 'image':\n                const indexedImage = getIndexedSegmentItem(newSelection.image);\n                const image = indexedImage?.segments[0];\n\n                if (image) {\n                    image.isSelected = true;\n                    setSelection(model, image);\n\n                    return true;\n                } else {\n                    return false;\n                }\n\n            case 'table':\n                const indexedTable = getIndexedTableItem(newSelection.table);\n\n                if (indexedTable) {\n                    const firstCell =\n                        indexedTable.table.rows[newSelection.firstRow]?.cells[\n                            newSelection.firstColumn\n                        ];\n                    const lastCell =\n                        indexedTable.table.rows[newSelection.lastRow]?.cells[\n                            newSelection.lastColumn\n                        ];\n\n                    if (firstCell && lastCell) {\n                        setSelection(model, firstCell, lastCell);\n\n                        return true;\n                    }\n                }\n\n                return false;\n\n            case 'range':\n                const newRange = newSelection.range;\n                if (newRange) {\n                    const {\n                        startContainer,\n                        startOffset,\n                        endContainer,\n                        endOffset,\n                        collapsed,\n                    } = newRange;\n\n                    delete model.hasRevertedRangeSelection;\n\n                    if (collapsed) {\n                        return !!this.reconcileNodeSelection(\n                            startContainer,\n                            startOffset,\n                            model.format,\n                            selectionMarker\n                        );\n                    } else if (\n                        startContainer == endContainer &&\n                        isNodeOfType(startContainer, 'TEXT_NODE')\n                    ) {\n                        if (newSelection.isReverted) {\n                            model.hasRevertedRangeSelection = true;\n                        }\n\n                        return (\n                            isIndexedSegment(startContainer) &&\n                            !!this.reconcileTextSelection(\n                                startContainer,\n                                startOffset,\n                                endOffset,\n                                selectionMarker\n                            )\n                        );\n                    } else {\n                        const marker1 = this.reconcileNodeSelection(startContainer, startOffset);\n                        const marker2 = this.reconcileNodeSelection(endContainer, endOffset);\n\n                        if (marker1 && marker2) {\n                            if (newSelection.isReverted) {\n                                model.hasRevertedRangeSelection = true;\n                            }\n\n                            setSelection(model, marker1, marker2);\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    }\n                }\n\n                break;\n        }\n\n        return false;\n    }\n\n    reconcileChildList(addedNodes: ArrayLike<Node>, removedNodes: ArrayLike<Node>): boolean {\n        let canHandle = true;\n        const context: ReconcileChildListContext = {\n            segIndex: -1,\n        };\n\n        // First process added nodes\n        const addedNode = addedNodes[0];\n\n        if (addedNodes.length == 1 && isNodeOfType(addedNode, 'TEXT_NODE')) {\n            canHandle = this.reconcileAddedNode(addedNode, context);\n        } else if (addedNodes.length > 0) {\n            canHandle = false;\n        }\n\n        // Second, process removed nodes\n        const removedNode = removedNodes[0];\n\n        if (canHandle && removedNodes.length == 1) {\n            canHandle = this.reconcileRemovedNode(removedNode, context);\n        } else if (removedNodes.length > 0) {\n            canHandle = false;\n        }\n\n        return canHandle && !context.pendingTextNode;\n    }\n\n    reconcileElementId(element: HTMLElement) {\n        if (isElementOfType(element, 'img')) {\n            const indexedImg = getIndexedSegmentItem(element);\n\n            if (indexedImg?.segments[0]?.segmentType == 'Image') {\n                indexedImg.segments[0].format.id = element.id;\n\n                return true;\n            } else {\n                return false;\n            }\n        } else if (isElementOfType(element, 'table')) {\n            const indexedTable = getIndexedTableItem(element);\n\n            if (indexedTable) {\n                indexedTable.table.format.id = element.id;\n\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    private onBlockEntityDelimiter(\n        node: Node | null,\n        entity: ContentModelEntity,\n        parent: ContentModelBlockGroup\n    ) {\n        if (isNodeOfType(node, 'ELEMENT_NODE') && isEntityDelimiter(node) && node.firstChild) {\n            const indexedDelimiter = node.firstChild as IndexedEntityDelimiter;\n\n            indexedDelimiter.__roosterjsContentModel = { entity, parent };\n        }\n    }\n\n    private isCollapsed(selection: RangeSelectionForCache): boolean {\n        const { start, end } = selection;\n\n        return start.node == end.node && start.offset == end.offset;\n    }\n\n    private reconcileNodeSelection(\n        node: Node,\n        offset: number,\n        defaultFormat?: ContentModelSegmentFormat,\n        selectionMarker?: ContentModelSelectionMarker\n    ): Selectable | undefined {\n        if (isNodeOfType(node, 'TEXT_NODE')) {\n            if (isIndexedSegment(node)) {\n                return this.reconcileTextSelection(node, offset, undefined, selectionMarker);\n            } else if (isIndexedDelimiter(node)) {\n                return this.reconcileDelimiterSelection(node, defaultFormat);\n            } else {\n                return undefined;\n            }\n        } else if (offset >= node.childNodes.length) {\n            return this.insertMarker(node.lastChild, true /*isAfter*/);\n        } else {\n            return this.insertMarker(node.childNodes[offset], false /*isAfter*/);\n        }\n    }\n\n    private insertMarker(node: Node | null, isAfter: boolean): Selectable | undefined {\n        let marker: ContentModelSelectionMarker | undefined;\n        const segmentItem = node && getIndexedSegmentItem(node);\n\n        if (segmentItem) {\n            const { paragraph, segments } = segmentItem;\n            const index = paragraph.segments.indexOf(segments[0]);\n\n            if (index >= 0) {\n                const formatSegment =\n                    (!isAfter && paragraph.segments[index - 1]) || paragraph.segments[index];\n                marker = createSelectionMarker(formatSegment.format);\n\n                paragraph.segments.splice(isAfter ? index + 1 : index, 0, marker);\n            }\n        }\n\n        return marker;\n    }\n\n    private reconcileTextSelection(\n        textNode: IndexedSegmentNode,\n        startOffset?: number,\n        endOffset?: number,\n        selectionMarker?: ContentModelSelectionMarker\n    ) {\n        const { paragraph, segments } = textNode.__roosterjsContentModel;\n        const first = segments[0];\n        const last = segments[segments.length - 1];\n        let selectable: Selectable | undefined;\n\n        if (first?.segmentType == 'Text' && last?.segmentType == 'Text') {\n            const newSegments: ContentModelSegment[] = [];\n            const txt = textNode.nodeValue || '';\n            const textSegments: ContentModelText[] = [];\n\n            if (startOffset === undefined) {\n                first.text = txt;\n                newSegments.push(first);\n                textSegments.push(first);\n            } else {\n                if (startOffset > 0) {\n                    first.text = txt.substring(0, startOffset);\n                    newSegments.push(first);\n                    textSegments.push(first);\n                }\n\n                if (endOffset === undefined) {\n                    const marker = createSelectionMarker(selectionMarker?.format ?? first.format);\n                    newSegments.push(marker);\n\n                    if (startOffset < (textNode.nodeValue ?? '').length) {\n                        if (first.link) {\n                            addLink(marker, first.link);\n                        }\n\n                        if (first.code) {\n                            addCode(marker, first.code);\n                        }\n                    }\n\n                    selectable = marker;\n                    endOffset = startOffset;\n                } else if (endOffset > startOffset) {\n                    const middle = createText(\n                        txt.substring(startOffset, endOffset),\n                        selectionMarker?.format ?? first.format,\n                        first.link,\n                        first.code\n                    );\n\n                    middle.isSelected = true;\n                    newSegments.push(middle);\n                    textSegments.push(middle);\n                    selectable = middle;\n                }\n\n                if (endOffset < txt.length) {\n                    const newLast = createText(\n                        txt.substring(endOffset),\n                        selectionMarker?.format ?? first.format,\n                        first.link,\n                        first.code\n                    );\n                    newSegments.push(newLast);\n                    textSegments.push(newLast);\n                }\n            }\n\n            let firstIndex = paragraph.segments.indexOf(first);\n            let lastIndex = paragraph.segments.indexOf(last);\n\n            if (firstIndex >= 0 && lastIndex >= 0) {\n                while (\n                    firstIndex > 0 &&\n                    paragraph.segments[firstIndex - 1].segmentType == 'SelectionMarker'\n                ) {\n                    firstIndex--;\n                }\n\n                while (\n                    lastIndex < paragraph.segments.length - 1 &&\n                    paragraph.segments[lastIndex + 1].segmentType == 'SelectionMarker'\n                ) {\n                    lastIndex++;\n                }\n\n                paragraph.segments.splice(firstIndex, lastIndex - firstIndex + 1, ...newSegments);\n            }\n\n            this.onSegment(textNode, paragraph, textSegments);\n        } else if (first?.segmentType == 'Entity' && first == last) {\n            const wrapper = first.wrapper;\n            const index = paragraph.segments.indexOf(first);\n            const delimiter = textNode.parentElement;\n            const isBefore = wrapper.previousSibling == delimiter;\n            const isAfter = wrapper.nextSibling == delimiter;\n\n            if (index >= 0 && delimiter && isEntityDelimiter(delimiter) && (isBefore || isAfter)) {\n                const marker = createSelectionMarker(\n                    selectionMarker?.format ??\n                        (paragraph.segments[isAfter ? index + 1 : index - 1] ?? first).format\n                );\n\n                paragraph.segments.splice(isAfter ? index + 1 : index, 0, marker);\n\n                selectable = marker;\n            }\n        }\n\n        return selectable;\n    }\n\n    private reconcileDelimiterSelection(\n        node: IndexedEntityDelimiter,\n        defaultFormat?: ContentModelSegmentFormat\n    ) {\n        let marker: ContentModelSelectionMarker | undefined;\n\n        const { entity, parent } = node.__roosterjsContentModel;\n        const index = parent.blocks.indexOf(entity);\n        const delimiter = node.parentElement;\n        const wrapper = entity.wrapper;\n        const isBefore = wrapper.previousSibling == delimiter;\n        const isAfter = wrapper.nextSibling == delimiter;\n\n        if (index >= 0 && delimiter && isEntityDelimiter(delimiter) && (isBefore || isAfter)) {\n            marker = createSelectionMarker(defaultFormat);\n\n            const para = createParagraph(\n                true /*isImplicit*/,\n                undefined /*blockFormat*/,\n                defaultFormat\n            );\n\n            para.segments.push(marker);\n            parent.blocks.splice(isBefore ? index : index + 1, 0, para);\n        }\n\n        return marker;\n    }\n\n    private reconcileAddedNode(node: Text, context: ReconcileChildListContext): boolean {\n        let segmentItem: SegmentItem | null = null;\n        let index = -1;\n        let existingSegment: ContentModelSegment;\n        const { previousSibling, nextSibling } = node;\n\n        if (\n            (segmentItem = getIndexedSegmentItem(getLastLeaf(previousSibling))) &&\n            (existingSegment = segmentItem.segments[segmentItem.segments.length - 1]) &&\n            (index = segmentItem.paragraph.segments.indexOf(existingSegment)) >= 0\n        ) {\n            // When we can find indexed segment before current one, use it as the insert index\n            this.indexNode(segmentItem.paragraph, index + 1, node, existingSegment.format);\n        } else if (\n            (segmentItem = getIndexedSegmentItem(getFirstLeaf(nextSibling))) &&\n            (existingSegment = segmentItem.segments[0]) &&\n            (index = segmentItem.paragraph.segments.indexOf(existingSegment)) >= 0\n        ) {\n            // When we can find indexed segment after current one, use it as the insert index\n            this.indexNode(segmentItem.paragraph, index, node, existingSegment.format);\n        } else if (context.paragraph && context.segIndex >= 0) {\n            // When there is indexed paragraph from removed nodes, we can use it as the insert index\n            this.indexNode(context.paragraph, context.segIndex, node, context.format);\n        } else if (context.pendingTextNode === undefined) {\n            // When we can't find the insert index, set current node as pending node\n            // so later we can pick it up when we have enough info when processing removed node\n            // Only do this when pendingTextNode is undefined. If it is null it means there was already a pending node before\n            // and in that case we should return false since we can't handle two pending text node\n            context.pendingTextNode = node;\n        } else {\n            return false;\n        }\n\n        return true;\n    }\n\n    private reconcileRemovedNode(node: Node, context: ReconcileChildListContext): boolean {\n        let segmentItem: SegmentItem | null = null;\n        let removingSegment: ContentModelSegment;\n\n        if (\n            context.segIndex < 0 &&\n            !context.paragraph && // No previous removed segment or related paragraph found, and\n            (segmentItem = getIndexedSegmentItem(node)) && // The removed node is indexed, and\n            (removingSegment = segmentItem.segments[0]) // There is at least one related segment\n        ) {\n            // Now we can remove the indexed segment from the paragraph, and remember it, later we may need to use it\n            context.format = removingSegment.format;\n            context.paragraph = segmentItem.paragraph;\n            context.segIndex = segmentItem.paragraph.segments.indexOf(segmentItem.segments[0]);\n\n            if (context.segIndex < 0) {\n                // Indexed segment is not under paragraph, something wrong happens, we cannot keep handling\n                return false;\n            }\n\n            for (let i = 0; i < segmentItem.segments.length; i++) {\n                const index = segmentItem.paragraph.segments.indexOf(segmentItem.segments[i]);\n\n                if (index >= 0) {\n                    segmentItem.paragraph.segments.splice(index, 1);\n                }\n            }\n\n            if (context.pendingTextNode) {\n                // If we have pending text node added but not indexed, do it now\n                this.indexNode(\n                    context.paragraph,\n                    context.segIndex,\n                    context.pendingTextNode,\n                    segmentItem.segments[0].format\n                );\n\n                // Set to null since we have processed it.\n                // Next time we see a pending node we know we have already processed one so it is a situation we cannot handle\n                context.pendingTextNode = null;\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private indexNode(\n        paragraph: ContentModelParagraph,\n        index: number,\n        textNode: Text,\n        format?: ContentModelSegmentFormat\n    ) {\n        const copiedFormat = format ? { ...format } : undefined;\n\n        if (copiedFormat) {\n            getObjectKeys(copiedFormat).forEach(key => {\n                if (EmptySegmentFormat[key] === undefined) {\n                    delete copiedFormat[key];\n                }\n            });\n        }\n\n        const text = createText(textNode.textContent ?? '', copiedFormat);\n\n        paragraph.segments.splice(index, 0, text);\n        this.onSegment(textNode, paragraph, [text]);\n    }\n\n    private selectionMarkerToKeepWhenEnteringTextNode(\n        oldSelection: CacheSelection,\n        newSelection: DOMSelection\n    ): ContentModelSelectionMarker | undefined {\n        // For CJK keyboard input on mobile, we may have a situation like this:\n        // User toggle bold/italic/underline on an empty div, the pending format will be applied on the selection marker\n        // then type some text, the selection move to the text node and the selection marker will be recreated during the reconciliation and lose its original formatting\n        // In this case, we need to keep the original formatting of the selection marker to match the pending format\n\n        if (\n            this.keepSelectionMarkerWhenEnteringTextNode &&\n            oldSelection.type == 'range' &&\n            this.isCollapsed(oldSelection) &&\n            newSelection.type == 'range' &&\n            isNodeOfType(newSelection.range.commonAncestorContainer, 'TEXT_NODE') &&\n            newSelection.range.commonAncestorContainer.parentElement == oldSelection.start.node &&\n            isIndexedSegment(newSelection.range.commonAncestorContainer) &&\n            newSelection.range.commonAncestorContainer.__roosterjsContentModel.paragraph.segments[0]\n                .segmentType == 'SelectionMarker'\n        ) {\n            return newSelection.range.commonAncestorContainer.__roosterjsContentModel.paragraph\n                .segments[0];\n        }\n        return undefined;\n    }\n}\n\nfunction getLastLeaf(node: Node | null): Node | null {\n    while (node?.lastChild) {\n        node = node.lastChild;\n    }\n\n    return node;\n}\n\nfunction getFirstLeaf(node: Node | null): Node | null {\n    while (node?.firstChild) {\n        node = node.firstChild;\n    }\n\n    return node;\n}\n\nfunction internalClearIndex(container: Node) {\n    unindex(container as IndexedSegmentNode);\n\n    for (let node = container.firstChild; node; node = node.nextSibling) {\n        internalClearIndex(node);\n    }\n}\n","import { createDOMHelper } from '../../editor/core/DOMHelperImpl';\nimport {\n    findClosestBlockEntityContainer,\n    findClosestEntityWrapper,\n    isNodeOfType,\n} from 'roosterjs-content-model-dom';\nimport type { DOMHelper, TextMutationObserver } from 'roosterjs-content-model-types';\nimport type { Mutation } from './MutationType';\n\nclass TextMutationObserverImpl implements TextMutationObserver {\n    private observer: MutationObserver;\n    private domHelper: DOMHelper;\n\n    constructor(\n        private contentDiv: HTMLDivElement,\n        private onMutation: (mutation: Mutation) => void\n    ) {\n        this.observer = new MutationObserver(this.onMutationInternal);\n        this.domHelper = createDOMHelper(contentDiv);\n    }\n\n    startObserving() {\n        this.observer.observe(this.contentDiv, {\n            subtree: true,\n            childList: true,\n            attributes: true,\n            characterData: true,\n        });\n    }\n\n    stopObserving() {\n        this.observer.disconnect();\n    }\n\n    flushMutations(ignoreMutations?: boolean) {\n        const mutations = this.observer.takeRecords();\n\n        if (!ignoreMutations) {\n            this.onMutationInternal(mutations);\n        }\n    }\n\n    private onMutationInternal = (mutations: MutationRecord[]) => {\n        let canHandle = true;\n        let firstTarget: Node | null = null;\n        let lastTextChangeNode: Node | null = null;\n        let addedNodes: Node[] = [];\n        let removedNodes: Node[] = [];\n        let reconcileText = false;\n\n        const ignoredNodes = new Set<Node>();\n        const includedNodes = new Set<Node>();\n\n        for (let i = 0; i < mutations.length && canHandle; i++) {\n            const mutation = mutations[i];\n            const target = mutation.target;\n\n            if (ignoredNodes.has(target)) {\n                continue;\n            } else if (!includedNodes.has(target)) {\n                if (\n                    findClosestEntityWrapper(target, this.domHelper) ||\n                    findClosestBlockEntityContainer(target, this.domHelper)\n                ) {\n                    ignoredNodes.add(target);\n\n                    continue;\n                } else {\n                    includedNodes.add(target);\n                }\n            }\n\n            switch (mutation.type) {\n                case 'attributes':\n                    if (this.domHelper.isNodeInEditor(target, true /*excludingSelf*/)) {\n                        if (\n                            mutation.attributeName == 'id' &&\n                            isNodeOfType(target, 'ELEMENT_NODE')\n                        ) {\n                            this.onMutation({ type: 'elementId', element: target });\n                        } else {\n                            // We cannot handle attributes changes on editor content for now\n                            canHandle = false;\n                        }\n                    }\n                    break;\n\n                case 'characterData':\n                    if (lastTextChangeNode && lastTextChangeNode != mutation.target) {\n                        // Multiple text nodes got changed, we don't know how to handle it\n                        canHandle = false;\n                    } else {\n                        lastTextChangeNode = mutation.target;\n                        reconcileText = true;\n                    }\n                    break;\n\n                case 'childList':\n                    if (!firstTarget) {\n                        firstTarget = mutation.target;\n                    } else if (firstTarget != mutation.target) {\n                        canHandle = false;\n                    }\n\n                    if (canHandle) {\n                        addedNodes = addedNodes.concat(Array.from(mutation.addedNodes));\n                        removedNodes = removedNodes.concat(Array.from(mutation.removedNodes));\n                    }\n\n                    break;\n            }\n        }\n\n        if (canHandle) {\n            if (addedNodes.length > 0 || removedNodes.length > 0) {\n                this.onMutation({\n                    type: 'childList',\n                    addedNodes,\n                    removedNodes,\n                });\n            }\n\n            if (reconcileText) {\n                this.onMutation({ type: 'text' });\n            }\n        } else {\n            this.onMutation({ type: 'unknown' });\n        }\n    };\n}\n\n/**\n * @internal\n */\nexport function createTextMutationObserver(\n    contentDiv: HTMLDivElement,\n    onMutation: (mutation: Mutation) => void\n): TextMutationObserver {\n    return new TextMutationObserverImpl(contentDiv, onMutation);\n}\n","import type {\n    CachePluginState,\n    ContentModelDocument,\n    DOMSelection,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function updateCache(\n    state: CachePluginState,\n    model: ContentModelDocument,\n    selection: DOMSelection | null | undefined\n) {\n    state.cachedModel = model;\n\n    if (selection?.type == 'range') {\n        const {\n            range: { startContainer, startOffset, endContainer, endOffset },\n            isReverted,\n        } = selection;\n        state.cachedSelection = {\n            type: 'range',\n            isReverted: isReverted,\n            start: {\n                node: startContainer,\n                offset: startOffset,\n            },\n            end: {\n                node: endContainer,\n                offset: endOffset,\n            },\n        };\n    } else {\n        state.cachedSelection = selection ?? undefined;\n    }\n}\n","import { getSelectionRootNode } from 'roosterjs-content-model-dom';\nimport type {\n    ContextMenuPluginState,\n    ContextMenuProvider,\n    IEditor,\n    PluginWithState,\n    EditorOptions,\n    DOMEventRecord,\n} from 'roosterjs-content-model-types';\n\nconst ContextMenuButton = 2;\n\n/**\n * Edit Component helps handle Content edit features\n */\nclass ContextMenuPlugin implements PluginWithState<ContextMenuPluginState> {\n    private editor: IEditor | null = null;\n    private state: ContextMenuPluginState;\n    private disposer: (() => void) | null = null;\n\n    /**\n     * Construct a new instance of EditPlugin\n     * @param options The editor options\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            contextMenuProviders:\n                options.plugins?.filter<ContextMenuProvider<any>>(isContextMenuProvider) || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContextMenu';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        const eventHandlers: Partial<\n            { [P in keyof HTMLElementEventMap]: DOMEventRecord<HTMLElementEventMap[P]> }\n        > = {\n            contextmenu: {\n                beforeDispatch: (event: MouseEvent | PointerEvent) =>\n                    this.onContextMenuEvent(event),\n            },\n        };\n        this.disposer = this.editor.attachDomEvent(<Record<string, DOMEventRecord>>eventHandlers);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer?.();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onContextMenuEvent = (e: MouseEvent | PointerEvent) => {\n        if (this.editor) {\n            const allItems: any[] = [];\n            const mouseEvent = e as MouseEvent;\n            const pointerEvent = e as PointerEvent;\n\n            // ContextMenu event can be triggered from mouse right click or keyboard (e.g. Shift+F10 on Windows)\n            // Need to check if this is from keyboard, we need to get target node from selection because in that case\n            // event.target is always the element that attached context menu event, here it will be editor content div.\n            const targetNode =\n                mouseEvent.button == ContextMenuButton\n                    ? (mouseEvent.target as Node)\n                    : pointerEvent?.pointerType === 'touch' || pointerEvent?.pointerType === 'pen'\n                    ? (pointerEvent.target as Node)\n                    : this.getFocusedNode(this.editor);\n\n            if (targetNode) {\n                this.state.contextMenuProviders.forEach(provider => {\n                    const items = provider.getContextMenuItems(targetNode, mouseEvent) ?? [];\n                    if (items?.length > 0) {\n                        if (allItems.length > 0) {\n                            allItems.push(null);\n                        }\n\n                        allItems.push(...items);\n                    }\n                });\n            }\n\n            this.editor?.triggerEvent('contextMenu', {\n                rawEvent: mouseEvent,\n                items: allItems,\n            });\n        }\n    };\n\n    private getFocusedNode(editor: IEditor) {\n        const selection = editor.getDOMSelection();\n\n        if (selection) {\n            if (selection.type == 'range') {\n                selection.range.collapse(true /*toStart*/);\n            }\n\n            return getSelectionRootNode(selection) || null;\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction isContextMenuProvider(source: unknown): source is ContextMenuProvider<any> {\n    return !!(<ContextMenuProvider<any>>source)?.getContextMenuItems;\n}\n\n/**\n * @internal\n * Create a new instance of EditPlugin.\n */\nexport function createContextMenuPlugin(\n    options: EditorOptions\n): PluginWithState<ContextMenuPluginState> {\n    return new ContextMenuPlugin(options);\n}\n","import { deleteEmptyList } from './utils/deleteEmptyList';\nimport { getContentForCopy } from '../../command/cutCopy/getContentForCopy';\nimport { paste } from '../../command/paste/paste';\nimport {\n    ChangeSource,\n    deleteSelection,\n    extractClipboardItems,\n    normalizeContentModel,\n    toArray,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ClipboardData,\n    CopyPastePluginState,\n    IEditor,\n    EditorOptions,\n    PluginWithState,\n} from 'roosterjs-content-model-types';\n\n/**\n * Copy and paste plugin for handling onCopy and onPaste event\n */\nclass CopyPastePlugin implements PluginWithState<CopyPastePluginState> {\n    private editor: IEditor | null = null;\n    private disposer: (() => void) | null = null;\n    private state: CopyPastePluginState;\n\n    /**\n     * Construct a new instance of CopyPastePlugin\n     * @param option The editor option\n     */\n    constructor(option: EditorOptions) {\n        this.state = {\n            allowedCustomPasteType: option.allowedCustomPasteType || [],\n            tempDiv: null,\n            defaultPasteType: option.defaultPasteType,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'CopyPaste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.attachDomEvent({\n            paste: {\n                beforeDispatch: e => this.onPaste(e),\n            },\n            copy: {\n                beforeDispatch: e => this.onCutCopy(e, false /*isCut*/),\n            },\n            cut: {\n                beforeDispatch: e => this.onCutCopy(e, true /*isCut*/),\n            },\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        if (this.state.tempDiv) {\n            this.state.tempDiv.parentNode?.removeChild(this.state.tempDiv);\n            this.state.tempDiv = null;\n        }\n\n        if (this.disposer) {\n            this.disposer();\n        }\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onCutCopy(event: Event, isCut: boolean) {\n        if (!this.editor || !isClipboardEvent(event)) {\n            return;\n        }\n\n        const textAndHtmlContent = getContentForCopy(this.editor, isCut, event);\n\n        if (textAndHtmlContent) {\n            const { htmlContent, textContent } = textAndHtmlContent;\n            event.preventDefault();\n            event.clipboardData?.setData('text/html', htmlContent.innerHTML);\n            event.clipboardData?.setData('text/plain', textContent);\n\n            if (isCut) {\n                this.editor.formatContentModel(\n                    (model, context) => {\n                        if (\n                            deleteSelection(model, [deleteEmptyList], context).deleteResult ==\n                            'range'\n                        ) {\n                            normalizeContentModel(model);\n                        }\n\n                        return true;\n                    },\n                    {\n                        apiName: 'cut',\n                        changeSource: ChangeSource.Cut,\n                    }\n                );\n            }\n        }\n    }\n\n    private onPaste = (event: Event) => {\n        if (this.editor && isClipboardEvent(event)) {\n            const editor = this.editor;\n\n            const dataTransfer = event.clipboardData;\n\n            if (shouldPreventDefaultPaste(dataTransfer, editor)) {\n                event.preventDefault();\n                extractClipboardItems(\n                    toArray(dataTransfer!.items),\n                    this.state.allowedCustomPasteType\n                ).then((clipboardData: ClipboardData) => {\n                    if (!editor.isDisposed()) {\n                        paste(editor, clipboardData, this.state.defaultPasteType);\n                    }\n                });\n            }\n        }\n    };\n}\n\nfunction isClipboardEvent(event: Event): event is ClipboardEvent {\n    return !!(event as ClipboardEvent).clipboardData;\n}\n\n/**\n * @internal\n * Exported only for unit testing\n */\nexport function shouldPreventDefaultPaste(\n    dataTransfer: DataTransfer | null,\n    editor: IEditor\n): boolean {\n    if (!dataTransfer?.items) {\n        return false;\n    }\n\n    if (!editor.getEnvironment().isAndroid) {\n        return true;\n    }\n\n    // On Android, the clipboard data from Office apps is a file, which can't be loaded\n    // so we have to allow the default browser behavior\n    return toArray(dataTransfer.items).some(item => {\n        const { type } = item;\n        const isNormalFile = item.kind === 'file' && type !== '';\n        const isText = type.indexOf('text/') === 0;\n        return isNormalFile || isText;\n    });\n}\n\n/**\n * @internal\n * Create a new instance of CopyPastePlugin\n * @param option The editor option\n */\nexport function createCopyPastePlugin(\n    option: EditorOptions\n): PluginWithState<CopyPastePluginState> {\n    return new CopyPastePlugin(option);\n}\n","import {\n    getClosestAncestorBlockGroupIndex,\n    hasSelectionInBlock,\n    hasSelectionInBlockGroup,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DeleteSelectionContext,\n    DeleteSelectionStep,\n    ReadonlyContentModelBlock,\n} from 'roosterjs-content-model-types';\n\nfunction isEmptyBlock(block: ReadonlyContentModelBlock | undefined): boolean {\n    if (block && block.blockType == 'Paragraph') {\n        return block.segments.every(\n            segment => segment.segmentType !== 'SelectionMarker' && segment.segmentType == 'Br'\n        );\n    }\n\n    if (block && block.blockType == 'BlockGroup') {\n        return block.blocks.every(isEmptyBlock);\n    }\n\n    return !!block;\n}\n\n/**\n * @internal\n * If the first item o the list is selected in a expanded selection, we need to remove the list item levels\n * @param context A context object provided by formatContentModel API\n */\nexport const deleteEmptyList: DeleteSelectionStep = (context: DeleteSelectionContext) => {\n    const { insertPoint, deleteResult } = context;\n    if (deleteResult == 'range' && insertPoint?.path) {\n        const index = getClosestAncestorBlockGroupIndex(\n            insertPoint.path,\n            ['ListItem'],\n            ['TableCell']\n        );\n        const item = insertPoint.path[index];\n        if (index >= 0 && item && item.blockGroupType == 'ListItem') {\n            const listItemIndex = insertPoint.path[index + 1].blocks.indexOf(item);\n            const previousBlock =\n                listItemIndex > -1\n                    ? insertPoint.path[index + 1].blocks[listItemIndex - 1]\n                    : undefined;\n            const nextBlock =\n                listItemIndex > -1\n                    ? insertPoint.path[index + 1].blocks[listItemIndex + 1]\n                    : undefined;\n            if (\n                hasSelectionInBlockGroup(item) &&\n                (!previousBlock || hasSelectionInBlock(previousBlock)) &&\n                nextBlock &&\n                isEmptyBlock(nextBlock)\n            ) {\n                mutateBlock(item).levels = [];\n            }\n        }\n    }\n};\n","import { createCachePlugin } from './cache/CachePlugin';\nimport { createContextMenuPlugin } from './contextMenu/ContextMenuPlugin';\nimport { createCopyPastePlugin } from './copyPaste/CopyPastePlugin';\nimport { createDOMEventPlugin } from './domEvent/DOMEventPlugin';\nimport { createEntityPlugin } from './entity/EntityPlugin';\nimport { createFormatPlugin } from './format/FormatPlugin';\nimport { createLifecyclePlugin } from './lifecycle/LifecyclePlugin';\nimport { createSelectionPlugin } from './selection/SelectionPlugin';\nimport { createUndoPlugin } from './undo/UndoPlugin';\nimport type { EditorCorePlugins, EditorOptions } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create core plugins for editor\n * @param options Options of editor\n */\nexport function createEditorCorePlugins(\n    options: EditorOptions,\n    contentDiv: HTMLDivElement\n): EditorCorePlugins {\n    return {\n        cache: createCachePlugin(options, contentDiv),\n        format: createFormatPlugin(options),\n        copyPaste: createCopyPastePlugin(options),\n        domEvent: createDOMEventPlugin(options, contentDiv),\n        lifecycle: createLifecyclePlugin(options, contentDiv),\n        entity: createEntityPlugin(),\n        selection: createSelectionPlugin(options),\n        contextMenu: createContextMenuPlugin(options),\n        undo: createUndoPlugin(options),\n    };\n}\n","import {\n    ChangeSource,\n    isCharacterValue,\n    isCursorMovingKey,\n    isNodeOfType,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DOMEventPluginState,\n    IEditor,\n    DOMEventRecord,\n    EditorOptions,\n    PluginWithState,\n} from 'roosterjs-content-model-types';\n\nconst EventTypeMap: Record<string, 'keyDown' | 'keyUp' | 'keyPress'> = {\n    keydown: 'keyDown',\n    keyup: 'keyUp',\n    keypress: 'keyPress',\n};\n\n/**\n * DOMEventPlugin handles customized DOM events, including:\n * 1. Keyboard event\n * 2. Mouse event\n * 3. IME state\n * 4. Drop event\n * 5. Focus and blur event\n * 6. Input event\n * 7. Scroll event\n * It contains special handling for Safari since Safari cannot get correct selection when onBlur event is triggered in editor.\n */\nclass DOMEventPlugin implements PluginWithState<DOMEventPluginState> {\n    private editor: IEditor | null = null;\n    private disposer: (() => void) | null = null;\n    private state: DOMEventPluginState;\n    private pointerEvent: PointerEvent | null = null;\n    private timer = 0;\n\n    /**\n     * Construct a new instance of DOMEventPlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.state = {\n            isInIME: false,\n            scrollContainer: options.scrollContainer || contentDiv,\n            mouseDownX: null,\n            mouseDownY: null,\n            mouseUpEventListerAdded: false,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'DOMEvent';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        const document = this.editor.getDocument();\n        const eventHandlers: Partial<\n            { [P in keyof HTMLElementEventMap]: DOMEventRecord<HTMLElementEventMap[P]> }\n        > = {\n            // 1. Keyboard event\n            keypress: this.keyboardEventHandler,\n            keydown: this.keyboardEventHandler,\n            keyup: this.keyboardEventHandler,\n            input: this.inputEventHandler,\n\n            // 2. Mouse event\n            mousedown: { beforeDispatch: this.onMouseDown },\n            dblclick: { beforeDispatch: (event: MouseEvent) => this.onDoubleClick(event) },\n\n            // 3. IME state management\n            compositionstart: { beforeDispatch: this.onCompositionStart },\n            compositionend: { beforeDispatch: this.onCompositionEnd },\n\n            // 4. Drag and Drop event\n            dragstart: { beforeDispatch: this.onDragStart },\n            drop: { beforeDispatch: this.onDrop },\n\n            // 5. Pointer event\n            pointerdown: { beforeDispatch: (event: PointerEvent) => this.onPointerDown(event) },\n        };\n\n        this.disposer = this.editor.attachDomEvent(<Record<string, DOMEventRecord>>eventHandlers);\n\n        // 7. Scroll event\n        this.state.scrollContainer.addEventListener('scroll', this.onScroll);\n        document.defaultView?.addEventListener('scroll', this.onScroll);\n        document.defaultView?.addEventListener('resize', this.onScroll);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.removeMouseUpEventListener();\n\n        const document = this.editor?.getDocument();\n        document?.defaultView?.removeEventListener('resize', this.onScroll);\n        document?.defaultView?.removeEventListener('scroll', this.onScroll);\n        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);\n        this.disposer?.();\n        this.disposer = null;\n        this.editor = null;\n        this.pointerEvent = null;\n\n        if (this.timer) {\n            document?.defaultView?.clearTimeout(this.timer);\n            this.timer = 0;\n        }\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onDragStart = (e: Event) => {\n        const dragEvent = e as DragEvent;\n        const node = dragEvent.target as Node;\n        const element = isNodeOfType(node, 'ELEMENT_NODE') ? node : node.parentElement;\n\n        if (element && !element.isContentEditable) {\n            dragEvent.preventDefault();\n        }\n    };\n\n    private onDrop = () => {\n        const doc = this.editor?.getDocument();\n\n        doc?.defaultView?.requestAnimationFrame(() => {\n            if (this.editor) {\n                this.editor.takeSnapshot();\n                this.editor.triggerEvent('contentChanged', {\n                    source: ChangeSource.Drop,\n                });\n            }\n        });\n    };\n\n    private onScroll = (e: Event) => {\n        this.editor?.triggerEvent('scroll', {\n            rawEvent: e,\n            scrollContainer: this.state.scrollContainer,\n        });\n    };\n\n    private keyboardEventHandler: DOMEventRecord<KeyboardEvent> = {\n        beforeDispatch: event => {\n            const eventType = EventTypeMap[event.type];\n\n            if (isCharacterValue(event) || isCursorMovingKey(event)) {\n                // Stop propagation for Character keys and Up/Down/Left/Right/Home/End/PageUp/PageDown\n                // since editor already handles these keys and no need to propagate to parents\n                event.stopPropagation();\n            }\n\n            const isAndroid = this.editor?.getEnvironment()?.isAndroid ?? false;\n            const isComposing = !isAndroid && (event.isComposing || this.state.isInIME);\n\n            if (this.editor && eventType && !isComposing) {\n                this.editor.triggerEvent(eventType, {\n                    rawEvent: event,\n                });\n            }\n        },\n    };\n\n    private inputEventHandler: DOMEventRecord<Event> = {\n        beforeDispatch: event => {\n            event.stopPropagation();\n\n            const isAndroid = this.editor?.getEnvironment()?.isAndroid ?? false;\n            const isComposing =\n                !isAndroid && ((event as InputEvent).isComposing || this.state.isInIME);\n\n            if (this.editor && !isComposing) {\n                this.editor.triggerEvent('input', {\n                    rawEvent: event as InputEvent,\n                });\n            }\n        },\n    };\n\n    private onMouseDown = (event: MouseEvent) => {\n        if (this.editor) {\n            if (!this.state.mouseUpEventListerAdded) {\n                this.editor\n                    .getDocument()\n                    .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\n                this.state.mouseUpEventListerAdded = true;\n                this.state.mouseDownX = event.pageX;\n                this.state.mouseDownY = event.pageY;\n            }\n\n            this.editor.triggerEvent('mouseDown', {\n                rawEvent: event,\n            });\n\n            if (event.defaultPrevented) {\n                this.pointerEvent = null;\n            }\n            if (this.pointerEvent) {\n                this.editor.triggerEvent('pointerDown', {\n                    rawEvent: this.pointerEvent,\n                    originalEvent: event,\n                });\n            }\n        }\n    };\n\n    private onMouseUp = (rawEvent: MouseEvent) => {\n        if (this.editor) {\n            this.removeMouseUpEventListener();\n            this.editor.triggerEvent('mouseUp', {\n                rawEvent,\n                isClicking:\n                    this.state.mouseDownX == rawEvent.pageX &&\n                    this.state.mouseDownY == rawEvent.pageY,\n            });\n        }\n        if (this.pointerEvent) {\n            this.pointerEvent = null;\n        }\n    };\n\n    private onDoubleClick = (event: MouseEvent) => {\n        if (this.editor) {\n            this.editor.triggerEvent('doubleClick', {\n                rawEvent: event,\n            });\n        }\n    };\n\n    private onCompositionStart = () => {\n        this.state.isInIME = true;\n    };\n\n    private onCompositionEnd = (rawEvent: CompositionEvent) => {\n        this.state.isInIME = false;\n        this.editor?.triggerEvent('compositionEnd', {\n            rawEvent,\n        });\n    };\n\n    private removeMouseUpEventListener() {\n        if (this.editor && this.state.mouseUpEventListerAdded) {\n            this.state.mouseUpEventListerAdded = false;\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private onPointerDown = (e: PointerEvent) => {\n        if (e.pointerType === 'touch' || e.pointerType === 'pen') {\n            this.pointerEvent = e;\n        }\n    };\n}\n\n/**\n * @internal\n * Create a new instance of DOMEventPlugin.\n * @param option The editor option\n * @param contentDiv The editor content DIV element\n */\nexport function createDOMEventPlugin(\n    option: EditorOptions,\n    contentDiv: HTMLDivElement\n): PluginWithState<DOMEventPluginState> {\n    return new DOMEventPlugin(option, contentDiv);\n}\n","import { findAllEntities } from './findAllEntities';\nimport {\n    createEntity,\n    generateEntityClassNames,\n    getAllEntityWrappers,\n    getObjectKeys,\n    isEntityElement,\n    parseEntityFormat,\n    transformColor,\n} from 'roosterjs-content-model-dom';\nimport {\n    handleCompositionEndEvent,\n    handleDelimiterContentChangedEvent,\n    handleDelimiterKeyDownEvent,\n} from './entityDelimiterUtils';\nimport type {\n    ChangedEntity,\n    ContentChangedEvent,\n    EntityOperation,\n    EntityPluginState,\n    IEditor,\n    MouseUpEvent,\n    PluginEvent,\n    PluginWithState,\n} from 'roosterjs-content-model-types';\n\nconst ENTITY_ID_REGEX = /_(\\d{1,8})$/;\n\n/**\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\n */\nclass EntityPlugin implements PluginWithState<EntityPluginState> {\n    private editor: IEditor | null = null;\n    private state: EntityPluginState;\n\n    /**\n     * Construct a new instance of EntityPlugin\n     */\n    constructor() {\n        this.state = {\n            entityMap: {},\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Entity';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.state.entityMap = {};\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case 'mouseUp':\n                    this.handleMouseUpEvent(this.editor, event);\n                    break;\n                case 'contentChanged':\n                    this.handleContentChangedEvent(this.editor, event);\n                    break;\n                case 'keyDown':\n                    handleDelimiterKeyDownEvent(this.editor, event);\n                    break;\n                case 'compositionEnd':\n                    handleCompositionEndEvent(this.editor, event);\n                    break;\n                case 'editorReady':\n                    this.handleContentChangedEvent(this.editor);\n                    break;\n                case 'extractContentWithDom':\n                    this.handleExtractContentWithDomEvent(this.editor, event.clonedRoot);\n                    break;\n            }\n        }\n    }\n\n    private handleMouseUpEvent(editor: IEditor, event: MouseUpEvent) {\n        const { rawEvent, isClicking } = event;\n        let node: Node | null = rawEvent.target as Node;\n\n        if (isClicking && this.editor) {\n            while (node && this.editor.getDOMHelper().isNodeInEditor(node)) {\n                if (isEntityElement(node)) {\n                    this.triggerEvent(editor, node as HTMLElement, 'click', rawEvent);\n                    break;\n                } else {\n                    node = node.parentNode;\n                }\n            }\n        }\n    }\n\n    private handleContentChangedEvent(editor: IEditor, event?: ContentChangedEvent) {\n        const modifiedEntities: ChangedEntity[] =\n            event?.changedEntities ?? this.getChangedEntities(editor);\n        const entityStates = event?.entityStates;\n\n        modifiedEntities.forEach(entry => {\n            const { entity, operation, rawEvent } = entry;\n            const {\n                entityFormat: { id, entityType, isFakeEntity },\n                wrapper,\n            } = entity;\n\n            if (entityType && !isFakeEntity) {\n                if (operation == 'newEntity') {\n                    entity.entityFormat.id = this.ensureUniqueId(entityType, id ?? '', wrapper);\n                    wrapper.className = generateEntityClassNames(entity.entityFormat);\n\n                    if (entity.entityFormat.isReadonly) {\n                        wrapper.contentEditable = 'false';\n                    }\n\n                    const eventResult = this.triggerEvent(editor, wrapper, operation, rawEvent);\n\n                    this.state.entityMap[entity.entityFormat.id] = {\n                        element: wrapper,\n                        canPersist: eventResult?.shouldPersist,\n                    };\n\n                    if (editor.isDarkMode()) {\n                        transformColor(\n                            wrapper,\n                            true /*includeSelf*/,\n                            'lightToDark',\n                            editor.getColorManager(),\n                            {\n                                tableBorders: editor.isExperimentalFeatureEnabled(\n                                    'TransformTableBorderColors'\n                                ),\n                            }\n                        );\n                    }\n                } else if (id) {\n                    const mapEntry = this.state.entityMap[id];\n\n                    if (mapEntry) {\n                        mapEntry.isDeleted = true;\n                    }\n\n                    this.triggerEvent(editor, wrapper, operation, rawEvent);\n                }\n            }\n        });\n\n        entityStates?.forEach(entityState => {\n            const { id, state } = entityState;\n            const wrapper = this.state.entityMap[id]?.element;\n\n            if (wrapper) {\n                this.triggerEvent(\n                    editor,\n                    wrapper,\n                    'updateEntityState',\n                    undefined /*rawEvent*/,\n                    state\n                );\n            }\n        });\n\n        handleDelimiterContentChangedEvent(editor);\n    }\n\n    private getChangedEntities(editor: IEditor): ChangedEntity[] {\n        const result: ChangedEntity[] = [];\n\n        editor.formatContentModel(model => {\n            findAllEntities(model, result);\n            return false;\n        });\n\n        getObjectKeys(this.state.entityMap).forEach(id => {\n            const entry = this.state.entityMap[id];\n\n            if (!entry.isDeleted) {\n                const index = result.findIndex(\n                    x =>\n                        x.operation == 'newEntity' &&\n                        x.entity.entityFormat.id == id &&\n                        x.entity.wrapper == entry.element\n                );\n\n                if (index >= 0) {\n                    // Found matched entity in editor, so there is no change to this entity,\n                    // we can safely remove it from the new entity array\n                    result.splice(index, 1);\n                } else {\n                    // Entity is not in editor, which means it is deleted, use a temporary entity here to represent this entity\n                    const format = parseEntityFormat(entry.element);\n\n                    if (!format.isFakeEntity) {\n                        const entity = createEntity(\n                            entry.element,\n                            format.isReadonly,\n                            {},\n                            format.entityType,\n                            format.id\n                        );\n\n                        result.push({\n                            entity: entity,\n                            operation: 'overwrite',\n                        });\n                    }\n                }\n            }\n        });\n\n        return result;\n    }\n\n    private handleExtractContentWithDomEvent(editor: IEditor, root: HTMLElement) {\n        getAllEntityWrappers(root).forEach(element => {\n            element.removeAttribute('contentEditable');\n\n            this.triggerEvent(editor, element, 'replaceTemporaryContent');\n        });\n    }\n\n    private triggerEvent(\n        editor: IEditor,\n        wrapper: HTMLElement,\n        operation: EntityOperation,\n        rawEvent?: Event,\n        state?: string\n    ) {\n        const format = parseEntityFormat(wrapper);\n\n        return format.id && format.entityType && !format.isFakeEntity\n            ? editor.triggerEvent('entityOperation', {\n                  operation: operation,\n                  rawEvent,\n                  entity: {\n                      id: format.id,\n                      type: format.entityType,\n                      isReadonly: !!format.isReadonly,\n                      wrapper,\n                  },\n                  state: operation == 'updateEntityState' ? state : undefined,\n                  shouldPersist: operation == 'newEntity' ? true : undefined, // By default, we always persist entity now\n              })\n            : null;\n    }\n\n    private ensureUniqueId(type: string, id: string, wrapper: HTMLElement): string {\n        const match = ENTITY_ID_REGEX.exec(id);\n        const baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;\n\n        // Make sure entity id is unique\n        let newId = '';\n\n        for (let num = (match && parseInt(match[1])) || 0; ; num++) {\n            newId = num > 0 ? `${baseId}_${num}` : baseId;\n\n            const item = this.state.entityMap[newId];\n\n            if (!item || item.element == wrapper) {\n                break;\n            }\n        }\n\n        return newId;\n    }\n}\n\n/**\n * @internal\n * Create a new instance of EntityPlugin.\n */\nexport function createEntityPlugin(): PluginWithState<EntityPluginState> {\n    return new EntityPlugin();\n}\n","import {\n    getSelectedSegmentsAndParagraphs,\n    isBlockEntityContainer,\n    isEntityDelimiter,\n    isNodeOfType,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelEntity,\n    IEditor,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function adjustSelectionAroundEntity(\n    editor: IEditor,\n    key: 'ArrowLeft' | 'ArrowRight',\n    shiftKey: boolean\n) {\n    const selection = editor.isDisposed() ? null : editor.getDOMSelection();\n\n    if (!selection || selection.type != 'range') {\n        return;\n    }\n\n    const { range, isReverted } = selection;\n    const anchorNode = isReverted ? range.startContainer : range.endContainer;\n    const offset = isReverted ? range.startOffset : range.endOffset;\n    const delimiter = isNodeOfType(anchorNode, 'ELEMENT_NODE')\n        ? anchorNode\n        : anchorNode.parentElement;\n    const isRtl =\n        delimiter &&\n        editor.getDocument().defaultView?.getComputedStyle(delimiter).direction == 'rtl';\n    const movingBefore = (key == 'ArrowLeft') != !!isRtl;\n\n    if (\n        delimiter &&\n        ((isEntityDelimiter(delimiter, !movingBefore) &&\n            ((movingBefore && offset == 0) || (!movingBefore && offset == 1))) ||\n            isBlockEntityContainer(delimiter))\n    ) {\n        editor.formatContentModel(model => {\n            const allSel = getSelectedSegmentsAndParagraphs(\n                model,\n                false /*includingFormatHolder*/,\n                true /*includingEntity*/\n            );\n            const sel = allSel[isReverted ? 0 : allSel.length - 1];\n            const index = sel?.[1]?.segments.indexOf(sel[0]) ?? -1;\n\n            if (sel && sel[1] && index >= 0) {\n                const [segment, paragraph, path] = sel;\n                const isShrinking = shiftKey && !range.collapsed && movingBefore != !!isReverted;\n                const entitySegment = isShrinking\n                    ? segment\n                    : paragraph.segments[movingBefore ? index - 1 : index + 1];\n\n                const pairedDelimiter = findPairedDelimiter(\n                    entitySegment,\n                    path,\n                    paragraph,\n                    movingBefore\n                );\n\n                if (pairedDelimiter) {\n                    const newRange = getNewRange(\n                        range,\n                        isShrinking,\n                        movingBefore,\n                        pairedDelimiter,\n                        shiftKey\n                    );\n\n                    editor.setDOMSelection({\n                        type: 'range',\n                        range: newRange,\n                        isReverted: newRange.collapsed ? false : isReverted,\n                    });\n                }\n            }\n\n            return false;\n        });\n    }\n}\n\nfunction getNewRange(\n    originalRange: Range,\n    isShrinking: boolean,\n    movingBefore: boolean,\n    pairedDelimiter: HTMLElement,\n    shiftKey: boolean\n) {\n    const newRange = originalRange.cloneRange();\n\n    if (isShrinking) {\n        if (movingBefore) {\n            newRange.setEndBefore(pairedDelimiter);\n        } else {\n            newRange.setStartAfter(pairedDelimiter);\n        }\n    } else {\n        if (movingBefore) {\n            newRange.setStartBefore(pairedDelimiter);\n        } else {\n            newRange.setEndAfter(pairedDelimiter);\n        }\n        if (!shiftKey) {\n            if (movingBefore) {\n                newRange.setEndBefore(pairedDelimiter);\n            } else {\n                newRange.setStartAfter(pairedDelimiter);\n            }\n        }\n    }\n\n    return newRange;\n}\n\nfunction findPairedDelimiter(\n    entitySegment: ReadonlyContentModelSegment,\n    path: ReadonlyContentModelBlockGroup[],\n    paragraph: ReadonlyContentModelParagraph,\n    movingBefore: boolean\n) {\n    let entity: ContentModelEntity | null = null;\n\n    if (entitySegment?.segmentType == 'Entity') {\n        // Inline entity\n        entity = entitySegment;\n    } else {\n        // Block entity\n        const blocks = path[0].blocks;\n        const paraIndex = blocks.indexOf(paragraph);\n        const entityBlock =\n            paraIndex >= 0 ? blocks[movingBefore ? paraIndex - 1 : paraIndex + 1] : null;\n\n        if (entityBlock?.blockType == 'Entity') {\n            entity = entityBlock;\n        }\n    }\n\n    const pairedDelimiter = entity\n        ? movingBefore\n            ? entity.wrapper.previousElementSibling\n            : entity.wrapper.nextElementSibling\n        : null;\n\n    return isNodeOfType(pairedDelimiter, 'ELEMENT_NODE') &&\n        isEntityDelimiter(pairedDelimiter, movingBefore)\n        ? pairedDelimiter\n        : null;\n}\n","import { adjustSelectionAroundEntity } from './adjustSelectionAroundEntity';\nimport { normalizePos } from '../selection/normalizePos';\nimport {\n    addDelimiters,\n    createBr,\n    createModelToDomContext,\n    createParagraph,\n    isEntityDelimiter,\n    isEntityElement,\n    isNodeOfType,\n    parseEntityFormat,\n    findClosestEntityWrapper,\n    iterateSelections,\n    isCharacterValue,\n    findClosestBlockEntityContainer,\n    mutateSegment,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    CompositionEndEvent,\n    ContentModelFormatter,\n    ContentModelSegmentFormat,\n    IEditor,\n    KeyDownEvent,\n    RangeSelection,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelParagraph,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\nconst DelimiterBefore = 'entityDelimiterBefore';\nconst DelimiterAfter = 'entityDelimiterAfter';\nconst DelimiterSelector = '.' + DelimiterAfter + ',.' + DelimiterBefore;\nconst ZeroWidthSpace = '\\u200B';\nconst EntityInfoName = '_Entity';\nconst InlineEntitySelector = 'span.' + EntityInfoName;\n\n/**\n * @internal exported only for unit test\n */\nexport function preventTypeInDelimiter(node: HTMLElement, editor: IEditor) {\n    const isAfter = node.classList.contains(DelimiterAfter);\n    const entitySibling = isAfter ? node.previousElementSibling : node.nextElementSibling;\n    if (entitySibling && isEntityElement(entitySibling)) {\n        removeInvalidDelimiters(\n            [entitySibling.previousElementSibling, entitySibling.nextElementSibling].filter(\n                element => !!element\n            ) as HTMLElement[]\n        );\n        editor.formatContentModel((model, context) => {\n            iterateSelections(model, (_path, _tableContext, block, _segments) => {\n                if (block?.blockType == 'Paragraph') {\n                    block.segments.forEach(segment => {\n                        if (\n                            segment.segmentType == 'Text' &&\n                            segment.text.indexOf(ZeroWidthSpace) >= 0\n                        ) {\n                            mutateSegment(block, segment, segment => {\n                                segment.text = segment.text.replace(ZeroWidthSpace, '');\n                            });\n                        }\n                    });\n                }\n            });\n\n            context.skipUndoSnapshot = true;\n\n            return true;\n        });\n    }\n}\n\nfunction addDelimitersIfNeeded(\n    nodes: Element[] | NodeListOf<Element>,\n    format: ContentModelSegmentFormat | null\n) {\n    if (nodes.length > 0) {\n        const context = createModelToDomContext();\n        nodes.forEach(node => {\n            if (\n                isNodeOfType(node, 'ELEMENT_NODE') &&\n                isEntityElement(node) &&\n                !node.isContentEditable\n            ) {\n                addDelimiters(node.ownerDocument, node as HTMLElement, format, context);\n            }\n        });\n    }\n}\n\nfunction removeNode(el: Node | undefined | null) {\n    el?.parentElement?.removeChild(el);\n}\n\nfunction removeInvalidDelimiters(nodes: Element[] | NodeListOf<Element>) {\n    nodes.forEach(node => {\n        if (!isNodeOfType(node, 'ELEMENT_NODE')) {\n            return;\n        }\n        if (isEntityDelimiter(node)) {\n            const sibling = node.classList.contains(DelimiterBefore)\n                ? node.nextElementSibling\n                : node.previousElementSibling;\n            if (!(isNodeOfType(sibling, 'ELEMENT_NODE') && isEntityElement(sibling))) {\n                removeNode(node);\n            }\n        } else {\n            removeDelimiterAttr(node);\n        }\n    });\n}\n\nfunction removeDelimiterAttr(node: Element | undefined | null, checkEntity: boolean = true) {\n    if (!node) {\n        return;\n    }\n\n    const isAfter = node.classList.contains(DelimiterAfter);\n    const entitySibling = isAfter ? node.previousElementSibling : node.nextElementSibling;\n    if (checkEntity && entitySibling && isEntityElement(entitySibling)) {\n        return;\n    }\n\n    node.classList.remove(DelimiterAfter, DelimiterBefore);\n\n    node.normalize();\n    node.childNodes.forEach(cn => {\n        const index = cn.textContent?.indexOf(ZeroWidthSpace) ?? -1;\n        if (index >= 0) {\n            const range = new Range();\n            range.setStart(cn, index);\n            range.setEnd(cn, index + 1);\n            range.deleteContents();\n        }\n    });\n}\n\nfunction getFocusedElement(\n    selection: RangeSelection,\n    existingTextInDelimiter?: string\n): HTMLElement | null {\n    const { range, isReverted } = selection;\n    let node: Node | null = isReverted ? range.startContainer : range.endContainer;\n    let offset = isReverted ? range.startOffset : range.endOffset;\n\n    if (node) {\n        const pos = normalizePos(node, offset);\n        node = pos.node;\n        offset = pos.offset;\n    }\n\n    if (!isNodeOfType(node, 'ELEMENT_NODE')) {\n        const textToCheck = existingTextInDelimiter\n            ? ZeroWidthSpace + existingTextInDelimiter\n            : ZeroWidthSpace;\n\n        if (node.textContent != textToCheck && (node.textContent || '').length == offset) {\n            node = node.nextSibling ?? node.parentElement?.closest(DelimiterSelector) ?? null;\n        } else {\n            node = node?.parentElement?.closest(DelimiterSelector) ?? null;\n        }\n    } else {\n        node = node.childNodes.length == offset ? node : node.childNodes.item(offset);\n    }\n    if (node && !node.hasChildNodes()) {\n        node = node.nextSibling;\n    }\n    return isNodeOfType(node, 'ELEMENT_NODE') ? node : null;\n}\n\n/**\n * @internal\n */\nexport function handleDelimiterContentChangedEvent(editor: IEditor) {\n    const helper = editor.getDOMHelper();\n    removeInvalidDelimiters(helper.queryElements(DelimiterSelector));\n    addDelimitersIfNeeded(helper.queryElements(InlineEntitySelector), editor.getPendingFormat());\n}\n\n/**\n * @internal\n */\nexport function handleCompositionEndEvent(editor: IEditor, event: CompositionEndEvent) {\n    const selection = editor.getDOMSelection();\n\n    if (selection?.type == 'range' && selection.range.collapsed) {\n        const node = getFocusedElement(selection, event.rawEvent.data);\n\n        if (\n            node?.firstChild &&\n            isNodeOfType(node.firstChild, 'TEXT_NODE') &&\n            node.matches(DelimiterSelector) &&\n            node.textContent == ZeroWidthSpace + event.rawEvent.data\n        ) {\n            preventTypeInDelimiter(node, editor);\n        }\n    }\n}\n\n/**\n * @internal\n */\nexport function handleDelimiterKeyDownEvent(editor: IEditor, event: KeyDownEvent) {\n    const selection = editor.getDOMSelection();\n\n    if (!selection || selection.type != 'range') {\n        return;\n    }\n\n    const rawEvent = event.rawEvent;\n    const range = selection.range;\n    const key = rawEvent.key;\n\n    switch (key) {\n        case 'Enter':\n            const helper = editor.getDOMHelper();\n            const entity = findClosestEntityWrapper(range.startContainer, helper);\n\n            if (entity && isNodeOfType(entity, 'ELEMENT_NODE') && helper.isNodeInEditor(entity)) {\n                triggerEntityEventOnEnter(editor, entity, rawEvent);\n            }\n\n            break;\n\n        case 'ArrowLeft':\n        case 'ArrowRight':\n            if (!rawEvent.altKey && !rawEvent.ctrlKey && !rawEvent.metaKey) {\n                // Handle in async so focus is already moved, this makes us easier to check if we should adjust the selection\n                editor.getDocument().defaultView?.requestAnimationFrame(() => {\n                    adjustSelectionAroundEntity(editor, key, rawEvent.shiftKey);\n                });\n            }\n            break;\n\n        default:\n            if (isCharacterValue(rawEvent) && range.collapsed) {\n                handleInputOnDelimiter(editor, range, getFocusedElement(selection), rawEvent);\n            }\n\n            break;\n    }\n}\n\nfunction handleInputOnDelimiter(\n    editor: IEditor,\n    range: Range,\n    focusedNode: HTMLElement | null,\n    rawEvent: KeyboardEvent\n) {\n    const helper = editor.getDOMHelper();\n\n    if (focusedNode && isEntityDelimiter(focusedNode) && helper.isNodeInEditor(focusedNode)) {\n        const blockEntityContainer = findClosestBlockEntityContainer(focusedNode, helper);\n        const isEnter = rawEvent.key === 'Enter';\n\n        if (blockEntityContainer && helper.isNodeInEditor(blockEntityContainer)) {\n            const isAfter = focusedNode.classList.contains(DelimiterAfter);\n\n            if (isAfter) {\n                range.setStartAfter(blockEntityContainer);\n            } else {\n                range.setStartBefore(blockEntityContainer);\n            }\n\n            range.collapse(true /* toStart */);\n\n            if (isEnter) {\n                rawEvent.preventDefault();\n            }\n\n            editor.formatContentModel(handleKeyDownInBlockDelimiter, {\n                selectionOverride: {\n                    type: 'range',\n                    isReverted: false,\n                    range,\n                },\n            });\n        } else {\n            if (isEnter) {\n                editor.formatContentModel((model, context) => {\n                    const result = handleEnterInlineEntity(model, context);\n\n                    if (result) {\n                        rawEvent.preventDefault();\n                    }\n\n                    return result;\n                });\n            } else {\n                editor.takeSnapshot();\n                editor\n                    .getDocument()\n                    .defaultView?.requestAnimationFrame(() =>\n                        preventTypeInDelimiter(focusedNode, editor)\n                    );\n            }\n        }\n    }\n}\n\n/**\n * @internal Exported Only for unit test\n * @returns\n */\nexport const handleKeyDownInBlockDelimiter: ContentModelFormatter = (model, context) => {\n    iterateSelections(model, (_path, _tableContext, readonlyBlock) => {\n        if (readonlyBlock?.blockType == 'Paragraph') {\n            const block = mutateBlock(readonlyBlock);\n\n            delete block.isImplicit;\n            const selectionMarker = block.segments.find(w => w.segmentType == 'SelectionMarker');\n            if (selectionMarker?.segmentType == 'SelectionMarker') {\n                block.segmentFormat = { ...selectionMarker.format };\n                context.newPendingFormat = { ...selectionMarker.format };\n            }\n            block.segments.unshift(createBr());\n        }\n    });\n\n    return true;\n};\n\n/**\n * @internal Exported Only for unit test\n * @returns\n */\nexport const handleEnterInlineEntity: ContentModelFormatter = model => {\n    let readonlySelectionBlock: ReadonlyContentModelParagraph | undefined;\n    let selectionBlockParent: ReadonlyContentModelBlockGroup | undefined;\n\n    iterateSelections(model, (path, _tableContext, block) => {\n        if (block?.blockType == 'Paragraph') {\n            readonlySelectionBlock = block;\n            selectionBlockParent = path[0];\n        }\n    });\n\n    if (selectionBlockParent?.blockGroupType == 'ListItem') {\n        // No need to handle list item since it will be handled by common enter handler code\n        return false;\n    }\n\n    if (readonlySelectionBlock && selectionBlockParent) {\n        const markerIndex = readonlySelectionBlock.segments.findIndex(\n            segment => segment.segmentType == 'SelectionMarker'\n        );\n\n        if (markerIndex >= 0) {\n            const selectionBlock = mutateBlock(readonlySelectionBlock);\n            const segmentsAfterMarker = selectionBlock.segments.splice(markerIndex);\n\n            const newPara: ShallowMutableContentModelParagraph = createParagraph(\n                false,\n                selectionBlock.format,\n                selectionBlock.segmentFormat,\n                selectionBlock.decorator\n            );\n\n            if (\n                selectionBlock.segments.every(\n                    x => x.segmentType == 'SelectionMarker' || x.segmentType == 'Br'\n                ) ||\n                segmentsAfterMarker.every(x => x.segmentType == 'SelectionMarker')\n            ) {\n                newPara.segments.push(createBr(selectionBlock.format));\n            }\n\n            newPara.segments.push(...segmentsAfterMarker);\n\n            const selectionBlockIndex = selectionBlockParent.blocks.indexOf(selectionBlock);\n            if (selectionBlockIndex >= 0) {\n                mutateBlock(selectionBlockParent).blocks.splice(\n                    selectionBlockIndex + 1,\n                    0,\n                    newPara\n                );\n            }\n        }\n    }\n\n    return true;\n};\n\nconst triggerEntityEventOnEnter = (\n    editor: IEditor,\n    wrapper: HTMLElement,\n    rawEvent: KeyboardEvent\n) => {\n    const format = parseEntityFormat(wrapper);\n    if (format.id && format.entityType && !format.isFakeEntity) {\n        editor.triggerEvent('entityOperation', {\n            operation: 'click',\n            entity: {\n                id: format.id,\n                type: format.entityType,\n                isReadonly: !!format.isReadonly,\n                wrapper,\n            },\n            rawEvent: rawEvent,\n        });\n    }\n};\n","import type { ChangedEntity, ReadonlyContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function findAllEntities(group: ReadonlyContentModelBlockGroup, entities: ChangedEntity[]) {\n    group.blocks.forEach(block => {\n        switch (block.blockType) {\n            case 'BlockGroup':\n                findAllEntities(block, entities);\n                break;\n\n            case 'Entity':\n                entities.push({\n                    entity: block,\n                    operation: 'newEntity',\n                });\n                break;\n\n            case 'Paragraph':\n                block.segments.forEach(segment => {\n                    switch (segment.segmentType) {\n                        case 'Entity':\n                            entities.push({\n                                entity: segment,\n                                operation: 'newEntity',\n                            });\n                            break;\n\n                        case 'General':\n                            findAllEntities(segment, entities);\n                            break;\n                    }\n                });\n                break;\n\n            case 'Table':\n                block.rows.forEach(row =>\n                    row.cells.forEach(cell => findAllEntities(cell, entities))\n                );\n                break;\n        }\n    });\n}\n","import { applyDefaultFormat } from './applyDefaultFormat';\nimport { applyPendingFormat } from './applyPendingFormat';\nimport {\n    getObjectKeys,\n    isBlockElement,\n    isCharacterValue,\n    isCursorMovingKey,\n    isNodeOfType,\n    normalizeFontFamily,\n    normalizeSegmentFormat,\n} from 'roosterjs-content-model-dom';\nimport type {\n    BackgroundColorFormat,\n    FontFamilyFormat,\n    FontSizeFormat,\n    FormatPluginState,\n    IEditor,\n    PluginEvent,\n    PluginWithState,\n    EditorOptions,\n    TextColorFormat,\n} from 'roosterjs-content-model-types';\n\n// During IME input, KeyDown event will have \"Process\" as key\nconst ProcessKey = 'Process';\n// For some Android IME, KeyDown event will have \"Unidentified\" as key\nconst UnidentifiedKey = 'Unidentified';\nconst DefaultStyleKeyMap: Record<\n    keyof (FontFamilyFormat & FontSizeFormat & TextColorFormat & BackgroundColorFormat),\n    keyof CSSStyleDeclaration\n> = {\n    backgroundColor: 'backgroundColor',\n    textColor: 'color',\n    fontFamily: 'fontFamily',\n    fontSize: 'fontSize',\n};\n\n/**\n * FormatPlugin plugins helps editor to do formatting on top of content model.\n * This includes:\n * 1. Handle pending format changes when selection is collapsed\n */\nclass FormatPlugin implements PluginWithState<FormatPluginState> {\n    private editor: IEditor | null = null;\n    private defaultFormatKeys: Set<keyof CSSStyleDeclaration>;\n    private state: FormatPluginState;\n    private lastCheckedNode: Node | null = null;\n\n    /**\n     * Construct a new instance of FormatPlugin class\n     * @param option The editor option\n     */\n    constructor(option: EditorOptions) {\n        this.state = {\n            defaultFormat: { ...option.defaultSegmentFormat },\n            pendingFormat: null,\n        };\n\n        const defaultFormat = this.state.defaultFormat;\n\n        if (defaultFormat.fontFamily) {\n            defaultFormat.fontFamily = normalizeFontFamily(defaultFormat.fontFamily);\n        }\n\n        this.defaultFormatKeys = new Set<keyof CSSStyleDeclaration>();\n\n        getObjectKeys(DefaultStyleKeyMap).forEach(key => {\n            if (this.state.defaultFormat[key]) {\n                this.defaultFormatKeys.add(DefaultStyleKeyMap[key]);\n            }\n        });\n    }\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'Format';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        this.state.defaultFormat = normalizeSegmentFormat(\n            this.state.defaultFormat,\n            editor.getEnvironment()\n        );\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState(): FormatPluginState {\n        return this.state;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case 'input':\n                this.checkAndApplyPendingFormat(event.rawEvent.data);\n\n                break;\n\n            case 'compositionEnd':\n                this.checkAndApplyPendingFormat(event.rawEvent.data);\n                break;\n\n            case 'keyDown':\n                const isAndroidIME =\n                    this.editor.getEnvironment().isAndroid && event.rawEvent.key == UnidentifiedKey;\n                if (isCursorMovingKey(event.rawEvent)) {\n                    this.clearPendingFormat();\n                    this.lastCheckedNode = null;\n                } else if (\n                    this.defaultFormatKeys.size > 0 &&\n                    (isAndroidIME ||\n                        isCharacterValue(event.rawEvent) ||\n                        event.rawEvent.key == ProcessKey) &&\n                    this.shouldApplyDefaultFormat(this.editor)\n                ) {\n                    applyDefaultFormat(this.editor, this.state.defaultFormat);\n                }\n\n                break;\n\n            case 'mouseUp':\n            case 'contentChanged':\n                this.lastCheckedNode = null;\n\n                if (!this.canApplyPendingFormat()) {\n                    this.clearPendingFormat();\n                }\n                break;\n        }\n    }\n\n    private checkAndApplyPendingFormat(data: string | null) {\n        if (this.editor && data && this.state.pendingFormat) {\n            applyPendingFormat(\n                this.editor,\n                data,\n                this.state.pendingFormat.format,\n                this.state.pendingFormat.paragraphFormat\n            );\n            this.clearPendingFormat();\n        }\n    }\n\n    private clearPendingFormat() {\n        this.state.pendingFormat = null;\n    }\n\n    /**\n     * @internal\n     * Check if this editor can apply pending format\n     * @param editor The editor to get format from\n     */\n    private canApplyPendingFormat(): boolean {\n        let result = false;\n\n        if (this.state.pendingFormat && this.editor) {\n            const selection = this.editor.getDOMSelection();\n            const range =\n                selection?.type == 'range' && selection.range.collapsed ? selection.range : null;\n            const { node, offset } = this.state.pendingFormat.insertPoint;\n\n            if (range && range.startContainer == node && range.startOffset == offset) {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n\n    private shouldApplyDefaultFormat(editor: IEditor): boolean {\n        const selection = editor.getDOMSelection();\n        const range = selection?.type == 'range' ? selection.range : null;\n        const posContainer = range?.startContainer ?? null;\n\n        if (posContainer && posContainer != this.lastCheckedNode) {\n            // Cache last checked parent node so no need to check it again if user is keep typing under the same node\n            this.lastCheckedNode = posContainer;\n\n            const domHelper = editor.getDOMHelper();\n            let element: HTMLElement | null = isNodeOfType(posContainer, 'ELEMENT_NODE')\n                ? posContainer\n                : posContainer.parentElement;\n            const foundFormatKeys = new Set<keyof CSSStyleDeclaration>();\n\n            while (element?.parentElement && domHelper.isNodeInEditor(element.parentElement)) {\n                if (element.getAttribute?.('style')) {\n                    const style = element.style;\n                    this.defaultFormatKeys.forEach(key => {\n                        if (style[key]) {\n                            foundFormatKeys.add(key);\n                        }\n                    });\n\n                    if (foundFormatKeys.size == this.defaultFormatKeys.size) {\n                        return false;\n                    }\n                }\n\n                if (isBlockElement(element)) {\n                    break;\n                }\n\n                element = element.parentElement;\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * @internal\n * Create a new instance of FormatPlugin.\n * @param option The editor option\n */\nexport function createFormatPlugin(option: EditorOptions): PluginWithState<FormatPluginState> {\n    return new FormatPlugin(option);\n}\n","import { iterateSelections } from 'roosterjs-content-model-dom';\nimport type { ContentModelSegmentFormat, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * When necessary, set default format as current pending format so it will be applied when Input event is fired\n * @param editor The editor object\n * @param defaultFormat The default segment format to apply\n */\nexport function applyDefaultFormat(editor: IEditor, defaultFormat: ContentModelSegmentFormat) {\n    const selection = editor.getDOMSelection();\n\n    if (selection?.type == 'range' && selection.range.collapsed) {\n        editor.formatContentModel((model, context) => {\n            iterateSelections(model, (path, _, paragraph, segments) => {\n                const marker = segments?.[0];\n                if (\n                    paragraph?.blockType == 'Paragraph' &&\n                    marker?.segmentType == 'SelectionMarker'\n                ) {\n                    const blocks = path[0].blocks;\n                    const blockCount = blocks.length;\n                    const blockIndex = blocks.indexOf(paragraph);\n\n                    if (\n                        paragraph.isImplicit &&\n                        paragraph.segments.length == 1 &&\n                        paragraph.segments[0] == marker &&\n                        blockCount > 0 &&\n                        blockIndex == blockCount - 1\n                    ) {\n                        // Focus is in the last paragraph which is implicit and there is not other segments.\n                        // This can happen when focus is moved after all other content under current block group.\n                        // We need to check if browser will merge focus into previous paragraph by checking if\n                        // previous block is block. If previous block is paragraph, browser will most likely merge\n                        // the input into previous paragraph, then nothing need to do here. Otherwise we need to\n                        // apply pending format since this input event will start a new real paragraph.\n                        const previousBlock = blocks[blockIndex - 1];\n\n                        if (previousBlock?.blockType != 'Paragraph') {\n                            context.newPendingFormat = getNewPendingFormat(\n                                editor,\n                                defaultFormat,\n                                marker.format\n                            );\n                        }\n                    } else if (paragraph.segments.every(x => x.segmentType != 'Text')) {\n                        context.newPendingFormat = getNewPendingFormat(\n                            editor,\n                            defaultFormat,\n                            marker.format\n                        );\n                    }\n                }\n\n                // Stop searching more selection\n                return true;\n            });\n\n            // We didn't do any change but just apply default format to pending format, so no need to write back\n            return false;\n        });\n    }\n}\n\nfunction getNewPendingFormat(\n    editor: IEditor,\n    defaultFormat: ContentModelSegmentFormat,\n    markerFormat: ContentModelSegmentFormat\n): ContentModelSegmentFormat {\n    return {\n        ...defaultFormat,\n        ...editor.getPendingFormat(),\n        ...markerFormat,\n    };\n}\n","import {\n    createText,\n    getObjectKeys,\n    iterateSelections,\n    mutateBlock,\n    mutateSegment,\n    normalizeContentModel,\n    setParagraphNotImplicit,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelFormatBase,\n    ContentModelSegmentFormat,\n    IEditor,\n} from 'roosterjs-content-model-types';\n\nconst ANSI_SPACE = '\\u0020';\nconst NON_BREAK_SPACE = '\\u00A0';\n\n/**\n * @internal\n * Apply pending format to the text user just input\n * @param editor The editor to get format from\n * @param data The text user just input\n */\nexport function applyPendingFormat(\n    editor: IEditor,\n    data: string,\n    segmentFormat?: ContentModelSegmentFormat,\n    paragraphFormat?: ContentModelBlockFormat\n) {\n    let isChanged = false;\n\n    editor.formatContentModel(\n        (model, context) => {\n            iterateSelections(model, (_, __, block, segments) => {\n                if (\n                    block?.blockType == 'Paragraph' &&\n                    segments?.length == 1 &&\n                    segments[0].segmentType == 'SelectionMarker'\n                ) {\n                    const marker = segments[0];\n                    const index = block.segments.indexOf(marker);\n                    const previousSegment = block.segments[index - 1];\n\n                    if (previousSegment?.segmentType == 'Text') {\n                        const text = previousSegment.text;\n                        const subStr = text.substr(-data.length, data.length);\n\n                        // For space, there can be &#32 (space) or &#160 (&nbsp;), we treat them as the same\n                        if (subStr == data || (data == ANSI_SPACE && subStr == NON_BREAK_SPACE)) {\n                            if (\n                                segmentFormat &&\n                                !isSubFormatIncluded(previousSegment.format, segmentFormat)\n                            ) {\n                                mutateSegment(block, previousSegment, previousSegment => {\n                                    previousSegment.text = text.substring(\n                                        0,\n                                        text.length - data.length\n                                    );\n                                });\n\n                                mutateSegment(block, marker, (marker, block) => {\n                                    marker.format = { ...segmentFormat };\n\n                                    const newText = createText(\n                                        data == ANSI_SPACE ? NON_BREAK_SPACE : data,\n                                        {\n                                            ...previousSegment.format,\n                                            ...segmentFormat,\n                                        }\n                                    );\n\n                                    block.segments.splice(index, 0, newText);\n                                    setParagraphNotImplicit(block);\n                                });\n\n                                isChanged = true;\n                            }\n\n                            if (\n                                paragraphFormat &&\n                                !isSubFormatIncluded(block.format, paragraphFormat)\n                            ) {\n                                const mutableParagraph = mutateBlock(block);\n\n                                Object.assign(mutableParagraph.format, paragraphFormat);\n                                isChanged = true;\n                            }\n                        }\n                    }\n                }\n                return true;\n            });\n\n            if (isChanged) {\n                normalizeContentModel(model);\n                context.skipUndoSnapshot = true;\n            }\n\n            return isChanged;\n        },\n        {\n            apiName: 'applyPendingFormat',\n        }\n    );\n}\n\nfunction isSubFormatIncluded<T extends ContentModelFormatBase>(containerFormat: T, subFormat: T) {\n    const keys = getObjectKeys(subFormat);\n    let result = true;\n\n    keys.forEach(key => {\n        if (containerFormat[key] !== subFormat[key]) {\n            result = false;\n        }\n    });\n\n    return result;\n}\n","import { ChangeSource, getObjectKeys, setColor } from 'roosterjs-content-model-dom';\nimport { createAriaLiveElement } from '../../utils/createAriaLiveElement';\nimport type {\n    IEditor,\n    LifecyclePluginState,\n    PluginEvent,\n    PluginWithState,\n    EditorOptions,\n    RewriteFromModel,\n} from 'roosterjs-content-model-types';\n\nconst ContentEditableAttributeName = 'contenteditable';\nconst DefaultTextColor = '#000000';\nconst DefaultBackColor = '#ffffff';\n\n/**\n * Lifecycle plugin handles editor initialization and disposing\n */\nclass LifecyclePlugin implements PluginWithState<LifecyclePluginState> {\n    private editor: IEditor | null = null;\n    private state: LifecyclePluginState;\n    private initializer: (() => void) | null = null;\n    private disposer: (() => void) | null = null;\n    private adjustColor: () => void;\n\n    /**\n     * Construct a new instance of LifecyclePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        // Make the container editable and set its selection styles\n        if (contentDiv.getAttribute(ContentEditableAttributeName) === null) {\n            this.initializer = () => {\n                contentDiv.contentEditable = 'true';\n                contentDiv.style.userSelect = 'text';\n            };\n            this.disposer = () => {\n                contentDiv.style.userSelect = '';\n                contentDiv.removeAttribute(ContentEditableAttributeName);\n            };\n        }\n        this.adjustColor = options.doNotAdjustEditorColor\n            ? () => {}\n            : () => {\n                  this.adjustContainerColor(contentDiv);\n              };\n\n        this.state = {\n            isDarkMode: !!options.inDarkMode,\n            shadowEditFragment: null,\n            styleElements: {},\n            announcerStringGetter: options.announcerStringGetter,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Lifecycle';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        // Set content DIV to be editable\n        this.initializer?.();\n\n        // Set editor background color for dark mode\n        this.adjustColor();\n\n        // Let other plugins know that we are ready\n        const rewriteFromModel: RewriteFromModel = this.state.rewriteFromModel ?? {\n            addedBlockElements: [],\n            removedBlockElements: [],\n        };\n\n        this.editor.triggerEvent('editorReady', rewriteFromModel, true /*broadcast*/);\n        delete this.state.rewriteFromModel;\n\n        // Initialize the Announce container.\n        this.state.announceContainer = createAriaLiveElement(editor.getDocument());\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor?.triggerEvent('beforeDispose', {}, true /*broadcast*/);\n\n        getObjectKeys(this.state.styleElements).forEach(key => {\n            const element = this.state.styleElements[key];\n\n            element.parentElement?.removeChild(element);\n            delete this.state.styleElements[key];\n        });\n\n        const announceContainer = this.state.announceContainer;\n\n        if (announceContainer) {\n            announceContainer.parentElement?.removeChild(announceContainer);\n            delete this.state.announceContainer;\n        }\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n            this.initializer = null;\n        }\n\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == 'contentChanged' &&\n            (event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode)\n        ) {\n            this.adjustColor();\n        }\n    }\n\n    private adjustContainerColor(contentDiv: HTMLElement) {\n        if (this.editor) {\n            const { isDarkMode } = this.state;\n            const darkColorHandler = this.editor.getColorManager();\n\n            setColor(\n                contentDiv,\n                DefaultTextColor,\n                false /*isBackground*/,\n                isDarkMode,\n                darkColorHandler\n            );\n            setColor(\n                contentDiv,\n                DefaultBackColor,\n                true /*isBackground*/,\n                isDarkMode,\n                darkColorHandler\n            );\n        }\n    }\n}\n\n/**\n * @internal\n * Create a new instance of LifecyclePlugin.\n * @param option The editor option\n * @param contentDiv The editor content DIV element\n */\nexport function createLifecyclePlugin(\n    option: EditorOptions,\n    contentDiv: HTMLDivElement\n): PluginWithState<LifecyclePluginState> {\n    return new LifecyclePlugin(option, contentDiv);\n}\n","import { findCoordinate } from './findCoordinate';\nimport { findTableCellElement } from '../../coreApi/setDOMSelection/findTableCellElement';\nimport { isSingleImageInSelection } from './isSingleImageInSelection';\nimport { normalizePos } from './normalizePos';\nimport {\n    isCharacterValue,\n    isElementOfType,\n    isModifierKey,\n    isNodeOfType,\n    parseTableCells,\n    toArray,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DOMSelection,\n    IEditor,\n    PluginEvent,\n    PluginWithState,\n    SelectionPluginState,\n    EditorOptions,\n    DOMHelper,\n    ParsedTable,\n    TableSelectionInfo,\n    TableCellCoordinate,\n} from 'roosterjs-content-model-types';\n\nconst MouseLeftButton = 0;\nconst MouseRightButton = 2;\nconst Up = 'ArrowUp';\nconst Down = 'ArrowDown';\nconst Left = 'ArrowLeft';\nconst Right = 'ArrowRight';\nconst Tab = 'Tab';\n\n/**\n * @internal\n */\nexport const DEFAULT_SELECTION_BORDER_COLOR = '#DB626C';\n/**\n * @internal\n */\nexport const DEFAULT_TABLE_CELL_SELECTION_BACKGROUND_COLOR = '#C6C6C6';\n\nclass SelectionPlugin implements PluginWithState<SelectionPluginState> {\n    private editor: IEditor | null = null;\n    private state: SelectionPluginState;\n    private disposer: (() => void) | null = null;\n    private logicalRootDisposer: (() => void) | null = null;\n    private isSafari = false;\n    private isMac = false;\n    private scrollTopCache: number = 0;\n\n    constructor(options: EditorOptions) {\n        this.state = {\n            selection: null,\n            tableSelection: null,\n            imageSelectionBorderColor:\n                options.imageSelectionBorderColor ?? DEFAULT_SELECTION_BORDER_COLOR,\n            imageSelectionBorderColorDark: options.imageSelectionBorderColor\n                ? undefined\n                : DEFAULT_SELECTION_BORDER_COLOR,\n            tableCellSelectionBackgroundColor:\n                options.tableCellSelectionBackgroundColor ??\n                DEFAULT_TABLE_CELL_SELECTION_BACKGROUND_COLOR,\n            tableCellSelectionBackgroundColorDark: options.tableCellSelectionBackgroundColor\n                ? undefined\n                : DEFAULT_TABLE_CELL_SELECTION_BACKGROUND_COLOR,\n        };\n    }\n\n    getName() {\n        return 'Selection';\n    }\n\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        if (!this.state.imageSelectionBorderColorDark && this.state.imageSelectionBorderColor) {\n            this.state.imageSelectionBorderColorDark = editor\n                .getColorManager()\n                .getDarkColor(this.state.imageSelectionBorderColor, undefined, 'border');\n        }\n\n        if (\n            !this.state.tableCellSelectionBackgroundColorDark &&\n            this.state.tableCellSelectionBackgroundColor\n        ) {\n            this.state.tableCellSelectionBackgroundColorDark = editor\n                .getColorManager()\n                .getDarkColor(\n                    this.state.tableCellSelectionBackgroundColor,\n                    undefined,\n                    'background'\n                );\n        }\n\n        const env = this.editor.getEnvironment();\n        const document = this.editor.getDocument();\n\n        this.isSafari = !!env.isSafari;\n        this.isMac = !!env.isMac;\n        document.addEventListener('selectionchange', this.onSelectionChange);\n        if (this.isSafari) {\n            this.disposer = this.editor.attachDomEvent({\n                focus: { beforeDispatch: this.onFocus },\n                drop: { beforeDispatch: this.onDrop },\n            });\n        } else {\n            this.disposer = this.editor.attachDomEvent({\n                focus: { beforeDispatch: this.onFocus },\n                blur: { beforeDispatch: this.onBlur },\n                drop: { beforeDispatch: this.onDrop },\n            });\n        }\n    }\n\n    dispose() {\n        this.editor?.getDocument().removeEventListener('selectionchange', this.onSelectionChange);\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n\n        this.logicalRootDisposer?.();\n        this.logicalRootDisposer = null;\n\n        this.detachMouseEvent();\n        this.editor = null;\n    }\n\n    getState(): SelectionPluginState {\n        return this.state;\n    }\n\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case 'mouseDown':\n                this.onMouseDown(this.editor, event.rawEvent);\n                break;\n\n            case 'mouseUp':\n                this.onMouseUp();\n                break;\n\n            case 'keyDown':\n                this.onKeyDown(this.editor, event.rawEvent);\n                break;\n\n            case 'contentChanged':\n                this.state.tableSelection = null;\n                break;\n\n            case 'scroll':\n                if (!this.editor.hasFocus()) {\n                    this.scrollTopCache = event.scrollContainer.scrollTop;\n                }\n                break;\n\n            case 'logicalRootChanged':\n                this.logicalRootDisposer?.();\n                if (this.isSafari) {\n                    this.logicalRootDisposer = this.editor.attachDomEvent({\n                        focus: { beforeDispatch: this.onFocus },\n                        drop: { beforeDispatch: this.onDrop },\n                    });\n                } else {\n                    this.logicalRootDisposer = this.editor.attachDomEvent({\n                        focus: { beforeDispatch: this.onFocus },\n                        blur: { beforeDispatch: this.onBlur },\n                        drop: { beforeDispatch: this.onDrop },\n                    });\n                }\n                break;\n        }\n    }\n\n    private onMouseDown(editor: IEditor, rawEvent: MouseEvent) {\n        const selection = editor.getDOMSelection();\n        let image: HTMLImageElement | null;\n\n        // Image selection\n        if (\n            selection?.type == 'image' &&\n            (rawEvent.button == MouseLeftButton ||\n                (rawEvent.button == MouseRightButton &&\n                    !this.getClickingImage(rawEvent) &&\n                    !this.getContainedTargetImage(rawEvent, selection)))\n        ) {\n            this.setDOMSelection(null /*domSelection*/, null /*tableSelection*/);\n        }\n\n        if (\n            (image =\n                this.getClickingImage(rawEvent) ??\n                this.getContainedTargetImage(rawEvent, selection)) &&\n            image.isContentEditable\n        ) {\n            this.setDOMSelection(\n                {\n                    type: 'image',\n                    image: image,\n                },\n                null\n            );\n            return;\n        }\n\n        // Table selection\n        if (selection?.type == 'table' && rawEvent.button == MouseLeftButton) {\n            this.setDOMSelection(null /*domSelection*/, null /*tableSelection*/);\n        }\n\n        let tableSelection: TableSelectionInfo | null;\n        const target = rawEvent.target as Node;\n\n        if (\n            target &&\n            rawEvent.button == MouseLeftButton &&\n            (tableSelection = this.parseTableSelection(target, target, editor.getDOMHelper()))\n        ) {\n            this.state.tableSelection = tableSelection;\n\n            if (rawEvent.detail >= 3) {\n                const lastCo = findCoordinate(\n                    tableSelection.parsedTable,\n                    rawEvent.target as Node,\n                    editor.getDOMHelper()\n                );\n\n                if (lastCo) {\n                    // Triple click, select the current cell\n                    tableSelection.lastCo = lastCo;\n                    this.updateTableSelection(lastCo);\n                    rawEvent.preventDefault();\n                }\n            }\n\n            this.state.mouseDisposer?.();\n            this.state.mouseDisposer = editor.attachDomEvent({\n                mousemove: {\n                    beforeDispatch: this.onMouseMove,\n                },\n            });\n        }\n    }\n\n    private onMouseMove = (event: Event) => {\n        if (this.editor && this.state.tableSelection) {\n            const hasTableSelection = !!this.state.tableSelection.lastCo;\n            const currentNode = event.target as Node;\n            const domHelper = this.editor.getDOMHelper();\n\n            const range = this.editor.getDocument().createRange();\n            const startNode = this.state.tableSelection.startNode;\n            const isReverted =\n                currentNode.compareDocumentPosition(startNode) == Node.DOCUMENT_POSITION_FOLLOWING;\n\n            if (isReverted) {\n                range.setStart(currentNode, 0);\n                range.setEnd(\n                    startNode,\n                    isNodeOfType(startNode, 'TEXT_NODE')\n                        ? startNode.nodeValue?.length ?? 0\n                        : startNode.childNodes.length\n                );\n            } else {\n                range.setStart(startNode, 0);\n                range.setEnd(currentNode, 0);\n            }\n\n            // Use common container of the range to search a common table that covers both start and end node\n            const tableStart = range.commonAncestorContainer;\n            const newTableSelection = this.parseTableSelection(tableStart, startNode, domHelper);\n\n            if (newTableSelection) {\n                const lastCo = findCoordinate(\n                    newTableSelection.parsedTable,\n                    currentNode,\n                    domHelper\n                );\n\n                if (newTableSelection.table != this.state.tableSelection.table) {\n                    // Move mouse into another table (nest table scenario)\n                    this.state.tableSelection = newTableSelection;\n                    this.state.tableSelection.lastCo = lastCo ?? undefined;\n                }\n\n                const updated = lastCo && this.updateTableSelection(lastCo);\n\n                if (hasTableSelection || updated) {\n                    event.preventDefault();\n                }\n            } else if (this.editor.getDOMSelection()?.type == 'table') {\n                // Move mouse out of table\n                this.setDOMSelection(\n                    {\n                        type: 'range',\n                        range,\n                        isReverted,\n                    },\n                    this.state.tableSelection\n                );\n            }\n        }\n    };\n\n    private onMouseUp() {\n        this.detachMouseEvent();\n    }\n\n    private onDrop = () => {\n        this.detachMouseEvent();\n    };\n\n    private onKeyDown(editor: IEditor, rawEvent: KeyboardEvent) {\n        const key = rawEvent.key;\n        const selection = editor.getDOMSelection();\n        const win = editor.getDocument().defaultView;\n\n        switch (selection?.type) {\n            case 'image':\n                if (!isModifierKey(rawEvent) && !rawEvent.shiftKey && selection.image.parentNode) {\n                    if (key === 'Escape') {\n                        this.selectBeforeOrAfterElement(editor, selection.image);\n                        rawEvent.stopPropagation();\n                    } else if (key !== 'Delete' && key !== 'Backspace') {\n                        this.selectBeforeOrAfterElement(editor, selection.image);\n                    }\n                }\n\n                if (\n                    (isModifierKey(rawEvent) || rawEvent.shiftKey) &&\n                    selection.image &&\n                    !this.isSafari\n                ) {\n                    const range = selection.image.ownerDocument.createRange();\n                    range.selectNode(selection.image);\n                    this.setDOMSelection(\n                        {\n                            type: 'range',\n                            range,\n                            isReverted: false,\n                        },\n                        null /* tableSelection */\n                    );\n                }\n                break;\n\n            case 'range':\n                if (key == Up || key == Down || key == Left || key == Right || key == Tab) {\n                    const start = selection.range.startContainer;\n                    this.state.tableSelection = this.parseTableSelection(\n                        start,\n                        start,\n                        editor.getDOMHelper()\n                    );\n\n                    if (this.state.tableSelection && !rawEvent.defaultPrevented) {\n                        if (key == Tab) {\n                            this.handleSelectionInTable(this.getTabKey(rawEvent));\n                            rawEvent.preventDefault();\n                        } else {\n                            win?.requestAnimationFrame(() => this.handleSelectionInTable(key));\n                        }\n                    }\n                }\n                break;\n\n            case 'table':\n                // After a content change event is handled tableSelection state is reset to null\n                // Since we have table selection from DOMSelection, we can use it to re-create the tableSelection state\n                if (this.state.tableSelection == null) {\n                    const { table, firstRow, firstColumn, lastRow, lastColumn } = selection;\n\n                    const parsedTable = parseTableCells(table);\n                    if (parsedTable) {\n                        const firstCo = { row: firstRow, col: firstColumn };\n                        const lastCo = { row: lastRow, col: lastColumn };\n\n                        // Create the tableSelection with current table info\n                        this.state.tableSelection = {\n                            table,\n                            parsedTable,\n                            firstCo,\n                            lastCo,\n                            startNode: findTableCellElement(parsedTable, firstCo)?.cell || table,\n                        };\n                    }\n                }\n                if (this.state.tableSelection?.lastCo) {\n                    const { shiftKey, key } = rawEvent;\n\n                    if (shiftKey && (key == Left || key == Right)) {\n                        const isRtl =\n                            win?.getComputedStyle(this.state.tableSelection.table).direction ==\n                            'rtl';\n\n                        this.updateTableSelectionFromKeyboard(\n                            0,\n                            (key == Left ? -1 : 1) * (isRtl ? -1 : 1)\n                        );\n                        rawEvent.preventDefault();\n                    } else if (shiftKey && (key == Up || key == Down)) {\n                        this.updateTableSelectionFromKeyboard(key == Up ? -1 : 1, 0);\n                        rawEvent.preventDefault();\n                    } else if (key != 'Shift' && !isCharacterValue(rawEvent)) {\n                        if (key == Up || key == Down || key == Left || key == Right) {\n                            this.setDOMSelection(null /*domSelection*/, this.state.tableSelection);\n                            win?.requestAnimationFrame(() => this.handleSelectionInTable(key));\n                        }\n                    }\n                }\n                break;\n        }\n    }\n\n    private getTabKey(rawEvent: KeyboardEvent) {\n        return rawEvent.shiftKey ? 'TabLeft' : 'TabRight';\n    }\n\n    private handleSelectionInTable(\n        key: 'ArrowUp' | 'ArrowDown' | 'ArrowLeft' | 'ArrowRight' | 'TabLeft' | 'TabRight'\n    ) {\n        if (!this.editor || !this.state.tableSelection) {\n            return;\n        }\n\n        const selection = this.editor.getDOMSelection();\n        const domHelper = this.editor.getDOMHelper();\n\n        if (selection?.type == 'range') {\n            const {\n                range: { collapsed, startContainer, endContainer, commonAncestorContainer },\n                isReverted,\n            } = selection;\n            const start = isReverted ? endContainer : startContainer;\n            const end: Node | null = isReverted ? startContainer : endContainer;\n            const tableSel = this.parseTableSelection(commonAncestorContainer, start, domHelper);\n\n            if (!tableSel) {\n                return;\n            }\n\n            let lastCo = findCoordinate(tableSel?.parsedTable, end, domHelper);\n            let tabMove = false;\n            const { parsedTable, firstCo: oldCo, table } = this.state.tableSelection;\n\n            if (lastCo && tableSel.table == table) {\n                if (lastCo.col != oldCo.col && (key == Up || key == Down)) {\n                    const change = key == Up ? -1 : 1;\n                    const originalTd = findTableCellElement(parsedTable, oldCo)?.cell;\n                    let td: HTMLTableCellElement | null = null;\n\n                    lastCo = { row: oldCo.row + change, col: oldCo.col };\n\n                    while (lastCo.row >= 0 && lastCo.row < parsedTable.length) {\n                        td = findTableCellElement(parsedTable, lastCo)?.cell || null;\n\n                        if (td == originalTd) {\n                            lastCo.row += change;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    if (collapsed && td) {\n                        this.setRangeSelectionInTable(\n                            td,\n                            key == Up ? td.childNodes.length : 0,\n                            this.editor\n                        );\n                    } else if (!td && (lastCo.row == -1 || lastCo.row <= parsedTable.length)) {\n                        this.selectBeforeOrAfterElement(\n                            this.editor,\n                            table,\n                            change == 1 /* after */,\n                            change != 1 /* setSelectionInNextSiblingElement */\n                        );\n                    }\n                } else if (key == 'TabLeft' || key == 'TabRight') {\n                    const reverse = key == 'TabLeft';\n                    for (\n                        let step = reverse ? -1 : 1,\n                            row = lastCo.row ?? 0,\n                            col = (lastCo.col ?? 0) + step;\n                        ;\n                        col += step\n                    ) {\n                        if (col < 0 || col >= parsedTable[row].length) {\n                            row += step;\n                            if (row < 0) {\n                                this.selectBeforeOrAfterElement(this.editor, tableSel.table);\n                                break;\n                            } else if (row >= parsedTable.length) {\n                                this.selectBeforeOrAfterElement(\n                                    this.editor,\n                                    tableSel.table,\n                                    true /*after*/\n                                );\n                                break;\n                            }\n                            col = reverse ? parsedTable[row].length - 1 : 0;\n                        }\n                        const cell = parsedTable[row][col];\n\n                        if (typeof cell != 'string') {\n                            tabMove = true;\n                            this.setRangeSelectionInTable(\n                                cell,\n                                0,\n                                this.editor,\n                                true /* selectAll */\n                            );\n                            lastCo.row = row;\n                            lastCo.col = col;\n                            break;\n                        }\n                    }\n                } else {\n                    this.state.tableSelection = null;\n                }\n\n                if (\n                    collapsed &&\n                    (lastCo.col != oldCo.col || lastCo.row != oldCo.row) &&\n                    lastCo.row >= 0 &&\n                    lastCo.row == parsedTable.length - 1 &&\n                    lastCo.col == parsedTable[lastCo.row]?.length - 1\n                ) {\n                    this.editor?.announce({ defaultStrings: 'announceOnFocusLastCell' });\n                }\n            }\n\n            if (!collapsed && lastCo && !tabMove) {\n                this.state.tableSelection = tableSel;\n                this.updateTableSelection(lastCo);\n            }\n        }\n    }\n\n    private setRangeSelectionInTable(\n        cell: Node,\n        nodeOffset: number,\n        editor: IEditor,\n        selectAll?: boolean\n    ) {\n        const range = editor.getDocument().createRange();\n        if (selectAll && cell.firstChild && cell.lastChild) {\n            const cellStart = cell.firstChild;\n            const cellEnd = cell.lastChild;\n            // Get first deepest editable position in the cell\n            const posStart = normalizePos(cellStart, 0);\n            // Get last deepest editable position in the cell\n            const posEnd = normalizePos(cellEnd, cellEnd.childNodes.length);\n\n            range.setStart(posStart.node, posStart.offset);\n            range.setEnd(posEnd.node, posEnd.offset);\n\n            if (range.toString() === '') {\n                range.collapse(true /* toStart */);\n            }\n        } else {\n            // Get deepest editable position in the cell\n            const { node, offset } = normalizePos(cell, nodeOffset);\n\n            range.setStart(node, offset);\n            range.collapse(true /* toStart */);\n        }\n\n        this.setDOMSelection(\n            {\n                type: 'range',\n                range,\n                isReverted: false,\n            },\n            null /*tableSelection*/\n        );\n    }\n\n    private updateTableSelectionFromKeyboard(rowChange: number, colChange: number) {\n        if (this.state.tableSelection?.lastCo && this.editor) {\n            const { lastCo, parsedTable } = this.state.tableSelection;\n            const row = lastCo.row + rowChange;\n            const col = lastCo.col + colChange;\n\n            if (row >= 0 && row < parsedTable.length && col >= 0 && col < parsedTable[row].length) {\n                this.updateTableSelection({ row, col });\n            }\n        }\n    }\n\n    private selectBeforeOrAfterElement(\n        editor: IEditor,\n        element: HTMLElement,\n        after?: boolean,\n        setSelectionInNextSiblingElement?: boolean\n    ) {\n        const doc = editor.getDocument();\n        const parent = element.parentNode;\n        const index = parent && toArray(parent.childNodes).indexOf(element);\n        let sibling: Element | undefined | null;\n\n        if (parent && index !== null && index >= 0) {\n            const range = doc.createRange();\n            if (\n                setSelectionInNextSiblingElement &&\n                (sibling = after ? element.nextElementSibling : element.previousElementSibling) &&\n                isNodeOfType(sibling, 'ELEMENT_NODE')\n            ) {\n                range.selectNodeContents(sibling);\n                range.collapse(false /* toStart */);\n            } else {\n                range.setStart(parent, index + (after ? 1 : 0));\n                range.collapse();\n            }\n\n            this.setDOMSelection(\n                {\n                    type: 'range',\n                    range: range,\n                    isReverted: false,\n                },\n                null /*tableSelection*/\n            );\n        }\n    }\n\n    private getClickingImage(event: UIEvent): HTMLImageElement | null {\n        const target = event.target as Node;\n\n        return isNodeOfType(target, 'ELEMENT_NODE') && isElementOfType(target, 'img')\n            ? target\n            : null;\n    }\n\n    // MacOS will not create a mouseUp event if contextMenu event is not prevent defaulted.\n    // Make sure we capture image target even if image is wrapped\n    private getContainedTargetImage = (\n        event: MouseEvent,\n        previousSelection: DOMSelection | null\n    ): HTMLImageElement | null => {\n        if (!this.isMac || !previousSelection || previousSelection.type !== 'image') {\n            return null;\n        }\n\n        const target = event.target as Node;\n        if (\n            isNodeOfType(target, 'ELEMENT_NODE') &&\n            isElementOfType(target, 'span') &&\n            target.firstChild === previousSelection.image\n        ) {\n            return previousSelection.image;\n        }\n        return null;\n    };\n\n    private onFocus = () => {\n        if (!this.state.skipReselectOnFocus && this.state.selection) {\n            this.setDOMSelection(this.state.selection, this.state.tableSelection);\n        }\n\n        if (this.state.selection?.type == 'range' && !this.isSafari) {\n            // Editor is focused, now we can get live selection. So no need to keep a selection if the selection type is range.\n            this.state.selection = null;\n        }\n\n        if (this.scrollTopCache && this.editor) {\n            const sc = this.editor.getScrollContainer();\n            sc.scrollTop = this.scrollTopCache;\n            this.scrollTopCache = 0;\n        }\n    };\n\n    private onBlur = () => {\n        if (this.editor) {\n            if (!this.state.selection) {\n                this.state.selection = this.editor.getDOMSelection();\n            }\n            const sc = this.editor.getScrollContainer();\n            this.scrollTopCache = sc.scrollTop;\n        }\n    };\n\n    private onSelectionChange = () => {\n        if (this.editor?.hasFocus() && !this.editor.isInShadowEdit()) {\n            const newSelection = this.editor.getDOMSelection();\n\n            //If am image selection changed to a wider range due a keyboard event, we should update the selection\n            const selection = this.editor.getDocument().getSelection();\n            if (selection && selection.focusNode) {\n                const image = isSingleImageInSelection(selection);\n                if (newSelection?.type == 'image' && !image) {\n                    const range = selection.getRangeAt(0);\n                    this.editor.setDOMSelection({\n                        type: 'range',\n                        range,\n                        isReverted:\n                            selection.focusNode != range.endContainer ||\n                            selection.focusOffset != range.endOffset,\n                    });\n                } else if (newSelection?.type !== 'image' && image) {\n                    this.editor.setDOMSelection({\n                        type: 'image',\n                        image,\n                    });\n                }\n            }\n\n            // Safari has problem to handle onBlur event. When blur, we cannot get the original selection from editor.\n            // So we always save a selection whenever editor has focus. Then after blur, we can still use this cached selection.\n            if (newSelection?.type == 'range') {\n                if (this.isSafari) {\n                    this.state.selection = newSelection;\n                }\n            }\n        }\n    };\n\n    private parseTableSelection(\n        tableStart: Node,\n        tdStart: Node,\n        domHelper: DOMHelper\n    ): TableSelectionInfo | null {\n        let table: HTMLTableElement | null;\n        let parsedTable: ParsedTable | null;\n        let firstCo: TableCellCoordinate | null;\n\n        if (\n            (table = domHelper.findClosestElementAncestor(tableStart, 'table')) &&\n            table.isContentEditable &&\n            (parsedTable = parseTableCells(table)) &&\n            (firstCo = findCoordinate(parsedTable, tdStart, domHelper))\n        ) {\n            return { table, parsedTable, firstCo, startNode: tdStart };\n        } else {\n            return null;\n        }\n    }\n\n    private updateTableSelection(lastCo: TableCellCoordinate) {\n        if (this.state.tableSelection && this.editor) {\n            const {\n                table,\n                firstCo,\n                parsedTable,\n                startNode,\n                lastCo: oldCo,\n            } = this.state.tableSelection;\n\n            if (oldCo || firstCo.row != lastCo.row || firstCo.col != lastCo.col) {\n                this.state.tableSelection.lastCo = lastCo;\n                this.setDOMSelection(\n                    {\n                        type: 'table',\n                        table,\n                        firstRow: firstCo.row,\n                        firstColumn: firstCo.col,\n                        lastRow: lastCo.row,\n                        lastColumn: lastCo.col,\n                        tableSelectionInfo: this.state.tableSelection,\n                    },\n                    { table, firstCo, lastCo, parsedTable, startNode }\n                );\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private setDOMSelection(\n        selection: DOMSelection | null,\n        tableSelection: TableSelectionInfo | null\n    ) {\n        this.editor?.setDOMSelection(selection);\n        this.state.tableSelection = tableSelection;\n    }\n\n    private detachMouseEvent() {\n        if (this.state.mouseDisposer) {\n            this.state.mouseDisposer();\n            this.state.mouseDisposer = undefined;\n        }\n    }\n}\n\n/**\n * @internal\n * Create a new instance of SelectionPlugin.\n * @param option The editor option\n */\nexport function createSelectionPlugin(\n    options: EditorOptions\n): PluginWithState<SelectionPluginState> {\n    return new SelectionPlugin(options);\n}\n","import type { DOMHelper, ParsedTable, TableCellCoordinate } from 'roosterjs-content-model-types';\n\nconst TableCellSelector = 'TH,TD';\n\n/**\n * @internal\n * Find coordinate of a given element from a parsed table\n */\nexport function findCoordinate(\n    parsedTable: ParsedTable,\n    element: Node,\n    domHelper: DOMHelper\n): TableCellCoordinate | null {\n    const td = domHelper.findClosestElementAncestor(element, TableCellSelector);\n    let result: TableCellCoordinate | null = null;\n\n    // Try to do a fast check if both TD are in the given TABLE\n    if (td) {\n        parsedTable.some((row, rowIndex) => {\n            const colIndex = td ? row.indexOf(td as HTMLTableCellElement) : -1;\n\n            return (result = colIndex >= 0 ? { row: rowIndex, col: colIndex } : null);\n        });\n    }\n\n    // For nested table scenario, try to find the outer TAble cells\n    if (!result) {\n        parsedTable.some((row, rowIndex) => {\n            const colIndex = row.findIndex(\n                cell => typeof cell == 'object' && cell.contains(element)\n            );\n\n            return (result = colIndex >= 0 ? { row: rowIndex, col: colIndex } : null);\n        });\n    }\n\n    return result;\n}\n","import { isElementOfType, isNodeOfType } from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n */\nexport function isSingleImageInSelection(selection: Selection | Range): HTMLImageElement | null {\n    const { startNode, endNode, startOffset, endOffset } = getProps(selection);\n\n    const max = Math.max(startOffset, endOffset);\n    const min = Math.min(startOffset, endOffset);\n\n    if (startNode && endNode && startNode == endNode && max - min == 1) {\n        const node = startNode?.childNodes.item(min);\n        if (isNodeOfType(node, 'ELEMENT_NODE') && isElementOfType(node, 'img')) {\n            return node;\n        }\n    }\n    return null;\n}\nfunction getProps(\n    selection: Selection | Range\n): { startNode: Node | null; endNode: Node | null; startOffset: number; endOffset: number } {\n    if (isSelection(selection)) {\n        return {\n            startNode: selection.anchorNode,\n            endNode: selection.focusNode,\n            startOffset: selection.anchorOffset,\n            endOffset: selection.focusOffset,\n        };\n    } else {\n        return {\n            startNode: selection.startContainer,\n            endNode: selection.endContainer,\n            startOffset: selection.startOffset,\n            endOffset: selection.endOffset,\n        };\n    }\n}\n\nfunction isSelection(selection: Selection | Range): selection is Selection {\n    return !!(selection as Selection).getRangeAt;\n}\n","import { isNodeOfType } from 'roosterjs-content-model-dom';\nimport type { DOMInsertPoint } from 'roosterjs-content-model-types';\n\n/**\n * HTML void elements\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\n * void elements so users don't accidentally create child nodes in them\n */\nconst HTML_VOID_ELEMENTS = [\n    'AREA',\n    'BASE',\n    'BR',\n    'COL',\n    'COMMAND',\n    'EMBED',\n    'HR',\n    'IMG',\n    'INPUT',\n    'KEYGEN',\n    'LINK',\n    'META',\n    'PARAM',\n    'SOURCE',\n    'TRACK',\n    'WBR',\n];\n\n/**\n * @internal\n */\nexport function normalizePos(node: Node, offset: number): DOMInsertPoint {\n    const len = isNodeOfType(node, 'TEXT_NODE')\n        ? node.nodeValue?.length ?? 0\n        : node.childNodes.length;\n    offset = Math.max(Math.min(offset, len), 0);\n\n    while (node?.lastChild) {\n        if (offset >= node.childNodes.length) {\n            node = node.lastChild;\n            offset = isNodeOfType(node, 'TEXT_NODE')\n                ? node.nodeValue?.length ?? 0\n                : node.childNodes.length;\n        } else {\n            const nextNode = node.childNodes[offset];\n\n            if (\n                isNodeOfType(nextNode, 'ELEMENT_NODE') &&\n                HTML_VOID_ELEMENTS.indexOf(nextNode.tagName) >= 0\n            ) {\n                break;\n            } else {\n                node = node.childNodes[offset];\n                offset = 0;\n            }\n        }\n    }\n\n    return { node, offset };\n}\n","import type { Snapshot, Snapshots, SnapshotsManager } from 'roosterjs-content-model-types';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAX_SIZE_LIMIT = 1e7;\n\nclass SnapshotsManagerImpl implements SnapshotsManager {\n    private snapshots: Snapshots;\n    private hasNewContentValue: boolean = false;\n\n    constructor(snapshots?: Snapshots) {\n        this.snapshots = snapshots ?? {\n            snapshots: [],\n            totalSize: 0,\n            currentIndex: -1,\n            autoCompleteIndex: -1,\n            maxSize: MAX_SIZE_LIMIT,\n        };\n    }\n\n    get hasNewContent(): boolean {\n        return this.hasNewContentValue;\n    }\n\n    set hasNewContent(value: boolean) {\n        this.hasNewContentValue = value;\n    }\n\n    canMove(step: number): boolean {\n        const newIndex = this.snapshots.currentIndex + step;\n        return newIndex >= 0 && newIndex < this.snapshots.snapshots.length;\n    }\n\n    move(step: number): Snapshot | null {\n        let result: Snapshot | null = null;\n\n        if (this.canMove(step)) {\n            this.snapshots.currentIndex += step;\n            this.snapshots.autoCompleteIndex = -1;\n            result = this.snapshots.snapshots[this.snapshots.currentIndex];\n        }\n\n        this.snapshots.onChanged?.('move');\n\n        return result;\n    }\n\n    addSnapshot(snapshot: Snapshot, isAutoCompleteSnapshot: boolean): void {\n        const currentSnapshot = this.snapshots.snapshots[this.snapshots.currentIndex];\n        const isSameSnapshot =\n            currentSnapshot &&\n            currentSnapshot.html == snapshot.html &&\n            !currentSnapshot.additionalState &&\n            !snapshot.additionalState &&\n            !currentSnapshot.entityStates &&\n            !snapshot.entityStates;\n        const addSnapshot = !currentSnapshot || shouldAddSnapshot(currentSnapshot, snapshot);\n\n        if (this.snapshots.currentIndex < 0 || addSnapshot) {\n            this.clearRedo();\n            this.snapshots.snapshots.push(snapshot);\n            this.snapshots.currentIndex++;\n            this.snapshots.totalSize += this.getSnapshotLength(snapshot);\n\n            let removeCount = 0;\n            while (\n                removeCount < this.snapshots.snapshots.length &&\n                this.snapshots.totalSize > this.snapshots.maxSize\n            ) {\n                this.snapshots.totalSize -= this.getSnapshotLength(\n                    this.snapshots.snapshots[removeCount]\n                );\n                removeCount++;\n            }\n\n            if (removeCount > 0) {\n                this.snapshots.snapshots.splice(0, removeCount);\n                this.snapshots.currentIndex -= removeCount;\n\n                if (this.snapshots.autoCompleteIndex >= 0) {\n                    this.snapshots.autoCompleteIndex -= removeCount;\n                }\n            }\n\n            if (isAutoCompleteSnapshot) {\n                this.snapshots.autoCompleteIndex = this.snapshots.currentIndex;\n            }\n        } else if (isSameSnapshot) {\n            // replace the currentSnapshot's metadata so the selection is updated\n            this.snapshots.snapshots.splice(this.snapshots.currentIndex, 1, snapshot);\n        }\n\n        this.snapshots.onChanged?.('add');\n    }\n\n    clearRedo(): void {\n        if (this.canMove(1)) {\n            let removedSize = 0;\n            for (\n                let i = this.snapshots.currentIndex + 1;\n                i < this.snapshots.snapshots.length;\n                i++\n            ) {\n                removedSize += this.getSnapshotLength(this.snapshots.snapshots[i]);\n            }\n\n            this.snapshots.snapshots.splice(this.snapshots.currentIndex + 1);\n            this.snapshots.totalSize -= removedSize;\n            this.snapshots.autoCompleteIndex = -1;\n\n            this.snapshots.onChanged?.('clear');\n        }\n    }\n\n    canUndoAutoComplete(): boolean {\n        return (\n            this.snapshots.autoCompleteIndex >= 0 &&\n            this.snapshots.currentIndex - this.snapshots.autoCompleteIndex == 1\n        );\n    }\n\n    private getSnapshotLength(snapshot: Snapshot) {\n        return snapshot.html?.length ?? 0;\n    }\n}\n\n/**\n * @internal\n * Create a new instance of Undo Snapshots Manager\n * @param snapshots @optional Snapshots object for storing undo snapshots. If not passed, default implementation will be used\n */\nexport function createSnapshotsManager(snapshots?: Snapshots): SnapshotsManager {\n    return new SnapshotsManagerImpl(snapshots);\n}\n\nfunction shouldAddSnapshot(currentSnapshot: Snapshot, snapshot: Snapshot) {\n    return (\n        currentSnapshot.html !== snapshot.html ||\n        (currentSnapshot.additionalState &&\n            snapshot.additionalState &&\n            JSON.stringify(currentSnapshot.additionalState) !==\n                JSON.stringify(snapshot.additionalState)) ||\n        (!currentSnapshot.additionalState && snapshot.additionalState) ||\n        (currentSnapshot.entityStates &&\n            snapshot.entityStates &&\n            currentSnapshot.entityStates !== snapshot.entityStates) ||\n        (!currentSnapshot.entityStates && snapshot.entityStates)\n    );\n}\n","import { createSnapshotsManager } from './SnapshotsManagerImpl';\nimport { isCursorMovingKey } from 'roosterjs-content-model-dom';\nimport { undo } from '../../command/undo/undo';\nimport type {\n    ContentChangedEvent,\n    IEditor,\n    PluginEvent,\n    PluginWithState,\n    EditorOptions,\n    UndoPluginState,\n} from 'roosterjs-content-model-types';\n\nconst Backspace = 'Backspace';\nconst Delete = 'Delete';\nconst Enter = 'Enter';\n\n/**\n * Provides snapshot based undo service for Editor\n */\nclass UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: IEditor | null = null;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            snapshotsManager: createSnapshotsManager(options.snapshots),\n            isRestoring: false,\n            isNested: false,\n            autoCompleteInsertPoint: null,\n            lastKeyPress: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            !!this.editor &&\n            event.eventType == 'keyDown' &&\n            event.rawEvent.key == Backspace &&\n            !event.rawEvent.ctrlKey &&\n            this.canUndoAutoComplete(this.editor)\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        if (!this.editor) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case 'editorReady':\n                const manager = this.state.snapshotsManager;\n                const canUndo = manager.hasNewContent || manager.canMove(-1);\n                const canRedo = manager.canMove(1);\n\n                if (!canUndo && !canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case 'keyDown':\n                this.onKeyDown(this.editor, event.rawEvent);\n                break;\n            case 'keyPress':\n                this.onKeyPress(this.editor, event.rawEvent);\n                break;\n            case 'compositionEnd':\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case 'contentChanged':\n                this.onContentChanged(event);\n                break;\n            case 'beforeKeyboardEditing':\n                this.onBeforeKeyboardEditing(event.rawEvent);\n                break;\n\n            case 'mouseDown':\n                if (this.state.snapshotsManager.hasNewContent) {\n                    this.addUndoSnapshot();\n                }\n                break;\n        }\n    }\n\n    private onKeyDown(editor: IEditor, evt: KeyboardEvent): void {\n        const { snapshotsManager } = this.state;\n\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        // Ignore if keycombo is ALT+BACKSPACE\n        if ((evt.key == Backspace && !evt.altKey) || evt.key == Delete) {\n            if (evt.key == Backspace && !evt.ctrlKey && this.canUndoAutoComplete(editor)) {\n                evt.preventDefault();\n                undo(editor);\n                this.state.autoCompleteInsertPoint = null;\n                this.state.lastKeyPress = evt.key;\n            } else if (!evt.defaultPrevented) {\n                const selection = editor.getDOMSelection();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selection &&\n                    (selection.type != 'range' ||\n                        !selection.range.collapsed ||\n                        this.state.lastKeyPress != evt.key ||\n                        this.isCtrlOrMetaPressed(editor, evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                snapshotsManager.hasNewContent = true;\n                this.state.lastKeyPress = evt.key;\n            }\n        } else if (isCursorMovingKey(evt)) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (snapshotsManager.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.state.lastKeyPress = null;\n        } else if (this.state.lastKeyPress == Backspace || this.state.lastKeyPress == Delete) {\n            if (snapshotsManager.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n        }\n    }\n\n    private onKeyPress(editor: IEditor, evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        const selection = editor.getDOMSelection();\n\n        if (\n            (selection && (selection.type != 'range' || !selection.range.collapsed)) ||\n            (evt.key == ' ' && this.state.lastKeyPress != ' ') ||\n            evt.key == Enter\n        ) {\n            this.addUndoSnapshot();\n\n            if (evt.key == Enter) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.snapshotsManager.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.state.lastKeyPress = evt.key;\n    }\n\n    private onBeforeKeyboardEditing(event: KeyboardEvent) {\n        // For keyboard event (triggered from Content Model), we can get its keycode from event.data\n        // And when user is keep pressing the same key, mark editor with \"hasNewContent\" so that next time user\n        // do some other action or press a different key, we will add undo snapshot\n        if (event.key != this.state.lastKeyPress) {\n            this.addUndoSnapshot();\n        }\n\n        this.state.lastKeyPress = event.key;\n        this.state.snapshotsManager.hasNewContent = true;\n    }\n\n    private onContentChanged(event: ContentChangedEvent) {\n        if (!this.state.isRestoring && !event.skipUndo) {\n            this.clearRedoForInput();\n        }\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsManager.clearRedo();\n        this.state.lastKeyPress = null;\n        this.state.snapshotsManager.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete(editor: IEditor) {\n        const selection = editor.getDOMSelection();\n\n        return (\n            this.state.snapshotsManager.canUndoAutoComplete() &&\n            selection?.type == 'range' &&\n            selection.range.collapsed &&\n            selection.range.startContainer == this.state.autoCompleteInsertPoint?.node &&\n            selection.range.startOffset == this.state.autoCompleteInsertPoint.offset\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor?.takeSnapshot();\n        this.state.autoCompleteInsertPoint = null;\n    }\n\n    private isCtrlOrMetaPressed(editor: IEditor, event: KeyboardEvent) {\n        const env = editor.getEnvironment();\n\n        return env.isMac ? event.metaKey : event.ctrlKey;\n    }\n}\n\n/**\n * @internal\n * Create a new instance of UndoPlugin.\n * @param option The editor option\n */\nexport function createUndoPlugin(option: EditorOptions): PluginWithState<UndoPluginState> {\n    return new UndoPlugin(option);\n}\n","import { createEditorCore } from './core/createEditorCore';\nimport {\n    createEmptyModel,\n    ChangeSource,\n    cloneModel,\n    transformColor,\n    createDomToModelContextWithConfig,\n    domToContentModel,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelDocument,\n    ContentModelFormatter,\n    ContentModelSegmentFormat,\n    DarkColorHandler,\n    DOMEventRecord,\n    DOMHelper,\n    DOMSelection,\n    EditorEnvironment,\n    FormatContentModelOptions,\n    IEditor,\n    PluginEventData,\n    PluginEventFromType,\n    PluginEventType,\n    Snapshot,\n    SnapshotsManager,\n    EditorCore,\n    EditorOptions,\n    Rect,\n    EntityState,\n    CachedElementHandler,\n    DomToModelOptionForCreateModel,\n    AnnounceData,\n    ExperimentalFeature,\n    LegacyTrustedHTMLHandler,\n    DOMCreator,\n} from 'roosterjs-content-model-types';\n\n/**\n * The main editor class based on Content Model\n */\nexport class Editor implements IEditor {\n    private core: EditorCore | null = null;\n\n    /**\n     * Creates an instance of Editor\n     * @param contentDiv The DIV HTML element which will be the container element of editor\n     * @param options An optional options object to customize the editor\n     */\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\n        this.core = createEditorCore(contentDiv, options);\n\n        const initialModel =\n            options.initialModel ?? createEmptyModel(this.core.format.defaultFormat);\n\n        this.core.api.setContentModel(\n            this.core,\n            initialModel,\n            { ignoreSelection: true },\n            undefined /*onNodeCreated*/,\n            true /*isInitializing*/\n        );\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\n    }\n\n    /**\n     * Dispose this editor, dispose all plugins and custom data\n     */\n    dispose() {\n        const core = this.getCore();\n\n        for (let i = core.plugins.length - 1; i >= 0; i--) {\n            const plugin = core.plugins[i];\n\n            try {\n                plugin.dispose();\n            } catch (e) {\n                // Cache the error and pass it out, then keep going since dispose should always succeed\n                core.disposeErrorHandler?.(plugin, e as Error);\n            }\n        }\n\n        core.darkColorHandler.reset();\n\n        this.core = null;\n    }\n\n    /**\n     * Get whether this editor is disposed\n     * @returns True if editor is disposed, otherwise false\n     */\n    isDisposed(): boolean {\n        return !this.core;\n    }\n\n    /**\n     * Create Content Model from DOM tree in this editor\n     * @param mode What kind of Content Model we want. Currently we support the following values:\n     * - disconnected: Returns a disconnected clone of Content Model from editor which you can do any change on it and it won't impact the editor content.\n     * If there is any entity in editor, the returned object will contain cloned copy of entity wrapper element.\n     * If editor is in dark mode, the cloned entity will be converted back to light mode.\n     * - clean: Similar with disconnected, this will return a disconnected model, the difference is \"clean\" mode will not include any selection info.\n     * This is usually used for exporting content\n     */\n    getContentModelCopy(mode: 'connected' | 'disconnected' | 'clean'): ContentModelDocument {\n        const core = this.getCore();\n\n        switch (mode) {\n            case 'connected': // Get a connected model is deprecated. Now we will always return disconnected model\n            case 'disconnected':\n                return cloneModel(\n                    core.api.createContentModel(core, {\n                        tryGetFromCache: false,\n                    }),\n                    {\n                        includeCachedElement: this.cloneOptionCallback,\n                    }\n                );\n\n            case 'clean':\n                const domToModelContext = createDomToModelContextWithConfig(\n                    core.environment.domToModelSettings.calculated,\n                    core.api.createEditorContext(core, false /*saveIndex*/)\n                );\n\n                return cloneModel(domToContentModel(core.physicalRoot, domToModelContext), {\n                    includeCachedElement: this.cloneOptionCallback,\n                });\n        }\n    }\n\n    /**\n     * Get current running environment, such as if editor is running on Mac\n     */\n    getEnvironment(): EditorEnvironment {\n        return this.getCore().environment;\n    }\n\n    /**\n     * Get current DOM selection\n     */\n    getDOMSelection(): DOMSelection | null {\n        const core = this.getCore();\n\n        return core.api.getDOMSelection(core);\n    }\n\n    /**\n     * Set DOMSelection into editor content.\n     * @param selection The selection to set\n     */\n    setDOMSelection(selection: DOMSelection | null) {\n        const core = this.getCore();\n\n        core.api.setDOMSelection(core, selection);\n    }\n\n    /**\n     * Set a new logical root (most likely due to focus change)\n     * @param logicalRoot The new logical root (has to be child of physicalRoot)\n     */\n    setLogicalRoot(logicalRoot: HTMLDivElement) {\n        const core = this.getCore();\n\n        core.api.setLogicalRoot(core, logicalRoot);\n    }\n\n    /**\n     * The general API to do format change with Content Model\n     * It will grab a Content Model for current editor content, and invoke a callback function\n     * to do format change. Then according to the return value, write back the modified content model into editor.\n     * If there is cached model, it will be used and updated.\n     * @param formatter Formatter function, see ContentModelFormatter\n     * @param options More options, see FormatContentModelOptions\n     */\n    formatContentModel(\n        formatter: ContentModelFormatter,\n        options?: FormatContentModelOptions,\n        domToModelOptions?: DomToModelOptionForCreateModel\n    ): void {\n        const core = this.getCore();\n\n        core.api.formatContentModel(core, formatter, options, domToModelOptions);\n    }\n\n    /**\n     * Get pending format of editor if any, or return null\n     */\n    getPendingFormat(): ContentModelSegmentFormat | null {\n        return this.getCore().format.pendingFormat?.format ?? null;\n    }\n\n    /**\n     * Get a DOM Helper object to help access DOM tree in editor\n     */\n    getDOMHelper(): DOMHelper {\n        return this.getCore().domHelper;\n    }\n\n    /**\n     * Add a single undo snapshot to undo stack\n     * @param entityState @optional State for entity if we want to add entity state for this snapshot\n     */\n    takeSnapshot(entityState?: EntityState): Snapshot | null {\n        const core = this.getCore();\n\n        return core.api.addUndoSnapshot(\n            core,\n            false /*canUndoByBackspace*/,\n            entityState ? [entityState] : undefined\n        );\n    }\n\n    /**\n     * Restore an undo snapshot into editor\n     * @param snapshot The snapshot to restore\n     */\n    restoreSnapshot(snapshot: Snapshot): void {\n        const core = this.getCore();\n\n        core.api.restoreUndoSnapshot(core, snapshot);\n    }\n\n    /**\n     * Get document which contains this editor\n     * @returns The HTML document which contains this editor\n     */\n    getDocument(): Document {\n        return this.getCore().environment.document;\n    }\n\n    /**\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\n     */\n    focus() {\n        const core = this.getCore();\n        core.api.focus(core);\n    }\n\n    /**\n     * Check if focus is in editor now\n     * @returns true if focus is in editor, otherwise false\n     */\n    hasFocus(): boolean {\n        const core = this.getCore();\n        return core.domHelper.hasFocus();\n    }\n\n    /**\n     * Trigger an event to be dispatched to all plugins\n     * @param eventType Type of the event\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\n     * the result of this function provides a chance to read the modified result\n     */\n    triggerEvent<T extends PluginEventType>(\n        eventType: T,\n        data: PluginEventData<T>,\n        broadcast: boolean = false\n    ): PluginEventFromType<T> {\n        const core = this.getCore();\n        const event = ({\n            eventType,\n            ...data,\n        } as any) as PluginEventFromType<T>;\n        core.api.triggerEvent(core, event, broadcast);\n\n        return event;\n    }\n\n    /**\n     * Attach a DOM event to the editor content DIV\n     * @param eventMap A map from event name to its handler\n     */\n    attachDomEvent(eventMap: Record<string, DOMEventRecord>): () => void {\n        const core = this.getCore();\n        return core.api.attachDomEvent(core, eventMap);\n    }\n\n    /**\n     * Get undo snapshots manager\n     */\n    getSnapshotsManager(): SnapshotsManager {\n        const core = this.getCore();\n\n        return core.undo.snapshotsManager;\n    }\n\n    /**\n     * Check if the editor is in dark mode\n     * @returns True if the editor is in dark mode, otherwise false\n     */\n    isDarkMode(): boolean {\n        return this.getCore().lifecycle.isDarkMode;\n    }\n\n    /**\n     * Set the dark mode state and transforms the content to match the new state.\n     * @param isDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\n     */\n    setDarkModeState(isDarkMode?: boolean) {\n        const core = this.getCore();\n\n        if (!!isDarkMode != core.lifecycle.isDarkMode) {\n            transformColor(\n                core.physicalRoot,\n                false /*includeSelf*/,\n                isDarkMode ? 'lightToDark' : 'darkToLight',\n                core.darkColorHandler,\n                {\n                    tableBorders: this.isExperimentalFeatureEnabled('TransformTableBorderColors'),\n                }\n            );\n\n            core.lifecycle.isDarkMode = !!isDarkMode;\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: 'contentChanged',\n                    source: isDarkMode\n                        ? ChangeSource.SwitchToDarkMode\n                        : ChangeSource.SwitchToLightMode,\n                    skipUndo: true,\n                },\n                true\n            );\n        }\n    }\n\n    /**\n     * Check if editor is in Shadow Edit mode\n     */\n    isInShadowEdit() {\n        return !!this.getCore().lifecycle.shadowEditFragment;\n    }\n\n    /**\n     * Make the editor in \"Shadow Edit\" mode.\n     * In Shadow Edit mode, all format change will finally be ignored.\n     * This can be used for building a live preview feature for format button, to allow user\n     * see format result without really apply it.\n     * This function can be called repeated. If editor is already in shadow edit mode, we can still\n     * use this function to do more shadow edit operation.\n     */\n    startShadowEdit() {\n        const core = this.getCore();\n        core.api.switchShadowEdit(core, true /*isOn*/);\n    }\n\n    /**\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\n     */\n    stopShadowEdit() {\n        const core = this.getCore();\n        core.api.switchShadowEdit(core, false /*isOn*/);\n    }\n\n    /**\n     * Get a color manager object for this editor.\n     */\n    getColorManager(): DarkColorHandler {\n        return this.getCore().darkColorHandler;\n    }\n\n    /**\n     * @deprecated\n     * Get a function to convert HTML string to trusted HTML string.\n     * By default it will just return the input HTML directly. To override this behavior,\n     * pass your own trusted HTML handler to EditorOptions.trustedHTMLHandler\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types\n     */\n    getTrustedHTMLHandler(): LegacyTrustedHTMLHandler {\n        return this.getCore().trustedHTMLHandler;\n    }\n\n    /**\n     * Get a function to convert HTML string to a trust Document.\n     * By default it will just convert the original HTML string into a Document object directly.\n     * To override, pass your own trusted HTML handler to EditorOptions.trustedHTMLHandler\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types\n     */\n    getDOMCreator(): DOMCreator {\n        return this.getCore().domCreator;\n    }\n\n    /**\n     * Get the scroll container of the editor\n     */\n    getScrollContainer(): HTMLElement {\n        return this.getCore().domEvent.scrollContainer;\n    }\n\n    /**\n     * Retrieves the rect of the visible viewport of the editor.\n     */\n    getVisibleViewport(): Rect | null {\n        return this.getCore().api.getVisibleViewport(this.getCore());\n    }\n\n    /**\n     * Add CSS rules for editor\n     * @param key A string to identify the CSS rule type. When set CSS rules with the same key again, existing rules with the same key will be replaced.\n     * @param cssRule The CSS rule string, must be a valid CSS rule string, or browser may throw exception. Pass null to clear existing rules\n     * @param subSelectors @optional If the rule is used for child element under editor, use this parameter to specify the child elements. Each item will be\n     * combined with root selector together to build a separate rule.\n     */\n    setEditorStyle(\n        key: string,\n        cssRule: string | null,\n        subSelectors?: 'before' | 'after' | string[]\n    ): void {\n        const core = this.getCore();\n\n        core.api.setEditorStyle(core, key, cssRule, subSelectors);\n    }\n\n    /**\n     * Announce the given data\n     * @param announceData Data to announce\n     */\n    announce(announceData: AnnounceData): void {\n        const core = this.getCore();\n\n        core.api.announce(core, announceData);\n    }\n\n    /**\n     * Check if a given feature is enabled\n     * @param featureName The name of feature to check\n     */\n    isExperimentalFeatureEnabled(featureName: ExperimentalFeature | string): boolean {\n        return this.getCore().experimentalFeatures.indexOf(featureName) >= 0;\n    }\n\n    /**\n     * @returns the current EditorCore object\n     * @throws a standard Error if there's no core object\n     */\n    protected getCore(): EditorCore {\n        if (!this.core) {\n            throw new Error('Editor is already disposed');\n        }\n        return this.core;\n    }\n\n    private cloneOptionCallback: CachedElementHandler = (node, type) => {\n        if (type == 'cache') {\n            return undefined;\n        }\n\n        const result = node.cloneNode(true /*deep*/) as HTMLElement;\n\n        if (this.isDarkMode()) {\n            const colorHandler = this.getColorManager();\n\n            transformColor(result, true /*includeSelf*/, 'darkToLight', colorHandler, {\n                tableBorders: this.isExperimentalFeatureEnabled('TransformTableBorderColors'),\n            });\n\n            result.style.color = result.style.color || 'inherit';\n            result.style.backgroundColor = result.style.backgroundColor || 'inherit';\n        }\n\n        return result;\n    };\n}\n","import {\n    getColor,\n    getRangesByText,\n    isBlockElement,\n    isNodeOfType,\n    parseValueWithUnit,\n    toArray,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelSegmentFormat,\n    DarkColorHandler,\n    DOMHelper,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport interface DOMHelperImplOption {\n    cloneIndependentRoot?: boolean;\n}\n\nclass DOMHelperImpl implements DOMHelper {\n    constructor(private contentDiv: HTMLElement, private options: DOMHelperImplOption) {}\n\n    queryElements(selector: string): HTMLElement[] {\n        return toArray(this.contentDiv.querySelectorAll(selector)) as HTMLElement[];\n    }\n\n    getTextContent(): string {\n        return this.contentDiv.textContent || '';\n    }\n\n    isNodeInEditor(node: Node, excludeRoot?: boolean): boolean {\n        return excludeRoot && node == this.contentDiv ? false : this.contentDiv.contains(node);\n    }\n\n    calculateZoomScale(): number {\n        const originalWidth = this.contentDiv.getBoundingClientRect()?.width || 0;\n        const visualWidth = this.contentDiv.offsetWidth;\n\n        return visualWidth > 0 && originalWidth > 0\n            ? Math.round((originalWidth / visualWidth) * 100) / 100\n            : 1;\n    }\n\n    setDomAttribute(name: string, value: string | null) {\n        if (value === null) {\n            this.contentDiv.removeAttribute(name);\n        } else {\n            this.contentDiv.setAttribute(name, value);\n        }\n    }\n\n    getDomAttribute(name: string): string | null {\n        return this.contentDiv.getAttribute(name);\n    }\n\n    getDomStyle<T extends keyof CSSStyleDeclaration>(style: T): CSSStyleDeclaration[T] {\n        return this.contentDiv.style[style];\n    }\n\n    findClosestElementAncestor(startFrom: Node, selector?: string): HTMLElement | null {\n        const startElement = isNodeOfType(startFrom, 'ELEMENT_NODE')\n            ? startFrom\n            : startFrom.parentElement;\n        const closestElement = selector\n            ? (startElement?.closest(selector) as HTMLElement | null)\n            : startElement;\n\n        return closestElement &&\n            this.isNodeInEditor(closestElement) &&\n            closestElement != this.contentDiv\n            ? closestElement\n            : null;\n    }\n\n    /**\n     * Find the closest block element ancestor from the given node within current editing scope\n     * @param startFrom The node to start the search from\n     * @returns The closest block element ancestor\n     */\n    findClosestBlockElement(startFrom: Node): HTMLElement {\n        let node: Node | null = startFrom;\n\n        while (node && this.isNodeInEditor(node)) {\n            if (isNodeOfType(node, 'ELEMENT_NODE') && isBlockElement(node)) {\n                return node;\n            }\n\n            node = node.parentElement;\n        }\n\n        return this.contentDiv;\n    }\n\n    hasFocus(): boolean {\n        const activeElement = this.contentDiv.ownerDocument.activeElement;\n        return !!(activeElement && this.contentDiv.contains(activeElement));\n    }\n\n    /**\n     * Check if the root element is in RTL mode\n     */\n    isRightToLeft(): boolean {\n        const contentDiv = this.contentDiv;\n        const style = contentDiv.ownerDocument.defaultView?.getComputedStyle(contentDiv);\n\n        return style?.direction == 'rtl';\n    }\n\n    /**\n     * Get the width of the editable area of the editor content div\n     */\n    getClientWidth(): number {\n        const contentDiv = this.contentDiv;\n        const style = contentDiv.ownerDocument.defaultView?.getComputedStyle(contentDiv);\n        const paddingLeft = parseValueWithUnit(style?.paddingLeft);\n        const paddingRight = parseValueWithUnit(style?.paddingRight);\n        return this.contentDiv.clientWidth - (paddingLeft + paddingRight);\n    }\n\n    /**\n     * Get a deep cloned root element\n     */\n    getClonedRoot(): HTMLElement {\n        if (this.options.cloneIndependentRoot) {\n            const doc = this.contentDiv.ownerDocument.implementation.createHTMLDocument();\n            const clone = doc.importNode(this.contentDiv, true /*deep*/);\n\n            return clone;\n        } else {\n            return this.contentDiv.cloneNode(true /*deep*/) as HTMLElement;\n        }\n    }\n\n    /**\n     * Get format of the container element\n     * @param isInDarkMode Optional flag to indicate if the environment is in dark mode\n     * @param darkColorHandler Optional DarkColorHandler to retrieve dark mode colors\n     */\n    getContainerFormat(\n        isInDarkMode?: boolean,\n        darkColorHandler?: DarkColorHandler\n    ): ContentModelSegmentFormat {\n        const window = this.contentDiv.ownerDocument.defaultView;\n\n        const style = window?.getComputedStyle(this.contentDiv);\n\n        return style\n            ? {\n                  fontSize: style.fontSize,\n                  fontFamily: style.fontFamily,\n                  fontWeight: style.fontWeight,\n                  textColor: getColor(\n                      this.contentDiv,\n                      false /*isBackgroundColor*/,\n                      !!isInDarkMode,\n                      darkColorHandler,\n                      style.color\n                  ),\n                  backgroundColor: getColor(\n                      this.contentDiv,\n                      true /*isBackgroundColor*/,\n                      !!isInDarkMode,\n                      darkColorHandler,\n                      style.backgroundColor\n                  ),\n                  italic: style.fontStyle == 'italic',\n                  letterSpacing: style.letterSpacing,\n                  lineHeight: style.lineHeight,\n                  strikethrough: style.textDecoration?.includes('line-through'),\n                  superOrSubScriptSequence: style.verticalAlign,\n                  underline: style.textDecoration?.includes('underline'),\n              }\n            : {};\n    }\n\n    /**\n     * Get text ranges by searching for a specific text, with options to match case and whole word.\n     * This will only search within editable elements.\n     * @param text The text to search for\n     * @param matchCase Whether to match case\n     * @param wholeWord Whether to match whole word\n     * @returns An array of Ranges that match the search criteria\n     */\n    getRangesByText(text: string, matchCase: boolean, wholeWord: boolean): Range[] {\n        return getRangesByText(this.contentDiv, text, matchCase, wholeWord, true /*editableOnly*/);\n    }\n}\n\n/**\n * @internal Create new instance of DOMHelper\n */\nexport function createDOMHelper(\n    contentDiv: HTMLElement,\n    options: DOMHelperImplOption = {}\n): DOMHelper {\n    return new DOMHelperImpl(contentDiv, options);\n}\n","import { defaultGenerateColorKey } from 'roosterjs-content-model-dom';\nimport type {\n    DarkColorHandler,\n    ColorTransformFunction,\n    Colors,\n} from 'roosterjs-content-model-types';\n\nclass DarkColorHandlerImpl implements DarkColorHandler {\n    constructor(\n        private readonly root: HTMLElement,\n        public getDarkColor: ColorTransformFunction,\n        public readonly knownColors: Record<string, Colors>,\n        public generateColorKey: ColorTransformFunction\n    ) {}\n\n    updateKnownColor(isDarkMode: boolean, key?: string, colorPair?: Colors): void {\n        if (key && colorPair) {\n            // Has values to set\n            // When in light mode: Update the value to known values, do not touch container property\n            // When in dark mode: Update the value to known colors, set value to container\n            if (!this.knownColors[key]) {\n                this.knownColors[key] = colorPair;\n            }\n\n            if (isDarkMode) {\n                this.root.style.setProperty(key, colorPair.darkModeColor);\n            }\n        } else {\n            // No value to set\n            // When in light mode: No op\n            // When in dark mode: Set all values to container, do not touch known values\n            if (isDarkMode) {\n                Object.keys(this.knownColors).forEach(key => {\n                    this.root.style.setProperty(key, this.knownColors[key].darkModeColor);\n                });\n            }\n        }\n    }\n\n    reset() {\n        Object.keys(this.knownColors).forEach(key => {\n            this.root.style.removeProperty(key);\n        });\n    }\n}\n\n/**\n * @internal\n */\nexport function createDarkColorHandler(\n    root: HTMLElement,\n    getDarkColor: ColorTransformFunction,\n    knownColors: Record<string, Colors> = {},\n    generateColorKey: ColorTransformFunction = defaultGenerateColorKey\n): DarkColorHandler {\n    return new DarkColorHandlerImpl(root, getDarkColor, knownColors, generateColorKey);\n}\n","import { coreApiMap } from '../../coreApi/coreApiMap';\nimport { createDarkColorHandler } from './DarkColorHandlerImpl';\nimport { createDOMCreator, createTrustedHTMLHandler, isDOMCreator } from '../../utils/domCreator';\nimport { createDOMHelper } from './DOMHelperImpl';\nimport { createDomToModelSettings, createModelToDomSettings } from './createEditorDefaultSettings';\nimport { createEditorCorePlugins } from '../../corePlugin/createEditorCorePlugins';\nimport type {\n    EditorEnvironment,\n    PluginState,\n    EditorCore,\n    EditorCorePlugins,\n    EditorOptions,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal Create core object for editor\n * @param contentDiv Editor content DIV\n * @param options Editor options\n */\nexport function createEditorCore(contentDiv: HTMLDivElement, options: EditorOptions): EditorCore {\n    const corePlugins = createEditorCorePlugins(options, contentDiv);\n    const domCreator = createDOMCreator(options.trustedHTMLHandler);\n\n    return {\n        physicalRoot: contentDiv,\n        logicalRoot: contentDiv,\n        api: { ...coreApiMap, ...options.coreApiOverride },\n        originalApi: { ...coreApiMap },\n        plugins: [\n            corePlugins.cache,\n            corePlugins.format,\n            corePlugins.copyPaste,\n            corePlugins.domEvent,\n            corePlugins.selection,\n            corePlugins.entity,\n            ...(options.plugins ?? []).filter(x => !!x),\n            corePlugins.undo,\n            corePlugins.contextMenu,\n            corePlugins.lifecycle,\n        ],\n        environment: createEditorEnvironment(contentDiv, options),\n        darkColorHandler: createDarkColorHandler(\n            contentDiv,\n            options.getDarkColor ?? getDarkColorFallback,\n            options.knownColors,\n            options.generateColorKey\n        ),\n        trustedHTMLHandler:\n            options.trustedHTMLHandler && !isDOMCreator(options.trustedHTMLHandler)\n                ? options.trustedHTMLHandler\n                : createTrustedHTMLHandler(domCreator),\n        domCreator: domCreator,\n        domHelper: createDOMHelper(contentDiv, {\n            cloneIndependentRoot: options.experimentalFeatures?.includes('CloneIndependentRoot'),\n        }),\n        ...getPluginState(corePlugins),\n        disposeErrorHandler: options.disposeErrorHandler,\n        onFixUpModel: options.onFixUpModel,\n        experimentalFeatures: options.experimentalFeatures ? [...options.experimentalFeatures] : [],\n    };\n}\n\nfunction createEditorEnvironment(\n    contentDiv: HTMLElement,\n    options: EditorOptions\n): EditorEnvironment {\n    const navigator = contentDiv.ownerDocument.defaultView?.navigator;\n    const userAgent = navigator?.userAgent ?? '';\n    const appVersion = navigator?.appVersion ?? '';\n\n    return {\n        document: contentDiv.ownerDocument,\n        domToModelSettings: createDomToModelSettings(options),\n        modelToDomSettings: createModelToDomSettings(options),\n        isMac: appVersion.indexOf('Mac') != -1,\n        isAndroid: /android/i.test(userAgent),\n        isIOS: /iPad|iPhone/.test(userAgent),\n        isSafari:\n            userAgent.indexOf('AppleWebKit') >= 0 &&\n            userAgent.indexOf('Chrome') < 0 &&\n            userAgent.indexOf('Android') < 0,\n        isMobileOrTablet: getIsMobileOrTablet(userAgent),\n    };\n}\n\nfunction getIsMobileOrTablet(userAgent: string) {\n    // Reference: http://detectmobilebrowsers.com/\n    // The default regex on the website doesn't consider tablet.\n    // To support tablet, add |android|ipad|playbook|silk to the first regex according to the info in /about page\n    if (\n        /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(\n            userAgent\n        ) ||\n        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(\n            userAgent.substring(0, 4)\n        )\n    ) {\n        return true;\n    }\n    return false;\n}\n\nfunction getPluginState(corePlugins: EditorCorePlugins): PluginState {\n    return {\n        domEvent: corePlugins.domEvent.getState(),\n        copyPaste: corePlugins.copyPaste.getState(),\n        cache: corePlugins.cache.getState(),\n        format: corePlugins.format.getState(),\n        lifecycle: corePlugins.lifecycle.getState(),\n        entity: corePlugins.entity.getState(),\n        selection: corePlugins.selection.getState(),\n        contextMenu: corePlugins.contextMenu.getState(),\n        undo: corePlugins.undo.getState(),\n    };\n}\n\n/**\n * @internal Export for test only\n * A fallback function, always return original color\n */\nexport function getDarkColorFallback(color: string) {\n    return color;\n}\n","import { createDomToModelConfig, createModelToDomConfig } from 'roosterjs-content-model-dom';\nimport {\n    listItemMetadataApplier,\n    listLevelMetadataApplier,\n} from '../../override/listMetadataApplier';\nimport type {\n    ContentModelSettings,\n    DomToModelOption,\n    DomToModelSettings,\n    ModelToDomOption,\n    ModelToDomSettings,\n    EditorOptions,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create default DOM to Content Model conversion settings for an editor\n * @param options The editor options\n */\nexport function createDomToModelSettings(\n    options: EditorOptions\n): ContentModelSettings<DomToModelOption, DomToModelSettings> {\n    const builtIn: DomToModelOption = {};\n    const customized: DomToModelOption = options.defaultDomToModelOptions ?? {};\n\n    return {\n        builtIn,\n        customized,\n        calculated: createDomToModelConfig([builtIn, customized]),\n    };\n}\n\n/**\n * @internal\n * Create default Content Model to DOM conversion settings for an editor\n * @param options The editor options\n */\nexport function createModelToDomSettings(\n    options: EditorOptions\n): ContentModelSettings<ModelToDomOption, ModelToDomSettings> {\n    const builtIn: ModelToDomOption = {\n        metadataAppliers: {\n            listItem: listItemMetadataApplier,\n            listLevel: listLevelMetadataApplier,\n        },\n    };\n    const customized: ModelToDomOption = options.defaultModelToDomOptions ?? {};\n\n    return {\n        builtIn,\n        customized,\n        calculated: createModelToDomConfig([builtIn, customized]),\n    };\n}\n","// Editor\nexport { Editor } from './editor/Editor';\n\n// Editor command\nexport { createModelFromHtml } from './command/createModelFromHtml/createModelFromHtml';\nexport { exportContent } from './command/exportContent/exportContent';\nexport { undo } from './command/undo/undo';\nexport { redo } from './command/redo/redo';\nexport { paste } from './command/paste/paste';\n\n//Editor copy helper\nexport { getContentForCopy } from './command/cutCopy/getContentForCopy';\n","import type { FormatParser, SizeFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal Do not paste width for Format Containers since it may be generated by browser according to temp div width\n */\nexport const containerSizeFormatParser: FormatParser<SizeFormat> = (format, element) => {\n    // For pasted content, there may be existing width generated by browser from the temp DIV. So we need to remove it.\n    if (element.tagName == 'DIV' || element.tagName == 'P') {\n        delete format.width;\n        delete format.height;\n    }\n};\n","import {\n    ListMetadataDefinition,\n    OrderedListStyleMap,\n    UnorderedListStyleMap,\n    getAutoListStyleType,\n    getOrderedListNumberStr,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelListItemFormat,\n    ContentModelListItemLevelFormat,\n    ListMetadataFormat,\n    MetadataApplier,\n} from 'roosterjs-content-model-types';\n\nconst OrderedMapPlaceholderRegex = /\\$\\{(\\w+)\\}/;\n\nfunction getListStyleValue(\n    listType: 'OL' | 'UL',\n    listStyleType: number,\n    listNumber?: number\n): string | undefined {\n    if (listType == 'OL') {\n        const numberStr = getOrderedListNumberStr(listStyleType, listNumber ?? 1);\n        const template = OrderedListStyleMap[listStyleType];\n\n        return template ? template.replace(OrderedMapPlaceholderRegex, numberStr) : undefined;\n    } else {\n        return UnorderedListStyleMap[listStyleType];\n    }\n}\n\nfunction shouldApplyToItem(listStyleType: number, listType: 'OL' | 'UL') {\n    const style =\n        listType == 'OL'\n            ? OrderedListStyleMap[listStyleType]\n            : UnorderedListStyleMap[listStyleType];\n\n    return style?.indexOf('\"') >= 0;\n}\n\n/**\n * @internal\n */\nexport const listItemMetadataApplier: MetadataApplier<\n    ListMetadataFormat,\n    ContentModelListItemFormat\n> = {\n    metadataDefinition: ListMetadataDefinition,\n    applierFunction: (metadata, format, context) => {\n        const depth = context.listFormat.nodeStack.length - 2; // Minus two for the parent element and convert length to index\n\n        if (depth >= 0) {\n            const listType = context.listFormat.nodeStack[depth + 1].listType ?? 'OL';\n            const listStyleType = getAutoListStyleType(listType, metadata ?? {}, depth);\n\n            if (listStyleType !== undefined) {\n                if (shouldApplyToItem(listStyleType, listType)) {\n                    format.listStyleType = getListStyleValue(\n                        listType,\n                        listStyleType,\n                        context.listFormat.threadItemCounts[depth]\n                    );\n                } else {\n                    delete format.listStyleType;\n                }\n            }\n        }\n    },\n};\n\n/**\n * @internal\n */\nexport const listLevelMetadataApplier: MetadataApplier<\n    ListMetadataFormat,\n    ContentModelListItemLevelFormat\n> = {\n    metadataDefinition: ListMetadataDefinition,\n    applierFunction: (metadata, format, context) => {\n        const depth = context.listFormat.nodeStack.length - 2; // Minus two for the parent element and convert length to index\n\n        if (depth >= 0) {\n            const listType = context.listFormat.nodeStack[depth + 1].listType ?? 'OL';\n            const listStyleType = getAutoListStyleType(listType, metadata ?? {}, depth);\n\n            if (listStyleType !== undefined) {\n                if (!shouldApplyToItem(listStyleType, listType)) {\n                    const listNumber =\n                        context.listFormat.threadItemCounts[depth] > 0\n                            ? context.listFormat.threadItemCounts[depth]\n                            : 1;\n                    const listStyleTypeFormat = getListStyleValue(\n                        listType,\n                        listStyleType,\n                        listNumber\n                    );\n\n                    if (listStyleTypeFormat) {\n                        format.listStyleType = listStyleTypeFormat;\n                    }\n                } else {\n                    delete format.listStyleType;\n                }\n            }\n        }\n    },\n};\n","import { isBlockElement, isElementOfType, isNodeOfType } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelEntity,\n    EntityInfoFormat,\n    FormatParser,\n    OnNodeCreated,\n} from 'roosterjs-content-model-types';\n\nconst BlockEntityClass = '_EBlock';\nconst OneHundredPercent = '100%';\nconst InlineBlock = 'inline-block';\n\n/**\n * @internal\n */\nexport const onCreateCopyEntityNode: OnNodeCreated = (model, node) => {\n    const entityModel = model as ContentModelEntity;\n    if (\n        entityModel &&\n        entityModel.wrapper &&\n        entityModel.blockType == 'Entity' &&\n        isNodeOfType(node, 'ELEMENT_NODE') &&\n        isElementOfType(node, 'div') &&\n        !isBlockElement(entityModel.wrapper) &&\n        entityModel.wrapper.style.display == InlineBlock &&\n        entityModel.wrapper.style.width == OneHundredPercent\n    ) {\n        node.classList.add(BlockEntityClass);\n        node.style.display = 'block';\n        node.style.width = '';\n    }\n};\n\n/**\n * @internal\n */\nexport const pasteBlockEntityParser: FormatParser<EntityInfoFormat> = (_, element) => {\n    if (element.classList.contains(BlockEntityClass)) {\n        element.classList.remove(BlockEntityClass);\n        element.style.display = InlineBlock;\n        element.style.width = OneHundredPercent;\n    }\n};\n","import type { DisplayFormat, FormatParser } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const pasteDisplayFormatParser: FormatParser<DisplayFormat> = (format, element) => {\n    const display = element.style.display;\n\n    if (display && display != 'flex') {\n        format.display = display;\n    }\n};\n","import {\n    AllowedTags,\n    DisallowedTags,\n    sanitizeElement,\n} from '../command/createModelFromHtml/sanitizeElement';\nimport type {\n    DomToModelOptionForSanitizing,\n    ElementProcessor,\n    ValueSanitizer,\n} from 'roosterjs-content-model-types';\n\nconst DefaultStyleSanitizers: Readonly<Record<string, ValueSanitizer>> = {\n    position: false,\n};\n\n/**\n * @internal\n */\nexport function createPasteEntityProcessor(\n    options: DomToModelOptionForSanitizing\n): ElementProcessor<HTMLElement> {\n    const allowedTags = AllowedTags.concat(options.additionalAllowedTags);\n    const disallowedTags = DisallowedTags.concat(options.additionalDisallowedTags);\n    const styleSanitizers = Object.assign({}, DefaultStyleSanitizers, options.styleSanitizers);\n    const attrSanitizers = options.attributeSanitizers;\n\n    return (group, element, context) => {\n        const sanitizedElement = sanitizeElement(\n            element,\n            allowedTags,\n            disallowedTags,\n            styleSanitizers,\n            attrSanitizers\n        );\n\n        if (sanitizedElement) {\n            context.defaultElementProcessors.entity(group, sanitizedElement, context);\n        }\n    };\n}\n","import { moveChildNodes } from 'roosterjs-content-model-dom';\nimport {\n    AllowedTags,\n    createSanitizedElement,\n    DisallowedTags,\n} from '../command/createModelFromHtml/sanitizeElement';\nimport type {\n    DomToModelOptionForSanitizing,\n    ElementProcessor,\n    ValueSanitizer,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal Export for test only\n */\nexport const removeDisplayFlex: ValueSanitizer = value => {\n    return value == 'flex' ? null : value;\n};\n\nconst DefaultStyleSanitizers: Readonly<Record<string, ValueSanitizer>> = {\n    position: false,\n    display: removeDisplayFlex,\n};\n\n/**\n * @internal\n */\nexport function createPasteGeneralProcessor(\n    options: DomToModelOptionForSanitizing\n): ElementProcessor<HTMLElement> {\n    const allowedTags = AllowedTags.concat(options.additionalAllowedTags);\n    const disallowedTags = DisallowedTags.concat(options.additionalDisallowedTags);\n    const styleSanitizers = Object.assign({}, DefaultStyleSanitizers, options.styleSanitizers);\n    const attrSanitizers = options.attributeSanitizers;\n\n    return (group, element, context) => {\n        const tag = element.tagName.toLowerCase();\n        const processor: ElementProcessor<HTMLElement> | undefined =\n            allowedTags.indexOf(tag) >= 0\n                ? (group, element, context) => {\n                      const sanitizedElement = createSanitizedElement(\n                          element.ownerDocument,\n                          element.tagName,\n                          element.attributes,\n                          styleSanitizers,\n                          attrSanitizers\n                      );\n\n                      moveChildNodes(sanitizedElement, element);\n                      context.defaultElementProcessors['*']?.(group, sanitizedElement, context);\n                  }\n                : disallowedTags.indexOf(tag) >= 0\n                ? undefined // Ignore those disallowed tags\n                : context.defaultElementProcessors.span; // For other unknown tags, treat them as SPAN\n\n        processor?.(group, element, context);\n    };\n}\n","import { isWhiteSpacePreserved } from 'roosterjs-content-model-dom';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const pasteTextProcessor: ElementProcessor<Text> = (group, text, context) => {\n    const whiteSpace = context.blockFormat.whiteSpace;\n\n    if (isWhiteSpacePreserved(whiteSpace)) {\n        text.nodeValue = text.nodeValue?.replace(/\\u0020\\u0020/g, '\\u0020\\u00A0') ?? '';\n    }\n\n    context.defaultElementProcessors['#text'](group, text, context);\n};\n","import type { FormatParser, WhiteSpaceFormat } from 'roosterjs-content-model-types';\n\nconst WhiteSpacePre = 'pre';\n\n/**\n * @internal\n */\nexport const pasteWhiteSpaceFormatParser: FormatParser<WhiteSpaceFormat> = (\n    format,\n    element,\n    context,\n    defaultStyle\n) => {\n    if (element.style.whiteSpace != WhiteSpacePre) {\n        context.defaultFormatParsers.whiteSpace?.(format, element, context, defaultStyle);\n    }\n};\n","/**\n * @internal\n */\nexport function createAriaLiveElement(document: Document): HTMLDivElement {\n    const div = document.createElement('div');\n\n    div.style.clip = 'rect(0px, 0px, 0px, 0px)';\n    div.style.clipPath = 'inset(100%)';\n    div.style.height = '1px';\n    div.style.overflow = 'hidden';\n    div.style.position = 'absolute';\n    div.style.whiteSpace = 'nowrap';\n    div.style.width = '1px';\n    div.ariaLive = 'assertive';\n\n    document.body.appendChild(div);\n\n    return div;\n}\n","import type {\n    DOMCreator,\n    LegacyTrustedHTMLHandler,\n    TrustedHTMLHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const createTrustedHTMLHandler = (domCreator: DOMCreator): LegacyTrustedHTMLHandler => {\n    return (html: string) => domCreator.htmlToDOM(html).body.innerHTML;\n};\n\n/**\n * @internal\n */\nexport function createDOMCreator(trustedHTMLHandler?: TrustedHTMLHandler): DOMCreator {\n    return trustedHTMLHandler && isDOMCreator(trustedHTMLHandler)\n        ? trustedHTMLHandler\n        : trustedHTMLHandlerToDOMCreator(trustedHTMLHandler as LegacyTrustedHTMLHandler);\n}\n\n/**\n * @internal\n */\nexport function isDOMCreator(\n    trustedHTMLHandler: TrustedHTMLHandler\n): trustedHTMLHandler is DOMCreator {\n    return typeof (trustedHTMLHandler as DOMCreator).htmlToDOM === 'function';\n}\n\n/**\n * @internal\n */\nexport const defaultTrustHtmlHandler: LegacyTrustedHTMLHandler = (html: string) => {\n    return html;\n};\n\nfunction trustedHTMLHandlerToDOMCreator(trustedHTMLHandler?: LegacyTrustedHTMLHandler): DOMCreator {\n    const handler = trustedHTMLHandler || defaultTrustHtmlHandler;\n    return {\n        htmlToDOM: (html: string) => new DOMParser().parseFromString(handler(html), 'text/html'),\n        isBypassed: !trustedHTMLHandler,\n    };\n}\n","import type { DefaultImplicitFormatMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * A map from tag name to its default implicit formats\n */\nexport const defaultContentModelFormatMap: DefaultImplicitFormatMap = {\n    a: {\n        underline: true,\n        textColor: undefined, // Set to undefined to force override color from parent element so we can write correct link color if any, because browser will assign a default color for link if it doesn't have one\n    },\n    blockquote: {\n        marginTop: '1em',\n        marginBottom: '1em',\n        marginLeft: '40px',\n        marginRight: '40px',\n    },\n    code: {\n        fontFamily: 'monospace',\n    },\n    dd: {\n        marginLeft: '40px',\n    },\n    dl: {\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    h1: {\n        fontWeight: 'bold',\n        fontSize: '2em',\n    },\n    h2: {\n        fontWeight: 'bold',\n        fontSize: '1.5em',\n    },\n    h3: {\n        fontWeight: 'bold',\n        fontSize: '1.17em',\n    },\n    h4: {\n        fontWeight: 'bold',\n        fontSize: '1em', // Set this default value here to overwrite existing font size when change heading level\n    },\n    h5: {\n        fontWeight: 'bold',\n        fontSize: '0.83em',\n    },\n    h6: {\n        fontWeight: 'bold',\n        fontSize: '0.67em',\n    },\n    p: {\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    pre: {\n        fontFamily: 'monospace',\n        whiteSpace: 'pre',\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    th: {\n        fontWeight: 'bold',\n    },\n};\n","import type { DefaultStyleMap } from 'roosterjs-content-model-types';\n\nconst blockElement: Partial<CSSStyleDeclaration> = {\n    display: 'block',\n};\n\n/**\n * @internal\n */\nexport const defaultHTMLStyleMap: DefaultStyleMap = {\n    address: blockElement,\n    article: blockElement,\n    aside: blockElement,\n    b: {\n        fontWeight: 'bold',\n    },\n    blockquote: {\n        display: 'block',\n        marginTop: '1em',\n        marginBottom: '1em',\n        marginLeft: '40px',\n        marginRight: '40px',\n    },\n    br: blockElement,\n    center: {\n        display: 'block',\n        textAlign: 'center',\n    },\n    dd: { display: 'block', marginInlineStart: '40px' },\n    div: blockElement,\n    dl: {\n        display: 'block',\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    dt: blockElement,\n    em: {\n        fontStyle: 'italic',\n    },\n    fieldset: blockElement,\n    figcaption: blockElement,\n    figure: blockElement,\n    footer: blockElement,\n    form: blockElement,\n    h1: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '2em',\n    },\n    h2: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '1.5em',\n    },\n    h3: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '1.17em',\n    },\n    h4: {\n        display: 'block',\n        fontWeight: 'bold',\n    },\n    h5: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '0.83em',\n    },\n    h6: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '0.67em',\n    },\n    header: blockElement,\n    hr: blockElement,\n    i: {\n        fontStyle: 'italic',\n    },\n    li: {\n        display: 'list-item',\n    },\n    main: blockElement,\n    nav: blockElement,\n    ol: { ...blockElement, paddingInlineStart: '40px' },\n    p: {\n        display: 'block',\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    pre: {\n        display: 'block',\n        fontFamily: 'monospace',\n        whiteSpace: 'pre',\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    s: {\n        textDecoration: 'line-through',\n    },\n    section: blockElement,\n    strike: {\n        textDecoration: 'line-through',\n    },\n    strong: {\n        fontWeight: 'bold',\n    },\n    sub: {\n        verticalAlign: 'sub',\n        fontSize: 'smaller',\n    },\n    sup: {\n        verticalAlign: 'super',\n        fontSize: 'smaller',\n    },\n    table: {\n        display: 'table',\n        boxSizing: 'border-box',\n    },\n    td: {\n        display: 'table-cell',\n    },\n    th: {\n        display: 'table-cell',\n        fontWeight: 'bold',\n    },\n    u: {\n        textDecoration: 'underline',\n    },\n    ul: { ...blockElement, paddingInlineStart: '40px' },\n};\n","/**\n *  Enum used to control the different types of bullet list\n */\nexport const BulletListType = {\n    /**\n     * Minimum value of the enum\n     */\n    Min: 1,\n    /**\n     * Bullet triggered by *\n     */\n    Disc: 1,\n    /**\n     * Bullet triggered by -\n     */\n    Dash: 2,\n    /**\n     * Bullet triggered by --\n     */\n    Square: 3,\n    /**\n     * Bullet triggered by >\n     */\n    ShortArrow: 4,\n    /**\n     * Bullet triggered by ->\n     */\n    LongArrow: 5,\n    /**\n     * Bullet triggered by =>\n     */\n    UnfilledArrow: 6,\n    /**\n     * Bullet triggered by \n     */\n    Hyphen: 7,\n    /**\n     * Bullet triggered by -->\n     */\n    DoubleLongArrow: 8,\n    /**\n     * Bullet type circle\n     */\n    Circle: 9,\n    /**\n     * Box Shadow bullet type\n     */\n    BoxShadow: 10,\n    /**\n     * Rhombus with a cross inside\n     */\n    Xrhombus: 11,\n    /**\n     * Check mark bullet type\n     */\n    CheckMark: 12,\n    /**\n     * Maximum value of the enum\n     */\n    Max: 12,\n};\n","/**\n * Possible change sources. Here are the predefined sources.\n * It can also be other string if the change source can't fall into these sources.\n */\nexport const ChangeSource = {\n    /**\n     * Content changed by auto link\n     */\n    AutoLink: 'AutoLink',\n    /**\n     * Content changed by create link\n     */\n    CreateLink: 'CreateLink',\n    /**\n     * Content changed by format\n     */\n    Format: 'Format',\n    /**\n     * Content changed by image resize\n     */\n    ImageResize: 'ImageResize',\n    /**\n     * Content changed by paste\n     */\n    Paste: 'Paste',\n    /**\n     * Content changed by setContent API\n     */\n    SetContent: 'SetContent',\n    /**\n     * Content changed by cut operation\n     */\n    Cut: 'Cut',\n    /**\n     * Content changed by drag & drop operation\n     */\n    Drop: 'Drop',\n    /**\n     * Insert a new entity into editor\n     */\n    InsertEntity: 'InsertEntity',\n    /**\n     * Editor is switched to dark mode, content color is changed\n     */\n    SwitchToDarkMode: 'SwitchToDarkMode',\n    /**\n     * Editor is switched to light mode, content color is changed\n     */\n    SwitchToLightMode: 'SwitchToLightMode',\n    /**\n     * List chain reorganized numbers of lists\n     */\n    ListChain: 'ListChain',\n    /**\n     * Keyboard event, used by Content Model.\n     * Data of this event will be the key code number\n     */\n    Keyboard: 'Keyboard',\n\n    /**\n     * Content changed by auto format\n     */\n    AutoFormat: 'AutoFormat',\n\n    /**\n     * Content changed by replace\n     */\n    Replace: 'Replace',\n};\n","import type { ContentModelSegmentFormat } from 'roosterjs-content-model-types';\n\n/**\n * Provide a default empty instance of segment format with all its properties\n */\nexport const EmptySegmentFormat: Readonly<Required<ContentModelSegmentFormat>> = {\n    backgroundColor: '',\n    fontFamily: '',\n    fontSize: '',\n    fontWeight: '',\n    italic: false,\n    letterSpacing: '',\n    lineHeight: '',\n    strikethrough: false,\n    superOrSubScriptSequence: '',\n    textColor: '',\n    underline: false,\n};\n","/**\n *  Enum used to control the different types of numbering list\n */\nexport const NumberingListType = {\n    /**\n     * Minimum value of the enum\n     */\n    Min: 1,\n    /**\n     * Numbering triggered by 1.\n     */\n    Decimal: 1,\n    /**\n     * Numbering triggered by 1-\n     */\n    DecimalDash: 2,\n    /**\n     * Numbering triggered by 1)\n     */\n    DecimalParenthesis: 3,\n    /**\n     * Numbering triggered by (1)\n     */\n    DecimalDoubleParenthesis: 4,\n    /**\n     * Numbering triggered by a.\n     */\n    LowerAlpha: 5,\n    /**\n     * Numbering triggered by a)\n     */\n    LowerAlphaParenthesis: 6,\n    /**\n     * Numbering triggered by (a)\n     */\n    LowerAlphaDoubleParenthesis: 7,\n    /**\n     * Numbering triggered by a-\n     */\n    LowerAlphaDash: 8,\n    /**\n     * Numbering triggered by A.\n     */\n    UpperAlpha: 9,\n    /**\n     * Numbering triggered by A)\n     */\n    UpperAlphaParenthesis: 10,\n    /**\n     * Numbering triggered by (A)\n     */\n    UpperAlphaDoubleParenthesis: 11,\n    /**\n     * Numbering triggered by A-\n     */\n    UpperAlphaDash: 12,\n    /**\n     * Numbering triggered by i.\n     */\n    LowerRoman: 13,\n    /**\n     * Numbering triggered by i)\n     */\n    LowerRomanParenthesis: 14,\n    /**\n     * Numbering triggered by (i)\n     */\n    LowerRomanDoubleParenthesis: 15,\n    /**\n     * Numbering triggered by i-\n     */\n    LowerRomanDash: 16,\n    /**\n     * Numbering triggered by I.\n     */\n    UpperRoman: 17,\n    /**\n     * Numbering triggered by I)\n     */\n    UpperRomanParenthesis: 18,\n    /**\n     * Numbering triggered by (I)\n     */\n    UpperRomanDoubleParenthesis: 19,\n    /**\n     * Numbering triggered by I-\n     */\n    UpperRomanDash: 20,\n    /**\n     * Maximum value of the enum\n     */\n    Max: 20,\n};\n","import { NumberingListType } from './NumberingListType';\n\n/**\n * Style map for ordered list\n */\nexport const OrderedListStyleMap: Record<number, string> = {\n    [NumberingListType.Decimal]: 'decimal',\n    [NumberingListType.DecimalDash]: '\"${Number}- \"',\n    [NumberingListType.DecimalParenthesis]: '\"${Number}) \"',\n    [NumberingListType.DecimalDoubleParenthesis]: '\"(${Number}) \"',\n    [NumberingListType.LowerAlpha]: 'lower-alpha',\n    [NumberingListType.LowerAlphaDash]: '\"${LowerAlpha}- \"',\n    [NumberingListType.LowerAlphaParenthesis]: '\"${LowerAlpha}) \"',\n    [NumberingListType.LowerAlphaDoubleParenthesis]: '\"(${LowerAlpha}) \"',\n    [NumberingListType.UpperAlpha]: 'upper-alpha',\n    [NumberingListType.UpperAlphaDash]: '\"${UpperAlpha}- \"',\n    [NumberingListType.UpperAlphaParenthesis]: '\"${UpperAlpha}) \"',\n    [NumberingListType.UpperAlphaDoubleParenthesis]: '\"(${UpperAlpha}) \"',\n    [NumberingListType.LowerRoman]: 'lower-roman',\n    [NumberingListType.LowerRomanDash]: '\"${LowerRoman}- \"',\n    [NumberingListType.LowerRomanParenthesis]: '\"${LowerRoman}) \"',\n    [NumberingListType.LowerRomanDoubleParenthesis]: '\"(${LowerRoman}) \"',\n    [NumberingListType.UpperRoman]: 'upper-roman',\n    [NumberingListType.UpperRomanDash]: '\"${UpperRoman}- \"',\n    [NumberingListType.UpperRomanParenthesis]: '\"${UpperRoman}) \"',\n    [NumberingListType.UpperRomanDoubleParenthesis]: '\"(${UpperRoman}) \"',\n};\n","/**\n * Table format border\n */\nexport const TableBorderFormat = {\n    /**\n     * Minimum value\n     */\n    Min: 0,\n\n    /**\n     * All border of the table are displayed\n     *  __ __ __\n     * |__|__|__|\n     * |__|__|__|\n     * |__|__|__|\n     */\n    Default: 0,\n\n    /**\n     * Middle vertical border are not displayed\n     *  __ __ __\n     * |__ __ __|\n     * |__ __ __|\n     * |__ __ __|\n     */\n    ListWithSideBorders: 1,\n\n    /**\n     * All borders except header rows borders are displayed\n     *  __ __ __\n     *  __|__|__\n     *  __|__|__\n     */\n    NoHeaderBorders: 2,\n\n    /**\n     * The left and right border of the table are not displayed\n     *  __ __ __\n     *  __|__|__\n     *  __|__|__\n     *  __|__|__\n     */\n    NoSideBorders: 3,\n\n    /**\n     * Only the borders that divides the header row, first column and externals are displayed\n     *  __ __ __\n     * |__ __ __|\n     * |  |     |\n     * |__|__ __|\n     */\n    FirstColumnHeaderExternal: 4,\n\n    /**\n     * The header row has no vertical border, except for the first one\n     * The first column has no horizontal border, except for the first one\n     *  __ __ __\n     * |__ __ __\n     * |  |__|__|\n     * |  |__|__|\n     */\n    EspecialType1: 5,\n\n    /**\n     * The header row has no vertical border, except for the first one\n     * The only horizontal border of the table is the top and bottom of header row\n     *  __ __ __\n     * |__ __ __\n     * |  |     |\n     * |  |     |\n     */\n    EspecialType2: 6,\n\n    /**\n     * The only borders are the bottom of header row and the right border of first column\n     *  __ __ __\n     *    |\n     *    |\n     */\n    EspecialType3: 7,\n\n    /**\n     * No border\n     */\n    Clear: 8,\n\n    /**\n     * Maximum value\n     */\n    Max: 8,\n};\n","import { BulletListType } from './BulletListType';\n\n/**\n * Style map for unordered list\n */\nexport const UnorderedListStyleMap: Record<number, string> = {\n    [BulletListType.Disc]: 'disc',\n    [BulletListType.Square]: 'square',\n    [BulletListType.Circle]: 'circle',\n    [BulletListType.Dash]: '\"- \"',\n    [BulletListType.LongArrow]: '\" \"',\n    [BulletListType.DoubleLongArrow]: '\" \"',\n    [BulletListType.ShortArrow]: '\" \"',\n    [BulletListType.UnfilledArrow]: '\" \"',\n    [BulletListType.Hyphen]: '\" \"',\n    [BulletListType.CheckMark]: '\" \"',\n    [BulletListType.Xrhombus]: '\" \"',\n    [BulletListType.BoxShadow]: '\" \"',\n};\n","import { defaultProcessorMap } from './defaultProcessors';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport {\n    defaultFormatKeysPerCategory,\n    defaultFormatParsers,\n} from '../../formatHandlers/defaultFormatHandlers';\nimport type {\n    ContentModelBlockFormat,\n    DomToModelContext,\n    DomToModelDecoratorContext,\n    DomToModelFormatContext,\n    DomToModelOption,\n    DomToModelSelectionContext,\n    DomToModelSettings,\n    EditorContext,\n    FormatParser,\n    FormatParsers,\n    FormatParsersPerCategory,\n    TextFormatParser,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create context object for DOM to Content Model conversion\n * @param editorContext Context of editor\n * @param options Option array to customize the DOM to Model conversion behavior\n */\nexport function createDomToModelContext(\n    editorContext?: EditorContext,\n    ...options: (DomToModelOption | undefined)[]\n): DomToModelContext {\n    return createDomToModelContextWithConfig(createDomToModelConfig(options), editorContext);\n}\n\n/**\n * Create context object for DOM to Content Model conversion with an existing configure\n * @param config A full config object to define how to convert DOM tree to Content Model\n * @param editorContext Context of editor\n */\nexport function createDomToModelContextWithConfig(\n    config: DomToModelSettings,\n    editorContext?: EditorContext\n) {\n    return Object.assign(\n        {},\n        editorContext,\n        createDomToModelSelectionContext(),\n        createDomToModelFormatContext(editorContext?.isRootRtl),\n        createDomToModelDecoratorContext(),\n        config\n    );\n}\n\nfunction createDomToModelSelectionContext(): DomToModelSelectionContext {\n    return { isInSelection: false };\n}\n\nfunction createDomToModelFormatContext(isRootRtl?: boolean): DomToModelFormatContext {\n    const blockFormat: ContentModelBlockFormat = isRootRtl ? { direction: 'rtl' } : {};\n\n    return {\n        blockFormat,\n        segmentFormat: {},\n\n        listFormat: {\n            levels: [],\n            threadItemCounts: [],\n        },\n    };\n}\n\nfunction createDomToModelDecoratorContext(): DomToModelDecoratorContext {\n    return {\n        link: {\n            format: {},\n            dataset: {},\n        },\n        code: {\n            format: {},\n        },\n        blockDecorator: {\n            format: {},\n            tagName: '',\n        },\n    };\n}\n\n/**\n * Create Dom to Content Model Config object\n * @param options All customizations of content model creation\n */\nexport function createDomToModelConfig(\n    options: (DomToModelOption | undefined)[]\n): DomToModelSettings {\n    return {\n        elementProcessors: Object.assign(\n            {},\n            defaultProcessorMap,\n            ...options.map(x => x?.processorOverride)\n        ),\n        formatParsers: buildFormatParsers(\n            options.map(x => x?.formatParserOverride),\n            options.map(x => x?.additionalFormatParsers)\n        ),\n        defaultElementProcessors: defaultProcessorMap,\n        defaultFormatParsers,\n        processNonVisibleElements: options.some(x => !!x?.processNonVisibleElements),\n    };\n}\n\n/**\n * @internal Export for test only\n * Build format parsers used by DOM to Content Model conversion\n * @param override\n * @param additionalParsersArray\n * @returns\n */\nexport function buildFormatParsers(\n    overrides: (Partial<FormatParsers> | undefined)[] = [],\n    additionalParsersArray: (Partial<FormatParsersPerCategory> | undefined)[] = []\n): FormatParsersPerCategory {\n    const combinedOverrides = Object.assign({}, ...overrides);\n\n    const result = getObjectKeys(defaultFormatKeysPerCategory).reduce(\n        (result, key) => {\n            const value = defaultFormatKeysPerCategory[key]\n                .map(\n                    formatKey =>\n                        (combinedOverrides[formatKey] === undefined\n                            ? defaultFormatParsers[formatKey]\n                            : combinedOverrides[formatKey]) as FormatParser<any>\n                )\n                .concat(\n                    ...additionalParsersArray.map(\n                        parsers => (parsers?.[key] ?? []) as FormatParser<any>[]\n                    )\n                );\n\n            result[key] = value;\n\n            return result;\n        },\n        {\n            text: [] as TextFormatParser[],\n        } as FormatParsersPerCategory\n    );\n\n    additionalParsersArray.forEach(parsers => {\n        if (parsers?.text) {\n            result.text = result.text.concat(parsers.text);\n        }\n    });\n\n    return result;\n}\n","import { brProcessor } from '../processors/brProcessor';\nimport { childProcessor } from '../processors/childProcessor';\nimport { codeProcessor } from '../processors/codeProcessor';\nimport { delimiterProcessor } from '../processors/delimiterProcessor';\nimport { elementProcessor } from '../processors/elementProcessor';\nimport { entityProcessor } from '../processors/entityProcessor';\nimport { fontProcessor } from '../processors/fontProcessor';\nimport { formatContainerProcessor } from '../processors/formatContainerProcessor';\nimport { generalProcessor } from '../processors/generalProcessor';\nimport { headingProcessor } from '../processors/headingProcessor';\nimport { hrProcessor } from '../processors/hrProcessor';\nimport { imageProcessor } from '../processors/imageProcessor';\nimport { knownElementProcessor } from '../processors/knownElementProcessor';\nimport { linkProcessor } from '../processors/linkProcessor';\nimport { listItemProcessor } from '../processors/listItemProcessor';\nimport { listProcessor } from '../processors/listProcessor';\nimport { pProcessor } from '../processors/pProcessor';\nimport { tableProcessor } from '../processors/tableProcessor';\nimport { textProcessor } from '../processors/textProcessor';\nimport { textWithSelectionProcessor } from '../processors/textWithSelectionProcessor';\nimport type { ElementProcessorMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const defaultProcessorMap: ElementProcessorMap = {\n    a: linkProcessor,\n    b: knownElementProcessor,\n    blockquote: knownElementProcessor,\n    br: brProcessor,\n    code: codeProcessor,\n    dd: formatContainerProcessor,\n    del: knownElementProcessor,\n    div: knownElementProcessor,\n    dl: formatContainerProcessor,\n    dt: formatContainerProcessor,\n    em: knownElementProcessor,\n    font: fontProcessor,\n    i: knownElementProcessor,\n    img: imageProcessor,\n    h1: headingProcessor,\n    h2: headingProcessor,\n    h3: headingProcessor,\n    h4: headingProcessor,\n    h5: headingProcessor,\n    h6: headingProcessor,\n    hr: hrProcessor,\n    li: listItemProcessor,\n    ol: listProcessor,\n    p: pProcessor,\n    pre: formatContainerProcessor,\n    s: knownElementProcessor,\n    section: knownElementProcessor,\n    span: knownElementProcessor,\n    strike: knownElementProcessor,\n    strong: knownElementProcessor,\n    sub: knownElementProcessor,\n    sup: knownElementProcessor,\n    table: tableProcessor,\n    u: knownElementProcessor,\n    ul: listProcessor,\n\n    '*': generalProcessor,\n    '#text': textProcessor,\n    textWithSelection: textWithSelectionProcessor,\n    element: elementProcessor,\n    entity: entityProcessor,\n    child: childProcessor,\n    delimiter: delimiterProcessor,\n};\n","import { createContentModelDocument } from '../modelApi/creators/createContentModelDocument';\nimport { normalizeContentModel } from '../modelApi/common/normalizeContentModel';\nimport type { ContentModelDocument, DomToModelContext } from 'roosterjs-content-model-types';\n\n/**\n * Create Content Model from DOM tree in this editor\n * @param root Root element of DOM tree to create Content Model from\n * @param context Context object for DOM to Content Model conversion\n * @returns A ContentModelDocument object that contains all the models created from the give root element\n */\nexport function domToContentModel(\n    root: HTMLElement | DocumentFragment,\n    context: DomToModelContext\n): ContentModelDocument {\n    const model = createContentModelDocument(context.defaultFormat);\n\n    if (context.selection?.type == 'range' && context.selection.isReverted) {\n        model.hasRevertedRangeSelection = true;\n    }\n\n    context.elementProcessors.child(model, root, context);\n\n    normalizeContentModel(model);\n\n    return model;\n}\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { ContextStyles } from './formatContainerProcessor';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { parseFormat } from '../utils/parseFormat';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelSegmentFormat,\n    DomToModelContext,\n} from 'roosterjs-content-model-types';\n\nconst SegmentDecoratorTags = ['A', 'CODE'];\n\n/**\n * @internal\n */\nexport function blockProcessor(\n    group: ContentModelBlockGroup,\n    element: HTMLElement,\n    context: DomToModelContext,\n    segmentFormat?: ContentModelSegmentFormat\n) {\n    const decorator = context.blockDecorator.tagName ? context.blockDecorator : undefined;\n    const isSegmentDecorator = SegmentDecoratorTags.indexOf(element.tagName) >= 0;\n\n    parseFormat(element, context.formatParsers.block, context.blockFormat, context);\n\n    const blockFormat = { ...context.blockFormat };\n\n    parseFormat(element, context.formatParsers.container, blockFormat, context);\n\n    ContextStyles.forEach(style => {\n        if (blockFormat[style]) {\n            context.blockFormat[style] = blockFormat[style];\n        }\n    });\n\n    if (!isSegmentDecorator) {\n        const paragraph = createParagraph(\n            false /*isImplicit*/,\n            blockFormat,\n            segmentFormat,\n            decorator\n        );\n\n        context.paragraphMap?.assignMarkerToModel(element, paragraph);\n\n        addBlock(group, paragraph);\n    }\n\n    context.elementProcessors.child(group, element, context);\n}\n","import { addSegment } from '../../modelApi/common/addSegment';\nimport { createBr } from '../../modelApi/creators/createBr';\nimport { getRegularSelectionOffsets } from '../utils/getRegularSelectionOffsets';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const brProcessor: ElementProcessor<HTMLBRElement> = (group, element, context) => {\n    const br = createBr(context.segmentFormat);\n    const [start, end] = getRegularSelectionOffsets(context, element);\n\n    if (start >= 0) {\n        context.isInSelection = true;\n    }\n\n    if (context.isInSelection) {\n        br.isSelected = true;\n    }\n\n    const paragraph = addSegment(group, br, context.blockFormat);\n\n    if (end >= 0) {\n        context.isInSelection = false;\n    }\n\n    context.domIndexer?.onSegment(element, paragraph, [br]);\n};\n","import { addSelectionMarker } from '../utils/addSelectionMarker';\nimport { getRegularSelectionOffsets } from '../utils/getRegularSelectionOffsets';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport type {\n    ContentModelBlockGroup,\n    DomToModelContext,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\n/**\n * Content Model Element Processor for child elements\n * @param group The parent block group\n * @param parent Parent DOM node to process\n * @param context DOM to Content Model context\n */\nexport const childProcessor: ElementProcessor<ParentNode> = (\n    group: ContentModelBlockGroup,\n    parent: ParentNode,\n    context: DomToModelContext\n) => {\n    const [nodeStartOffset, nodeEndOffset] = getRegularSelectionOffsets(context, parent);\n    let index = 0;\n\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        handleRegularSelection(index, context, group, nodeStartOffset, nodeEndOffset, parent);\n\n        processChildNode(group, child, context);\n\n        index++;\n    }\n\n    handleRegularSelection(index, context, group, nodeStartOffset, nodeEndOffset, parent);\n};\n\n/**\n * Helper function for processing child node\n * @param group The parent block group\n * @param parent Parent DOM node to process\n * @param context DOM to Content Model context\n */\nexport function processChildNode(\n    group: ContentModelBlockGroup,\n    child: Node,\n    context: DomToModelContext\n) {\n    if (\n        isNodeOfType(child, 'ELEMENT_NODE') &&\n        (child.style.display != 'none' || context.processNonVisibleElements)\n    ) {\n        context.elementProcessors.element(group, child, context);\n    } else if (isNodeOfType(child, 'TEXT_NODE')) {\n        context.elementProcessors['#text'](group, child, context);\n    }\n}\n\n/**\n * Helper function to handle regular (range based) selection when process child node\n * @param index Index of current child node in its parent\n * @param context DOM to Content Model context\n * @param group The parent block group\n * @param nodeStartOffset Start offset of current regular selection\n * @param nodeEndOffset  End offset of current regular selection\n * @param container The container node of this selection\n */\nexport function handleRegularSelection(\n    index: number,\n    context: DomToModelContext,\n    group: ContentModelBlockGroup,\n    nodeStartOffset: number,\n    nodeEndOffset: number,\n    container?: Node\n) {\n    if (index == nodeStartOffset) {\n        context.isInSelection = true;\n\n        addSelectionMarker(group, context, container, index);\n    }\n\n    if (index == nodeEndOffset && context.selection?.type == 'range') {\n        if (!context.selection.range.collapsed) {\n            addSelectionMarker(group, context, container, index);\n        }\n        context.isInSelection = false;\n    }\n}\n","import { knownElementProcessor } from './knownElementProcessor';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const codeProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    stackFormat(context, { code: 'codeDefault' }, () => {\n        parseFormat(element, context.formatParsers.code, context.code.format, context);\n\n        knownElementProcessor(group, element, context);\n    });\n};\n","import { addSelectionMarker } from '../utils/addSelectionMarker';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * @param group\n * @param node\n * @param context\n */\nexport const delimiterProcessor: ElementProcessor<Node> = (group, node, context) => {\n    const range = context.selection?.type == 'range' ? context.selection.range : null;\n\n    if (range) {\n        if (node.contains(range.startContainer)) {\n            context.isInSelection = true;\n\n            addSelectionMarker(group, context);\n        }\n\n        if (context.selection?.type == 'range' && node.contains(range.endContainer)) {\n            if (!context.selection.range.collapsed) {\n                addSelectionMarker(group, context);\n            }\n\n            context.isInSelection = false;\n        }\n    }\n};\n","import { isEntityDelimiter, isEntityElement } from '../../domUtils/entityUtils';\nimport type {\n    DomToModelContext,\n    ElementProcessor,\n    ElementProcessorMap,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * @param group\n * @param element\n * @param context\n */\nexport const elementProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const tagName = element.tagName.toLowerCase() as keyof ElementProcessorMap;\n    const processor = (tryGetProcessorForEntity(element, context) ||\n        tryGetProcessorForDelimiter(element, context) ||\n        context.elementProcessors[tagName] ||\n        (tagName.indexOf(':') >= 0 && context.elementProcessors.child) ||\n        context.elementProcessors['*']) as ElementProcessor<Node>;\n    processor(group, element, context);\n};\n\nfunction tryGetProcessorForEntity(element: HTMLElement, context: DomToModelContext) {\n    return isEntityElement(element) || element.contentEditable == 'false' // For readonly element, treat as an entity\n        ? context.elementProcessors.entity\n        : null;\n}\n\nfunction tryGetProcessorForDelimiter(element: HTMLElement, context: DomToModelContext) {\n    return isEntityDelimiter(element) ? context.elementProcessors.delimiter : null;\n}\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { addSegment } from '../../modelApi/common/addSegment';\nimport { createEntity } from '../../modelApi/creators/createEntity';\nimport { isBlockElement } from '../utils/isBlockElement';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * Content Model Element Processor for entity\n * @param group The parent block group\n * @param parent Parent DOM node to process\n * @param context DOM to Content Model context\n */\nexport const entityProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const isBlockEntity =\n        isBlockElement(element) ||\n        (element.style.display == 'inline-block' && element.style.width == '100%');\n\n    stackFormat(\n        context,\n        { segment: isBlockEntity ? 'empty' : undefined, paragraph: 'empty' },\n        () => {\n            const entityModel = createEntity(element, true /*isReadonly*/, context.segmentFormat);\n\n            parseFormat(element, context.formatParsers.entity, entityModel.entityFormat, context);\n\n            if (context.isInSelection) {\n                entityModel.isSelected = true;\n            }\n\n            if (isBlockEntity) {\n                addBlock(group, entityModel);\n            } else {\n                const paragraph = addSegment(group, entityModel);\n                context.domIndexer?.onSegment(element, paragraph, [entityModel]);\n            }\n        }\n    );\n};\n","import { isBlockElement } from '../utils/isBlockElement';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\nconst FontSizes = ['10px', '13px', '16px', '18px', '24px', '32px', '48px'];\n\nfunction getFontSize(size: string | null) {\n    const intSize = parseInt(size || '');\n\n    if (Number.isNaN(intSize)) {\n        return undefined;\n    } else if (intSize < 1) {\n        return FontSizes[0];\n    } else if (intSize > FontSizes.length) {\n        return FontSizes[FontSizes.length - 1];\n    } else {\n        return FontSizes[intSize - 1];\n    }\n}\n\n/**\n * @internal\n */\nexport const fontProcessor: ElementProcessor<HTMLFontElement> = (group, element, context) => {\n    stackFormat(\n        context,\n        {\n            segment: isBlockElement(element) ? 'shallowCloneForBlock' : 'shallowClone',\n        },\n        () => {\n            const fontFamily = element.getAttribute('face');\n            const fontSize = getFontSize(element.getAttribute('size'));\n            const textColor = element.getAttribute('color');\n            const format = context.segmentFormat;\n\n            if (fontFamily) {\n                format.fontFamily = fontFamily;\n            }\n\n            if (fontSize) {\n                format.fontSize = fontSize;\n            }\n\n            if (textColor) {\n                format.textColor = textColor;\n            }\n\n            parseFormat(element, context.formatParsers.segment, context.segmentFormat, context);\n\n            context.elementProcessors.child(group, element, context);\n        }\n    );\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { createFormatContainer } from '../../modelApi/creators/createFormatContainer';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { getDefaultStyle } from '../utils/getDefaultStyle';\nimport { parseFormat } from '../utils/parseFormat';\nimport { setParagraphNotImplicit } from '../../modelApi/block/setParagraphNotImplicit';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelFormatContainer,\n    ContentModelFormatContainerFormat,\n    ContentModelParagraph,\n    DomToModelContext,\n    ElementProcessor,\n    MarginFormat,\n    PaddingFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const ContextStyles: (keyof (MarginFormat & PaddingFormat))[] = [\n    'marginLeft',\n    'marginRight',\n    'paddingLeft',\n    'paddingRight',\n];\n\n/**\n * Content Model Element Processor for format container elements (e.g., blockquote, div)\n * Processes elements that create FormatContainer blocks in the content model.\n * This processor can be used in processorOverride to customize how specific elements are processed.\n * @param group The parent block group\n * @param element The DOM element to process\n * @param context DOM to Content Model context\n */\nexport const formatContainerProcessor: ElementProcessor<HTMLElement> = (\n    group,\n    element,\n    context\n) => {\n    formatContainerProcessorInternal(group, element, context, false /* forceFormatContainer */);\n};\n\n/**\n * @internal\n */\nexport const forceFormatContainerProcessor: ElementProcessor<HTMLElement> = (\n    group,\n    element,\n    context\n) => {\n    formatContainerProcessorInternal(group, element, context, true /* forceFormatContainer */);\n};\n\nconst formatContainerProcessorInternal = (\n    group: ContentModelBlockGroup,\n    element: HTMLElement,\n    context: DomToModelContext,\n    forceFormatContainer: boolean\n) => {\n    stackFormat(context, { segment: 'shallowCloneForBlock', paragraph: 'shallowClone' }, () => {\n        parseFormat(element, context.formatParsers.block, context.blockFormat, context);\n        parseFormat(element, context.formatParsers.segmentOnBlock, context.segmentFormat, context);\n\n        const format: ContentModelFormatContainerFormat = {\n            ...context.blockFormat,\n        };\n\n        parseFormat(element, context.formatParsers.container, format, context);\n\n        const tagName =\n            getDefaultStyle(element).display == 'block' ? element.tagName.toLowerCase() : 'div';\n        const formatContainer = createFormatContainer(tagName, format);\n\n        // It is possible to inherit margin left/right styles from parent DIV or other containers,\n        // since we are going into a deeper level of format container now,\n        // the container will render these styles so no need to keep them in context format\n        ContextStyles.forEach(style => {\n            delete context.blockFormat[style];\n        });\n\n        context.elementProcessors.child(formatContainer, element, context);\n\n        if (element.style.fontSize && parseInt(element.style.fontSize) == 0) {\n            formatContainer.zeroFontSize = true;\n        }\n\n        if (shouldFallbackToParagraph(formatContainer) && !forceFormatContainer) {\n            // For DIV container that only has one paragraph child, container style can be merged into paragraph\n            // and no need to have this container\n            const paragraph = formatContainer.blocks[0] as ContentModelParagraph;\n\n            if (formatContainer.zeroFontSize) {\n                paragraph.segmentFormat = Object.assign({}, paragraph.segmentFormat, {\n                    fontSize: '0',\n                });\n            }\n\n            Object.assign(paragraph.format, formatContainer.format);\n            setParagraphNotImplicit(paragraph);\n            addBlock(group, paragraph);\n        } else {\n            addBlock(group, formatContainer);\n        }\n    });\n\n    addBlock(group, createParagraph(true /*isImplicit*/, context.blockFormat));\n};\n\nfunction shouldFallbackToParagraph(formatContainer: ContentModelFormatContainer) {\n    const firstChild = formatContainer.blocks[0];\n\n    return (\n        formatContainer.tagName == 'div' &&\n        formatContainer.blocks.length == 1 &&\n        firstChild.blockType == 'Paragraph' &&\n        firstChild.isImplicit\n    );\n}\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { addDecorators } from '../../modelApi/common/addDecorators';\nimport { addSegment } from '../../modelApi/common/addSegment';\nimport { createGeneralBlock } from '../../modelApi/creators/createGeneralBlock';\nimport { createGeneralSegment } from '../../modelApi/creators/createGeneralSegment';\nimport { isBlockElement } from '../utils/isBlockElement';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\nconst generalBlockProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const block = createGeneralBlock(element);\n    const isSelectedBefore = context.isInSelection;\n\n    stackFormat(\n        context,\n        {\n            segment: 'empty',\n            paragraph: 'empty',\n            link: 'empty',\n        },\n        () => {\n            addBlock(group, block);\n\n            parseFormat(element, context.formatParsers.general, block.format, context);\n\n            context.elementProcessors.child(block, element, context);\n        }\n    );\n\n    if (isSelectedBefore && context.isInSelection) {\n        block.isSelected = true;\n    }\n};\n\nconst generalSegmentProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const segment = createGeneralSegment(element, context.segmentFormat);\n    const isSelectedBefore = context.isInSelection;\n\n    addDecorators(segment, context);\n    const paragraph = addSegment(group, segment);\n    context.domIndexer?.onSegment(element, paragraph, [segment]);\n\n    stackFormat(\n        context,\n        {\n            segment:\n                'empty' /*clearFormat, General segment will include all properties and styles when generate back to HTML, so no need to carry over existing segment format*/,\n        },\n        () => {\n            parseFormat(element, context.formatParsers.general, segment.format, context);\n\n            context.elementProcessors.child(segment, element, context);\n        }\n    );\n\n    if (isSelectedBefore && context.isInSelection) {\n        segment.isSelected = true;\n    }\n};\n\n/**\n * @internal\n */\nexport const generalProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const processor = isBlockElement(element) ? generalBlockProcessor : generalSegmentProcessor;\n\n    processor(group, element, context);\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { blockProcessor } from './blockProcessor';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { createParagraphDecorator } from '../../modelApi/creators/createParagraphDecorator';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ContentModelSegmentFormat, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const headingProcessor: ElementProcessor<HTMLHeadingElement> = (group, element, context) => {\n    stackFormat(\n        context,\n        { segment: 'shallowCloneForBlock', paragraph: 'shallowClone', blockDecorator: 'empty' },\n        () => {\n            const segmentFormat: ContentModelSegmentFormat = {};\n\n            parseFormat(element, context.formatParsers.segmentOnBlock, segmentFormat, context);\n\n            // These formats are already declared on heading element, no need to keep them in context.\n            // And we should not duplicate them in context, either. Because when we want to turn off heading,\n            // inner text should not keep those text format from heading.\n            getObjectKeys(segmentFormat).forEach(key => {\n                delete context.segmentFormat[key];\n            });\n\n            context.blockDecorator = createParagraphDecorator(element.tagName, segmentFormat);\n\n            blockProcessor(group, element, context);\n        }\n    );\n\n    addBlock(group, createParagraph(true /*isImplicit*/, context.blockFormat));\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { createDivider } from '../../modelApi/creators/createDivider';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const hrProcessor: ElementProcessor<HTMLHRElement> = (group, element, context) => {\n    stackFormat(\n        context,\n        {\n            paragraph: 'shallowClone',\n        },\n        () => {\n            parseFormat(element, context.formatParsers.divider, context.blockFormat, context);\n\n            const hr = createDivider('hr', context.blockFormat);\n\n            if (element.size) {\n                hr.size = element.size;\n            }\n\n            if (context.isInSelection) {\n                hr.isSelected = true;\n            }\n\n            addBlock(group, hr);\n        }\n    );\n};\n","import { addDecorators } from '../../modelApi/common/addDecorators';\nimport { addSegment } from '../../modelApi/common/addSegment';\nimport { createImage } from '../../modelApi/creators/createImage';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ContentModelImageFormat, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const imageProcessor: ElementProcessor<HTMLImageElement> = (group, element, context) => {\n    stackFormat(context, { segment: 'shallowClone' }, () => {\n        const imageFormat: ContentModelImageFormat = context.segmentFormat;\n\n        // Use getAttribute('src') instead of retrieving src directly, in case the src has port and may be stripped by browser\n        const src = element.getAttribute('src') ?? '';\n\n        parseFormat(element, context.formatParsers.segment, imageFormat, context);\n        parseFormat(element, context.formatParsers.image, imageFormat, context);\n        parseFormat(element, context.formatParsers.block, context.blockFormat, context);\n\n        const image = createImage(src, imageFormat);\n        const alt = element.alt;\n        const title = element.title;\n\n        parseFormat(element, context.formatParsers.dataset, image.dataset, context);\n        addDecorators(image, context);\n\n        if (alt) {\n            image.alt = alt;\n        }\n        if (title) {\n            image.title = title;\n        }\n        if (context.isInSelection) {\n            image.isSelected = true;\n        }\n        if (context.selection?.type == 'image' && context.selection.image == element) {\n            image.isSelectedAsImageSelection = true;\n            image.isSelected = true;\n        }\n\n        const paragraph = addSegment(group, image);\n        context.domIndexer?.onSegment(element, paragraph, [image]);\n    });\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { blockProcessor } from './blockProcessor';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { getDefaultStyle } from '../utils/getDefaultStyle';\nimport { isBlockElement } from '../utils/isBlockElement';\nimport { isBlockEntityContainer } from '../../domUtils/entityUtils';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport {\n    forceFormatContainerProcessor,\n    formatContainerProcessor,\n} from './formatContainerProcessor';\nimport type {\n    ContentModelSegmentFormat,\n    DomToModelContext,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\nconst FormatContainerTriggerStyles: (keyof CSSStyleDeclaration)[] = [\n    'marginBottom',\n    'marginTop',\n    'paddingBottom',\n    'paddingTop',\n    'paddingLeft',\n    'paddingRight',\n    'borderTopWidth',\n    'borderBottomWidth',\n    'borderLeftWidth',\n    'borderRightWidth',\n    'width',\n    'height',\n    'maxWidth',\n    'maxHeight',\n    'minWidth',\n    'minHeight',\n];\nconst FormatContainerTriggerAttributes = ['id'];\nconst ByPassFormatContainerTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'A'];\nconst SegmentDecoratorTags = ['A', 'CODE'];\n\n/**\n * @internal\n */\nexport const knownElementProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const isBlock = isBlockElement(element);\n    const isBlockContainer = isBlock || element.style.display == 'inline-block';\n\n    if (\n        isBlockContainer && // For inline-block here, we will also check if it should be represented as Format Container\n        shouldForceUseFormatContainer(element, context)\n    ) {\n        forceFormatContainerProcessor(group, element, context);\n    } else if (isBlockContainer && shouldUseFormatContainer(element, context)) {\n        formatContainerProcessor(group, element, context);\n    } else if (isBlockEntityContainer(element)) {\n        context.elementProcessors.child(group, element, context);\n    } else if (isBlock) {\n        const decorator = context.blockDecorator.tagName ? context.blockDecorator : undefined;\n        const isSegmentDecorator = SegmentDecoratorTags.indexOf(element.tagName) >= 0;\n\n        stackFormat(context, { segment: 'shallowCloneForBlock', paragraph: 'shallowClone' }, () => {\n            const segmentFormat: ContentModelSegmentFormat = {};\n\n            parseFormat(element, context.formatParsers.segmentOnBlock, segmentFormat, context);\n            Object.assign(context.segmentFormat, segmentFormat);\n\n            blockProcessor(group, element, context, segmentFormat);\n        });\n\n        if (isBlock && !isSegmentDecorator) {\n            addBlock(\n                group,\n                createParagraph(\n                    true /*isImplicit*/,\n                    context.blockFormat,\n                    undefined /*segmentFormat*/,\n                    decorator\n                )\n            );\n        }\n    } else {\n        stackFormat(\n            context,\n            {\n                segment: 'shallowClone',\n                paragraph: 'shallowClone',\n                link: 'cloneFormat',\n            },\n            () => {\n                parseFormat(element, context.formatParsers.segment, context.segmentFormat, context);\n\n                if (context.link.format.href && element.tagName != 'A') {\n                    parseFormat(\n                        element,\n                        context.formatParsers.segmentUnderLink,\n                        context.link.format,\n                        context\n                    );\n                }\n\n                context.elementProcessors.child(group, element, context);\n            }\n        );\n    }\n};\n\nfunction shouldForceUseFormatContainer(element: HTMLElement, context: DomToModelContext) {\n    return FormatContainerTriggerAttributes.some(attr => element.hasAttribute(attr));\n}\n\nfunction shouldUseFormatContainer(element: HTMLElement, context: DomToModelContext) {\n    // For those tags that we know we should not use format container, just return false\n    if (ByPassFormatContainerTags.indexOf(element.tagName) >= 0) {\n        return false;\n    }\n\n    const style = element.style;\n    const defaultStyle = getDefaultStyle(element);\n\n    const bgcolor = style.getPropertyValue('background-color');\n\n    // For block element with background, we need to use format container\n    if (bgcolor && bgcolor != 'transparent') {\n        return true;\n    }\n\n    // For block element with positive value of border width or top/bottom margin/padding,\n    // we need to use format container\n    if (\n        FormatContainerTriggerStyles.some(\n            key => parseInt((style[key] as string) || (defaultStyle[key] as string) || '') > 0\n        )\n    ) {\n        return true;\n    }\n\n    // For margin left/right with value \"auto\", we need to use format container\n    if (style.marginLeft == 'auto' || style.marginRight == 'auto') {\n        return true;\n    }\n\n    // For element with \"align\" attribute, we need to use format container\n    if (element.getAttribute('align')) {\n        return true;\n    }\n\n    return false;\n}\n","import { addSegment } from '../../modelApi/common/addSegment';\nimport { createText } from '../../modelApi/creators/createText';\nimport { knownElementProcessor } from './knownElementProcessor';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { StackFormatOptions } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const linkProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const name = element.getAttribute('name');\n    const href = element.getAttribute('href');\n\n    if (name || href) {\n        const isAnchor = !!name && !href;\n        const option: StackFormatOptions = {\n            // For anchor (name without ref), no need to add other styles\n            // For link (href exists), add default link styles\n            link: isAnchor ? 'empty' : 'linkDefault',\n        };\n\n        stackFormat(context, option, () => {\n            parseFormat(element, context.formatParsers.link, context.link.format, context);\n            parseFormat(element, context.formatParsers.dataset, context.link.dataset, context);\n\n            if (isAnchor && !element.firstChild) {\n                // Empty anchor, need to make sure it has some child in model\n                const emptyText = createText('', context.segmentFormat, {\n                    dataset: context.link.dataset,\n                    format: context.link.format,\n                });\n\n                if (context.isInSelection) {\n                    emptyText.isSelected = true;\n                }\n\n                addSegment(group, emptyText);\n            } else {\n                knownElementProcessor(group, element, context);\n            }\n        });\n    } else {\n        // A tag without name or href, can be treated as normal SPAN tag\n        knownElementProcessor(group, element, context);\n    }\n};\n","import { createListItem } from '../../modelApi/creators/createListItem';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listItemProcessor: ElementProcessor<HTMLLIElement> = (group, element, context) => {\n    const { listFormat } = context;\n\n    if (listFormat.listParent && listFormat.levels.length > 0) {\n        stackFormat(\n            context,\n            {\n                segment: 'shallowCloneForBlock',\n            },\n            () => {\n                parseFormat(\n                    element,\n                    context.formatParsers.segmentOnBlock,\n                    context.segmentFormat,\n                    context\n                );\n\n                const listItem = createListItem(listFormat.levels, context.segmentFormat);\n                parseFormat(\n                    element,\n                    context.formatParsers.listItemElement,\n                    listItem.format,\n                    context\n                );\n\n                listFormat.listParent!.blocks.push(listItem);\n\n                parseFormat(\n                    element,\n                    context.formatParsers.listItemThread,\n                    listItem.levels[listItem.levels.length - 1].format,\n                    context\n                );\n\n                context.elementProcessors.child(listItem, element, context);\n\n                const firstChild = listItem.blocks[0];\n\n                if (\n                    listItem.blocks.length == 1 &&\n                    firstChild.blockType == 'Paragraph' &&\n                    firstChild.isImplicit\n                ) {\n                    Object.assign(listItem.format, firstChild.format);\n                    firstChild.format = {};\n                }\n            }\n        );\n    } else {\n        const currentBlocks = listFormat.listParent?.blocks;\n        const lastItem = currentBlocks?.[currentBlocks?.length - 1];\n\n        context.elementProcessors['*'](\n            lastItem?.blockType == 'BlockGroup' ? lastItem : group,\n            element,\n            context\n        );\n    }\n};\n","import { createListLevel } from '../../modelApi/creators/createListLevel';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ContentModelListLevel, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listProcessor: ElementProcessor<HTMLOListElement | HTMLUListElement> = (\n    group,\n    element,\n    context\n) => {\n    stackFormat(\n        context,\n        {\n            segment: 'shallowCloneForBlock',\n            paragraph: 'shallowCloneForGroup',\n        },\n        () => {\n            const level: ContentModelListLevel = createListLevel(\n                element.tagName as 'OL' | 'UL',\n                context.blockFormat\n            );\n            const { listFormat } = context;\n\n            parseFormat(element, context.formatParsers.dataset, level.dataset, context);\n            parseFormat(element, context.formatParsers.listLevelThread, level.format, context);\n            parseFormat(element, context.formatParsers.listLevel, level.format, context);\n            parseFormat(element, context.formatParsers.segment, context.segmentFormat, context);\n\n            const originalListParent = listFormat.listParent;\n\n            listFormat.listParent = listFormat.listParent || group;\n            listFormat.levels.push(level);\n\n            try {\n                context.elementProcessors.child(group, element, context);\n            } finally {\n                listFormat.levels.pop();\n                listFormat.listParent = originalListParent;\n            }\n        }\n    );\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { blockProcessor } from './blockProcessor';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { createParagraphDecorator } from '../../modelApi/creators/createParagraphDecorator';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ContentModelSegmentFormat, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const pProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    stackFormat(\n        context,\n        { blockDecorator: 'empty', segment: 'shallowCloneForBlock', paragraph: 'shallowClone' },\n        () => {\n            context.blockDecorator = createParagraphDecorator(element.tagName);\n\n            const segmentFormat: ContentModelSegmentFormat = {};\n\n            parseFormat(element, context.formatParsers.segmentOnBlock, segmentFormat, context);\n            Object.assign(context.segmentFormat, segmentFormat);\n\n            blockProcessor(group, element, context, segmentFormat);\n        }\n    );\n\n    addBlock(group, createParagraph(true /*isImplicit*/, context.blockFormat));\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { createTable } from '../../modelApi/creators/createTable';\nimport { createTableCell } from '../../modelApi/creators/createTableCell';\nimport { getBoundingClientRect } from '../utils/getBoundingClientRect';\nimport { getSelectionRootNode } from '../../domUtils/selection/getSelectionRootNode';\nimport { isElementOfType } from '../../domUtils/isElementOfType';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport { parseFormat } from '../utils/parseFormat';\nimport { parseValueWithUnit } from '../../formatHandlers/utils/parseValueWithUnit';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelTableCellFormat,\n    DatasetFormat,\n    DomToModelContext,\n    ElementProcessor,\n    SizeFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Content Model Element Processor for table\n *\n * For Table with merged/splitted cells, HTML uses colSpan and rowSpan attributes to specify how it should be rendered.\n * To make it easier to edit a table, we will use a different way to describe table.\n *\n * 1. For a m * n table (m rows, n columns), we always create a m * n array for the cells.\n * 2. For a regular table cell, it is mapped to one item of this array\n * 3. For a merged/splitted table cell, it will has colSpan/rowSpan value. We also created TableCell model for those spanned\n * cells, and use \"spanLeft\" and \"spanAbove\" to mark its state\n * 4. When edit table, we always edit on this mapped m * n array because it always has an item for each cell\n * 5. When write back to DOM, we create TD/TH elements for those non-spanned cells, and mark its colSpan/rowSpan value according\n * its neighbour cell's spanLeft/spanAbove attribute\n * @param group The parent block group\n * @param parent Parent DOM node to process\n * @param context DOM to Content Model context\n */\nexport const tableProcessor: ElementProcessor<HTMLTableElement> = (\n    group,\n    tableElement,\n    context\n) => {\n    stackFormat(\n        context,\n        { segment: 'shallowCloneForBlock', paragraph: 'shallowCloneForGroup' },\n        () => {\n            parseFormat(tableElement, context.formatParsers.block, context.blockFormat, context);\n\n            const table = createTable(tableElement.rows.length, context.blockFormat);\n            const tableSelection = context.selection?.type == 'table' ? context.selection : null;\n            const selectedTable = tableSelection?.table;\n            const hasTableSelection = selectedTable == tableElement;\n            const recalculateTableSize = shouldRecalculateTableSize(tableElement, context);\n\n            if (context.allowCacheElement) {\n                table.cachedElement = tableElement;\n            }\n\n            context.domIndexer?.onTable(tableElement, table);\n\n            parseFormat(tableElement, context.formatParsers.table, table.format, context);\n            parseFormat(tableElement, context.formatParsers.tableBorder, table.format, context);\n            parseFormat(\n                tableElement,\n                context.formatParsers.segmentOnBlock,\n                context.segmentFormat,\n                context\n            );\n            parseFormat(tableElement, context.formatParsers.dataset, table.dataset, context);\n            addBlock(group, table);\n\n            const columnPositions: (number | undefined)[] = [0];\n            const hasColGroup = processColGroup(tableElement, context, columnPositions);\n            const rowPositions: number[] = [0];\n            const zoomScale = context.zoomScale || 1;\n\n            for (let row = 0; row < tableElement.rows.length; row++) {\n                const tr = tableElement.rows[row];\n                const tableRow = table.rows[row];\n\n                const tbody = tr.parentNode;\n\n                if (\n                    isNodeOfType(tbody, 'ELEMENT_NODE') &&\n                    (isElementOfType(tbody, 'tbody') ||\n                        isElementOfType(tbody, 'thead') ||\n                        isElementOfType(tbody, 'tfoot'))\n                ) {\n                    parseFormat(tbody, context.formatParsers.tableRow, tableRow.format, context);\n                } else if (context.allowCacheElement) {\n                    tableRow.cachedElement = tr;\n                }\n\n                parseFormat(tr, context.formatParsers.tableRow, tableRow.format, context);\n\n                stackFormat(context, { paragraph: 'shallowClone', segment: 'shallowClone' }, () => {\n                    const parent = tr.parentElement;\n                    const isInTableSection = parent && getIsInTableSection(parent);\n\n                    if (isInTableSection) {\n                        // If there is TBODY around TR, retrieve format from TBODY first, in case some format are declared there\n                        parseFormat(\n                            parent,\n                            context.formatParsers.block,\n                            context.blockFormat,\n                            context\n                        );\n                        parseFormat(\n                            parent,\n                            context.formatParsers.segmentOnBlock,\n                            context.segmentFormat,\n                            context\n                        );\n                    }\n\n                    parseFormat(tr, context.formatParsers.block, context.blockFormat, context);\n                    parseFormat(\n                        tr,\n                        context.formatParsers.segmentOnBlock,\n                        context.segmentFormat,\n                        context\n                    );\n\n                    tableRow.height = parseInt(tr.style.height) || 0;\n\n                    for (\n                        let sourceCol = 0, targetCol = 0;\n                        sourceCol < tr.cells.length;\n                        sourceCol++\n                    ) {\n                        for (; tableRow.cells[targetCol]; targetCol++) {}\n\n                        const td = tr.cells[sourceCol];\n                        const hasSelectionBeforeCell = context.isInSelection;\n                        if (recalculateTableSize) {\n                            const colEnd = targetCol + td.colSpan;\n                            const rowEnd = row + td.rowSpan;\n                            const needCalcWidth = columnPositions[colEnd] === undefined;\n                            const needCalcHeight = rowPositions[rowEnd] === undefined;\n\n                            if (needCalcWidth || needCalcHeight) {\n                                const rect = getBoundingClientRect(td);\n\n                                if (rect.width > 0 || rect.height > 0) {\n                                    if (needCalcWidth) {\n                                        const pos = columnPositions[targetCol];\n\n                                        columnPositions[colEnd] =\n                                            (typeof pos == 'number' ? pos : 0) +\n                                            rect.width / zoomScale;\n                                    }\n\n                                    if (needCalcHeight) {\n                                        rowPositions[rowEnd] =\n                                            rowPositions[row] + rect.height / zoomScale;\n                                    }\n                                }\n                            }\n                        }\n\n                        stackFormat(\n                            context,\n                            { paragraph: 'shallowClone', segment: 'shallowClone' },\n                            () => {\n                                parseFormat(\n                                    td,\n                                    context.formatParsers.block,\n                                    context.blockFormat,\n                                    context\n                                );\n                                parseFormat(\n                                    td,\n                                    context.formatParsers.segmentOnTableCell,\n                                    context.segmentFormat,\n                                    context\n                                );\n\n                                const cellFormat: ContentModelTableCellFormat = {\n                                    ...context.blockFormat,\n                                };\n                                const dataset: DatasetFormat = {};\n\n                                parseFormat(\n                                    td,\n                                    context.formatParsers.tableCell,\n                                    cellFormat,\n                                    context\n                                );\n                                parseFormat(\n                                    td,\n                                    context.formatParsers.tableBorder,\n                                    cellFormat,\n                                    context\n                                );\n                                parseFormat(td, context.formatParsers.dataset, dataset, context);\n\n                                for (\n                                    let colSpan = 1;\n                                    colSpan <= (td.colSpan == 0 ? 1 : td.colSpan);\n                                    colSpan++, targetCol++\n                                ) {\n                                    for (\n                                        let rowSpan = 1;\n                                        // RowSpan of 0 means it should span to the end of the table\n                                        // https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/td#rowspan\n                                        rowSpan <=\n                                        (td.rowSpan == 0\n                                            ? isInTableSection\n                                                ? translateRowSpanZero(parent, td)\n                                                : 1\n                                            : td.rowSpan);\n                                        rowSpan++\n                                    ) {\n                                        const hasTd = colSpan == 1 && rowSpan == 1;\n                                        const cell = createTableCell(\n                                            colSpan > 1,\n                                            rowSpan > 1,\n                                            td.tagName == 'TH',\n                                            cellFormat\n                                        );\n\n                                        cell.dataset = { ...dataset };\n\n                                        const spannedRow = table.rows[row + rowSpan - 1];\n\n                                        if (spannedRow) {\n                                            spannedRow.cells[targetCol] = cell;\n                                        }\n\n                                        if (hasTd) {\n                                            // When there is COLGROUP, width on table cell should be ignored, so we should not cache the table cell,\n                                            // and always recreate it when write back using the table formats\n                                            if (context.allowCacheElement && !hasColGroup) {\n                                                cell.cachedElement = td;\n                                            }\n\n                                            const { listParent, levels } = context.listFormat;\n\n                                            context.listFormat.listParent = undefined;\n                                            context.listFormat.levels = [];\n\n                                            try {\n                                                context.elementProcessors.child(cell, td, context);\n                                            } finally {\n                                                context.listFormat.listParent = listParent;\n                                                context.listFormat.levels = levels;\n                                            }\n                                        }\n\n                                        const hasSelectionAfterCell = context.isInSelection;\n\n                                        if (\n                                            (hasSelectionBeforeCell && hasSelectionAfterCell) ||\n                                            (hasTableSelection &&\n                                                tableSelection &&\n                                                row >= tableSelection.firstRow &&\n                                                row <= tableSelection.lastRow &&\n                                                targetCol >= tableSelection.firstColumn &&\n                                                targetCol <= tableSelection.lastColumn)\n                                        ) {\n                                            cell.isSelected = true;\n                                        }\n                                    }\n                                }\n                            }\n                        );\n                    }\n                });\n\n                for (let col = 0; col < tableRow.cells.length; col++) {\n                    if (!tableRow.cells[col]) {\n                        tableRow.cells[col] = createTableCell(\n                            false,\n                            false,\n                            false,\n                            context.blockFormat\n                        );\n                    }\n                }\n            }\n\n            table.widths = calcSizes(columnPositions);\n\n            const heights = calcSizes(rowPositions);\n\n            table.rows.forEach((row, i) => {\n                if (heights[i] > 0) {\n                    row.height = heights[i];\n                }\n            });\n        }\n    );\n};\n\nfunction translateRowSpanZero(parent: HTMLTableSectionElement, td: HTMLTableCellElement) {\n    const amountOfRows = parent.rows.length;\n\n    let tdIndex = -1;\n    for (let i = 0; i < parent.rows.length; i++) {\n        const row = parent.rows[i];\n        for (let j = 0; j < row.cells.length; j++) {\n            if (row.cells[j] === td) {\n                tdIndex = i;\n                break;\n            }\n        }\n        if (tdIndex !== -1) {\n            break;\n        }\n    }\n\n    return amountOfRows - tdIndex;\n}\n\nfunction calcSizes(positions: (number | undefined)[]): number[] {\n    const result: number[] = [];\n    let lastPos = 0;\n\n    for (let i = positions.length - 1; i >= 0; i--) {\n        const pos = positions[i];\n\n        if (typeof pos == 'number') {\n            lastPos = pos;\n            break;\n        }\n    }\n\n    for (let i = positions.length - 2; i >= 0; i--) {\n        const pos = positions[i];\n        if (pos === undefined) {\n            result[i] = 0;\n        } else {\n            result[i] = lastPos - pos;\n            lastPos = pos;\n        }\n    }\n\n    return result;\n}\n\nfunction processColGroup(\n    table: HTMLElement,\n    context: DomToModelContext,\n    result: (number | undefined)[]\n): boolean {\n    let lastPos = 0;\n    let hasColGroup = false;\n\n    for (let child = table.firstChild; child; child = child.nextSibling) {\n        if (isNodeOfType(child, 'ELEMENT_NODE') && child.tagName == 'COLGROUP') {\n            hasColGroup = true;\n\n            for (let col = child.firstChild; col; col = col.nextSibling) {\n                if (isNodeOfType(col, 'ELEMENT_NODE') && col.tagName == 'COL') {\n                    const colFormat: SizeFormat = {};\n\n                    parseFormat(col, context.formatParsers.tableColumn, colFormat, context);\n\n                    for (let i = 0; i < parseInt(col.getAttribute('span') ?? '1'); i++) {\n                        if (colFormat.width === undefined) {\n                            result.push(undefined);\n                        } else {\n                            const width = parseValueWithUnit(\n                                colFormat.width ?? '',\n                                undefined /*element*/,\n                                'px'\n                            );\n\n                            result.push(width + lastPos);\n                            lastPos += width;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return hasColGroup;\n}\n\nfunction shouldRecalculateTableSize(table: HTMLTableElement, context: DomToModelContext): boolean {\n    switch (context.recalculateTableSize) {\n        case true:\n        case 'all':\n            return true;\n\n        case 'selected':\n            const selectionRoot = getSelectionRootNode(context.selection);\n\n            return (\n                !!selectionRoot &&\n                (selectionRoot == table ||\n                    table.contains(selectionRoot) ||\n                    selectionRoot.contains(table))\n            );\n\n        default:\n            return false;\n    }\n}\n\nfunction getIsInTableSection(element: HTMLElement): element is HTMLTableSectionElement {\n    return (\n        isElementOfType(element, 'tbody') ||\n        isElementOfType(element, 'thead') ||\n        isElementOfType(element, 'tfoot')\n    );\n}\n","import { ensureParagraph } from '../../modelApi/common/ensureParagraph';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelText,\n    DomToModelContext,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const textProcessor: ElementProcessor<Text> = (\n    group: ContentModelBlockGroup,\n    textNode: Text,\n    context: DomToModelContext\n) => {\n    if (context.formatParsers.text.length > 0) {\n        stackFormat(context, { segment: 'shallowClone' }, () => {\n            context.formatParsers.text.forEach(parser => {\n                parser(context.segmentFormat, textNode, context);\n            });\n            internalTextProcessor(group, textNode, context);\n        });\n    } else {\n        internalTextProcessor(group, textNode, context);\n    }\n};\n\nfunction internalTextProcessor(\n    group: ContentModelBlockGroup,\n    textNode: Text,\n    context: DomToModelContext\n) {\n    const paragraph = ensureParagraph(group, context.blockFormat);\n    const segmentCount = paragraph.segments.length;\n\n    context.elementProcessors.textWithSelection(group, textNode, context);\n\n    const newSegments = paragraph.segments.slice(segmentCount);\n    context.domIndexer?.onSegment(\n        textNode,\n        paragraph,\n        newSegments.filter((x): x is ContentModelText => x?.segmentType == 'Text')\n    );\n}\n","import { addSelectionMarker } from '../utils/addSelectionMarker';\nimport { addTextSegment } from '../../modelApi/common/addTextSegment';\nimport { getRegularSelectionOffsets } from '../utils/getRegularSelectionOffsets';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const textWithSelectionProcessor: ElementProcessor<Text> = (group, textNode, context) => {\n    let txt = textNode.nodeValue || '';\n    const offsets = getRegularSelectionOffsets(context, textNode);\n    const txtStartOffset = offsets[0];\n    let txtEndOffset = offsets[1];\n\n    if (txtStartOffset >= 0) {\n        const subText = txt.substring(0, txtStartOffset);\n        addTextSegment(group, subText, context);\n        context.isInSelection = true;\n\n        addSelectionMarker(group, context, textNode, txtStartOffset);\n\n        txt = txt.substring(txtStartOffset);\n        txtEndOffset -= txtStartOffset;\n    }\n\n    if (txtEndOffset >= 0) {\n        const subText = txt.substring(0, txtEndOffset);\n        addTextSegment(group, subText, context);\n\n        if (\n            context.selection &&\n            (context.selection.type != 'range' || !context.selection.range.collapsed)\n        ) {\n            addSelectionMarker(group, context, textNode, offsets[1]); // Must use offsets[1] here as the unchanged offset value, cannot use txtEndOffset since it has been modified\n        }\n\n        context.isInSelection = false;\n        txt = txt.substring(txtEndOffset);\n    }\n\n    addTextSegment(group, txt, context);\n};\n","import { addSegment } from '../../modelApi/common/addSegment';\nimport { buildSelectionMarker } from './buildSelectionMarker';\nimport type { ContentModelBlockGroup, DomToModelContext } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function addSelectionMarker(\n    group: ContentModelBlockGroup,\n    context: DomToModelContext,\n    container?: Node,\n    offset?: number\n) {\n    const marker = buildSelectionMarker(group, context, container, offset);\n\n    addSegment(group, marker, context.blockFormat, marker.format);\n}\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport type { ContentModelFormatBase } from 'roosterjs-content-model-types';\n\n/**\n * Check if the two given formats object are equal. This is a check to value but not to reference\n * @param f1 The first format object to check\n * @param f2 The second format object to check\n */\nexport function areSameFormats<T extends ContentModelFormatBase>(f1: T, f2: T) {\n    if (f1 == f2) {\n        return true;\n    } else {\n        const keys1 = getObjectKeys(f1);\n        const keys2 = getObjectKeys(f2);\n\n        return keys1.length == keys2.length && keys1.every(key => f1[key] == f2[key]);\n    }\n}\n","import { addDecorators } from '../../modelApi/common/addDecorators';\nimport { createSelectionMarker } from '../../modelApi/creators/createSelectionMarker';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelSegmentFormat,\n    ContentModelSelectionMarker,\n    DomToModelContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Build a new selection marker with correct format according to its parent paragraph\n * @param group The BlockGroup that paragraph belongs to\n * @param context Current DOM to Model context\n * @param container @optional Container Node, used for retrieving pending format\n * @param offset @optional Container offset, used for retrieving pending format\n * @returns A new selection marker\n */\nexport function buildSelectionMarker(\n    group: ContentModelBlockGroup,\n    context: DomToModelContext,\n    container?: Node,\n    offset?: number\n): ContentModelSelectionMarker {\n    const lastPara = group.blocks[group.blocks.length - 1];\n    const formatFromParagraph: ContentModelSegmentFormat =\n        !lastPara || lastPara.blockType != 'Paragraph'\n            ? {}\n            : lastPara.decorator\n            ? {\n                  fontFamily: lastPara.decorator.format.fontFamily,\n                  fontSize: lastPara.decorator.format.fontSize,\n              }\n            : lastPara.segmentFormat\n            ? {\n                  fontFamily: lastPara.segmentFormat.fontFamily,\n                  fontSize: lastPara.segmentFormat.fontSize,\n              }\n            : {};\n\n    const pendingFormat =\n        context.pendingFormat &&\n        context.pendingFormat.insertPoint.node === container &&\n        context.pendingFormat.insertPoint.offset === offset\n            ? context.pendingFormat.format\n            : undefined;\n\n    const format: ContentModelSegmentFormat = Object.assign(\n        {},\n        context.defaultFormat,\n        formatFromParagraph,\n        context.segmentFormat,\n        pendingFormat\n    );\n\n    const marker = createSelectionMarker(format);\n\n    addDecorators(marker, context);\n\n    return marker;\n}\n","/**\n * @internal\n */\nexport function getBoundingClientRect(element: Element): DOMRect {\n    return element.getBoundingClientRect();\n}\n","import { defaultHTMLStyleMap } from '../../config/defaultHTMLStyleMap';\nimport type { DefaultStyleMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Get default CSS style of given element\n * @param element The element to get default style from\n * @returns A valid CSS style object\n */\nexport function getDefaultStyle(element: HTMLElement): Partial<CSSStyleDeclaration> {\n    const tag = element.tagName.toLowerCase() as keyof DefaultStyleMap;\n\n    return defaultHTMLStyleMap[tag] || {};\n}\n","import type { DomToModelContext } from 'roosterjs-content-model-types';\n\n/**\n * Get offset numbers of a regular (range based) selection.\n * If the selection start/end position is not in the given node, it will return -1 for the related value\n * @param context DOM to Content Model context used for retrieve the selection\n * @param currentContainer The container node to check\n * @returns a tuple of start and end offsets. -1 means selection is not directly under the given node\n */\nexport function getRegularSelectionOffsets(\n    context: DomToModelContext,\n    currentContainer: Node\n): [number, number] {\n    const range = context.selection?.type == 'range' ? context.selection.range : null;\n\n    const startOffset = range?.startContainer == currentContainer ? range.startOffset : -1;\n    const endOffset = range?.endContainer == currentContainer ? range.endOffset! : -1;\n\n    return [startOffset, endOffset];\n}\n","import { getDefaultStyle } from './getDefaultStyle';\n\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table', 'table-cell', 'flex'];\n\n/**\n * Check if the given element will be layout as a block\n * @param element The element to check\n * @param context The context of DOM to Content Model conversion\n */\nexport function isBlockElement(element: HTMLElement): boolean {\n    const display = element.style.display == 'none' ? null : element.style.display;\n    const effectiveDisplay = display || getDefaultStyle(element).display || '';\n\n    return BLOCK_DISPLAY_STYLES.indexOf(effectiveDisplay) >= 0;\n}\n","import { getDefaultStyle } from './getDefaultStyle';\nimport type {\n    ContentModelFormatBase,\n    DomToModelContext,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\n/**\n * Parse formats of the given HTML element using specified format parsers\n * @param element The element to parse format from\n * @param parsers The parses we are using to parse format\n * @param format The format object to hold result format\n * @param context DOM to Content Model context\n */\nexport function parseFormat<T extends ContentModelFormatBase>(\n    element: HTMLElement,\n    parsers: (FormatParser<T> | null)[],\n    format: T,\n    context: DomToModelContext\n) {\n    const defaultStyle = getDefaultStyle(element);\n\n    parsers.forEach(parser => {\n        parser?.(format, element, context, defaultStyle);\n    });\n}\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelCode,\n    ContentModelFormatBase,\n    ContentModelLink,\n    ContentModelParagraphDecorator,\n    ContentModelSegmentFormat,\n    DomToModelContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport interface StackFormatOptions {\n    segment?: 'shallowClone' | 'shallowCloneForBlock' | 'empty';\n    paragraph?: 'shallowClone' | 'shallowCloneForGroup' | 'empty';\n    blockDecorator?: 'empty';\n    link?: 'linkDefault' | 'cloneFormat' | 'empty';\n    code?: 'codeDefault' | 'empty';\n}\n\n// Some styles, such as background color, won't be inherited by block element if it was originally\n// declared from an inline element. So we need to skip them.\n// e.g.\n// <span style=\"background-color: red\">\n//   line 1       <---------------------------- in red here\n//   <div>line 2</div>  <---------------------- not in red here\n// </span>\nconst SkippedStylesForBlockOnSegmentOnSegment: (keyof ContentModelSegmentFormat)[] = [\n    'backgroundColor',\n];\nconst SkippedStylesForTable: (keyof ContentModelBlockFormat)[] = [\n    'marginLeft',\n    'marginRight',\n    'paddingLeft',\n    'paddingRight',\n];\n\n/**\n * @internal\n */\nexport function stackFormat(\n    context: DomToModelContext,\n    options: StackFormatOptions,\n    callback: () => void\n) {\n    const {\n        segmentFormat,\n        blockFormat,\n        link: linkFormat,\n        code: codeFormat,\n        blockDecorator: decoratorFormat,\n    } = context;\n    const { segment, paragraph, link, code, blockDecorator } = options;\n\n    try {\n        context.segmentFormat = stackFormatInternal(segmentFormat, segment);\n        context.blockFormat = stackFormatInternal(blockFormat, paragraph);\n        context.link = stackLinkInternal(linkFormat, link);\n        context.code = stackCodeInternal(codeFormat, code);\n        context.blockDecorator = stackDecoratorInternal(decoratorFormat, blockDecorator);\n\n        callback();\n    } finally {\n        context.segmentFormat = segmentFormat;\n        context.blockFormat = blockFormat;\n        context.link = linkFormat;\n        context.code = codeFormat;\n        context.blockDecorator = decoratorFormat;\n    }\n}\n\nfunction stackLinkInternal(\n    linkFormat: ContentModelLink,\n    link?: 'linkDefault' | 'cloneFormat' | 'empty'\n) {\n    switch (link) {\n        case 'linkDefault':\n            return {\n                format: {\n                    underline: true,\n                },\n                dataset: {},\n            };\n\n        case 'empty':\n            return {\n                format: {},\n                dataset: {},\n            };\n\n        case 'cloneFormat':\n        default:\n            return {\n                dataset: linkFormat.dataset,\n                format: { ...linkFormat.format },\n            };\n    }\n}\n\nfunction stackCodeInternal(codeFormat: ContentModelCode, code?: 'codeDefault' | 'empty') {\n    switch (code) {\n        case 'codeDefault':\n            return {\n                format: {\n                    fontFamily: 'monospace',\n                },\n            };\n        case 'empty':\n            return {\n                format: {},\n            };\n        default:\n            return codeFormat;\n    }\n}\n\nfunction stackDecoratorInternal(\n    format: ContentModelParagraphDecorator,\n    decorator?: 'decoratorDefault' | 'empty'\n) {\n    switch (decorator) {\n        case 'empty':\n            return {\n                format: {},\n                tagName: '',\n            };\n        default:\n            return format;\n    }\n}\n\nfunction stackFormatInternal<T extends ContentModelFormatBase>(\n    format: T,\n    processType?: 'shallowClone' | 'shallowCloneForBlock' | 'shallowCloneForGroup' | 'empty'\n): T | {} {\n    switch (processType) {\n        case 'empty':\n            return {};\n\n        case undefined:\n            return format;\n\n        default:\n            const result = { ...format };\n\n            getObjectKeys(format).forEach(key => {\n                if (\n                    (processType == 'shallowCloneForBlock' &&\n                        SkippedStylesForBlockOnSegmentOnSegment.indexOf(\n                            key as keyof ContentModelSegmentFormat\n                        ) >= 0) ||\n                    (processType == 'shallowCloneForGroup' &&\n                        SkippedStylesForTable.indexOf(key as keyof ContentModelBlockFormat) >= 0)\n                ) {\n                    delete result[key];\n                }\n            });\n\n            if (processType == 'shallowClone' || processType == 'shallowCloneForGroup') {\n                const blockFormat = format as ContentModelBlockFormat;\n\n                // For a new paragraph, if current text indent is already applied to previous block in the same level,\n                // we need to ignore it according to browser rendering behavior\n                if (blockFormat.textIndent) {\n                    delete (result as ContentModelBlockFormat).isTextIndentApplied;\n                    blockFormat.isTextIndentApplied = true;\n                }\n            }\n\n            return result;\n    }\n}\n","import { applyFormat } from '../modelToDom/utils/applyFormat';\nimport { isElementOfType } from './isElementOfType';\nimport { isNodeOfType } from './isNodeOfType';\nimport { toArray } from './toArray';\nimport type {\n    ContentModelEntityFormat,\n    ContentModelSegmentFormat,\n    DOMHelper,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\nconst ENTITY_INFO_NAME = '_Entity';\nconst ENTITY_INFO_SELECTOR = '.' + ENTITY_INFO_NAME;\nconst ENTITY_TYPE_PREFIX = '_EType_';\nconst ENTITY_ID_PREFIX = '_EId_';\nconst ENTITY_READONLY_PREFIX = '_EReadonly_';\nconst ZERO_WIDTH_SPACE = '\\u200B';\nconst DELIMITER_BEFORE = 'entityDelimiterBefore';\nconst DELIMITER_AFTER = 'entityDelimiterAfter';\nconst BLOCK_ENTITY_CONTAINER = '_E_EBlockEntityContainer';\nconst BLOCK_ENTITY_CONTAINER_SELECTOR = '.' + BLOCK_ENTITY_CONTAINER;\n\n/**\n * Check if the given DOM Node is an entity wrapper element\n */\nexport function isEntityElement(node: Node): boolean {\n    return isNodeOfType(node, 'ELEMENT_NODE') && node.classList.contains(ENTITY_INFO_NAME);\n}\n\n/**\n * Find the closest entity wrapper element from a given DOM node\n * @param node The node to start looking for entity wrapper\n * @param domHelper The DOM helper to use\n */\nexport function findClosestEntityWrapper(\n    startNode: Node,\n    domHelper: DOMHelper\n): HTMLElement | null {\n    return domHelper.findClosestElementAncestor(startNode, ENTITY_INFO_SELECTOR);\n}\n\n/**\n * Find the closest block entity wrapper element from a given DOM node\n * @param node The node to start looking for entity container\n * @param domHelper The DOM helper\n * @returns\n */\nexport function findClosestBlockEntityContainer(\n    node: Node,\n    domHelper: DOMHelper\n): HTMLElement | null {\n    return domHelper.findClosestElementAncestor(node, BLOCK_ENTITY_CONTAINER_SELECTOR);\n}\n\n/**\n * Get all entity wrapper elements under the given root element\n * @param root The root element to query from\n * @returns An array of entity wrapper elements\n */\nexport function getAllEntityWrappers(root: HTMLElement): HTMLElement[] {\n    return toArray(root.querySelectorAll('.' + ENTITY_INFO_NAME)) as HTMLElement[];\n}\n\n/**\n * Parse entity format from entity wrapper element\n * @param wrapper The wrapper element to parse entity format from\n * @returns Entity format\n */\nexport function parseEntityFormat(wrapper: HTMLElement): ContentModelEntityFormat {\n    let isEntity = false;\n    const format: ContentModelEntityFormat = {};\n\n    wrapper.classList.forEach(name => {\n        isEntity = parseEntityClassName(name, format) || isEntity;\n    });\n\n    if (!isEntity) {\n        format.isFakeEntity = true;\n        format.isReadonly = !wrapper.isContentEditable;\n    }\n\n    return format;\n}\n\n/**\n * Parse entity class names from entity wrapper element\n * @param className Class names of entity\n * @param format The output entity format object\n */\nfunction parseEntityClassName(\n    className: string,\n    format: ContentModelEntityFormat\n): boolean | undefined {\n    if (className == ENTITY_INFO_NAME) {\n        return true;\n    } else if (className.indexOf(ENTITY_TYPE_PREFIX) == 0) {\n        format.entityType = className.substring(ENTITY_TYPE_PREFIX.length);\n    } else if (className.indexOf(ENTITY_ID_PREFIX) == 0) {\n        format.id = className.substring(ENTITY_ID_PREFIX.length);\n    } else if (className.indexOf(ENTITY_READONLY_PREFIX) == 0) {\n        format.isReadonly = className.substring(ENTITY_READONLY_PREFIX.length) == '1';\n    }\n}\n\n/**\n * Generate Entity class names for an entity wrapper\n * @param format The source entity format object\n * @returns A combined CSS class name string for entity wrapper\n */\nexport function generateEntityClassNames(format: ContentModelEntityFormat): string {\n    return format.isFakeEntity\n        ? ''\n        : `${ENTITY_INFO_NAME} ${ENTITY_TYPE_PREFIX}${format.entityType ?? ''} ${\n              format.id ? `${ENTITY_ID_PREFIX}${format.id} ` : ''\n          }${ENTITY_READONLY_PREFIX}${format.isReadonly ? '1' : '0'}`;\n}\n\n/**\n * Checks whether the node provided is a Entity delimiter\n * @param node the node to check\n * @param isBefore True to match delimiter before entity only, false to match delimiter after entity, or undefined means match both\n * @return true if it is a delimiter\n */\nexport function isEntityDelimiter(element: HTMLElement, isBefore?: boolean): boolean {\n    const matchBefore = isBefore === undefined || isBefore;\n    const matchAfter = isBefore === undefined || !isBefore;\n\n    return (\n        isElementOfType(element, 'span') &&\n        ((matchAfter && element.classList.contains(DELIMITER_AFTER)) ||\n            (matchBefore && element.classList.contains(DELIMITER_BEFORE))) &&\n        element.textContent === ZERO_WIDTH_SPACE\n    );\n}\n\n/**\n * Check if the given element is a container element of block entity\n * @param element The element to check\n * @returns True if the element is a block entity container, otherwise false\n */\nexport function isBlockEntityContainer(element: HTMLElement): boolean {\n    return isElementOfType(element, 'div') && element.classList.contains(BLOCK_ENTITY_CONTAINER);\n}\n\n/**\n * Adds delimiters to the element provided. If the delimiters already exists, will not be added\n * @param element the node to add the delimiters\n * @param format format to set to the delimiters, so when typing inside of one the format is not lost\n * @param context Model to Dom context to use.\n */\nexport function addDelimiters(\n    doc: Document,\n    element: HTMLElement,\n    format?: ContentModelSegmentFormat | null,\n    context?: ModelToDomContext\n): HTMLElement[] {\n    let [delimiterAfter, delimiterBefore] = getDelimiters(element);\n\n    if (!delimiterAfter) {\n        delimiterAfter = insertDelimiter(doc, element, true /*isAfter*/);\n        if (context && format) {\n            applyFormat(delimiterAfter, context.formatAppliers.segment, format, context);\n        }\n    }\n\n    if (!delimiterBefore) {\n        delimiterBefore = insertDelimiter(doc, element, false /*isAfter*/);\n        if (context && format) {\n            applyFormat(delimiterBefore, context.formatAppliers.segment, format, context);\n        }\n    }\n\n    return [delimiterAfter, delimiterBefore];\n}\n\nfunction getDelimiters(entityWrapper: HTMLElement): (HTMLElement | undefined)[] {\n    const result: (HTMLElement | undefined)[] = [];\n    const { nextElementSibling, previousElementSibling } = entityWrapper;\n    result.push(\n        isDelimiter(nextElementSibling, DELIMITER_AFTER),\n        isDelimiter(previousElementSibling, DELIMITER_BEFORE)\n    );\n\n    return result;\n}\n\nfunction isDelimiter(el: Element | null, className: string): HTMLElement | undefined {\n    return el?.classList.contains(className) && el.textContent == ZERO_WIDTH_SPACE\n        ? (el as HTMLElement)\n        : undefined;\n}\n\nfunction insertDelimiter(doc: Document, element: Element, isAfter: boolean) {\n    const span = doc.createElement('span');\n\n    span.className = isAfter ? DELIMITER_AFTER : DELIMITER_BEFORE;\n    span.appendChild(doc.createTextNode(ZERO_WIDTH_SPACE));\n    element.parentNode?.insertBefore(span, isAfter ? element.nextSibling : element);\n\n    return span;\n}\n","import type { PluginEvent } from 'roosterjs-content-model-types';\n\n/**\n * Gets the cached event data by cache key from event object if there is already one.\n * Otherwise, call getter function to create one, and cache it.\n * @param event The event object\n * @param key Cache key string, need to be unique\n * @param getter Getter function to get the object when it is not in cache yet\n */\nexport function cacheGetEventData<T, E extends PluginEvent>(\n    event: E,\n    key: string,\n    getter: (event: E) => T\n): T {\n    const result =\n        event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\n            ? <T>event.eventDataCache[key]\n            : getter(event);\n    event.eventDataCache = event.eventDataCache || {};\n    event.eventDataCache[key] = result;\n\n    return result;\n}\n","const CTRL_CHAR_CODE = 'Control';\nconst ALT_CHAR_CODE = 'Alt';\nconst META_CHAR_CODE = 'Meta';\n\nconst CursorMovingKeys = new Set<string>([\n    'ArrowUp',\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight',\n    'Home',\n    'End',\n    'PageUp',\n    'PageDown',\n]);\n\n/**\n * Returns true when the event was fired from a modifier key, otherwise false\n * @param event The keyboard event object\n */\nexport function isModifierKey(event: KeyboardEvent): boolean {\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHAR_CODE;\n    const isAltKey = event.altKey || event.key === ALT_CHAR_CODE;\n    const isMetaKey = event.metaKey || event.key === META_CHAR_CODE;\n\n    return isCtrlKey || isAltKey || isMetaKey;\n}\n\n/**\n * Returns true when the event was fired from a key that produces a character value, otherwise false\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\n * So if we missed some case here it is still acceptable.\n * @param event The keyboard event object\n */\nexport function isCharacterValue(event: KeyboardEvent): boolean {\n    return !isModifierKey(event) && !!event.key && event.key.length == 1;\n}\n\n/**\n * Returns true if the given event is a cursor moving event (Left, Right, Up, Down, Home, End, Page Up, Page Down).\n * This does not check modifier keys (Ctrl, Alt, Meta). So if there are modifier keys pressed, it can still return true if one of the modifier key is pressed\n * @param event The keyboard event to check\n */\nexport function isCursorMovingKey(event: KeyboardEvent): boolean {\n    return CursorMovingKeys.has(event.key);\n}\n","import { readFile } from '../readFile';\nimport type { ClipboardData, EdgeLinkPreview } from 'roosterjs-content-model-types';\n\nconst ContentHandlers: {\n    [contentType: string]: (data: ClipboardData, value: string, type?: string) => void;\n} = {\n    ['text/html']: (data, value) => (data.rawHtml = value),\n    ['text/plain']: (data, value) => (data.text = value),\n    ['text/*']: (data, value, type?) => !!type && (data.customValues[type] = value),\n    ['text/link-preview']: tryParseLinkPreview,\n    ['text/uri-list']: (data, value) => (data.text = value),\n};\n\n/**\n * Extract clipboard items to be a ClipboardData object for IE\n * @param items The clipboard items retrieve from a DataTransfer object\n * @param allowedCustomPasteType Allowed custom content type when paste besides text/plain, text/html and images\n    Only text types are supported, and do not add \"text/\" prefix to the type values\n */\nexport function extractClipboardItems(\n    items: DataTransferItem[],\n    allowedCustomPasteType?: string[]\n): Promise<ClipboardData> {\n    const data: ClipboardData = {\n        types: [],\n        text: '',\n        image: null,\n        files: [],\n        rawHtml: null,\n        customValues: {},\n        pasteNativeEvent: true,\n    };\n\n    return Promise.all(\n        (items || []).map(item => {\n            const type = item.type;\n\n            if (type.indexOf('image/') == 0 && !data.image && item.kind == 'file') {\n                data.types.push(type);\n                data.image = item.getAsFile();\n                return new Promise<void>(resolve => {\n                    if (data.image) {\n                        readFile(data.image, dataUrl => {\n                            data.imageDataUri = dataUrl;\n                            resolve();\n                        });\n                    } else {\n                        resolve();\n                    }\n                });\n            } else if (item.kind == 'file') {\n                return new Promise<void>(resolve => {\n                    const file = item.getAsFile();\n                    if (!!file) {\n                        data.types.push(type);\n                        data.files!.push(file);\n                    }\n                    resolve();\n                });\n            } else {\n                const customType = getAllowedCustomType(type, allowedCustomPasteType);\n                const handler =\n                    ContentHandlers[type] || (customType ? ContentHandlers['text/*'] : null);\n                return new Promise<void>(resolve =>\n                    handler\n                        ? item.getAsString(value => {\n                              data.types.push(type);\n                              handler(data, value, customType);\n                              resolve();\n                          })\n                        : resolve()\n                );\n            }\n        })\n    ).then(() => data);\n}\n\nfunction tryParseLinkPreview(data: ClipboardData, value: string) {\n    try {\n        data.customValues['link-preview'] = value;\n        data.linkPreview = JSON.parse(value) as EdgeLinkPreview;\n    } catch {}\n}\n\nfunction getAllowedCustomType(type: string, allowedCustomPasteType?: string[]) {\n    const textType = type.indexOf('text/') == 0 ? type.substring('text/'.length) : null;\n    const index =\n        allowedCustomPasteType && textType ? allowedCustomPasteType.indexOf(textType) : -1;\n    return textType && index >= 0 ? textType : undefined;\n}\n","/**\n * Provide a strong-typed version of Object.keys()\n * @param obj The source object\n * @returns Array of keys\n */\nexport function getObjectKeys<T extends string | number | symbol>(\n    obj: Record<T, any> | Partial<Record<T, any>>\n): T[] {\n    return Object.keys(obj) as T[];\n}\n","import { isBlockElement } from '../domToModel/utils/isBlockElement';\nimport { isNodeOfType } from './isNodeOfType';\nimport { isPunctuation, isSpace } from './stringUtil';\n\nconst SplittingTags: string[] = ['BR', 'HR', 'IMG'];\n\ninterface SearchContext {\n    text: string;\n    matchCase: boolean;\n    wholeWord: boolean;\n    result: Range[];\n    paragraphText: string;\n    editableOnly: boolean;\n    indexes: {\n        node: Text;\n        length: number;\n    }[];\n}\n\n/**\n * Search text from the given root element and return all ranges that match the search criteria\n * @param root Root element to search from\n * @param text Text to search for\n * @param matchCase Whether to match case\n * @param wholeWord Whether to match whole words only\n * @param editableOnly Whether to search only in editable elements\n * @returns Array of matching ranges\n */\nexport function getRangesByText(\n    root: HTMLElement,\n    text: string,\n    matchCase: boolean,\n    wholeWord: boolean,\n    editableOnly?: boolean\n): Range[] {\n    const context: SearchContext = {\n        text: matchCase ? text : text.toLowerCase(),\n        matchCase,\n        wholeWord,\n        result: [],\n        paragraphText: '',\n        indexes: [],\n        editableOnly: !!editableOnly,\n    };\n\n    if (context.text) {\n        iterateTextNodes(root, context);\n    }\n\n    return context.result;\n}\n\nfunction isSplittingElement(element: HTMLElement) {\n    return isBlockElement(element) || SplittingTags.indexOf(element.tagName) >= 0;\n}\n\nfunction iterateTextNodes(root: HTMLElement, context: SearchContext) {\n    const canSearchText = !context.editableOnly || root.isContentEditable;\n\n    for (let node = root.firstChild; node; node = node.nextSibling) {\n        if (isNodeOfType(node, 'TEXT_NODE') && canSearchText) {\n            const nodeText = context.matchCase\n                ? node.nodeValue || ''\n                : (node.nodeValue || '').toLowerCase();\n\n            if (nodeText) {\n                context.paragraphText += nodeText;\n                context.indexes.push({ node, length: nodeText.length });\n            }\n        } else if (isNodeOfType(node, 'ELEMENT_NODE')) {\n            if (context.paragraphText && isSplittingElement(node)) {\n                search(root.ownerDocument, context);\n            }\n\n            iterateTextNodes(node, context);\n        }\n    }\n\n    if (context.paragraphText && isSplittingElement(root)) {\n        search(root.ownerDocument, context);\n    }\n}\n\nfunction search(doc: Document, context: SearchContext) {\n    let offset: number;\n    let startIndex = 0;\n\n    while ((offset = context.paragraphText.indexOf(context.text, startIndex)) > -1) {\n        if (\n            !context.wholeWord ||\n            ((offset == 0 || isSpaceOrPunctuation(context.paragraphText[offset - 1])) &&\n                (offset + context.text.length == context.paragraphText.length ||\n                    isSpaceOrPunctuation(context.paragraphText[offset + context.text.length])))\n        ) {\n            const start = findNodeAndOffset(context.indexes, offset, false /*isEnd*/);\n            const end = findNodeAndOffset(\n                context.indexes,\n                offset + context.text.length,\n                true /*isEnd*/\n            );\n\n            if (start && end) {\n                const range = doc.createRange();\n\n                range.setStart(start.node, start.offset);\n                range.setEnd(end.node, end.offset);\n                context.result.push(range);\n            }\n        }\n\n        startIndex = offset + context.text.length;\n    }\n\n    context.paragraphText = '';\n    context.indexes = [];\n}\n\nfunction isSpaceOrPunctuation(char: string) {\n    return isSpace(char) || isPunctuation(char);\n}\n\nfunction findNodeAndOffset(\n    lengths: { length: number; node: Text }[],\n    offset: number,\n    isEnd: boolean\n): { node: Text; offset: number } | null {\n    let currentIndex = 0;\n\n    for (let i = 0; i < lengths.length; i++) {\n        const segmentLength = lengths[i].length;\n\n        if (\n            isEnd ? currentIndex + segmentLength >= offset : currentIndex + segmentLength > offset\n        ) {\n            return { node: lengths[i].node, offset: offset - currentIndex };\n        }\n\n        currentIndex += segmentLength;\n    }\n\n    return null;\n}\n","const StartsWithUnsupportedCharacter = /^[.|\\-|_|\\d]/;\n\n/**\n * Returns a safe Id to use in Native APIs.\n * IDs that start with number or hyphen can throw errors if used.\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id\n * @param id\n * @returns\n */\nexport function getSafeIdSelector(id: string) {\n    if (!id) {\n        return id;\n    }\n\n    if (id.match(StartsWithUnsupportedCharacter)) {\n        return `[id=\"${id}\"]`;\n    } else {\n        return `#${id}`;\n    }\n}\n","/**\n * @internal\n */\nexport interface HiddenProperty {\n    /**\n     * A marker string that can be used to identify a specific paragraph in the DOM.\n     * This is useful for scenarios where you need to track or manipulate specific paragraphs\n     */\n    paragraphMarker?: string;\n\n    /**\n     * Specify we should not delete this element when delete/backspace key is pressed\n     */\n    undeletable?: boolean;\n\n    /**\n     * Specify the image state. Example: if the image is in editable state\n     */\n    imageState?: string;\n}\n\ninterface NodeWithHiddenProperty extends Node {\n    __roosterjsHiddenProperty?: HiddenProperty;\n}\n\n/**\n * @internal\n */\nexport function getHiddenProperty<Key extends keyof HiddenProperty>(\n    node: Node,\n    key: Key\n): HiddenProperty[Key] | undefined {\n    const nodeWithHiddenProperty = node as NodeWithHiddenProperty;\n    const hiddenProperty = nodeWithHiddenProperty.__roosterjsHiddenProperty;\n\n    return hiddenProperty ? hiddenProperty[key] : undefined;\n}\n\n/**\n * @internal\n */\nexport function setHiddenProperty<Key extends keyof HiddenProperty>(\n    node: Node,\n    key: Key,\n    value: HiddenProperty[Key]\n) {\n    const nodeWithHiddenProperty = node as NodeWithHiddenProperty;\n    const hiddenProperty = nodeWithHiddenProperty.__roosterjsHiddenProperty || {};\n\n    hiddenProperty[key] = value;\n    nodeWithHiddenProperty.__roosterjsHiddenProperty = hiddenProperty;\n}\n","import { getHiddenProperty, setHiddenProperty } from './hiddenProperty';\n\n/**\n * Get image state from element. This is used to store a image state.\n */\nexport function getImageState(element: HTMLElement): string | undefined {\n    return getHiddenProperty(element, 'imageState');\n}\n\n/**\n * Set image state to element. This is used to store a image state.\n */\nexport function setImageState(element: HTMLElement, marker: string): void {\n    setHiddenProperty(element, 'imageState', marker);\n}\n","import { getHiddenProperty, setHiddenProperty } from './hiddenProperty';\n\n/**\n * Get paragraph marker from element. This is used to mark the end of a paragraph in a block element.\n */\nexport function getParagraphMarker(element: HTMLElement): string | undefined {\n    return getHiddenProperty(element, 'paragraphMarker');\n}\n\n/**\n * Set paragraph marker to element. This is used to mark the end of a paragraph in a block element.\n */\nexport function setParagraphMarker(element: HTMLElement, marker: string): void {\n    setHiddenProperty(element, 'paragraphMarker', marker);\n}\n","import { getHiddenProperty, setHiddenProperty } from './hiddenProperty';\nimport type { HiddenProperty } from './hiddenProperty';\n\nconst UndeletableLinkKey: keyof HiddenProperty = 'undeletable';\n\n/**\n * Set a hidden property on a link element to indicate whether it is undeletable or not.\n * This is used to prevent the link from being deleted when the user tries to delete it.\n * @param a The link element to set the property on\n * @param undeletable Whether the link is undeletable or not\n */\nexport function setLinkUndeletable(a: HTMLAnchorElement, undeletable: boolean) {\n    setHiddenProperty(a, UndeletableLinkKey, undeletable);\n}\n\n/**\n * Check if a link element is undeletable or not.\n * This is used to determine if the link can be deleted when the user tries to delete it.\n * @param a The link element to check\n * @returns True if the link is undeletable, false otherwise\n */\nexport function isLinkUndeletable(a: HTMLAnchorElement): boolean {\n    return !!getHiddenProperty(a, UndeletableLinkKey);\n}\n","/**\n * Check if the given element is of the type that we are checking according to its tag name\n * @param element The element to check\n * @param tag The HTML tag name to check\n * @returns True if the element has the given tag, otherwise false\n */\nexport function isElementOfType<Tag extends keyof HTMLElementTagNameMap>(\n    element: HTMLElement,\n    tag: Tag\n): element is HTMLElementTagNameMap[Tag] {\n    return element?.tagName?.toLocaleLowerCase() == tag;\n}\n","// List of elements that have generic roles by default\nconst genericRoleElements = new Set([\n    'div',\n    'span',\n    'p',\n    'section',\n    'article',\n    'aside',\n    'header',\n    'footer',\n    'main',\n    'nav',\n    'address',\n    'blockquote',\n    'pre',\n    'figure',\n    'figcaption',\n    'hgroup',\n]);\n\n/**\n * @internal\n */\nexport function isGenericRoleElement(element: Element | null): element is Element {\n    if (!element) {\n        return false;\n    }\n\n    const tagName = element.tagName.toLowerCase();\n\n    return genericRoleElements.has(tagName);\n}\n","import type { NodeTypeMap } from 'roosterjs-content-model-types';\n\n/**\n * Type checker for Node. Return true if it of the specified node type\n * @param node The node to check\n * @param expectedType The type to check\n */\nexport function isNodeOfType<T extends keyof NodeTypeMap>(\n    node: Node | null | undefined,\n    expectedType: T\n): node is NodeTypeMap[T] {\n    return !!node && node.nodeType == Node[expectedType];\n}\n","// According to https://developer.mozilla.org/en-US/docs/Web/CSS/white-space, these style values will need to preserve white spaces\nconst WHITESPACE_PRE_VALUES = ['pre', 'pre-wrap', 'break-spaces'];\n\n/**\n * Check if the given white-space style value will cause preserving white space\n * @param whiteSpace The white-space style value to check\n */\nexport function isWhiteSpacePreserved(whiteSpace: string | undefined): boolean {\n    return !!whiteSpace && WHITESPACE_PRE_VALUES.indexOf(whiteSpace) >= 0;\n}\n","/**\n * Replace all child nodes of the given target node to the child nodes of source node.\n * @param target Target node, all child nodes of this node will be removed if keepExistingChildren is not set to true\n * @param source (Optional) source node, all child nodes of this node will be move to target node\n * @param keepExistingChildren (Optional) When set to true, all existing child nodes of target will be kept\n */\nexport function moveChildNodes(target: Node, source?: Node, keepExistingChildren?: boolean) {\n    if (!target) {\n        return;\n    }\n\n    while (!keepExistingChildren && target.firstChild) {\n        target.removeChild(target.firstChild);\n    }\n\n    while (source?.firstChild) {\n        target.appendChild(source.firstChild);\n    }\n}\n\n/**\n * Wrap all child nodes of the given parent element using a new element with the given tag name\n * @param parent The parent element\n * @param tagName The tag name of new wrapper\n * @returns New wrapper element\n */\nexport function wrapAllChildNodes<T extends keyof HTMLElementTagNameMap>(\n    parent: HTMLElement,\n    tagName: T\n): HTMLElementTagNameMap[T] {\n    const newElement = parent.ownerDocument.createElement(tagName);\n\n    moveChildNodes(newElement, parent);\n    parent.appendChild(newElement);\n\n    return newElement;\n}\n","import type { Rect } from 'roosterjs-content-model-types';\n\n/**\n * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\n * We validate that and only return a rect when the passed in ClientRect is valid\n * @param clientRect Client rect object normally retrieved from getBoundingClientRect function\n */\nexport function normalizeRect(clientRect: DOMRect): Rect | null {\n    const { left, right, top, bottom } =\n        clientRect || <DOMRect>{ left: 0, right: 0, top: 0, bottom: 0 };\n    return left === 0 && right === 0 && top === 0 && bottom === 0\n        ? null\n        : {\n              left: Math.round(left),\n              right: Math.round(right),\n              top: Math.round(top),\n              bottom: Math.round(bottom),\n          };\n}\n","/**\n * Read a file object and invoke a callback function with the data url of this file\n * @param file The file to read\n * @param callback the callback to invoke with data url of the file.\n * If fail to read, dataUrl will be null\n */\nexport function readFile(file: File, callback: (dataUrl: string | null) => void) {\n    try {\n        if (file) {\n            const reader = new FileReader();\n            reader.onload = () => {\n                callback(reader.result as string);\n            };\n            reader.onerror = () => {\n                callback(null);\n            };\n            reader.readAsDataURL(file);\n        }\n    } catch {\n        callback(null);\n    }\n}\n","import { toArray } from './toArray';\n\n/**\n * Retrieves metadata from the given document, including HTML attributes and meta tags.\n * @param doc The document from which to retrieve metadata.\n * @returns A record containing metadata key-value pairs.\n */\nexport function retrieveDocumentMetadata(doc: Document): Record<string, string> {\n    const result: Record<string, string> = {};\n    const attributes = doc.querySelector('html')?.attributes;\n\n    (attributes ? toArray(attributes) : []).forEach(attr => {\n        result[attr.name] = attr.value;\n    });\n\n    toArray(doc.querySelectorAll('meta')).forEach(meta => {\n        result[meta.name] = meta.content;\n    });\n\n    return result;\n}\n","import { isEntityElement } from './entityUtils';\nimport { isNodeOfType } from './isNodeOfType';\nimport type { RewriteFromModel } from 'roosterjs-content-model-types';\n\n/**\n * When set a DOM tree into editor, reuse the existing element in editor and no need to change it\n * @param parent Parent node of the reused element\n * @param element The element to keep in parent node\n * @param refNode Reference node, it is point to current node that is being processed. It must be a child of parent node, or null.\n * We will start processing from this node, if it is not the same with element, remove it and keep processing its next sibling,\n * until we see an element that is the same with the passed in element or null.\n * @returns The new reference element\n */\nexport function reuseCachedElement(\n    parent: Node,\n    element: Node,\n    refNode: Node | null,\n    context?: RewriteFromModel\n): Node | null {\n    if (element.parentNode == parent) {\n        const isEntity = isEntityElement(element);\n\n        // Remove nodes before the one we are hitting since they don't appear in Content Model at this position.\n        // But we don't want to touch entity since it would better to keep entity at its place unless it is removed\n        // In that case we will remove it after we have handled all other nodes\n        while (refNode && refNode != element && (isEntity || !isEntityElement(refNode))) {\n            const next = refNode.nextSibling;\n\n            refNode.parentNode?.removeChild(refNode);\n\n            if (isNodeOfType(refNode, 'ELEMENT_NODE')) {\n                context?.removedBlockElements.push(refNode);\n            }\n\n            refNode = next;\n        }\n\n        if (refNode && refNode == element) {\n            refNode = refNode.nextSibling;\n        } else {\n            parent.insertBefore(element, refNode);\n        }\n    } else {\n        parent.insertBefore(element, refNode);\n    }\n\n    return refNode;\n}\n","import type { DOMHelper, Rect } from 'roosterjs-content-model-types';\n\n/**\n * Scroll a given rectangle into view within a scroll container\n * @param scrollContainer The container to scroll\n * @param visibleRect The currently visible rectangle within the scroll container\n * @param domHelper The DOM helper of the editor\n * @param targetRect The target rectangle to scroll into view\n * @param scrollMargin Optional margin to apply when scrolling\n * @param preferTop Optional flag to indicate whether to prefer aligning the top or bottom of the target rect when the target rect is higher than visible rect @default false\n */\nexport function scrollRectIntoView(\n    scrollContainer: HTMLElement,\n    visibleRect: Rect,\n    domHelper: DOMHelper,\n    targetRect: Rect,\n    scrollMargin: number = 0,\n    preferTop: boolean = false\n) {\n    let zoomScale: number | undefined;\n    let margin = 0;\n\n    if (scrollMargin != 0) {\n        zoomScale = getZoomScale(domHelper, zoomScale);\n\n        margin = Math.max(\n            0,\n            Math.min(\n                scrollMargin * zoomScale,\n                (visibleRect.bottom - visibleRect.top - targetRect.bottom + targetRect.top) / 2\n            )\n        );\n    }\n\n    const top = targetRect.top - margin;\n    const bottom = targetRect.bottom + margin;\n    const height = bottom - top;\n\n    // Define scroll operations\n    const scrollUp = () => {\n        zoomScale = getZoomScale(domHelper, zoomScale);\n        scrollContainer.scrollTop -= (visibleRect.top - top) / zoomScale;\n    };\n\n    const scrollDown = () => {\n        zoomScale = getZoomScale(domHelper, zoomScale);\n        scrollContainer.scrollTop += (bottom - visibleRect.bottom) / zoomScale;\n    };\n\n    // Determine which operations to perform and in what order\n    const needsScrollUp = top < visibleRect.top;\n    const needsScrollDown = bottom > visibleRect.bottom;\n\n    if (height > visibleRect.bottom - visibleRect.top) {\n        // If the target rect is larger than visible rect, only perform one scroll operation\n        if (preferTop) {\n            scrollUp();\n        } else {\n            scrollDown();\n        }\n    } else if (preferTop) {\n        if (needsScrollUp) {\n            scrollUp();\n        } else if (needsScrollDown) {\n            scrollDown();\n        }\n    } else {\n        if (needsScrollDown) {\n            scrollDown();\n        } else if (needsScrollUp) {\n            scrollUp();\n        }\n    }\n}\n\n// domHelper.calculateZoomScale() may be an expensive call, so we cache the value during a single operation\nfunction getZoomScale(domHelper: DOMHelper, knownZoomScale: number | undefined): number {\n    if (knownZoomScale === undefined) {\n        return domHelper.calculateZoomScale();\n    } else {\n        return knownZoomScale;\n    }\n}\n","import { isNodeOfType } from '../isNodeOfType';\nimport { normalizeRect } from '../normalizeRect';\nimport type { DOMInsertPoint, Rect } from 'roosterjs-content-model-types';\n\n/**\n * Get bounding rect of the given DOM insert point\n * @param doc The document object\n * @param pos The input DOM insert point\n */\nexport function getDOMInsertPointRect(doc: Document, pos: DOMInsertPoint): Rect | null {\n    const range = doc.createRange();\n\n    return (\n        tryGetRectFromPos(pos, range) ?? // 1. try get from the pos directly using getBoundingClientRect or getClientRects\n        tryGetRectFromPos((pos = normalizeInsertPoint(pos)), range) ?? // 2. try get normalized pos, this can work when insert point is inside text node\n        tryGetRectFromNode(pos.node) // 3. fallback to node rect using getBoundingClientRect\n    );\n}\n\nfunction normalizeInsertPoint(pos: DOMInsertPoint) {\n    let { node, offset } = pos;\n\n    while (node.lastChild) {\n        if (offset == node.childNodes.length) {\n            node = node.lastChild;\n            offset = node.childNodes.length;\n        } else {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n    }\n\n    return { node, offset };\n}\n\nfunction tryGetRectFromPos(pos: DOMInsertPoint, range: Range): Rect | null {\n    const { node, offset } = pos;\n\n    range.setStart(node, offset);\n    range.setEnd(node, offset);\n\n    const rect = normalizeRect(range.getBoundingClientRect());\n\n    if (rect) {\n        return rect;\n    } else {\n        const rects = range.getClientRects && range.getClientRects();\n\n        return rects && rects.length == 1 ? normalizeRect(rects[0]) : null;\n    }\n}\n\nfunction tryGetRectFromNode(node: Node) {\n    return isNodeOfType(node, 'ELEMENT_NODE') && node.getBoundingClientRect\n        ? normalizeRect(node.getBoundingClientRect())\n        : null;\n}\n","import type { DOMSelection } from 'roosterjs-content-model-types';\n\n/**\n * Get root node of a given DOM selection\n * For table selection, root node is the selected table\n * For image selection, root node is the selected image\n * For range selection, root node is the common ancestor container node of the selection range\n * @param selection The selection to get root node from\n */\nexport function getSelectionRootNode(selection: DOMSelection | undefined): Node | undefined {\n    return !selection\n        ? undefined\n        : selection.type == 'range'\n        ? selection.range.commonAncestorContainer\n        : selection.type == 'table'\n        ? selection.table\n        : selection.type == 'image'\n        ? selection.image\n        : undefined;\n}\n","const SPACES_REGEX = /[\\u2000\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\s\\t\\r\\n]/gm;\nconst PUNCTUATIONS = '.,?!:\"()[]\\\\/';\n\n/**\n * Check if the given character is punctuation\n * @param char The character to check\n */\nexport function isPunctuation(char: string) {\n    return PUNCTUATIONS.indexOf(char) >= 0;\n}\n\n/**\n * Check if the give character is a space. A space can be normal ASCII pace (32) or non-break space (160) or other kinds of spaces\n * such as ZeroWidthSpace, ...\n * @param char The character to check\n */\nexport function isSpace(char: string) {\n    const code = char?.charCodeAt(0) ?? 0;\n    return code == 160 || code == 32 || SPACES_REGEX.test(char);\n}\n\n/**\n * Normalize spaces of the given string. After normalization, all leading (for forward) or trailing (for backward) spaces\n * will be replaces with non-break space (160)\n * @param txt The string to normalize\n * @param isForward Whether normalize forward or backward\n */\nexport function normalizeText(txt: string, isForward: boolean): string {\n    return txt.replace(isForward ? /^\\u0020+/ : /\\u0020+$/, '\\u00A0');\n}\n","import type { Border } from 'roosterjs-content-model-types';\n\nconst BorderStyles = [\n    'none',\n    'hidden',\n    'dotted',\n    'dashed',\n    'solid',\n    'double',\n    'groove',\n    'ridge',\n    'inset',\n    'outset',\n];\nconst BorderSizeRegex = /^(thin|medium|thick|[\\d\\.]+\\w*)$/;\n\n/**\n * Extract an integrated border string with border width, style, color to value tuple\n * @param combinedBorder The integrated border style string\n * @returns An array with the splitted values\n */\nexport function extractBorderValues(combinedBorder?: string): Border {\n    const result: Border = {};\n    const values = (combinedBorder || '').replace(/, /g, ',').split(' ');\n\n    values.forEach(v => {\n        if (BorderStyles.indexOf(v) >= 0 && !result.style) {\n            result.style = v;\n        } else if (BorderSizeRegex.test(v) && !result.width) {\n            result.width = v;\n        } else if (v && !result.color) {\n            result.color = v;\n        }\n    });\n\n    return result;\n}\n\n/**\n * Combine border value array back to string\n * @param values Input string values\n * @param initialValue Initial value for those items without valid value\n */\nexport function combineBorderValue(value: Border): string {\n    return [value.width || '', value.style || '', value.color || ''].join(' ').trim() || 'none';\n}\n","/**\n * Check if the given bold style represents a bold style\n * @param boldStyle The style to check\n */\nexport function isBold(boldStyle?: string): boolean {\n    return (\n        !!boldStyle && (boldStyle == 'bold' || boldStyle == 'bolder' || parseInt(boldStyle) >= 600)\n    );\n}\n","/**\n * Normalize font family string to a standard format\n * Add quotes around font family names that contain non-alphanumeric/dash characters\n * @param fontFamily The font family string to normalize\n * @returns The normalized font family string\n */\nexport function normalizeFontFamily(fontFamily: string): string {\n    const existingQuotedFontsRegex = /(\".*?\")|('.*?')/g;\n    let match = existingQuotedFontsRegex.exec(fontFamily);\n    let start = 0;\n    const result: string[] = [];\n\n    while (match) {\n        process(fontFamily, result, start, match.index);\n\n        start = match.index + match[0].length;\n        result.push(match[0]);\n\n        match = existingQuotedFontsRegex.exec(fontFamily);\n    }\n\n    process(fontFamily, result, start, fontFamily.length);\n\n    return result.join(', ');\n}\n\nfunction process(fontFamily: string, result: string[], start: number, end: number) {\n    const families = fontFamily.substring(start, end).split(',');\n\n    families.forEach(family => {\n        family = family.trim();\n\n        if (family) {\n            // Check if the family name contains non-alphanumeric characters\n            if (/[^a-zA-Z0-9\\-]/.test(family)) {\n                result.push(`\"${family}\"`);\n            } else {\n                result.push(family);\n            }\n        }\n    });\n}\n","import { BorderColorKeyMap, BorderKeys } from '../../formatHandlers/utils/borderKeys';\nimport { isElementOfType } from '../isElementOfType';\nimport {\n    adaptColor,\n    getColor,\n    getLightModeColor,\n    setColor,\n} from '../../formatHandlers/utils/color';\nimport type { DarkColorHandler } from 'roosterjs-content-model-types';\n\n/**\n * Configuration options for controlling which elements and styles undergo color transformation.\n * By default, text and background colors are transformed for all elements.\n */\nexport interface TransformColorOptions {\n    tableBorders: boolean;\n}\n\n/**\n * Edit and transform color of elements between light mode and dark mode\n * By default, text and background colors are transformed for all elements.\n * @param rootNode The root DOM node to transform\n * @param includeSelf True to transform the root node as well, otherwise false\n * @param direction To specify the transform direction, light to dark, or dark to light\n * @param darkColorHandler The dark color handler object to help do color transformation\n * @param transformColorOptions Configuration options for controlling which elements and styles undergo color transformation.\n */\nexport function transformColor(\n    rootNode: Node,\n    includeSelf: boolean,\n    direction: 'lightToDark' | 'darkToLight',\n    darkColorHandler?: DarkColorHandler,\n    transformColorOptions?: TransformColorOptions\n) {\n    const toDarkMode = direction == 'lightToDark';\n    const tableBorders = transformColorOptions?.tableBorders || false;\n    const transformer = (element: HTMLElement) => {\n        const textColor = getColor(element, false /*isBackground*/, !toDarkMode, darkColorHandler);\n        const backColor = getColor(element, true /*isBackground*/, !toDarkMode, darkColorHandler);\n\n        setColor(element, textColor, false /*isBackground*/, toDarkMode, darkColorHandler);\n        setColor(element, backColor, true /*isBackground*/, toDarkMode, darkColorHandler);\n\n        if (tableBorders) {\n            transformBorderColor(element, toDarkMode, darkColorHandler);\n        }\n    };\n\n    iterateElements(rootNode, transformer, includeSelf);\n}\n\nfunction transformBorderColor(\n    element: HTMLElement,\n    toDarkMode: boolean,\n    darkColorHandler?: DarkColorHandler\n) {\n    if (isElementOfType(element, 'td') || isElementOfType(element, 'th')) {\n        BorderKeys.forEach(key => {\n            const borderColorProperty = BorderColorKeyMap[key];\n            const style = element.style.getPropertyValue(borderColorProperty);\n            if (style) {\n                const lightColor = getLightModeColor(style, !toDarkMode, darkColorHandler);\n                if (lightColor) {\n                    const transformedColor = adaptColor(\n                        element,\n                        lightColor,\n                        'border',\n                        toDarkMode,\n                        darkColorHandler\n                    );\n                    if (transformedColor) {\n                        element.style.setProperty(borderColorProperty, transformedColor);\n                    }\n                }\n            }\n        });\n    }\n}\n\nfunction iterateElements(\n    root: Node,\n    transformer: (element: HTMLElement) => void,\n    includeSelf?: boolean\n) {\n    if (includeSelf && isHTMLElement(root)) {\n        transformer(root);\n    }\n\n    for (let child = root.firstChild; child; child = child.nextSibling) {\n        if (isHTMLElement(child)) {\n            transformer(child);\n        }\n\n        iterateElements(child, transformer);\n    }\n}\n\n// This is not a strict check, we just need to make sure this element has style so that we can set style to it\n// We don't use safeInstanceOf() here since this function will be called very frequently when extract html content\n// in dark mode, so we need to make sure this check is fast enough\nfunction isHTMLElement(node: Node): node is HTMLElement {\n    const htmlElement = <HTMLElement>node;\n    return node.nodeType == Node.ELEMENT_NODE && !!htmlElement.style;\n}\n","import { toArray } from '../toArray';\nimport type { ParsedTable } from 'roosterjs-content-model-types';\n\n/**\n * Parse a table into a two dimensions array of TD elements. For those merged cells, the value will be null.\n * @param table Input HTML Table element\n * @returns Array of TD elements\n */\nexport function parseTableCells(table: HTMLTableElement): ParsedTable {\n    const trs = toArray(table.rows);\n    const cells: ParsedTable = trs.map(row => []);\n\n    trs.forEach((tr, rowIndex) => {\n        for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\n            // Skip the cells which already initialized\n            for (; cells[rowIndex][targetCol] !== undefined; targetCol++) {}\n\n            const td = tr.cells[sourceCol];\n\n            for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\n                for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\n                    if (cells[rowIndex + rowSpan]) {\n                        cells[rowIndex + rowSpan][targetCol] =\n                            colSpan == 0\n                                ? rowSpan == 0\n                                    ? td\n                                    : 'spanTop'\n                                : rowSpan == 0\n                                ? 'spanLeft'\n                                : 'spanBoth';\n                    }\n                }\n            }\n        }\n\n        for (let col = 0; col < cells[rowIndex].length; col++) {\n            cells[rowIndex][col] = cells[rowIndex][col] || null;\n        }\n    });\n\n    return cells;\n}\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport function toArray(collection: DataTransferItemList): DataTransferItem[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport function toArray<T>(array: readonly T[]): T[];\n\nexport function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","/**\n * Removes the node and keep all children in place, return the parentNode where the children are attached\n * @param node the node to remove\n */\nexport function unwrap(node: Node): Node | null {\n    // Unwrap requires a parentNode\n    const parentNode = node ? node.parentNode : null;\n\n    if (!parentNode) {\n        return null;\n    }\n\n    while (node.firstChild) {\n        parentNode.insertBefore(node.firstChild, node);\n    }\n\n    parentNode.removeChild(node);\n    return parentNode;\n}\n","/**\n * Wrap the given node with a new element, put the wrapper node under the parent of the first node\n * and return the wrapper element.\n * @param doc Parent document object\n * @param node The node to wrap\n * @param wrapperTag The tag of wrapper HTML element\n * @returns The wrapper element\n */\nexport function wrap<T extends keyof HTMLElementTagNameMap>(\n    doc: Document,\n    node: Node,\n    wrapperTag: T\n): HTMLElementTagNameMap[T] {\n    const wrapper = doc.createElement(wrapperTag);\n    node.parentNode?.insertBefore(wrapper, node);\n    wrapper.appendChild(node);\n\n    return wrapper;\n}\n","import { isElementOfType } from '../../domUtils/isElementOfType';\nimport type { DirectionFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const directionFormatHandler: FormatHandler<DirectionFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        const dir = element.style.direction || element.dir || defaultStyle.direction;\n\n        if (dir) {\n            format.direction = dir == 'rtl' ? 'rtl' : 'ltr';\n        }\n    },\n    apply: (format, element) => {\n        if (format.direction) {\n            element.style.direction = format.direction;\n        }\n\n        if (format.direction == 'rtl' && isElementOfType(element, 'table')) {\n            element.style.justifySelf = 'flex-end';\n        }\n    },\n};\n","import type { DisplayFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const displayFormatHandler: FormatHandler<DisplayFormat> = {\n    parse: (format, element) => {\n        const display = element.style.display;\n\n        if (display) {\n            format.display = display;\n        }\n    },\n    apply: (format, element) => {\n        if (format.display) {\n            element.style.display = format.display;\n        }\n    },\n};\n","import { calcAlign, ResultMap } from '../utils/dir';\nimport { directionFormatHandler } from './directionFormatHandler';\nimport type {\n    DirectionFormat,\n    HtmlAlignFormat,\n    TextAlignFormat,\n} from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const htmlAlignFormatHandler: FormatHandler<\n    DirectionFormat & HtmlAlignFormat & TextAlignFormat\n> = {\n    parse: (format, element, context, defaultStyle) => {\n        // When there is text-align in CSS style on the same element, we should ignore HTML align\n        if (!element.style.textAlign) {\n            directionFormatHandler.parse(format, element, context, defaultStyle);\n\n            const htmlAlign = element.getAttribute('align');\n\n            if (htmlAlign) {\n                format.htmlAlign = calcAlign(htmlAlign, format.direction);\n                delete format.textAlign;\n                delete context.blockFormat.textAlign;\n            }\n        }\n    },\n    apply: (format, element) => {\n        const dir: 'ltr' | 'rtl' = format.direction == 'rtl' ? 'rtl' : 'ltr';\n\n        if (format.htmlAlign) {\n            element.setAttribute('align', ResultMap[format.htmlAlign][dir]);\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { LineHeightFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const lineHeightFormatHandler: FormatHandler<LineHeightFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const lineHeight = element.style.lineHeight || defaultStyle.lineHeight;\n\n        if (lineHeight && lineHeight != 'inherit') {\n            format.lineHeight = lineHeight;\n        }\n    },\n    apply: (format, element) => {\n        if (format.lineHeight) {\n            element.style.lineHeight = format.lineHeight;\n        }\n    },\n};\n","import { parseValueWithUnit } from '../utils/parseValueWithUnit';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { DirectionFormat, MarginFormat } from 'roosterjs-content-model-types';\n\nconst MarginKeys: (keyof MarginFormat & keyof CSSStyleDeclaration)[] = [\n    'marginTop',\n    'marginRight',\n    'marginBottom',\n    'marginLeft',\n];\n\nconst DefaultMarginKey: Record<\n    'ltr' | 'rtl',\n    Partial<Record<keyof MarginFormat, keyof CSSStyleDeclaration>>\n> = {\n    ltr: {\n        marginRight: 'marginInlineEnd',\n        marginLeft: 'marginInlineStart',\n    },\n    rtl: {\n        marginRight: 'marginInlineStart',\n        marginLeft: 'marginInlineEnd',\n    },\n};\n\nconst LTR: Record<keyof MarginFormat, keyof MarginFormat> = {\n    marginLeft: 'marginRight',\n    marginRight: 'marginLeft',\n    marginTop: 'marginTop',\n    marginBottom: 'marginBottom',\n};\n\n/**\n * @internal\n */\nexport const marginFormatHandler: FormatHandler<MarginFormat & DirectionFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        MarginKeys.forEach(key => {\n            const alternativeKey = DefaultMarginKey[format.direction ?? 'ltr'][key];\n            const value: string | undefined =\n                element.style[key] ||\n                defaultStyle[key] ||\n                (alternativeKey ? defaultStyle[alternativeKey]?.toString() : '');\n\n            if (value) {\n                switch (key) {\n                    case 'marginTop':\n                    case 'marginBottom':\n                        format[key] = value;\n                        break;\n\n                    case 'marginLeft':\n                    case 'marginRight':\n                        format[key] = format[key]\n                            ? parseValueWithUnit(format[key] || '', element) +\n                              parseValueWithUnit(value, element) +\n                              'px'\n                            : value;\n                        break;\n                }\n            }\n        });\n    },\n    apply: (format, element, context) => {\n        MarginKeys.forEach(key => {\n            const value = format[key];\n            const ltrKey = format.direction == 'rtl' ? LTR[key] : key;\n\n            if (value != context.implicitFormat[ltrKey]) {\n                element.style[key] = value || '0';\n            }\n        });\n    },\n};\n","import { directionFormatHandler } from './directionFormatHandler';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { DirectionFormat, PaddingFormat } from 'roosterjs-content-model-types';\n\nconst PaddingKeys: (keyof PaddingFormat & keyof CSSStyleDeclaration)[] = [\n    'paddingTop',\n    'paddingRight',\n    'paddingBottom',\n    'paddingLeft',\n];\n\nconst AlternativeKeyLtr: Partial<Record<\n    keyof PaddingFormat,\n    keyof CSSStyleDeclaration | undefined\n>> = {\n    paddingLeft: 'paddingInlineStart',\n};\n\nconst AlternativeKeyRtl: Partial<Record<\n    keyof PaddingFormat,\n    keyof CSSStyleDeclaration | undefined\n>> = {\n    paddingRight: 'paddingInlineStart',\n};\n\n/**\n * @internal\n */\nexport const paddingFormatHandler: FormatHandler<PaddingFormat & DirectionFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        directionFormatHandler.parse(format, element, context, defaultStyle);\n\n        PaddingKeys.forEach(key => {\n            let value = element.style[key];\n            const alterativeKey = (format.direction == 'rtl'\n                ? AlternativeKeyRtl\n                : AlternativeKeyLtr)[key];\n            const defaultValue: string =\n                (defaultStyle[key] ??\n                    (alterativeKey ? defaultStyle[alterativeKey] : undefined) ??\n                    '0px') + '';\n\n            if (!value) {\n                value = defaultValue;\n            }\n\n            if (!value || value == '0') {\n                value = '0px';\n            }\n\n            if (value && value != defaultValue) {\n                format[key] = value;\n            }\n        });\n    },\n    apply: (format, element, context) => {\n        PaddingKeys.forEach(key => {\n            const value = format[key];\n            let defaultValue: string | undefined = undefined;\n\n            if (element.tagName == 'OL' || element.tagName == 'UL') {\n                if (\n                    (format.direction == 'rtl' && key == 'paddingRight') ||\n                    (format.direction != 'rtl' && key == 'paddingLeft')\n                ) {\n                    defaultValue = '40px';\n                }\n            }\n\n            if (value && value != defaultValue) {\n                element.style[key] = value;\n            }\n        });\n    },\n};\n","import { calcAlign, ResultMap } from '../utils/dir';\nimport { directionFormatHandler } from './directionFormatHandler';\nimport type { DirectionFormat, TextAlignFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const textAlignFormatHandler: FormatHandler<DirectionFormat & TextAlignFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        directionFormatHandler.parse(format, element, context, defaultStyle);\n\n        const textAlign = element.style.textAlign || defaultStyle.textAlign;\n\n        if (textAlign && element.parentElement?.style.display !== 'flex') {\n            format.textAlign = calcAlign(textAlign, format.direction);\n        }\n    },\n    apply: (format, element) => {\n        const dir: 'ltr' | 'rtl' = format.direction == 'rtl' ? 'rtl' : 'ltr';\n\n        if (format.textAlign) {\n            element.style.textAlign = ResultMap[format.textAlign][dir];\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { TextIndentFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const textIndentFormatHandler: FormatHandler<TextIndentFormat> = {\n    parse: (format, element) => {\n        const textIndent = element.style.textIndent;\n\n        if (textIndent) {\n            format.textIndent = textIndent;\n        }\n    },\n    apply: (format, element) => {\n        if (format.textIndent) {\n            element.style.textIndent = format.textIndent;\n        }\n    },\n};\n","import { shouldSetValue } from '../utils/shouldSetValue';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { WhiteSpaceFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const whiteSpaceFormatHandler: FormatHandler<WhiteSpaceFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        const whiteSpace = element.style.whiteSpace || defaultStyle.whiteSpace;\n\n        if (shouldSetValue(whiteSpace, 'normal', format.whiteSpace, defaultStyle.whiteSpace)) {\n            format.whiteSpace = whiteSpace;\n        }\n    },\n    apply: (format, element, context) => {\n        const whiteSpace = context.implicitFormat.whiteSpace;\n        if (format.whiteSpace != whiteSpace) {\n            element.style.whiteSpace = format.whiteSpace || 'normal';\n        }\n    },\n};\n","import type { AriaFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const ariaFormatHandler: FormatHandler<AriaFormat> = {\n    parse: (format, element) => {\n        const ariaDescribedBy = element.getAttribute('aria-describedby');\n        const title = element.getAttribute('title');\n        if (ariaDescribedBy) {\n            format.ariaDescribedBy = ariaDescribedBy;\n        }\n        if (title) {\n            format.title = title;\n        }\n    },\n    apply: (format, element) => {\n        if (format.ariaDescribedBy) {\n            element.setAttribute('aria-describedby', format.ariaDescribedBy);\n        }\n        if (format.title) {\n            element.setAttribute('title', format.title);\n        }\n    },\n};\n","import { getColor, setColor } from '../utils/color';\nimport { shouldSetValue } from '../utils/shouldSetValue';\nimport type { BackgroundColorFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const backgroundColorFormatHandler: FormatHandler<BackgroundColorFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const backgroundColor =\n            getColor(\n                element,\n                true /*isBackground*/,\n                !!context.isDarkMode,\n                context.darkColorHandler\n            ) || defaultStyle.backgroundColor;\n\n        if (\n            shouldSetValue(\n                backgroundColor,\n                'transparent',\n                undefined /*existingValue*/,\n                defaultStyle.backgroundColor\n            )\n        ) {\n            format.backgroundColor = backgroundColor;\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.backgroundColor) {\n            setColor(\n                element,\n                format.backgroundColor,\n                true /*isBackground*/,\n                !!context.isDarkMode,\n                context.darkColorHandler\n            );\n        }\n    },\n};\n","import type { BorderBoxFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const borderBoxFormatHandler: FormatHandler<BorderBoxFormat> = {\n    parse: (format, element) => {\n        if (element.style?.boxSizing == 'border-box') {\n            format.useBorderBox = true;\n        }\n    },\n    apply: (format, element) => {\n        if (format.useBorderBox) {\n            element.style.boxSizing = 'border-box';\n        }\n    },\n};\n","import { adaptColor, getLightModeColor, retrieveElementColor } from '../utils/color';\nimport { BorderColorKeyMap, BorderKeys } from '../utils/borderKeys';\nimport { combineBorderValue, extractBorderValues } from '../../domUtils/style/borderValues';\nimport type { BorderFormat, BorderKey } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * Keys of border width\n */\nconst BorderWidthKeyMap: {\n    [key in BorderKey]: string;\n} = {\n    borderTop: 'border-top-width',\n    borderRight: 'border-right-width',\n    borderBottom: 'border-bottom-width',\n    borderLeft: 'border-left-width',\n};\n\n/**\n * Keys of border styles\n */\nconst BorderStyleKeyMap: {\n    [key in BorderKey]: string;\n} = {\n    borderTop: 'border-top-style',\n    borderRight: 'border-right-style',\n    borderBottom: 'border-bottom-style',\n    borderLeft: 'border-left-style',\n};\n\n/**\n * @internal\n */\nexport const borderColorFormatHandler: FormatHandler<BorderFormat> = {\n    parse: (format, element, context) => {\n        if (\n            context.experimentalFeatures &&\n            context.experimentalFeatures.indexOf('TransformTableBorderColors') > -1\n        ) {\n            BorderKeys.forEach(key => {\n                const width = element.style.getPropertyValue(BorderWidthKeyMap[key]);\n                const style = element.style.getPropertyValue(BorderStyleKeyMap[key]);\n                const borderColor = retrieveElementColor(element, key);\n\n                if (borderColor) {\n                    const lightModeColor = getLightModeColor(\n                        borderColor,\n                        !!context.isDarkMode,\n                        context.darkColorHandler\n                    );\n\n                    format[key] = combineBorderValue({\n                        width,\n                        style,\n                        color: lightModeColor,\n                    });\n                }\n            });\n        }\n    },\n    apply: (format, element, context) => {\n        if (\n            context.experimentalFeatures &&\n            context.experimentalFeatures.indexOf('TransformTableBorderColors') > -1\n        ) {\n            BorderKeys.forEach(key => {\n                const value = format[key];\n                if (value) {\n                    const borderValues = extractBorderValues(value);\n                    if (borderValues.color) {\n                        const transformedColor = adaptColor(\n                            element,\n                            borderValues.color,\n                            'border',\n                            !!context.isDarkMode,\n                            context.darkColorHandler\n                        );\n                        if (transformedColor) {\n                            const borderColorProperty = BorderColorKeyMap[key];\n                            element.style.setProperty(borderColorProperty, transformedColor);\n                        }\n                    }\n                }\n            });\n        }\n    },\n};\n","import { BorderKeys } from '../utils/borderKeys';\nimport type { BorderFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n// This array needs to match BorderKeys array\nconst BorderWidthKeys: (keyof CSSStyleDeclaration)[] = [\n    'borderTopWidth',\n    'borderRightWidth',\n    'borderBottomWidth',\n    'borderLeftWidth',\n];\n\nconst BorderRadiusKeys: (keyof BorderFormat & keyof CSSStyleDeclaration)[] = [\n    'borderTopLeftRadius',\n    'borderTopRightRadius',\n    'borderBottomLeftRadius',\n    'borderBottomRightRadius',\n];\n\nconst AllKeys = [...BorderKeys, ...BorderRadiusKeys];\n\n/**\n * @internal\n */\nexport const borderFormatHandler: FormatHandler<BorderFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        BorderKeys.forEach((key, i) => {\n            const value = element.style[key];\n            const defaultWidth = defaultStyle[BorderWidthKeys[i]] ?? '0px';\n            let width = element.style[BorderWidthKeys[i]];\n\n            if (width == '0') {\n                width = '0px';\n            }\n\n            if (value && width != defaultWidth) {\n                format[key] = value == 'none' ? '' : value;\n            }\n        });\n\n        const borderRadius = element.style.borderRadius;\n\n        if (borderRadius) {\n            format.borderRadius = borderRadius;\n        } else {\n            BorderRadiusKeys.forEach(key => {\n                const value = element.style[key];\n\n                if (value) {\n                    format[key] = value;\n                }\n            });\n        }\n    },\n    apply: (format, element) => {\n        AllKeys.forEach(key => {\n            const value = format[key];\n\n            if (value) {\n                element.style[key] = value;\n            }\n        });\n\n        if (format.borderRadius) {\n            element.style.borderRadius = format.borderRadius;\n        }\n    },\n};\n","import type { BoxShadowFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const boxShadowFormatHandler: FormatHandler<BoxShadowFormat> = {\n    parse: (format, element) => {\n        if (element.style?.boxShadow) {\n            format.boxShadow = element.style.boxShadow;\n        }\n    },\n    apply: (format, element) => {\n        if (format.boxShadow) {\n            element.style.boxShadow = format.boxShadow;\n        }\n    },\n};\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport type { DatasetFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const datasetFormatHandler: FormatHandler<DatasetFormat> = {\n    parse: (format, element) => {\n        const dataset = element.dataset;\n\n        getObjectKeys(dataset).forEach(key => {\n            format[key] = dataset[key] || '';\n        });\n    },\n\n    apply: (format, element) => {\n        getObjectKeys(format).forEach(key => {\n            element.dataset[key] = format[key];\n        });\n    },\n};\n","import type { FloatFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const floatFormatHandler: FormatHandler<FloatFormat> = {\n    parse: (format, element) => {\n        const float = element.style.float || element.getAttribute('align');\n\n        if (float) {\n            format.float = float;\n        }\n    },\n    apply: (format, element) => {\n        if (format.float) {\n            element.style.float = format.float;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { IdFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const idFormatHandler: FormatHandler<IdFormat> = {\n    parse: (format, element) => {\n        if (element.id) {\n            format.id = element.id;\n        }\n    },\n    apply: (format, element) => {\n        if (format.id) {\n            element.id = format.id;\n        }\n    },\n};\n","import type { RoleFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const roleFormatHandler: FormatHandler<RoleFormat> = {\n    parse: (format, element) => {\n        const role = element.getAttribute('role');\n\n        if (role) {\n            format.role = role;\n        }\n    },\n    apply: (format, element) => {\n        if (format.role) {\n            element.setAttribute('role', format.role);\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { SizeFormat } from 'roosterjs-content-model-types';\n\nconst PercentageRegex = /[\\d\\.]+%/;\n\n/**\n * @internal\n */\nexport const sizeFormatHandler: FormatHandler<SizeFormat> = {\n    parse: (format, element, context) => {\n        const width = element.style.width || tryParseSize(element, 'width');\n        const height = element.style.height || tryParseSize(element, 'height');\n        const maxWidth = element.style.maxWidth;\n        const maxHeight = element.style.maxHeight;\n        const minWidth = element.style.minWidth;\n        const minHeight = element.style.minHeight;\n\n        if (width) {\n            format.width = width;\n        }\n        if (height) {\n            format.height = height;\n        }\n        if (maxWidth) {\n            format.maxWidth = maxWidth;\n        }\n        if (maxHeight) {\n            format.maxHeight = maxHeight;\n        }\n        if (minWidth) {\n            format.minWidth = minWidth;\n        }\n        if (minHeight) {\n            format.minHeight = minHeight;\n        }\n    },\n    apply: (format, element) => {\n        if (format.width) {\n            element.style.width = format.width;\n        }\n        if (format.height) {\n            element.style.height = format.height;\n        }\n        if (format.maxWidth) {\n            element.style.maxWidth = format.maxWidth;\n        }\n        if (format.maxHeight) {\n            element.style.maxHeight = format.maxHeight;\n        }\n        if (format.minWidth) {\n            element.style.minWidth = format.minWidth;\n        }\n        if (format.minHeight) {\n            element.style.minHeight = format.minHeight;\n        }\n    },\n};\n\nfunction tryParseSize(element: HTMLElement, attrName: 'width' | 'height'): string | undefined {\n    const attrValue = element.getAttribute(attrName);\n    const value = parseInt(attrValue || '');\n\n    return attrValue && PercentageRegex.test(attrValue)\n        ? attrValue\n        : Number.isNaN(value) || value == 0\n        ? undefined\n        : value + 'px';\n}\n","import type { FormatHandler } from '../FormatHandler';\nimport type { VerticalAlignFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const verticalAlignFormatHandler: FormatHandler<VerticalAlignFormat> = {\n    parse: (format, element) => {\n        const align = element.style.verticalAlign || element.getAttribute('valign');\n\n        switch (align) {\n            case 'baseline':\n            case 'initial':\n            case 'super':\n            case 'sub':\n            case 'text-top':\n            case 'text-bottom':\n            case 'top':\n                format.verticalAlign = 'top';\n                break;\n\n            case 'bottom':\n                format.verticalAlign = 'bottom';\n                break;\n\n            case 'middle':\n                format.verticalAlign = 'middle';\n                break;\n        }\n    },\n    apply: (format, element) => {\n        if (format.verticalAlign) {\n            element.style.verticalAlign = format.verticalAlign;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { WordBreakFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const wordBreakFormatHandler: FormatHandler<WordBreakFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        const wordBreak = element.style.wordBreak || defaultStyle.wordBreak;\n\n        if (wordBreak) {\n            format.wordBreak = wordBreak;\n        }\n    },\n    apply: (format, element) => {\n        if (format.wordBreak) {\n            element.style.wordBreak = format.wordBreak;\n        }\n    },\n};\n","import { ariaFormatHandler } from './common/ariaFormatHandler';\nimport { backgroundColorFormatHandler } from './common/backgroundColorFormatHandler';\nimport { boldFormatHandler } from './segment/boldFormatHandler';\nimport { borderBoxFormatHandler } from './common/borderBoxFormatHandler';\nimport { borderColorFormatHandler } from './common/borderColorFormatHandler';\nimport { borderFormatHandler } from './common/borderFormatHandler';\nimport { boxShadowFormatHandler } from './common/boxShadowFormatHandler';\nimport { datasetFormatHandler } from './common/datasetFormatHandler';\nimport { directionFormatHandler } from './block/directionFormatHandler';\nimport { displayFormatHandler } from './block/displayFormatHandler';\nimport { entityFormatHandler } from './entity/entityFormatHandler';\nimport { floatFormatHandler } from './common/floatFormatHandler';\nimport { fontFamilyFormatHandler } from './segment/fontFamilyFormatHandler';\nimport { fontSizeFormatHandler } from './segment/fontSizeFormatHandler';\nimport { getObjectKeys } from '../domUtils/getObjectKeys';\nimport { htmlAlignFormatHandler } from './block/htmlAlignFormatHandler';\nimport { idFormatHandler } from './common/idFormatHandler';\nimport { imageStateFormatHandler } from './segment/imageStateFormatHandler';\nimport { italicFormatHandler } from './segment/italicFormatHandler';\nimport { legacyTableBorderFormatHandler } from './table/legacyTableBorderFormatHandler';\nimport { letterSpacingFormatHandler } from './segment/letterSpacingFormatHandler';\nimport { lineHeightFormatHandler } from './block/lineHeightFormatHandler';\nimport { linkFormatHandler } from './segment/linkFormatHandler';\nimport { listItemAlignFormatHandler } from './list/listItemAlignFormatHandler';\nimport { listItemThreadFormatHandler } from './list/listItemThreadFormatHandler';\nimport { listLevelThreadFormatHandler } from './list/listLevelThreadFormatHandler';\nimport { listStyleFormatHandler } from './list/listStyleFormatHandler';\nimport { marginFormatHandler } from './block/marginFormatHandler';\nimport { paddingFormatHandler } from './block/paddingFormatHandler';\nimport { roleFormatHandler } from './common/roleFormatHandler';\nimport { sizeFormatHandler } from './common/sizeFormatHandler';\nimport { strikeFormatHandler } from './segment/strikeFormatHandler';\nimport { superOrSubScriptFormatHandler } from './segment/superOrSubScriptFormatHandler';\nimport { tableLayoutFormatHandler } from './table/tableLayoutFormatHandler';\nimport { tableSpacingFormatHandler } from './table/tableSpacingFormatHandler';\nimport { textAlignFormatHandler } from './block/textAlignFormatHandler';\nimport { textColorFormatHandler } from './segment/textColorFormatHandler';\nimport { textColorOnTableCellFormatHandler } from './table/textColorOnTableCellFormatHandler';\nimport { textIndentFormatHandler } from './block/textIndentFormatHandler';\nimport { undeletableLinkFormatHandler } from './segment/undeletableLinkFormatHandler';\nimport { underlineFormatHandler } from './segment/underlineFormatHandler';\nimport { verticalAlignFormatHandler } from './common/verticalAlignFormatHandler';\nimport { whiteSpaceFormatHandler } from './block/whiteSpaceFormatHandler';\nimport { wordBreakFormatHandler } from './common/wordBreakFormatHandler';\nimport type { FormatHandler } from './FormatHandler';\nimport type {\n    ContentModelFormatMap,\n    FormatApplier,\n    FormatAppliers,\n    FormatHandlerTypeMap,\n    FormatKey,\n    FormatParser,\n    FormatParsers,\n} from 'roosterjs-content-model-types';\n\ntype FormatHandlers = {\n    [Key in FormatKey]: FormatHandler<FormatHandlerTypeMap[Key]>;\n};\n\nconst defaultFormatHandlerMap: FormatHandlers = {\n    aria: ariaFormatHandler,\n    backgroundColor: backgroundColorFormatHandler,\n    bold: boldFormatHandler,\n    border: borderFormatHandler,\n    borderBox: borderBoxFormatHandler,\n    borderColor: borderColorFormatHandler,\n    boxShadow: boxShadowFormatHandler,\n    dataset: datasetFormatHandler,\n    direction: directionFormatHandler,\n    display: displayFormatHandler,\n    float: floatFormatHandler,\n    fontFamily: fontFamilyFormatHandler,\n    fontSize: fontSizeFormatHandler,\n    entity: entityFormatHandler,\n    htmlAlign: htmlAlignFormatHandler,\n    id: idFormatHandler,\n    imageState: imageStateFormatHandler,\n    italic: italicFormatHandler,\n    legacyTableBorder: legacyTableBorderFormatHandler,\n    letterSpacing: letterSpacingFormatHandler,\n    lineHeight: lineHeightFormatHandler,\n    link: linkFormatHandler,\n    listItemAlign: listItemAlignFormatHandler,\n    listItemThread: listItemThreadFormatHandler,\n    listLevelThread: listLevelThreadFormatHandler,\n    listStyle: listStyleFormatHandler,\n    margin: marginFormatHandler,\n    padding: paddingFormatHandler,\n    role: roleFormatHandler,\n    size: sizeFormatHandler,\n    strike: strikeFormatHandler,\n    superOrSubScript: superOrSubScriptFormatHandler,\n    tableLayout: tableLayoutFormatHandler,\n    tableSpacing: tableSpacingFormatHandler,\n    textAlign: textAlignFormatHandler,\n    textColor: textColorFormatHandler,\n    textColorOnTableCell: textColorOnTableCellFormatHandler,\n    textIndent: textIndentFormatHandler,\n    undeletableLink: undeletableLinkFormatHandler,\n    underline: underlineFormatHandler,\n    verticalAlign: verticalAlignFormatHandler,\n    whiteSpace: whiteSpaceFormatHandler,\n    wordBreak: wordBreakFormatHandler,\n};\n\nconst styleBasedSegmentFormats: (keyof FormatHandlerTypeMap)[] = [\n    'letterSpacing',\n    'fontFamily',\n    'fontSize',\n];\n\nconst elementBasedSegmentFormats: (keyof FormatHandlerTypeMap)[] = [\n    'strike',\n    'underline',\n    'superOrSubScript',\n    'italic',\n    'bold',\n];\nconst sharedBlockFormats: (keyof FormatHandlerTypeMap)[] = [\n    'direction',\n    'textAlign',\n    'textIndent',\n    'lineHeight',\n    'whiteSpace',\n];\nconst sharedContainerFormats: (keyof FormatHandlerTypeMap)[] = [\n    'backgroundColor',\n    'margin',\n    'padding',\n    'border',\n];\n\n/**\n * @internal\n */\nexport const defaultFormatKeysPerCategory: {\n    [key in keyof ContentModelFormatMap]: (keyof FormatHandlerTypeMap)[];\n} = {\n    block: sharedBlockFormats,\n    listItemThread: ['listItemThread'],\n    listLevelThread: ['listLevelThread'],\n    listItemElement: [...sharedBlockFormats, 'listItemAlign', 'margin', 'listStyle'],\n    listLevel: ['direction', 'textAlign', 'margin', 'padding', 'listStyle', 'backgroundColor'],\n    styleBasedSegment: [...styleBasedSegmentFormats, 'textColor', 'backgroundColor', 'lineHeight'],\n    elementBasedSegment: elementBasedSegmentFormats,\n    segment: [\n        ...styleBasedSegmentFormats,\n        ...elementBasedSegmentFormats,\n        'textColor',\n        'backgroundColor',\n        'lineHeight',\n    ],\n    segmentOnBlock: [...styleBasedSegmentFormats, ...elementBasedSegmentFormats, 'textColor'],\n    segmentOnTableCell: [\n        ...styleBasedSegmentFormats,\n        ...elementBasedSegmentFormats,\n        'textColorOnTableCell',\n    ],\n    tableCell: [\n        'border',\n        'borderColor',\n        'backgroundColor',\n        'padding',\n        'verticalAlign',\n        'wordBreak',\n        'textColor',\n        'htmlAlign',\n        'size',\n    ],\n    tableRow: ['backgroundColor'],\n    tableColumn: ['size'],\n    table: [\n        'aria',\n        'id',\n        'border',\n        'backgroundColor',\n        'display',\n        'htmlAlign',\n        'margin',\n        'size',\n        'tableLayout',\n        'textColor',\n        'direction',\n        'role',\n    ],\n    tableBorder: ['borderBox', 'tableSpacing', 'legacyTableBorder'],\n    tableCellBorder: ['borderBox'],\n    image: [\n        'id',\n        'size',\n        'margin',\n        'padding',\n        'borderBox',\n        'border',\n        'boxShadow',\n        'display',\n        'float',\n        'verticalAlign',\n        'imageState',\n    ],\n    link: [\n        'link',\n        'textColor',\n        'underline',\n        'display',\n        'margin',\n        'padding',\n        'backgroundColor',\n        'border',\n        'size',\n        'textAlign',\n        'undeletableLink',\n    ],\n    segmentUnderLink: ['textColor'],\n    code: ['fontFamily', 'display'],\n    dataset: ['dataset'],\n    divider: [...sharedBlockFormats, ...sharedContainerFormats, 'display', 'size', 'htmlAlign'],\n    container: [...sharedContainerFormats, 'htmlAlign', 'size', 'display', 'id'],\n    entity: ['entity'],\n    general: ['textColor', 'backgroundColor'], // General model still need to do color transformation in dark mode\n};\n\n/**\n * @internal\n */\nexport const defaultFormatParsers: FormatParsers = getObjectKeys(defaultFormatHandlerMap).reduce(\n    (result, key) => {\n        result[key] = defaultFormatHandlerMap[key].parse as FormatParser<any>;\n        return result;\n    },\n    <FormatParsers>{}\n);\n\n/**\n * @internal\n */\nexport const defaultFormatAppliers: FormatAppliers = getObjectKeys(defaultFormatHandlerMap).reduce(\n    (result, key) => {\n        result[key] = defaultFormatHandlerMap[key].apply as FormatApplier<any>;\n        return result;\n    },\n    <FormatAppliers>{}\n);\n","import { generateEntityClassNames, parseEntityFormat } from '../../domUtils/entityUtils';\nimport type { EntityInfoFormat, IdFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const entityFormatHandler: FormatHandler<EntityInfoFormat & IdFormat> = {\n    parse: (format, element) => {\n        Object.assign(format, parseEntityFormat(element));\n    },\n\n    apply: (format, element) => {\n        if (!format.isFakeEntity) {\n            element.className = generateEntityClassNames(format);\n        }\n\n        if (format.isReadonly) {\n            element.contentEditable = 'false';\n        } else {\n            element.removeAttribute('contenteditable');\n        }\n    },\n};\n","import { calcAlign } from '../utils/dir';\nimport type { DirectionFormat, TextAlignFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const listItemAlignFormatHandler: FormatHandler<TextAlignFormat & DirectionFormat> = {\n    parse: (format, element, context) => {\n        // For list, we usually use align-self to implement alignment\n        if (element.style.alignSelf) {\n            format.textAlign = calcAlign(element.style.alignSelf, context.blockFormat.direction);\n        } else if (element.style.textAlign && element.parentElement?.style.display !== 'flex') {\n            let align = element.style.textAlign;\n\n            // For RTL environment, 'start' and 'end' in textAlign means opposite direction compared to LTR unless parent is using flex display\n            if (context.blockFormat.direction === 'rtl' && (align == 'start' || align == 'end')) {\n                align = align == 'start' ? 'end' : 'start';\n            }\n\n            format.textAlign = calcAlign(align, context.blockFormat.direction);\n        }\n    },\n    apply: (format, element) => {\n        if (format.textAlign) {\n            const parent = element.parentElement;\n\n            element.style.alignSelf = format.textAlign;\n\n            // For list item we use align-self to implement textAlign rather than text-align\n            element.style.removeProperty('text-align');\n\n            if (parent) {\n                parent.style.flexDirection = 'column';\n                parent.style.display = 'flex';\n            }\n        }\n    },\n};\n","import { isElementOfType } from '../../domUtils/isElementOfType';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { ListThreadFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listItemThreadFormatHandler: FormatHandler<ListThreadFormat> = {\n    parse: (format, element, context, defaultStyles) => {\n        const { listFormat } = context;\n        const depth = listFormat.levels.length;\n        const display = element.style.display || defaultStyles.display;\n\n        if (display && display != 'list-item') {\n            format.displayForDummyItem = display;\n        } else if (isLiUnderOl(element) && depth > 0) {\n            listFormat.threadItemCounts[depth - 1]++;\n            listFormat.threadItemCounts.splice(depth);\n            listFormat.levels.forEach(level => {\n                // Delete restart number so next list item doesn't need to have this value.\n                // Then it will be treated as a continuous list item to the previous one\n                delete level.format.startNumberOverride;\n            });\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.displayForDummyItem) {\n            element.style.display = format.displayForDummyItem;\n        } else if (isLiUnderOl(element)) {\n            const { listFormat } = context;\n            const { threadItemCounts } = listFormat;\n            const index = listFormat.nodeStack.length - 2; // The first one is always the parent of list, then minus another 1 to convert length to index\n\n            if (index >= 0) {\n                threadItemCounts.splice(index + 1);\n                threadItemCounts[index] = (threadItemCounts[index] ?? 0) + 1;\n            }\n        }\n    },\n};\n\nfunction isLiUnderOl(element: HTMLElement) {\n    return (\n        isElementOfType(element, 'li') &&\n        isNodeOfType(element.parentNode, 'ELEMENT_NODE') &&\n        isElementOfType(element.parentNode, 'ol')\n    );\n}\n","import { isElementOfType } from '../../domUtils/isElementOfType';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { ListThreadFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listLevelThreadFormatHandler: FormatHandler<ListThreadFormat> = {\n    parse: (format, element, context) => {\n        if (isElementOfType(element, 'ol')) {\n            const { listFormat } = context;\n            const { threadItemCounts, levels } = listFormat;\n            const depth = levels.length;\n\n            if (\n                element.start == 1 ||\n                typeof threadItemCounts[depth] !== 'number' ||\n                element.start != threadItemCounts[depth] + 1\n            ) {\n                format.startNumberOverride = element.start;\n            }\n\n            threadItemCounts[depth] = element.start - 1;\n        }\n    },\n    apply: (format, element, context) => {\n        const {\n            listFormat: { threadItemCounts, nodeStack },\n        } = context;\n\n        // The first one is always the parent of list, and minus another one to convert length to index\n        // This format applier needs to be executed after new list level is pushed into node stack\n        const depth = nodeStack.length - 2;\n\n        if (depth >= 0 && isElementOfType(element, 'ol')) {\n            const startNumber = format.startNumberOverride;\n\n            if (typeof startNumber === 'number') {\n                threadItemCounts[depth] = startNumber - 1;\n            } else if (typeof threadItemCounts[depth] != 'number') {\n                threadItemCounts[depth] = 0;\n            }\n\n            threadItemCounts.splice(depth + 1);\n            element.start = threadItemCounts[depth] + 1;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { ListStyleFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listStyleFormatHandler: FormatHandler<ListStyleFormat> = {\n    parse: (format, element) => {\n        const listStylePosition = element.style.listStylePosition;\n        const listStyleType = element.style.listStyleType;\n\n        if (listStylePosition) {\n            format.listStylePosition = listStylePosition;\n        }\n\n        if (listStyleType) {\n            format.listStyleType = listStyleType;\n        }\n    },\n    apply: (format, element) => {\n        if (format.listStylePosition) {\n            element.style.listStylePosition = format.listStylePosition;\n        }\n\n        if (format.listStyleType) {\n            element.style.listStyleType = format.listStyleType;\n        }\n    },\n};\n","import { shouldSetValue } from '../utils/shouldSetValue';\nimport { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { BoldFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const boldFormatHandler: FormatHandler<BoldFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const fontWeight = element.style.fontWeight || defaultStyle.fontWeight;\n\n        if (shouldSetValue(fontWeight, '400', format.fontWeight, defaultStyle.fontWeight)) {\n            format.fontWeight = fontWeight;\n        }\n    },\n    apply: (format, element, context) => {\n        if (typeof format.fontWeight === 'undefined') {\n            return;\n        }\n\n        const blockFontWeight = context.implicitFormat.fontWeight;\n\n        if (\n            (blockFontWeight && blockFontWeight != format.fontWeight) ||\n            (!blockFontWeight && format.fontWeight && format.fontWeight != 'normal')\n        ) {\n            if (format.fontWeight == 'bold') {\n                wrapAllChildNodes(element, 'b');\n            } else {\n                element.style.fontWeight = format.fontWeight || 'normal';\n            }\n        }\n    },\n};\n","import type { FontFamilyFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const fontFamilyFormatHandler: FormatHandler<FontFamilyFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const fontFamily = element.style.fontFamily || defaultStyle.fontFamily;\n\n        if (fontFamily && fontFamily != 'inherit') {\n            format.fontFamily = fontFamily;\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.fontFamily && format.fontFamily != context.implicitFormat.fontFamily) {\n            element.style.fontFamily = format.fontFamily;\n        }\n    },\n};\n","import { isSuperOrSubScript } from './superOrSubScriptFormatHandler';\nimport { parseValueWithUnit } from '../utils/parseValueWithUnit';\nimport type { EditorContext, FontSizeFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const fontSizeFormatHandler: FormatHandler<FontSizeFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const fontSize = element.style.fontSize || defaultStyle.fontSize;\n        const verticalAlign = element.style.verticalAlign || defaultStyle.verticalAlign;\n\n        // when font size is 'smaller' and the style is for superscript/subscript,\n        // the font size will be handled by superOrSubScript handler\n        if (fontSize && !isSuperOrSubScript(fontSize, verticalAlign) && fontSize != 'inherit') {\n            if (element.style.fontSize) {\n                format.fontSize = normalizeFontSize(\n                    fontSize,\n                    context.segmentFormat.fontSize,\n                    context\n                );\n            } else if (defaultStyle.fontSize) {\n                format.fontSize = fontSize;\n            }\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.fontSize && format.fontSize != context.implicitFormat.fontSize) {\n            element.style.fontSize = format.fontSize;\n        }\n    },\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\nconst KnownFontSizes: Record<string, string> = {\n    'xx-small': '6.75pt',\n    'x-small': '7.5pt',\n    small: '9.75pt',\n    medium: '12pt',\n    large: '13.5pt',\n    'x-large': '18pt',\n    'xx-large': '24pt',\n    'xxx-large': '36pt',\n};\n\nfunction normalizeFontSize(\n    fontSize: string,\n    contextFont: string | undefined,\n    context: EditorContext\n): string | undefined {\n    const knownFontSize = KnownFontSizes[fontSize];\n    const isRemUnit = fontSize.endsWith('rem');\n\n    if (knownFontSize) {\n        return knownFontSize;\n    } else if (\n        fontSize == 'smaller' ||\n        fontSize == 'larger' ||\n        fontSize.endsWith('em') ||\n        fontSize.endsWith('%') ||\n        isRemUnit\n    ) {\n        if (!contextFont && !isRemUnit) {\n            return undefined;\n        } else {\n            const existingFontSize = isRemUnit\n                ? context.rootFontSize\n                : parseValueWithUnit(contextFont);\n\n            if (existingFontSize) {\n                switch (fontSize) {\n                    case 'smaller':\n                        return Math.round((existingFontSize * 500) / 6) / 100 + 'px';\n                    case 'larger':\n                        return Math.round((existingFontSize * 600) / 5) / 100 + 'px';\n                    default:\n                        return parseValueWithUnit(fontSize, existingFontSize, 'px') + 'px';\n                }\n            }\n        }\n    } else if (fontSize == 'inherit' || fontSize == 'revert' || fontSize == 'unset') {\n        return undefined;\n    } else {\n        return fontSize;\n    }\n}\n","import { getImageState, setImageState } from '../../domUtils/hiddenProperties/imageState';\nimport type { ImageStateFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const imageStateFormatHandler: FormatHandler<ImageStateFormat> = {\n    parse: (format, element) => {\n        const marker = getImageState(element);\n        if (marker) {\n            format.imageState = marker;\n        }\n    },\n    apply: (format, element) => {\n        if (format.imageState) {\n            setImageState(element, format.imageState);\n        }\n    },\n};\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { ItalicFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const italicFormatHandler: FormatHandler<ItalicFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const fontStyle = element.style.fontStyle || defaultStyle.fontStyle;\n\n        if (fontStyle == 'italic' || fontStyle == 'oblique') {\n            format.italic = true;\n        } else if (fontStyle == 'initial' || fontStyle == 'normal') {\n            format.italic = false;\n        }\n    },\n    apply: (format, element, context) => {\n        if (typeof format.italic === 'undefined') {\n            return;\n        }\n\n        const implicitItalic = context.implicitFormat.italic;\n\n        if (!!implicitItalic != !!format.italic) {\n            if (format.italic) {\n                wrapAllChildNodes(element, 'i');\n            } else {\n                element.style.fontStyle = 'normal';\n            }\n        }\n    },\n};\n","import { shouldSetValue } from '../utils/shouldSetValue';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { LetterSpacingFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const letterSpacingFormatHandler: FormatHandler<LetterSpacingFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        const letterSpacing = element.style.letterSpacing || defaultStyle.letterSpacing;\n\n        if (\n            shouldSetValue(\n                letterSpacing,\n                'normal',\n                format.letterSpacing,\n                defaultStyle.letterSpacing\n            )\n        ) {\n            format.letterSpacing = letterSpacing;\n        }\n    },\n    apply: (format, element) => {\n        if (format.letterSpacing) {\n            element.style.letterSpacing = format.letterSpacing;\n        }\n    },\n};\n","import { isElementOfType } from '../../domUtils/isElementOfType';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { LinkFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const linkFormatHandler: FormatHandler<LinkFormat> = {\n    parse: (format, element) => {\n        if (isElementOfType(element, 'a')) {\n            const name = element.name;\n            const href = element.getAttribute('href'); // Use getAttribute to get original HREF but not the resolved absolute url\n            const target = element.target;\n            const rel = element.rel;\n            const id = element.id;\n            const className = element.className;\n            const title = element.title;\n\n            if (name) {\n                format.name = name;\n            }\n\n            if (href) {\n                format.href = href;\n            }\n\n            if (target) {\n                format.target = target;\n            }\n\n            if (id) {\n                format.anchorId = id;\n            }\n\n            if (rel) {\n                format.relationship = rel;\n            }\n\n            if (title) {\n                format.anchorTitle = title;\n            }\n\n            if (className) {\n                format.anchorClass = className;\n            }\n        }\n    },\n    apply: (format, element) => {\n        if (isElementOfType(element, 'a') && (format.href || format.name)) {\n            if (format.href) {\n                element.href = format.href;\n            }\n\n            if (format.name) {\n                element.name = format.name;\n            }\n\n            if (format.target) {\n                element.target = format.target;\n            }\n\n            if (format.anchorId) {\n                element.id = format.anchorId;\n            }\n\n            if (format.anchorClass) {\n                element.className = format.anchorClass;\n            }\n\n            if (format.anchorTitle) {\n                element.title = format.anchorTitle;\n            }\n\n            if (format.relationship) {\n                element.rel = format.relationship;\n            }\n        }\n    },\n};\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { StrikeFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const strikeFormatHandler: FormatHandler<StrikeFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const textDecoration = element.style.textDecoration || defaultStyle.textDecoration;\n\n        if (textDecoration?.indexOf('line-through')! >= 0) {\n            format.strikethrough = true;\n        }\n    },\n    apply: (format, element) => {\n        if (format.strikethrough) {\n            wrapAllChildNodes(element, 's');\n        }\n    },\n};\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { SuperOrSubScriptFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const superOrSubScriptFormatHandler: FormatHandler<SuperOrSubScriptFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const verticalAlign = element.style.verticalAlign || defaultStyle.verticalAlign;\n        const fontSize = element.style.fontSize || defaultStyle.fontSize;\n\n        if (isSuperOrSubScript(fontSize, verticalAlign)) {\n            format.superOrSubScriptSequence = (format.superOrSubScriptSequence || '')\n                .split(' ')\n                .concat(verticalAlign)\n                .join(' ')\n                .trim();\n        }\n    },\n    apply: (format, element) => {\n        if (format.superOrSubScriptSequence) {\n            format.superOrSubScriptSequence\n                .split(' ')\n                .reverse()\n                .forEach(value => {\n                    const tagName = value == 'super' ? 'sup' : value == 'sub' ? 'sub' : null;\n\n                    if (tagName) {\n                        wrapAllChildNodes(element, tagName);\n                    }\n                });\n        }\n    },\n};\n\n/**\n * @internal\n */\nexport function isSuperOrSubScript(\n    fontSize: string | undefined,\n    verticalAlign: string | undefined\n): verticalAlign is 'sub' | 'super' {\n    return fontSize == 'smaller' && (verticalAlign == 'sub' || verticalAlign == 'super');\n}\n","import { getColor, setColor } from '../utils/color';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { TextColorFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const textColorFormatHandler: FormatHandler<TextColorFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const textColor =\n            getColor(\n                element,\n                false /*isBackground*/,\n                !!context.isDarkMode,\n                context.darkColorHandler\n            ) || defaultStyle.color;\n\n        if (textColor && textColor != 'inherit') {\n            format.textColor = textColor;\n        }\n    },\n    apply: (format, element, context) => {\n        const implicitColor = context.implicitFormat.textColor;\n\n        if (format.textColor && format.textColor != implicitColor) {\n            setColor(\n                element,\n                format.textColor,\n                false /*isBackground*/,\n                !!context.isDarkMode,\n                context.darkColorHandler\n            );\n        }\n    },\n};\n","import { isElementOfType } from '../../domUtils/isElementOfType';\nimport {\n    isLinkUndeletable,\n    setLinkUndeletable,\n} from '../../domUtils/hiddenProperties/undeletableLink';\nimport type { UndeletableFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const undeletableLinkFormatHandler: FormatHandler<UndeletableFormat> = {\n    parse: (format, element) => {\n        if (isElementOfType(element, 'a') && isLinkUndeletable(element)) {\n            format.undeletable = true;\n        }\n    },\n\n    apply: (format, element) => {\n        if (format.undeletable && isElementOfType(element, 'a')) {\n            setLinkUndeletable(element, true);\n        }\n    },\n};\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { UnderlineFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const underlineFormatHandler: FormatHandler<UnderlineFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const textDecoration = element.style.textDecoration || defaultStyle.textDecoration;\n\n        if (textDecoration?.indexOf('underline')! >= 0) {\n            format.underline = true;\n        } else if (element.tagName == 'A' && textDecoration == 'none') {\n            format.underline = false;\n        }\n    },\n    apply: (format, element, context) => {\n        if (typeof format.underline === 'undefined') {\n            return;\n        }\n\n        const blockUnderline = context.implicitFormat.underline;\n\n        if (!!blockUnderline != !!format.underline) {\n            if (format.underline) {\n                wrapAllChildNodes(element, 'u');\n            } else {\n                element.style.textDecoration = 'none';\n            }\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { LegacyTableBorderFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const legacyTableBorderFormatHandler: FormatHandler<LegacyTableBorderFormat> = {\n    parse: (format, element) => {\n        const border = element.getAttribute('border');\n        const cellSpacing = element.getAttribute('cellspacing');\n        const cellpadding = element.getAttribute('cellpadding');\n\n        if (border) {\n            format.legacyTableBorder = border;\n        }\n\n        if (cellSpacing) {\n            format.cellSpacing = cellSpacing;\n        }\n\n        if (cellpadding) {\n            format.cellPadding = cellpadding;\n        }\n    },\n\n    apply: (format, element) => {\n        if (format.legacyTableBorder) {\n            element.setAttribute('border', format.legacyTableBorder);\n        }\n\n        if (format.cellSpacing) {\n            element.setAttribute('cellspacing', format.cellSpacing);\n        }\n\n        if (format.cellPadding) {\n            element.setAttribute('cellpadding', format.cellPadding);\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { TableLayoutFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const tableLayoutFormatHandler: FormatHandler<TableLayoutFormat> = {\n    parse: (format, element) => {\n        const tableLayout = element.style.tableLayout;\n        if (tableLayout && tableLayout != 'inherit') {\n            format.tableLayout = tableLayout;\n        }\n    },\n    apply: (format, element) => {\n        if (format.tableLayout) {\n            element.style.tableLayout = format.tableLayout;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { SpacingFormat } from 'roosterjs-content-model-types';\n\nconst BorderCollapsed = 'collapse';\nconst BorderSeparate = 'separate';\n\n/**\n * @internal\n */\nexport const tableSpacingFormatHandler: FormatHandler<SpacingFormat> = {\n    parse: (format, element) => {\n        if (element.style.borderCollapse == BorderCollapsed) {\n            format.borderCollapse = true;\n        }\n\n        if (element.style.borderCollapse == BorderSeparate) {\n            format.borderSeparate = true;\n        }\n    },\n    apply: (format, element) => {\n        if (format.borderCollapse) {\n            element.style.borderCollapse = BorderCollapsed;\n            element.style.borderSpacing = '0';\n            element.style.boxSizing = 'border-box';\n        } else if (format.borderSeparate) {\n            element.style.borderCollapse = BorderSeparate;\n            element.style.borderSpacing = '0';\n            element.style.boxSizing = 'border-box';\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { TextColorFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const textColorOnTableCellFormatHandler: FormatHandler<TextColorFormat> = {\n    parse: (format, element) => {\n        if (element.style.color) {\n            // Delete color from format since text color on TD/TH will be handled by separate code\n            // and text color on segment format context need to be reset so that it will not inherit\n            // value outer container\n            delete format.textColor;\n        }\n    },\n    apply: () => {},\n};\n","import type { BorderFormat, BorderKey } from 'roosterjs-content-model-types';\n\n/**\n * Keys of border items\n */\nexport const BorderKeys: (BorderKey & keyof BorderFormat & keyof CSSStyleDeclaration)[] = [\n    'borderTop',\n    'borderRight',\n    'borderBottom',\n    'borderLeft',\n];\n\n/**\n * @internal\n */\nexport const BorderColorKeyMap: {\n    [key in BorderKey]: string;\n} = {\n    borderTop: 'border-top-color',\n    borderRight: 'border-right-color',\n    borderBottom: 'border-bottom-color',\n    borderLeft: 'border-left-color',\n};\n","import { BorderColorKeyMap } from './borderKeys';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport type {\n    DarkColorHandler,\n    Colors,\n    ColorTransformFunction,\n    BorderKey,\n} from 'roosterjs-content-model-types';\n\n/**\n * List of deprecated colors\n */\nexport const DeprecatedColors: string[] = [\n    'inactiveborder',\n    'activeborder',\n    'inactivecaptiontext',\n    'inactivecaption',\n    'activecaption',\n    'appworkspace',\n    'infobackground',\n    'background',\n    'buttonhighlight',\n    'buttonshadow',\n    'captiontext',\n    'infotext',\n    'menutext',\n    'menu',\n    'scrollbar',\n    'threeddarkshadow',\n    'threedface',\n    'threedhighlight',\n    'threedlightshadow',\n    'threedfhadow',\n    'windowtext',\n    'windowframe',\n    'window',\n];\n\nconst BlackColor = 'rgb(0, 0, 0)';\nconst HEX3_REGEX = /^#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/;\nconst HEX6_REGEX = /^#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/;\nconst RGB_REGEX = /^rgb\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*\\)$/;\nconst RGBA_REGEX = /^rgba\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*\\)$/;\nconst VARIABLE_REGEX = /^\\s*var\\(\\s*(\\-\\-[a-zA-Z0-9\\-_]+)\\s*(?:,\\s*(.*))?\\)\\s*$/;\nconst VARIABLE_PREFIX = 'var(';\nconst VARIABLE_POSTFIX = ')';\nconst COLOR_VAR_PREFIX = '--darkColor';\n\n/**\n * Get color from given HTML element\n * @param element The element to get color from\n * @param isBackground True to get background color, false to get text color\n * @param isDarkMode Whether element is in dark mode now\n * @param darkColorHandler @optional The dark color handler object to help manager dark mode color\n * @param fallback @optional Fallback color to use if no color is found from the element\n */\nexport function getColor(\n    element: HTMLElement,\n    isBackground: boolean,\n    isDarkMode: boolean,\n    darkColorHandler?: DarkColorHandler,\n    fallback?: string\n): string | undefined {\n    const color = retrieveElementColor(element, isBackground ? 'background' : 'text', fallback);\n\n    return color\n        ? getLightModeColor(\n              color,\n              isDarkMode,\n              darkColorHandler,\n              isBackground ? undefined : BlackColor\n          )\n        : undefined;\n}\n\n/**\n * @internal\n */\nexport function getLightModeColor(\n    color: string,\n    isDarkMode: boolean,\n    darkColorHandler?: DarkColorHandler,\n    fallback?: string\n) {\n    if (DeprecatedColors.indexOf(color) > -1) {\n        return fallback;\n    } else if (darkColorHandler) {\n        const match = color.startsWith(VARIABLE_PREFIX) ? VARIABLE_REGEX.exec(color) : null;\n\n        if (match) {\n            color = match[2] || '';\n        } else if (isDarkMode) {\n            // If editor is in dark mode but the color is not in dark color format, it is possible the color was inserted from external code\n            // without any light color info. So we first try to see if there is a known dark color can match this color, and use its related\n            // light color as light mode color. Otherwise we need to drop this color to avoid show \"white on white\" content.\n            return findLightColorFromDarkColor(color, darkColorHandler.knownColors) || '';\n        }\n    }\n    return color;\n}\n\n/**\n * @internal\n */\nexport function retrieveElementColor(\n    element: HTMLElement,\n    source: 'text' | 'background' | BorderKey,\n    fallback?: string\n): string | undefined {\n    switch (source) {\n        case 'text':\n            return element.style.color || element.getAttribute('color') || fallback;\n\n        case 'background':\n            return element.style.backgroundColor || element.getAttribute('bgcolor') || fallback;\n\n        default:\n            return element.style.getPropertyValue(BorderColorKeyMap[source]) || fallback;\n    }\n}\n\n/**\n * Set color to given HTML element\n * @param element The element to set color to\n * @param color The color to set, always pass in color in light mode\n * @param isBackground True to set background color, false to set text color\n * @param isDarkMode Whether element is in dark mode now\n * @param darkColorHandler @optional The dark color handler object to help manager dark mode color\n */\nexport function setColor(\n    element: HTMLElement,\n    color: string | null | undefined,\n    isBackground: boolean,\n    isDarkMode: boolean,\n    darkColorHandler?: DarkColorHandler\n) {\n    const newColor = adaptColor(\n        element,\n        color,\n        isBackground ? 'background' : 'text',\n        isDarkMode,\n        darkColorHandler\n    );\n\n    element.removeAttribute(isBackground ? 'bgcolor' : 'color');\n    element.style.setProperty(isBackground ? 'background-color' : 'color', newColor || null);\n}\n\n/**\n * @internal\n */\nexport function adaptColor(\n    element: HTMLElement,\n    color: string | null | undefined,\n    colorType: 'text' | 'background' | 'border',\n    isDarkMode: boolean,\n    darkColorHandler?: DarkColorHandler\n) {\n    const match = color && color.startsWith(VARIABLE_PREFIX) ? VARIABLE_REGEX.exec(color) : null;\n    const [_, existingKey, fallbackColor] = match ?? [];\n\n    color = fallbackColor ?? color;\n\n    if (darkColorHandler && color) {\n        const key =\n            existingKey ||\n            darkColorHandler.generateColorKey(color, undefined /*baseLValue*/, colorType, element);\n        const darkModeColor =\n            darkColorHandler.knownColors?.[key]?.darkModeColor ||\n            darkColorHandler.getDarkColor(color, undefined /*baseLValue*/, colorType, element);\n\n        darkColorHandler.updateKnownColor(isDarkMode, key, {\n            lightModeColor: color,\n            darkModeColor,\n        });\n\n        color = isDarkMode ? `${VARIABLE_PREFIX}${key}, ${color}${VARIABLE_POSTFIX}` : color;\n    }\n\n    return color;\n}\n\n/**\n * Generate color key for dark color\n * @param lightColor The input light color\n * @returns Key of the color\n */\nexport const defaultGenerateColorKey: ColorTransformFunction = lightColor => {\n    return `${COLOR_VAR_PREFIX}_${lightColor.replace(/[^\\d\\w]/g, '_')}`;\n};\n\n/**\n * Parse color string to r/g/b value.\n * If the given color is not in a recognized format, return null\n * @param color The source color to parse\n * @returns An array of Red/Green/Blue value, or null if fail to parse\n */\nexport function parseColor(color: string): [number, number, number] | null {\n    color = (color || '').trim();\n\n    let match: RegExpMatchArray | null;\n    if ((match = color.match(HEX3_REGEX))) {\n        return [\n            parseInt(match[1] + match[1], 16),\n            parseInt(match[2] + match[2], 16),\n            parseInt(match[3] + match[3], 16),\n        ];\n    } else if ((match = color.match(HEX6_REGEX))) {\n        return [parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16)];\n    } else if ((match = color.match(RGB_REGEX) || color.match(RGBA_REGEX))) {\n        return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];\n    } else {\n        // CSS color names such as red, green is not included for now.\n        // If need, we can add those colors from https://www.w3.org/wiki/CSS/Properties/color/keywords\n        return null;\n    }\n}\n\nfunction findLightColorFromDarkColor(\n    darkColor: string,\n    knownColors?: Record<string, Colors>\n): string | null {\n    const rgbSearch = parseColor(darkColor);\n\n    if (rgbSearch && knownColors) {\n        const key = getObjectKeys(knownColors).find(key => {\n            const rgbCurrent = parseColor(knownColors[key].darkModeColor);\n\n            return (\n                rgbCurrent &&\n                rgbCurrent[0] == rgbSearch[0] &&\n                rgbCurrent[1] == rgbSearch[1] &&\n                rgbCurrent[2] == rgbSearch[2]\n            );\n        });\n\n        if (key) {\n            return knownColors[key].lightModeColor;\n        }\n    }\n\n    return null;\n}\n","/**\n * @internal\n */\nexport const ResultMap = {\n    start: {\n        ltr: 'left',\n        rtl: 'right',\n    },\n    center: {\n        ltr: 'center',\n        rtl: 'center',\n    },\n    end: {\n        ltr: 'right',\n        rtl: 'left',\n    },\n    initial: {\n        ltr: 'initial',\n        rtl: 'initial',\n    },\n    justify: {\n        ltr: 'justify',\n        rtl: 'justify',\n    },\n};\n\n/**\n * @internal\n */\nexport function calcAlign(align: string, dir?: 'ltr' | 'rtl') {\n    switch (align) {\n        case 'center':\n            return 'center';\n\n        case 'left':\n            return dir == 'rtl' ? 'end' : 'start';\n\n        case 'right':\n            return dir == 'rtl' ? 'start' : 'end';\n\n        case 'start':\n        case 'end':\n            return align;\n\n        case 'justify':\n        case 'initial':\n            return align;\n\n        default:\n            return undefined;\n    }\n}\n","const MarginValueRegex = /(-?\\d+(\\.\\d+)?)([a-z]+|%)/;\n\n// According to https://developer.mozilla.org/en-US/docs/Glossary/CSS_pixel, 1in = 96px\nconst PixelPerInch = 96;\n\nconst DefaultRootFontSize = 16;\n\n/**\n * Parse unit value with its unit\n * @param value The source value to parse\n * @param currentSizePxOrElement The source element which has this unit value, or current font size (in px) from context.\n * @param resultUnit Unit for result, can be px or pt. @default px\n */\nexport function parseValueWithUnit(\n    value: string = '',\n    currentSizePxOrElement?: number | HTMLElement,\n    resultUnit: 'px' | 'pt' = 'px'\n): number {\n    const match = MarginValueRegex.exec(value);\n    let result = 0;\n\n    if (match) {\n        const [_, numStr, __, unit] = match;\n        const num = parseFloat(numStr);\n\n        switch (unit) {\n            case 'px':\n                result = num;\n                break;\n            case 'pt':\n                result = ptToPx(num);\n                break;\n            case 'em':\n                result = getFontSize(currentSizePxOrElement) * num;\n                break;\n            case 'ex':\n                result = (getFontSize(currentSizePxOrElement) * num) / 2;\n                break;\n            case '%':\n                result = (getFontSize(currentSizePxOrElement) * num) / 100;\n                break;\n            case 'in':\n                result = num * PixelPerInch;\n                break;\n            case 'rem':\n                result = (getFontSize(currentSizePxOrElement) || DefaultRootFontSize) * num;\n                break;\n        }\n    }\n\n    if (result > 0 && resultUnit == 'pt') {\n        result = pxToPt(result);\n    }\n\n    return result;\n}\n\nfunction getFontSize(currentSizeOrElement?: number | HTMLElement): number {\n    if (typeof currentSizeOrElement === 'undefined') {\n        return 0;\n    } else if (typeof currentSizeOrElement === 'number') {\n        return currentSizeOrElement;\n    } else {\n        const styleInPt =\n            currentSizeOrElement.ownerDocument.defaultView?.getComputedStyle(currentSizeOrElement)\n                .fontSize ?? '';\n        const floatInPt = parseFloat(styleInPt);\n        const floatInPx = ptToPx(floatInPt);\n\n        return floatInPx;\n    }\n}\n\nfunction ptToPx(pt: number): number {\n    return Math.round((pt * 4000) / 3) / 1000;\n}\n\nfunction pxToPt(px: number) {\n    return Math.round((px * 3000) / 4) / 1000;\n}\n","/**\n * @internal\n */\nexport function shouldSetValue(\n    value: string | undefined,\n    normalValue: string,\n    existingValue: string | undefined,\n    defaultValue: string | undefined\n): boolean {\n    return (\n        !!value &&\n        value != 'inherit' &&\n        !!(value != normalValue || existingValue || (defaultValue && value != defaultValue))\n    );\n}\n","export { domToContentModel } from './domToModel/domToContentModel';\nexport { contentModelToDom } from './modelToDom/contentModelToDom';\nexport { contentModelToText } from './modelToText/contentModelToText';\n\nexport {\n    childProcessor,\n    handleRegularSelection,\n    processChildNode,\n} from './domToModel/processors/childProcessor';\nexport { entityProcessor } from './domToModel/processors/entityProcessor';\nexport { tableProcessor } from './domToModel/processors/tableProcessor';\nexport { formatContainerProcessor } from './domToModel/processors/formatContainerProcessor';\nexport { getRegularSelectionOffsets } from './domToModel/utils/getRegularSelectionOffsets';\nexport { parseFormat } from './domToModel/utils/parseFormat';\nexport { areSameFormats } from './domToModel/utils/areSameFormats';\nexport { isBlockElement } from './domToModel/utils/isBlockElement';\nexport { buildSelectionMarker } from './domToModel/utils/buildSelectionMarker';\n\nexport { updateMetadata, getMetadata, hasMetadata } from './modelApi/metadata/updateMetadata';\nexport { isNodeOfType } from './domUtils/isNodeOfType';\nexport { isElementOfType } from './domUtils/isElementOfType';\nexport { getObjectKeys } from './domUtils/getObjectKeys';\nexport { getSafeIdSelector } from './domUtils/getSafeIdSelector';\nexport { toArray } from './domUtils/toArray';\nexport { moveChildNodes, wrapAllChildNodes } from './domUtils/moveChildNodes';\nexport { wrap } from './domUtils/wrap';\nexport { unwrap } from './domUtils/unwrap';\nexport {\n    isEntityElement,\n    findClosestEntityWrapper,\n    getAllEntityWrappers,\n    parseEntityFormat,\n    generateEntityClassNames,\n    addDelimiters,\n    isEntityDelimiter,\n    isBlockEntityContainer,\n    findClosestBlockEntityContainer,\n} from './domUtils/entityUtils';\nexport { reuseCachedElement } from './domUtils/reuseCachedElement';\nexport { isWhiteSpacePreserved } from './domUtils/isWhiteSpacePreserved';\nexport { normalizeRect } from './domUtils/normalizeRect';\nexport { scrollRectIntoView } from './domUtils/scrollRectIntoView';\n\nexport { setLinkUndeletable, isLinkUndeletable } from './domUtils/hiddenProperties/undeletableLink';\n\nexport { createBr } from './modelApi/creators/createBr';\nexport { createListItem } from './modelApi/creators/createListItem';\nexport { createFormatContainer } from './modelApi/creators/createFormatContainer';\nexport { createParagraph } from './modelApi/creators/createParagraph';\nexport { createSelectionMarker } from './modelApi/creators/createSelectionMarker';\nexport { createTable } from './modelApi/creators/createTable';\nexport { createTableCell } from './modelApi/creators/createTableCell';\nexport { createText } from './modelApi/creators/createText';\nexport { createImage } from './modelApi/creators/createImage';\nexport { createContentModelDocument } from './modelApi/creators/createContentModelDocument';\nexport { createParagraphDecorator } from './modelApi/creators/createParagraphDecorator';\nexport { createGeneralSegment } from './modelApi/creators/createGeneralSegment';\nexport { createGeneralBlock } from './modelApi/creators/createGeneralBlock';\nexport { createEntity } from './modelApi/creators/createEntity';\nexport { createDivider } from './modelApi/creators/createDivider';\nexport { createListLevel } from './modelApi/creators/createListLevel';\nexport { createEmptyModel } from './modelApi/creators/createEmptyModel';\nexport { createTableRow } from './modelApi/creators/createTableRow';\n\nexport { mutateBlock, mutateSegments, mutateSegment } from './modelApi/common/mutate';\nexport { addBlock } from './modelApi/common/addBlock';\nexport { addCode } from './modelApi/common/addDecorators';\nexport { addLink } from './modelApi/common/addDecorators';\nexport { addTextSegment } from './modelApi/common/addTextSegment';\nexport { normalizeParagraph } from './modelApi/common/normalizeParagraph';\n\nexport { normalizeContentModel } from './modelApi/common/normalizeContentModel';\nexport { isGeneralSegment } from './modelApi/typeCheck/isGeneralSegment';\nexport { unwrapBlock } from './modelApi/common/unwrapBlock';\nexport { addSegment } from './modelApi/common/addSegment';\nexport { isEmpty } from './modelApi/common/isEmpty';\nexport { normalizeSingleSegment } from './modelApi/common/normalizeSegment';\nexport { mergeTextSegments } from './modelApi/common/mergeTextSegments';\nexport { normalizeSegmentFormat } from './modelApi/common/normalizeSegmentFormat';\n\nexport { setParagraphNotImplicit } from './modelApi/block/setParagraphNotImplicit';\nexport {\n    copyFormat,\n    ListFormats,\n    ListFormatsToKeep,\n    ListFormatsToMove,\n    ParagraphFormats,\n} from './modelApi/block/copyFormat';\nexport { getOrderedListNumberStr } from './modelApi/list/getOrderedListNumberStr';\nexport { getAutoListStyleType } from './modelApi/list/getAutoListStyleType';\n\nexport { parseValueWithUnit } from './formatHandlers/utils/parseValueWithUnit';\nexport { BorderKeys } from './formatHandlers/utils/borderKeys';\nexport {\n    DeprecatedColors,\n    getColor,\n    setColor,\n    parseColor,\n    defaultGenerateColorKey,\n} from './formatHandlers/utils/color';\n\nexport {\n    createDomToModelContext,\n    createDomToModelContextWithConfig,\n    createDomToModelConfig,\n} from './domToModel/context/createDomToModelContext';\nexport {\n    createModelToDomContext,\n    createModelToDomContextWithConfig,\n    createModelToDomConfig,\n} from './modelToDom/context/createModelToDomContext';\n\nexport { isBold } from './domUtils/style/isBold';\nexport { getSelectionRootNode } from './domUtils/selection/getSelectionRootNode';\nexport { getDOMInsertPointRect } from './domUtils/selection/getDOMInsertPointRect';\nexport { isCharacterValue, isModifierKey, isCursorMovingKey } from './domUtils/event/eventUtils';\nexport { combineBorderValue, extractBorderValues } from './domUtils/style/borderValues';\nexport { isPunctuation, isSpace, normalizeText } from './domUtils/stringUtil';\nexport { parseTableCells } from './domUtils/table/parseTableCells';\nexport { readFile } from './domUtils/readFile';\nexport { retrieveDocumentMetadata } from './domUtils/retrieveDocumentMetadata';\nexport { transformColor, TransformColorOptions } from './domUtils/style/transformColor';\nexport { normalizeFontFamily } from './domUtils/style/normalizeFontFamily';\nexport { extractClipboardItems } from './domUtils/event/extractClipboardItems';\nexport { cacheGetEventData } from './domUtils/event/cacheGetEventData';\nexport {\n    setParagraphMarker,\n    getParagraphMarker,\n} from './domUtils/hiddenProperties/paragraphMarker';\nexport { setImageState, getImageState } from './domUtils/hiddenProperties/imageState';\nexport { getRangesByText } from './domUtils/getRangesByText';\n\nexport { isBlockGroupOfType } from './modelApi/typeCheck/isBlockGroupOfType';\n\nexport { iterateSelections } from './modelApi/selection/iterateSelections';\nexport {\n    getFirstSelectedListItem,\n    getFirstSelectedTable,\n    getOperationalBlocks,\n    getSelectedParagraphs,\n    getSelectedSegments,\n    getSelectedSegmentsAndParagraphs,\n} from './modelApi/selection/collectSelections';\nexport { getSelectedCells } from './modelApi/selection/getSelectedCells';\nexport { hasSelectionInBlock } from './modelApi/selection/hasSelectionInBlock';\nexport { hasSelectionInSegment } from './modelApi/selection/hasSelectionInSegment';\nexport { hasSelectionInBlockGroup } from './modelApi/selection/hasSelectionInBlockGroup';\nexport { setSelection } from './modelApi/selection/setSelection';\n\nexport { cloneModel } from './modelApi/editing/cloneModel';\nexport { mergeModel } from './modelApi/editing/mergeModel';\nexport { deleteSelection } from './modelApi/editing/deleteSelection';\nexport { deleteSegment } from './modelApi/editing/deleteSegment';\nexport { deleteBlock } from './modelApi/editing/deleteBlock';\nexport { applyTableFormat, setFirstColumnFormatBorders } from './modelApi/editing/applyTableFormat';\nexport {\n    normalizeTable,\n    MIN_ALLOWED_TABLE_CELL_WIDTH,\n    MIN_ALLOWED_TABLE_CELL_HEIGHT,\n} from './modelApi/editing/normalizeTable';\nexport { setTableCellBackgroundColor } from './modelApi/editing/setTableCellBackgroundColor';\nexport { retrieveModelFormatState } from './modelApi/editing/retrieveModelFormatState';\nexport { getListStyleTypeFromString } from './modelApi/editing/getListStyleTypeFromString';\nexport { getSegmentTextFormat } from './modelApi/editing/getSegmentTextFormat';\nexport { getClosestAncestorBlockGroupIndex } from './modelApi/editing/getClosestAncestorBlockGroupIndex';\nexport { runEditSteps } from './modelApi/editing/runEditSteps';\n\nexport { updateImageMetadata, getImageMetadata } from './modelApi/metadata/updateImageMetadata';\nexport {\n    updateTableCellMetadata,\n    getTableCellMetadata,\n} from './modelApi/metadata/updateTableCellMetadata';\nexport { updateTableMetadata, getTableMetadata } from './modelApi/metadata/updateTableMetadata';\nexport {\n    updateListMetadata,\n    getListMetadata,\n    ListMetadataDefinition,\n} from './modelApi/metadata/updateListMetadata';\n\nexport { ChangeSource } from './constants/ChangeSource';\nexport { BulletListType } from './constants/BulletListType';\nexport { NumberingListType } from './constants/NumberingListType';\nexport { TableBorderFormat } from './constants/TableBorderFormat';\nexport { OrderedListStyleMap } from './constants/OrderedListStyleMap';\nexport { UnorderedListStyleMap } from './constants/UnorderedListStyleMap';\nexport { EmptySegmentFormat } from './constants/EmptySegmentFormat';\n","import type {\n    ContentModelBlockFormat,\n    ContentModelFormatBase,\n} from 'roosterjs-content-model-types';\n\n/**\n * When copy format between list and paragraph, these are the formats that we can copy and remove from the source\n */\nexport const ListFormatsToMove: (keyof ContentModelBlockFormat)[] = [\n    'marginRight',\n    'marginLeft',\n    'paddingRight',\n    'paddingLeft',\n];\n\n/**\n * When copy format between list and paragraph, these are the formats that we can copy and keep in the source\n */\nexport const ListFormatsToKeep: (keyof ContentModelBlockFormat)[] = [\n    'direction',\n    'textAlign',\n    'htmlAlign',\n];\n\n/**\n * When copy format from one block to another, these are all the formats that we can copy\n */\nexport const ListFormats: (keyof ContentModelBlockFormat)[] = ListFormatsToMove.concat(\n    ListFormatsToKeep\n);\n\n/**\n * When copy format between paragraphs, these are the formats that we can copy\n */\nexport const ParagraphFormats: (keyof ContentModelBlockFormat)[] = [\n    'backgroundColor',\n    'direction',\n    'textAlign',\n    'htmlAlign',\n    'lineHeight',\n    'textIndent',\n    'marginTop',\n    'marginRight',\n    'marginBottom',\n    'marginLeft',\n    'paddingTop',\n    'paddingRight',\n    'paddingBottom',\n    'paddingLeft',\n];\n\n/**\n * Copy formats from source to target with only specified keys\n * @param targetFormat The format object to copy format to\n * @param sourceFormat The format object to copy format from\n * @param formatKeys The format keys to copy\n * @param deleteOriginalFormat True to delete the original format from sourceFormat, false to keep it. @default false\n */\nexport function copyFormat<T extends ContentModelFormatBase>(\n    targetFormat: T,\n    sourceFormat: T,\n    formatKeys: (keyof T)[],\n    deleteOriginalFormat?: boolean\n) {\n    for (const key of formatKeys) {\n        if (sourceFormat[key] !== undefined) {\n            Object.assign(targetFormat, {\n                [key]: sourceFormat[key],\n            });\n\n            if (deleteOriginalFormat) {\n                delete sourceFormat[key];\n            }\n        }\n    }\n}\n","import { mutateBlock } from '../common/mutate';\nimport type { ReadonlyContentModelBlock } from 'roosterjs-content-model-types';\n\n/**\n * For a given block, if it is a paragraph, set it to be not-implicit\n * @param block The block to check\n */\nexport function setParagraphNotImplicit(block: ReadonlyContentModelBlock) {\n    if (block.blockType == 'Paragraph' && block.isImplicit) {\n        mutateBlock(block).isImplicit = false;\n    }\n}\n","import type {\n    ShallowMutableContentModelBlock,\n    ShallowMutableContentModelBlockGroup,\n} from 'roosterjs-content-model-types';\n\n/**\n * Add a given block to block group\n * @param group The block group to add block into\n * @param block The block to add\n */\nexport function addBlock(\n    group: ShallowMutableContentModelBlockGroup,\n    block: ShallowMutableContentModelBlock\n) {\n    group.blocks.push(block);\n}\n","import type {\n    DomToModelDecoratorContext,\n    ReadonlyContentModelCode,\n    ReadonlyContentModelLink,\n    ShallowMutableContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function addLink(\n    segment: ShallowMutableContentModelSegment,\n    link: ReadonlyContentModelLink\n) {\n    if (link.format.href || link.format.name) {\n        segment.link = {\n            format: { ...link.format },\n            dataset: { ...link.dataset },\n        };\n    }\n}\n\n/**\n * Add a code decorator into segment if any\n * @param segment The segment to add decorator to\n * @param code The code decorator to add\n */\nexport function addCode(\n    segment: ShallowMutableContentModelSegment,\n    code: ReadonlyContentModelCode\n) {\n    if (code.format.fontFamily) {\n        segment.code = {\n            format: { ...code.format },\n        };\n    }\n}\n\n/**\n * @internal\n */\nexport function addDecorators(\n    segment: ShallowMutableContentModelSegment,\n    context: DomToModelDecoratorContext\n) {\n    addLink(segment, context.link);\n    addCode(segment, context.code);\n}\n","import { ensureParagraph } from './ensureParagraph';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelBlockGroup,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelSegmentFormat,\n    ShallowMutableContentModelBlockGroup,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * Add a given segment into a paragraph from its parent group. If the last block of the given group is not paragraph, create a new paragraph.\n * @param group The parent block group of the paragraph to add segment into\n * @param newSegment The segment to add\n * @param blockFormat The block format used for creating a new paragraph when need\n * @returns The parent paragraph where the segment is added to\n */\nexport function addSegment(\n    group: ContentModelBlockGroup,\n    newSegment: ContentModelSegment,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat\n): ContentModelParagraph;\n\n/**\n * Add a given segment into a paragraph from its parent group. If the last block of the given group is not paragraph, create a new paragraph. (Shallow mutable)\n * @param group The parent block group of the paragraph to add segment into\n * @param newSegment The segment to add\n * @param blockFormat The block format used for creating a new paragraph when need\n * @returns The parent paragraph where the segment is added to\n */\nexport function addSegment(\n    group: ShallowMutableContentModelBlockGroup,\n    newSegment: ContentModelSegment,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat\n): ShallowMutableContentModelParagraph;\n\nexport function addSegment(\n    group: ShallowMutableContentModelBlockGroup,\n    newSegment: ContentModelSegment,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat\n): ShallowMutableContentModelParagraph {\n    const paragraph = ensureParagraph(group, blockFormat, segmentFormat);\n    const lastSegment = paragraph.segments[paragraph.segments.length - 1];\n\n    if (blockFormat?.textIndent) {\n        // For a new paragraph, if current text indent is already applied to previous block in the same level,\n        // we need to ignore it according to browser rendering behavior\n        if (blockFormat.isTextIndentApplied && paragraph.segments.length == 0) {\n            delete paragraph.format.textIndent;\n        } else {\n            blockFormat.isTextIndentApplied = true;\n        }\n\n        delete paragraph.format.isTextIndentApplied;\n    }\n\n    if (newSegment.segmentType == 'SelectionMarker') {\n        if (!lastSegment || !lastSegment.isSelected || !newSegment.isSelected) {\n            paragraph.segments.push(newSegment);\n        }\n    } else {\n        if (\n            newSegment.isSelected &&\n            lastSegment?.segmentType == 'SelectionMarker' &&\n            lastSegment.isSelected\n        ) {\n            paragraph.segments.pop();\n        }\n\n        paragraph.segments.push(newSegment);\n    }\n\n    return paragraph;\n}\n","import { addDecorators } from './addDecorators';\nimport { addSegment } from './addSegment';\nimport { createText } from '../creators/createText';\nimport { ensureParagraph } from './ensureParagraph';\nimport { hasSpacesOnly } from './hasSpacesOnly';\nimport { isWhiteSpacePreserved } from '../../domUtils/isWhiteSpacePreserved';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelText,\n    DomToModelContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Add a new text segment to current paragraph\n * @param group Current BlockGroup that the paragraph belong to\n * @param text Text content of the text segment\n * @param context Current DOM to Model context\n * @returns A new Text segment, or undefined if the input text is empty\n */\nexport function addTextSegment(\n    group: ContentModelBlockGroup,\n    text: string,\n    context: DomToModelContext\n): ContentModelText | undefined {\n    let textModel: ContentModelText | undefined;\n\n    if (text) {\n        const paragraph = ensureParagraph(group, context.blockFormat);\n\n        if (\n            !hasSpacesOnly(text) ||\n            (paragraph?.segments.length ?? 0) > 0 ||\n            isWhiteSpacePreserved(paragraph?.format.whiteSpace)\n        ) {\n            textModel = createText(text, context.segmentFormat);\n\n            if (context.isInSelection) {\n                textModel.isSelected = true;\n            }\n\n            addDecorators(textModel, context);\n\n            addSegment(group, textModel, context.blockFormat);\n        }\n    }\n\n    return textModel;\n}\n","import { addBlock } from './addBlock';\nimport { createParagraph } from '../creators/createParagraph';\nimport { mutateBlock } from './mutate';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelBlockGroup,\n    ContentModelParagraph,\n    ContentModelSegmentFormat,\n    ShallowMutableContentModelBlockGroup,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Ensure there is a Paragraph that can insert segments in a Content Model Block Group\n * @param group The parent block group of the target paragraph\n * @param blockFormat Format of the paragraph. This is only used if we need to create a new paragraph\n */\nexport function ensureParagraph(\n    group: ContentModelBlockGroup,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat\n): ContentModelParagraph;\n\n/**\n * @internal\n * Ensure there is a Paragraph that can insert segments in a Content Model Block Group (Shallow mutable)\n * @param group The parent block group of the target paragraph\n * @param blockFormat Format of the paragraph. This is only used if we need to create a new paragraph\n */\nexport function ensureParagraph(\n    group: ShallowMutableContentModelBlockGroup,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat\n): ShallowMutableContentModelParagraph;\n\nexport function ensureParagraph(\n    group: ShallowMutableContentModelBlockGroup,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat\n): ShallowMutableContentModelParagraph {\n    const lastBlock = group.blocks[group.blocks.length - 1];\n\n    if (lastBlock?.blockType == 'Paragraph') {\n        return mutateBlock(lastBlock);\n    } else {\n        const paragraph = createParagraph(true, blockFormat, segmentFormat);\n        addBlock(group, paragraph);\n\n        return paragraph;\n    }\n}\n","// A regex to match text that only has space and CR\n// We use real space char \" \" (\\u0020) here but not \"\\s\" since \"\\s\" will also match \"&nbsp;\" (\\u00A0) which is something we need to keep\nconst SPACE_TEXT_REGEX = /^[\\r\\n\\t ]*$/;\n\n/**\n * @internal\n * Check if the given string only has space, including line breaks.\n * @param txt The string to check\n */\nexport function hasSpacesOnly(txt: string): boolean {\n    return SPACE_TEXT_REGEX.test(txt);\n}\n","import type {\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function isBlockEmpty(block: ReadonlyContentModelBlock): boolean {\n    switch (block.blockType) {\n        case 'Paragraph':\n            return block.segments.length == 0;\n\n        case 'Table':\n            return block.rows.every(row => row.cells.length == 0);\n\n        case 'BlockGroup':\n            return isBlockGroupEmpty(block);\n\n        case 'Entity':\n            return false;\n\n        default:\n            return false;\n    }\n}\n\n/**\n * @internal\n */\nexport function isBlockGroupEmpty(group: ReadonlyContentModelBlockGroup): boolean {\n    switch (group.blockGroupType) {\n        case 'FormatContainer':\n            // Format Container of DIV is a container for style, so we always treat it as not empty\n            return group.tagName == 'div' ? false : group.blocks.every(isBlockEmpty);\n\n        case 'ListItem':\n            return group.blocks.every(isBlockEmpty);\n\n        case 'Document':\n        case 'General':\n        case 'TableCell':\n            return false;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * @internal\n */\nexport function isSegmentEmpty(\n    segment: ReadonlyContentModelSegment,\n    treatAnchorAsNotEmpty?: boolean\n): boolean {\n    switch (segment.segmentType) {\n        case 'Text':\n            return !segment.text && (!treatAnchorAsNotEmpty || !segment.link?.format.name);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Get whether the model is empty.\n * @returns true if the model is empty.\n */\nexport function isEmpty(\n    model: ReadonlyContentModelBlock | ReadonlyContentModelBlockGroup | ReadonlyContentModelSegment\n): boolean {\n    if (isBlockGroup(model)) {\n        return isBlockGroupEmpty(model);\n    } else if (isBlock(model)) {\n        return isBlockEmpty(model);\n    } else if (isSegment(model)) {\n        return isSegmentEmpty(model);\n    }\n\n    return false;\n}\n\nfunction isSegment(\n    model: ReadonlyContentModelBlock | ReadonlyContentModelBlockGroup | ReadonlyContentModelSegment\n): model is ReadonlyContentModelSegment {\n    return typeof (<ReadonlyContentModelSegment>model).segmentType === 'string';\n}\n\nfunction isBlock(\n    model: ReadonlyContentModelBlock | ReadonlyContentModelBlockGroup | ReadonlyContentModelSegment\n): model is ReadonlyContentModelBlock {\n    return typeof (<ReadonlyContentModelBlock>model).blockType === 'string';\n}\n\nfunction isBlockGroup(\n    model: ReadonlyContentModelBlock | ReadonlyContentModelBlockGroup | ReadonlyContentModelSegment\n): model is ReadonlyContentModelBlockGroup {\n    return typeof (<ReadonlyContentModelBlockGroup>model).blockGroupType === 'string';\n}\n","import { areSameFormats } from '../../domToModel/utils/areSameFormats';\nimport type {\n    ContentModelText,\n    ReadonlyContentModelCode,\n    ReadonlyContentModelLink,\n    ReadonlyContentModelSegment,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * Find continuous text segments that have the same format and decorators, merge them, So we can reduce total count of segments\n * @param block The parent paragraph to check.\n */\nexport function mergeTextSegments(block: ShallowMutableContentModelParagraph) {\n    let lastText: ContentModelText | null = null;\n\n    for (let i = 0; i < block.segments.length; i++) {\n        const segment = block.segments[i];\n\n        if (segment.segmentType != 'Text') {\n            lastText = null;\n        } else if (!lastText || !segmentsWithSameFormat(lastText, segment)) {\n            lastText = segment;\n        } else {\n            lastText.text += segment.text;\n            block.segments.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction segmentsWithSameFormat(\n    seg1: ReadonlyContentModelSegment,\n    seg2: ReadonlyContentModelSegment\n) {\n    return (\n        !!seg1.isSelected == !!seg2.isSelected &&\n        areSameFormats(seg1.format, seg2.format) &&\n        areSameLinks(seg1.link, seg2.link) &&\n        areSameCodes(seg1.code, seg2.code)\n    );\n}\n\nfunction areSameLinks(\n    link1: ReadonlyContentModelLink | undefined,\n    link2: ReadonlyContentModelLink | undefined\n) {\n    return (\n        (!link1 && !link2) ||\n        (link1 &&\n            link2 &&\n            areSameFormats(link1.format, link2.format) &&\n            areSameFormats(link1.dataset, link2.dataset))\n    );\n}\n\nfunction areSameCodes(\n    code1: ReadonlyContentModelCode | undefined,\n    code2: ReadonlyContentModelCode | undefined\n) {\n    return (!code1 && !code2) || (code1 && code2 && areSameFormats(code1.format, code2.format));\n}\n","import type {\n    MutableType,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelListItem,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n    ReadonlyContentModelTable,\n    ShallowMutableContentModelParagraph,\n    ShallowMutableContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * Convert a readonly block to mutable block, clear cached element if exist\n * @param block The block to convert from\n * @returns The same block object of its related mutable type\n */\nexport function mutateBlock<T extends ReadonlyContentModelBlockGroup | ReadonlyContentModelBlock>(\n    block: T\n): MutableType<T> {\n    if (block.cachedElement) {\n        delete block.cachedElement;\n    }\n\n    if (isTable(block)) {\n        block.rows.forEach(row => {\n            delete row.cachedElement;\n        });\n    } else if (isListItem(block)) {\n        block.levels.forEach(level => delete level.cachedElement);\n    }\n\n    const result = (block as unknown) as MutableType<T>;\n\n    return result;\n}\n\n/**\n * Convert segments of a readonly paragraph to be mutable.\n * Segments that are not belong to the given paragraph will be skipped\n * @param paragraph The readonly paragraph to convert from\n * @param segments The segments to convert from\n */\nexport function mutateSegments(\n    paragraph: ReadonlyContentModelParagraph,\n    segments: ReadonlyContentModelSegment[]\n): [ShallowMutableContentModelParagraph, ShallowMutableContentModelSegment[], number[]] {\n    const mutablePara = mutateBlock(paragraph);\n    const result: [\n        ShallowMutableContentModelParagraph,\n        ShallowMutableContentModelSegment[],\n        number[]\n    ] = [mutablePara, [], []];\n\n    if (segments) {\n        segments.forEach(segment => {\n            const index = paragraph.segments.indexOf(segment);\n\n            if (index >= 0) {\n                result[1].push(mutablePara.segments[index]);\n                result[2].push(index);\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * Convert a readonly segment to be mutable, together with its owner paragraph\n * If the segment does not belong to the given paragraph, return null for the segment\n * @param paragraph The readonly paragraph to convert from\n * @param segment The segment to convert from\n */\nexport function mutateSegment<T extends ReadonlyContentModelSegment>(\n    paragraph: ReadonlyContentModelParagraph,\n    segment: T,\n    callback?: (\n        segment: MutableType<T>,\n        paragraph: ShallowMutableContentModelParagraph,\n        index: number\n    ) => void\n): [ShallowMutableContentModelParagraph, MutableType<T> | null, number] {\n    const [mutablePara, mutableSegments, indexes] = mutateSegments(paragraph, [segment]);\n    const mutableSegment =\n        (mutableSegments[0] as ReadonlyContentModelSegment) == segment\n            ? (mutableSegments[0] as MutableType<T>)\n            : null;\n\n    if (callback && mutableSegment) {\n        callback(mutableSegments[0] as MutableType<T>, mutablePara, indexes[0]);\n    }\n\n    return [mutablePara, mutableSegment, indexes[0] ?? -1];\n}\n\nfunction isTable(\n    obj: ReadonlyContentModelBlockGroup | ReadonlyContentModelBlock\n): obj is ReadonlyContentModelTable {\n    return (obj as ReadonlyContentModelTable).blockType == 'Table';\n}\n\nfunction isListItem(\n    obj: ReadonlyContentModelBlockGroup | ReadonlyContentModelBlock\n): obj is ReadonlyContentModelListItem {\n    return (obj as ReadonlyContentModelListItem).blockGroupType == 'ListItem';\n}\n","import { isBlockEmpty } from './isEmpty';\nimport { ListFormats } from '../block/copyFormat';\nimport { mutateBlock } from './mutate';\nimport { normalizeParagraph } from './normalizeParagraph';\nimport { unwrapBlock } from './unwrapBlock';\nimport type { ReadonlyContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * For a given content model, normalize it to make the model be consistent.\n * This process includes:\n * - For a list item without any list level, unwrap the list item\n * - For a paragraph, make sure it has BR at the end if it is an empty paragraph\n * - For text segments under paragraph, make sure its space values are correct (use nbsp to replace space when necessary)\n * - For an empty block, remove it\n * @param group The root level block group of content model to normalize\n */\nexport function normalizeContentModel(group: ReadonlyContentModelBlockGroup) {\n    for (let i = group.blocks.length - 1; i >= 0; i--) {\n        const block = group.blocks[i];\n\n        switch (block.blockType) {\n            case 'BlockGroup':\n                if (block.blockGroupType == 'ListItem' && block.levels.length == 0) {\n                    i += block.blocks.length;\n                    unwrapBlock(group, block, ListFormats);\n                } else {\n                    normalizeContentModel(block);\n                }\n                break;\n            case 'Paragraph':\n                normalizeParagraph(block);\n                break;\n            case 'Table':\n                for (let r = 0; r < block.rows.length; r++) {\n                    for (let c = 0; c < block.rows[r].cells.length; c++) {\n                        if (block.rows[r].cells[c]) {\n                            normalizeContentModel(block.rows[r].cells[c]);\n                        }\n                    }\n                }\n                break;\n        }\n\n        if (isBlockEmpty(block)) {\n            mutateBlock(group).blocks.splice(i, 1);\n        }\n    }\n}\n","import { areSameFormats } from '../../domToModel/utils/areSameFormats';\nimport { createBr } from '../creators/createBr';\nimport { isSegmentEmpty } from './isEmpty';\nimport { isWhiteSpacePreserved } from '../../domUtils/isWhiteSpacePreserved';\nimport { mutateBlock, mutateSegment } from './mutate';\nimport { normalizeAllSegments } from './normalizeSegment';\nimport type {\n    ContentModelSegmentFormat,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * @param paragraph The paragraph to normalize\n * Normalize a paragraph. If it is empty, add a BR segment to make sure it can insert content\n */\nexport function normalizeParagraph(paragraph: ReadonlyContentModelParagraph) {\n    const segments = paragraph.segments;\n\n    if (!paragraph.isImplicit && segments.length > 0) {\n        const last = segments[segments.length - 1];\n        const secondLast = segments[segments.length - 2];\n\n        if (\n            last.segmentType == 'SelectionMarker' &&\n            (!secondLast || secondLast.segmentType == 'Br')\n        ) {\n            mutateBlock(paragraph).segments.push(createBr(last.format));\n        } else if (segments.length > 1 && segments[segments.length - 1].segmentType == 'Br') {\n            const noMarkerSegments = segments.filter(x => x.segmentType != 'SelectionMarker');\n\n            // When there is content with a <BR> tag at the end, we can remove the BR.\n            // But if there are more than one <BR> at the end, do not remove them.\n            if (\n                noMarkerSegments.length > 1 &&\n                noMarkerSegments[noMarkerSegments.length - 2].segmentType != 'Br'\n            ) {\n                mutateBlock(paragraph).segments.pop();\n            }\n        }\n\n        normalizeParagraphStyle(paragraph);\n    }\n\n    if (!isWhiteSpacePreserved(paragraph.format.whiteSpace)) {\n        normalizeAllSegments(paragraph);\n    }\n\n    removeEmptyLinks(paragraph);\n    removeEmptySegments(paragraph);\n    moveUpSegmentFormat(paragraph);\n}\n\nfunction normalizeParagraphStyle(paragraph: ReadonlyContentModelParagraph) {\n    // New paragraph should not have white-space style\n    if (\n        paragraph.format.whiteSpace &&\n        paragraph.segments.every(\n            seg => seg.segmentType == 'Br' || seg.segmentType == 'SelectionMarker'\n        )\n    ) {\n        delete mutateBlock(paragraph).format.whiteSpace;\n    }\n}\n\nfunction removeEmptySegments(block: ReadonlyContentModelParagraph) {\n    for (let j = block.segments.length - 1; j >= 0; j--) {\n        if (isSegmentEmpty(block.segments[j], true /*treatAnchorAsNotEmpty*/)) {\n            mutateBlock(block).segments.splice(j, 1);\n        }\n    }\n}\n\nfunction removeEmptyLinks(paragraph: ReadonlyContentModelParagraph) {\n    const marker = paragraph.segments.find(x => x.segmentType == 'SelectionMarker');\n    if (marker) {\n        const markerIndex = paragraph.segments.indexOf(marker);\n        const prev = paragraph.segments[markerIndex - 1];\n        const next = paragraph.segments[markerIndex + 1];\n\n        if (\n            (prev &&\n                !prev.link &&\n                areSameFormats(prev.format, marker.format) &&\n                (!next || (!next.link && areSameFormats(next.format, marker.format))) &&\n                marker.link) ||\n            (!prev &&\n                marker.link &&\n                next &&\n                !next.link &&\n                areSameFormats(next.format, marker.format))\n        ) {\n            mutateSegment(paragraph, marker, mutableMarker => {\n                delete mutableMarker.link;\n            });\n        }\n    }\n}\n\ntype FormatsToMoveUp = 'fontFamily' | 'fontSize' | 'textColor';\nconst formatsToMoveUp: FormatsToMoveUp[] = ['fontFamily', 'fontSize', 'textColor'];\n\n// When all segments are sharing the same segment format (font name, size and color), we can move its format to paragraph\nfunction moveUpSegmentFormat(paragraph: ReadonlyContentModelParagraph) {\n    if (!paragraph.decorator) {\n        const segments = paragraph.segments.filter(x => x.segmentType != 'SelectionMarker');\n        const target = paragraph.segmentFormat || {};\n        let changed = false;\n\n        formatsToMoveUp.forEach(key => {\n            changed = internalMoveUpSegmentFormat(segments, target, key) || changed;\n        });\n\n        if (changed) {\n            mutateBlock(paragraph).segmentFormat = target;\n        }\n    }\n}\n\nfunction internalMoveUpSegmentFormat(\n    segments: ReadonlyContentModelSegment[],\n    target: ContentModelSegmentFormat,\n    formatKey: FormatsToMoveUp\n): boolean {\n    const firstFormat = segments[0]?.format;\n\n    if (\n        firstFormat?.[formatKey] &&\n        segments.every(segment => segment.format[formatKey] == firstFormat[formatKey]) &&\n        target[formatKey] != firstFormat[formatKey]\n    ) {\n        target[formatKey] = firstFormat[formatKey];\n        return true;\n    } else {\n        return false;\n    }\n}\n","import { hasSpacesOnly } from './hasSpacesOnly';\nimport { mutateSegment } from './mutate';\nimport type {\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n    ReadonlyContentModelText,\n} from 'roosterjs-content-model-types';\n\nconst SPACE = '\\u0020';\nconst NONE_BREAK_SPACE = '\\u00A0';\nconst LEADING_SPACE_REGEX = /^\\u0020+/;\nconst TRAILING_SPACE_REGEX = /\\u0020+$/;\n\n/**\n * @internal\n */\nexport function normalizeAllSegments(paragraph: ReadonlyContentModelParagraph) {\n    const context = resetNormalizeSegmentContext();\n\n    paragraph.segments.forEach(segment => {\n        normalizeSegment(paragraph, segment, context);\n    });\n\n    normalizeTextSegments(paragraph, context.textSegments, context.lastInlineSegment);\n    normalizeLastTextSegment(paragraph, context.lastTextSegment, context.lastInlineSegment);\n}\n\n/**\n * Normalize a given segment, make sure its spaces are correctly represented by space and non-break space\n * @param segment The segment to normalize\n * @param ignoreTrailingSpaces Whether we should ignore the trailing space of the text segment @default false\n */\nexport function normalizeSingleSegment(\n    paragraph: ReadonlyContentModelParagraph,\n    segment: ReadonlyContentModelSegment,\n    ignoreTrailingSpaces: boolean = false\n) {\n    const context = resetNormalizeSegmentContext();\n\n    context.ignoreTrailingSpaces = ignoreTrailingSpaces;\n    normalizeSegment(paragraph, segment, context);\n}\n\n/**\n * @internal Export for test only\n */\nexport interface NormalizeSegmentContext {\n    textSegments: ReadonlyContentModelText[];\n    ignoreLeadingSpaces: boolean;\n    ignoreTrailingSpaces: boolean;\n    lastTextSegment: ReadonlyContentModelText | undefined;\n    lastInlineSegment: ReadonlyContentModelSegment | undefined;\n}\n\n/**\n * @internal Export for test only\n */\nexport function createNormalizeSegmentContext(): NormalizeSegmentContext {\n    return resetNormalizeSegmentContext();\n}\n\nfunction resetNormalizeSegmentContext(\n    context?: Partial<NormalizeSegmentContext>\n): NormalizeSegmentContext {\n    return Object.assign(context ?? {}, {\n        textSegments: [],\n        ignoreLeadingSpaces: true,\n        ignoreTrailingSpaces: true,\n        lastInlineSegment: undefined,\n        lastTextSegment: undefined,\n    });\n}\n\n/**\n * @internal Export for test only\n */\nexport function normalizeSegment(\n    paragraph: ReadonlyContentModelParagraph,\n    segment: ReadonlyContentModelSegment,\n    context: NormalizeSegmentContext\n) {\n    switch (segment.segmentType) {\n        case 'Br':\n            normalizeTextSegments(paragraph, context.textSegments, context.lastInlineSegment);\n            normalizeLastTextSegment(paragraph, context.lastTextSegment, context.lastInlineSegment);\n\n            // Line ends, reset all states\n            resetNormalizeSegmentContext(context);\n            break;\n\n        case 'Entity':\n        case 'General':\n        case 'Image':\n            // Here \"inline segment\" means a segment showing some content inline such as text, image, or other inline HTML elements\n            // BR will end current line, so it is not treated as \"inline\" here.\n            // We will do some normalization to the trailing spaces for non-inline-segments\n            context.lastInlineSegment = segment;\n            context.ignoreLeadingSpaces = false;\n            break;\n\n        case 'Text':\n            context.textSegments.push(segment);\n            context.lastInlineSegment = segment;\n            context.lastTextSegment = segment;\n\n            const first = segment.text.substring(0, 1);\n            const last = segment.text.substr(-1);\n\n            if (!hasSpacesOnly(segment.text)) {\n                if (first == SPACE) {\n                    // 1. Multiple leading space => single &nbsp; or empty (depends on if previous segment ends with space)\n                    mutateSegment(paragraph, segment, textSegment => {\n                        textSegment.text = textSegment.text.replace(\n                            LEADING_SPACE_REGEX,\n                            context.ignoreLeadingSpaces ? '' : NONE_BREAK_SPACE\n                        );\n                    });\n                }\n\n                if (last == SPACE) {\n                    // 2. Multiple trailing space => single space\n                    mutateSegment(paragraph, segment, textSegment => {\n                        textSegment.text = textSegment.text.replace(\n                            TRAILING_SPACE_REGEX,\n                            context.ignoreTrailingSpaces ? SPACE : NONE_BREAK_SPACE\n                        );\n                    });\n                }\n            }\n\n            context.ignoreLeadingSpaces = last == SPACE;\n\n            break;\n    }\n}\n\nfunction normalizeTextSegments(\n    paragraph: ReadonlyContentModelParagraph,\n    segments: ReadonlyContentModelText[],\n    lastInlineSegment: ReadonlyContentModelSegment | undefined\n) {\n    segments.forEach(segment => {\n        // 3. Segment ends with &nbsp; replace it with space if the previous char is not space so that next segment can wrap\n        // Only do this for segments that is not the last one since the last space will be removed in step 4\n        if (segment != lastInlineSegment) {\n            const text = segment.text;\n\n            if (\n                text.substr(-1) == NONE_BREAK_SPACE &&\n                text.length > 1 &&\n                text.substr(-2, 1) != SPACE\n            ) {\n                mutateSegment(paragraph, segment, textSegment => {\n                    textSegment.text = text.substring(0, text.length - 1) + SPACE;\n                });\n            }\n        }\n    });\n}\n\nfunction normalizeLastTextSegment(\n    paragraph: ReadonlyContentModelParagraph,\n    segment: ReadonlyContentModelText | undefined,\n    lastInlineSegment: ReadonlyContentModelSegment | undefined\n) {\n    if (segment && segment == lastInlineSegment && segment?.text.substr(-1) == SPACE) {\n        // 4. last text segment of the paragraph, remove trailing space\n        mutateSegment(paragraph, segment, textSegment => {\n            textSegment.text = textSegment.text.replace(TRAILING_SPACE_REGEX, '');\n        });\n    }\n}\n","import { createContentModelDocument } from '../creators/createContentModelDocument';\nimport { createDomToModelContextWithConfig } from '../../domToModel/context/createDomToModelContext';\nimport { createModelToDomContextWithConfig } from '../../modelToDom/context/createModelToDomContext';\nimport { createText } from '../creators/createText';\nimport { ensureParagraph } from './ensureParagraph';\nimport type {\n    ContentModelSegmentFormat,\n    DomToModelContext,\n    EditorEnvironment,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Some format values can be changed when apply to DOM, such as font family.\n * This function will normalize the format and return the same string after DOM modification.\n * @param format The format to be normalized\n * @return Normalized format\n */\nexport function normalizeSegmentFormat(\n    format: ContentModelSegmentFormat,\n    environment: EditorEnvironment\n): ContentModelSegmentFormat {\n    const span = environment.document.createElement('span');\n    const segment = createText('text', format);\n\n    const domToModelContext: DomToModelContext = createDomToModelContextWithConfig(\n        environment.domToModelSettings.calculated\n    );\n    const modelToDomContext: ModelToDomContext = createModelToDomContextWithConfig(\n        environment.modelToDomSettings.calculated\n    );\n    const model = createContentModelDocument();\n\n    modelToDomContext.modelHandlers.segment(\n        span.ownerDocument,\n        span,\n        segment,\n        modelToDomContext,\n        []\n    );\n\n    domToModelContext.elementProcessors.element(model, span, domToModelContext);\n\n    const paragraph = ensureParagraph(model);\n\n    return paragraph.segments[0]?.format ?? format;\n}\n","import { copyFormat } from '../../modelApi/block/copyFormat';\nimport { mutateBlock } from './mutate';\nimport { setParagraphNotImplicit } from '../block/setParagraphNotImplicit';\nimport type {\n    ContentModelBlockFormat,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n} from 'roosterjs-content-model-types';\n\n/**\n * Unwrap a given block group, move its child blocks to be under its parent group\n * @param parent Parent block group of the unwrapping group\n * @param groupToUnwrap  The block group to unwrap\n */\nexport function unwrapBlock(\n    parent: ReadonlyContentModelBlockGroup | null,\n    groupToUnwrap: ReadonlyContentModelBlockGroup & ReadonlyContentModelBlock,\n    formatsToKeep?: (keyof ContentModelBlockFormat)[]\n) {\n    const index = parent?.blocks.indexOf(groupToUnwrap) ?? -1;\n\n    if (index >= 0) {\n        groupToUnwrap.blocks.forEach(setParagraphNotImplicit);\n\n        if (parent) {\n            mutateBlock(parent)?.blocks.splice(\n                index,\n                1,\n                ...groupToUnwrap.blocks.map(x => {\n                    const mutableBlock = mutateBlock(x);\n\n                    if (formatsToKeep) {\n                        copyFormat<ContentModelBlockFormat>(\n                            mutableBlock.format,\n                            groupToUnwrap.format,\n                            formatsToKeep\n                        );\n                    }\n\n                    return mutableBlock;\n                })\n            );\n        }\n    }\n}\n","import type { ContentModelBr, ContentModelSegmentFormat } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelBr model\n * @param format @optional The format of this model\n */\nexport function createBr(format?: Readonly<ContentModelSegmentFormat>): ContentModelBr {\n    return {\n        segmentType: 'Br',\n        format: { ...format },\n    };\n}\n","import type {\n    ContentModelDocument,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelDocument model\n * @param defaultFormat @optional Default format of this model\n */\nexport function createContentModelDocument(\n    defaultFormat?: Readonly<ContentModelSegmentFormat>\n): ContentModelDocument {\n    const result: ContentModelDocument = {\n        blockGroupType: 'Document',\n        blocks: [],\n    };\n\n    if (defaultFormat) {\n        result.format = defaultFormat;\n    }\n\n    return result;\n}\n","import type { ContentModelBlockFormat, ContentModelDivider } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelDivider model\n * @param tagName Tag name of this divider. Currently only hr and div are supported\n * @param format @optional The format of this model\n */\nexport function createDivider(\n    tagName: 'hr' | 'div',\n    format?: Readonly<ContentModelBlockFormat>\n): ContentModelDivider {\n    return {\n        blockType: 'Divider',\n        tagName,\n        format: { ...format },\n    };\n}\n","import { createBr } from './createBr';\nimport { createContentModelDocument } from './createContentModelDocument';\nimport { createParagraph } from './createParagraph';\nimport { createSelectionMarker } from './createSelectionMarker';\nimport type {\n    ContentModelDocument,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create an empty Content Model Document with initial empty line and insert point with default format\n * @param format @optional The default format to be applied to this Content Model\n */\nexport function createEmptyModel(\n    format?: Readonly<ContentModelSegmentFormat>\n): ContentModelDocument {\n    const model = createContentModelDocument(format);\n    const paragraph = createParagraph(false /*isImplicit*/, undefined /*blockFormat*/, format);\n\n    paragraph.segments.push(createSelectionMarker(format), createBr(format));\n    model.blocks.push(paragraph);\n\n    return model;\n}\n","import type { ContentModelEntity, ContentModelSegmentFormat } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelEntity model\n * @param wrapper Wrapper element of this entity\n * @param isReadonly Whether this is a readonly entity @default true\n * @param segmentFormat @optional Segment format of this entity\n * @param type @optional Type of this entity\n * @param id @optional Id of this entity\n */\nexport function createEntity(\n    wrapper: HTMLElement,\n    isReadonly: boolean = true,\n    segmentFormat?: Readonly<ContentModelSegmentFormat>,\n    type?: string,\n    id?: string\n): ContentModelEntity {\n    return {\n        segmentType: 'Entity',\n        blockType: 'Entity',\n        format: { ...segmentFormat },\n        entityFormat: {\n            id,\n            entityType: type,\n            isReadonly,\n        },\n        wrapper,\n    };\n}\n","import type {\n    ContentModelFormatContainer,\n    ContentModelFormatContainerFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelFormatContainer model\n * @param tag Tag name of this format container, in lower case\n * @param format @optional The format of this model\n */\nexport function createFormatContainer(\n    tag: Lowercase<string>,\n    format?: Readonly<ContentModelFormatContainerFormat>\n): ContentModelFormatContainer {\n    return {\n        blockType: 'BlockGroup',\n        blockGroupType: 'FormatContainer',\n        tagName: tag,\n        blocks: [],\n        format: { ...format },\n    };\n}\n","import type { ContentModelGeneralBlock } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelGeneralBlock model\n * @param element Original element of this model\n */\nexport function createGeneralBlock(element: HTMLElement): ContentModelGeneralBlock {\n    return {\n        blockType: 'BlockGroup',\n        blockGroupType: 'General',\n        element: element,\n        blocks: [],\n        format: {},\n    };\n}\n","import type {\n    ContentModelGeneralSegment,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelGeneralSegment model\n * @param element The original DOM element\n * @param format @optional The format of this model\n */\nexport function createGeneralSegment(\n    element: HTMLElement,\n    format?: Readonly<ContentModelSegmentFormat>\n): ContentModelGeneralSegment {\n    return {\n        blockType: 'BlockGroup',\n        blockGroupType: 'General',\n        segmentType: 'General',\n        format: { ...format },\n        blocks: [],\n        element: element,\n    };\n}\n","import type { ContentModelImage, ContentModelImageFormat } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelImage model\n * @param src Image source\n * @param format @optional The format of this model\n */\nexport function createImage(\n    src: string,\n    format?: Readonly<ContentModelImageFormat>\n): ContentModelImage {\n    return {\n        segmentType: 'Image',\n        src: src,\n        format: { ...format },\n        dataset: {},\n    };\n}\n","import { createListLevel } from './createListLevel';\nimport { createSelectionMarker } from './createSelectionMarker';\nimport type {\n    ContentModelListItem,\n    ContentModelSegmentFormat,\n    ReadonlyContentModelListLevel,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelListItem model\n * @param levels Existing list levels\n * @param format @optional The format of this model\n */\nexport function createListItem(\n    levels: ReadonlyArray<ReadonlyContentModelListLevel>,\n    format?: Readonly<ContentModelSegmentFormat>\n): ContentModelListItem {\n    const formatHolder = createSelectionMarker(format);\n\n    formatHolder.isSelected = false;\n\n    return {\n        blockType: 'BlockGroup',\n        blockGroupType: 'ListItem',\n        blocks: [],\n        levels: levels\n            ? levels.map(level => createListLevel(level.listType, level.format, level.dataset))\n            : [],\n        formatHolder,\n        format: {},\n    };\n}\n","import type {\n    ContentModelListItemLevelFormat,\n    ContentModelListLevel,\n    ReadonlyDatasetFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelListLevel model\n * @param listType Tag name of the list, either OL or UL\n * @param format @optional The format of this model\n * @param dataset @optional The dataset of this model\n */\nexport function createListLevel(\n    listType: 'OL' | 'UL',\n    format?: Readonly<ContentModelListItemLevelFormat>,\n    dataset?: ReadonlyDatasetFormat\n): ContentModelListLevel {\n    return {\n        listType,\n        format: { ...format },\n        dataset: { ...dataset },\n    };\n}\n","import type {\n    ContentModelBlockFormat,\n    ContentModelParagraph,\n    ContentModelSegmentFormat,\n    ReadonlyContentModelParagraphDecorator,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelParagraph model\n * @param isImplicit @optional Whether this is an implicit paragraph. An implicit paragraph is a paragraph that will not render with DOM element container\n * @param blockFormat @optional Format of this paragraph\n * @param segmentFormat @optional Segment format applied to this block\n * @param decorator @optional Decorator of this paragraph\n */\nexport function createParagraph(\n    isImplicit?: boolean,\n    blockFormat?: Readonly<ContentModelBlockFormat>,\n    segmentFormat?: Readonly<ContentModelSegmentFormat>,\n    decorator?: ReadonlyContentModelParagraphDecorator\n): ContentModelParagraph {\n    const result: ContentModelParagraph = {\n        blockType: 'Paragraph',\n        segments: [],\n        format: { ...blockFormat },\n    };\n\n    if (segmentFormat && Object.keys(segmentFormat).length > 0) {\n        result.segmentFormat = { ...segmentFormat };\n    }\n\n    if (isImplicit) {\n        result.isImplicit = true;\n    }\n\n    if (decorator) {\n        result.decorator = {\n            tagName: decorator.tagName,\n            format: { ...decorator.format },\n        };\n    }\n\n    return result;\n}\n","import type {\n    ContentModelParagraphDecorator,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelParagraphDecorator model\n * @param tagName Tag name of this decorator\n * @param format @optional The format of this model\n */\nexport function createParagraphDecorator(\n    tagName: string,\n    format?: Readonly<ContentModelSegmentFormat>\n): ContentModelParagraphDecorator {\n    return {\n        tagName: tagName.toLocaleLowerCase(),\n        format: { ...format },\n    };\n}\n","import type {\n    ContentModelSegmentFormat,\n    ContentModelSelectionMarker,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelSelectionMarker model\n * @param format @optional The format of this model\n */\nexport function createSelectionMarker(\n    format?: Readonly<ContentModelSegmentFormat>\n): ContentModelSelectionMarker {\n    return {\n        segmentType: 'SelectionMarker',\n        isSelected: true,\n        format: { ...format },\n    };\n}\n","import { createTableRow } from './createTableRow';\nimport type {\n    ContentModelTable,\n    ContentModelTableFormat,\n    ContentModelTableRow,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelTable model\n * @param rowCount Count of rows of this table\n * @param format @optional The format of this model\n */\nexport function createTable(\n    rowCount: number,\n    format?: Readonly<ContentModelTableFormat>\n): ContentModelTable {\n    const rows: ContentModelTableRow[] = [];\n\n    for (let i = 0; i < rowCount; i++) {\n        rows.push(createTableRow());\n    }\n\n    return {\n        blockType: 'Table',\n        rows,\n        format: { ...format },\n        widths: [],\n        dataset: {},\n    };\n}\n","import type {\n    ContentModelTableCell,\n    ContentModelTableCellFormat,\n    ReadonlyDatasetFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelTableCell model\n * @param spanLeftOrColSpan @optional Whether this is a table cell merged with its left cell, or colspan number @default false\n * @param spanAboveOrRowSpan Whether this is a table cell merged with its upper cell, or rowSpan number @default false\n * @param isHeader @optional Whether this is a header cell @default false\n * @param format @optional The format of this model\n */\nexport function createTableCell(\n    spanLeftOrColSpan?: boolean | number,\n    spanAboveOrRowSpan?: boolean | number,\n    isHeader?: boolean,\n    format?: Readonly<ContentModelTableCellFormat>,\n    dataset?: ReadonlyDatasetFormat\n): ContentModelTableCell {\n    const spanLeft =\n        typeof spanLeftOrColSpan === 'number' ? spanLeftOrColSpan > 1 : !!spanLeftOrColSpan;\n    const spanAbove =\n        typeof spanAboveOrRowSpan === 'number' ? spanAboveOrRowSpan > 1 : !!spanAboveOrRowSpan;\n    return {\n        blockGroupType: 'TableCell',\n        blocks: [],\n        format: { ...format },\n        spanLeft,\n        spanAbove,\n        isHeader: !!isHeader,\n        dataset: { ...dataset },\n    };\n}\n","import type { ContentModelBlockFormat, ContentModelTableRow } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelTableRow model\n * @param format @optional The format of this model\n */\nexport function createTableRow(\n    format?: Readonly<ContentModelBlockFormat>,\n    height: number = 0\n): ContentModelTableRow {\n    return {\n        height: height,\n        format: { ...format },\n        cells: [],\n    };\n}\n","import { addCode, addLink } from '../common/addDecorators';\nimport type {\n    ContentModelSegmentFormat,\n    ContentModelText,\n    ReadonlyContentModelCode,\n    ReadonlyContentModelLink,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelText model\n * @param text Text of this model\n * @param format @optional The format of this model\n * @param link @optional The link decorator\n * @param code @option The code decorator\n */\nexport function createText(\n    text: string,\n    format?: Readonly<ContentModelSegmentFormat>,\n    link?: ReadonlyContentModelLink,\n    code?: ReadonlyContentModelCode\n): ContentModelText {\n    const result: ContentModelText = {\n        segmentType: 'Text',\n        text: text,\n        format: { ...format },\n    };\n\n    if (link) {\n        addLink(result, link);\n    }\n\n    if (code) {\n        addCode(result, code);\n    }\n\n    return result;\n}\n","import { BorderKeys } from '../../formatHandlers/utils/borderKeys';\nimport { combineBorderValue, extractBorderValues } from '../../domUtils/style/borderValues';\nimport { mutateBlock, mutateSegment } from '../common/mutate';\nimport { setTableCellBackgroundColor } from './setTableCellBackgroundColor';\nimport { TableBorderFormat } from '../../constants/TableBorderFormat';\nimport { updateTableCellMetadata } from '../metadata/updateTableCellMetadata';\nimport { updateTableMetadata } from '../metadata/updateTableMetadata';\nimport type {\n    BorderFormat,\n    ReadonlyContentModelTable,\n    ShallowMutableContentModelTableRow,\n    TableMetadataFormat,\n} from 'roosterjs-content-model-types';\n\nconst DEFAULT_FORMAT: Required<TableMetadataFormat> = {\n    topBorderColor: '#ABABAB',\n    bottomBorderColor: '#ABABAB',\n    verticalBorderColor: '#ABABAB',\n    hasHeaderRow: false,\n    hasFirstColumn: false,\n    hasBandedRows: false,\n    hasBandedColumns: false,\n    bgColorEven: null,\n    bgColorOdd: '#ABABAB20',\n    headerRowColor: '#ABABAB',\n    tableBorderFormat: TableBorderFormat.Default,\n    verticalAlign: null,\n};\n\ntype MetaOverrides = {\n    bgColorOverrides: boolean[][];\n    vAlignOverrides: boolean[][];\n    borderOverrides: boolean[][];\n};\n\n/**\n * Apply table format from table metadata and the passed in new format\n * @param table The table to apply format to\n * @param newFormat @optional New format to apply. When passed, this value will be merged into existing metadata format and default format\n * @param keepCellShade @optional When pass true, table cells with customized shade color will not be overwritten. @default false\n */\nexport function applyTableFormat(\n    table: ReadonlyContentModelTable,\n    newFormat?: TableMetadataFormat,\n    keepCellShade?: boolean\n) {\n    const mutableTable = mutateBlock(table);\n    const { rows } = mutableTable;\n\n    updateTableMetadata(mutableTable, format => {\n        const effectiveMetadata = {\n            ...DEFAULT_FORMAT,\n            ...format,\n            ...newFormat,\n        };\n\n        const metaOverrides: MetaOverrides = updateOverrides(rows, !keepCellShade);\n\n        formatCells(rows, effectiveMetadata, metaOverrides);\n        setFirstColumnFormatBorders(rows, effectiveMetadata);\n        setHeaderRowFormat(rows, effectiveMetadata, metaOverrides);\n\n        return effectiveMetadata;\n    });\n}\n\nfunction updateOverrides(\n    rows: ShallowMutableContentModelTableRow[],\n    removeCellShade: boolean\n): MetaOverrides {\n    const overrides: MetaOverrides = {\n        bgColorOverrides: [],\n        vAlignOverrides: [],\n        borderOverrides: [],\n    };\n\n    rows.forEach(row => {\n        const bgColorOverrides: boolean[] = [];\n        const vAlignOverrides: boolean[] = [];\n        const borderOverrides: boolean[] = [];\n\n        overrides.bgColorOverrides.push(bgColorOverrides);\n        overrides.vAlignOverrides.push(vAlignOverrides);\n        overrides.borderOverrides.push(borderOverrides);\n\n        row.cells.forEach(cell => {\n            updateTableCellMetadata(mutateBlock(cell), metadata => {\n                if (metadata && removeCellShade) {\n                    bgColorOverrides.push(false);\n                    delete metadata.bgColorOverride;\n                } else {\n                    bgColorOverrides.push(!!metadata?.bgColorOverride);\n                }\n                vAlignOverrides.push(!!metadata?.vAlignOverride);\n                borderOverrides.push(!!metadata?.borderOverride);\n\n                return metadata;\n            });\n        });\n    });\n\n    return overrides;\n}\n\ntype ShouldUseTransparentBorder = (indexProp: {\n    firstRow: boolean;\n    lastRow: boolean;\n    firstColumn: boolean;\n    lastColumn: boolean;\n}) => [boolean, boolean, boolean, boolean];\n\nconst BorderFormatters: Record<number, ShouldUseTransparentBorder | undefined> = {\n    [TableBorderFormat.Default]: _ => [false, false, false, false],\n    [TableBorderFormat.ListWithSideBorders]: ({ lastColumn, firstColumn }) => [\n        false,\n        !lastColumn,\n        false,\n        !firstColumn,\n    ],\n    [TableBorderFormat.FirstColumnHeaderExternal]: ({\n        firstColumn,\n        firstRow,\n        lastColumn,\n        lastRow,\n    }) => [\n        !firstRow,\n        (!lastColumn && !firstColumn) || (firstColumn && firstRow),\n        !lastRow && !firstRow,\n        !firstColumn,\n    ],\n    [TableBorderFormat.NoHeaderBorders]: ({ firstRow, firstColumn, lastColumn }) => [\n        firstRow,\n        firstRow || lastColumn,\n        false,\n        firstRow || firstColumn,\n    ],\n    [TableBorderFormat.NoSideBorders]: ({ firstColumn, lastColumn }) => [\n        false,\n        lastColumn,\n        false,\n        firstColumn,\n    ],\n    [TableBorderFormat.EspecialType1]: ({ firstRow, firstColumn }) => [\n        firstColumn && !firstRow,\n        firstRow,\n        firstColumn && !firstRow,\n        firstRow && !firstColumn,\n    ],\n    [TableBorderFormat.EspecialType2]: ({ firstRow, firstColumn }) => [\n        !firstRow,\n        firstRow || !firstColumn,\n        !firstRow,\n        !firstColumn,\n    ],\n    [TableBorderFormat.EspecialType3]: ({ firstColumn, firstRow }) => [\n        true,\n        firstRow || !firstColumn,\n        !firstRow,\n        true,\n    ],\n    [TableBorderFormat.Clear]: () => [true, true, true, true],\n};\n\n/*\n * Apply vertical align, borders, and background color to all cells in the table\n */\nfunction formatCells(\n    rows: ShallowMutableContentModelTableRow[],\n    format: TableMetadataFormat,\n    metaOverrides: MetaOverrides\n) {\n    const { hasBandedRows, hasBandedColumns, bgColorOdd, bgColorEven, hasFirstColumn } = format;\n\n    rows.forEach((row, rowIndex) => {\n        row.cells.forEach((readonlyCell, colIndex) => {\n            const cell = mutateBlock(readonlyCell);\n\n            // Format Borders\n            if (\n                !metaOverrides.borderOverrides[rowIndex][colIndex] &&\n                typeof format.tableBorderFormat == 'number'\n            ) {\n                const transparentBorderMatrix = BorderFormatters[format.tableBorderFormat]?.({\n                    firstRow: rowIndex === 0,\n                    lastRow: rowIndex === rows.length - 1,\n                    firstColumn: colIndex === 0,\n                    lastColumn: colIndex === row.cells.length - 1,\n                });\n\n                const formatColor = [\n                    format.topBorderColor,\n                    format.verticalBorderColor,\n                    format.bottomBorderColor,\n                    format.verticalBorderColor,\n                ];\n\n                transparentBorderMatrix?.forEach((alwaysUseTransparent, i) => {\n                    const borderColor = (!alwaysUseTransparent && formatColor[i]) || '';\n\n                    cell.format[BorderKeys[i]] = combineBorderValue({\n                        style: getBorderStyleFromColor(borderColor),\n                        width: '1px',\n                        color: borderColor,\n                    });\n                });\n            }\n\n            // Format Background Color\n            if (!metaOverrides.bgColorOverrides[rowIndex][colIndex]) {\n                let color: string | null | undefined;\n                if (hasFirstColumn && colIndex == 0 && rowIndex > 0) {\n                    color = null;\n                } else {\n                    color =\n                        hasBandedRows || hasBandedColumns\n                            ? (hasBandedColumns && colIndex % 2 != 0) ||\n                              (hasBandedRows && rowIndex % 2 != 0)\n                                ? bgColorOdd\n                                : bgColorEven\n                            : bgColorEven; /* bgColorEven is the default color */\n                }\n                setTableCellBackgroundColor(\n                    cell,\n                    color,\n                    false /*isColorOverride*/,\n                    true /*applyToSegments*/\n                );\n            }\n\n            // Format Vertical Align\n            if (format.verticalAlign && !metaOverrides.vAlignOverrides[rowIndex][colIndex]) {\n                cell.format.verticalAlign = format.verticalAlign;\n            }\n\n            // Format Header\n            cell.isHeader = false;\n        });\n    });\n}\n\n/**\n * Set the first column format borders for the table as well as header property\n * @param rows The rows of the table\n * @param format The table metadata format\n */\nexport function setFirstColumnFormatBorders(\n    rows: ShallowMutableContentModelTableRow[],\n    format: Partial<TableMetadataFormat>\n) {\n    rows.forEach((row, rowIndex) => {\n        row.cells.forEach((readonlyCell, cellIndex) => {\n            const cell = mutateBlock(readonlyCell);\n\n            if (cellIndex === 0) {\n                if (rowIndex == 0) {\n                    cell.isHeader = !!format.hasHeaderRow;\n                }\n\n                for (const block of cell.blocks) {\n                    if (block.blockType == 'Paragraph') {\n                        for (const segment of block.segments) {\n                            mutateSegment(block, segment, cellSegment => {\n                                if (format.hasFirstColumn) {\n                                    cellSegment.format.fontWeight = 'bold';\n                                    cell.format.fontWeight = 'bold';\n                                } else if (\n                                    cellSegment.format.fontWeight == 'bold' &&\n                                    cell.format.fontWeight == 'bold'\n                                ) {\n                                    delete cellSegment.format.fontWeight;\n                                    delete cell.format.fontWeight;\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        });\n    });\n}\n\nfunction setHeaderRowFormat(\n    rows: ShallowMutableContentModelTableRow[],\n    format: TableMetadataFormat,\n    metaOverrides: MetaOverrides\n) {\n    // Exit early if hasHeaderRow is not set\n    if (!format.hasHeaderRow) {\n        return;\n    }\n\n    const rowIndex = 0;\n\n    rows[rowIndex]?.cells.forEach((readonlyCell, cellIndex) => {\n        const cell = mutateBlock(readonlyCell);\n\n        cell.isHeader = true;\n        cell.format.fontWeight = 'bold';\n\n        if (format.headerRowColor) {\n            if (!metaOverrides.bgColorOverrides[rowIndex][cellIndex]) {\n                setTableCellBackgroundColor(\n                    cell,\n                    format.headerRowColor,\n                    false /*isColorOverride*/,\n                    true /*applyToSegments*/\n                );\n            }\n\n            setBorderColor(cell.format, 'borderTop', format.headerRowColor);\n            setBorderColor(cell.format, 'borderRight', format.headerRowColor);\n            setBorderColor(cell.format, 'borderLeft', format.headerRowColor);\n        }\n    });\n}\n\n/**\n * @param format The cell format to set the border color\n * @param key The border key to set the color\n * @param value The color to set. If not given, it removes the color and sets the style to transparent\n */\nfunction setBorderColor(format: BorderFormat, key: keyof BorderFormat, value?: string) {\n    const border = extractBorderValues(format[key]);\n    border.color = value || '';\n    border.style = getBorderStyleFromColor(border.color);\n    format[key] = combineBorderValue(border);\n}\n\nfunction getBorderStyleFromColor(color?: string): string {\n    return !color || color == 'transparent' ? 'none' : 'solid';\n}\n","import type {\n    ContentModelBlock,\n    ContentModelBlockBase,\n    ContentModelBlockGroupBase,\n    ContentModelBlockGroupType,\n    ContentModelBlockType,\n    ContentModelDivider,\n    ContentModelDocument,\n    ContentModelEntity,\n    ContentModelFormatBase,\n    ContentModelFormatContainer,\n    ContentModelGeneralBlock,\n    ContentModelImage,\n    ContentModelListItem,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelSegmentBase,\n    ContentModelSegmentType,\n    ContentModelSelectionMarker,\n    ContentModelTable,\n    ContentModelTableCell,\n    ContentModelWithDataset,\n    ContentModelWithFormat,\n    ContentModelGeneralSegment,\n    ContentModelText,\n    ContentModelTableRow,\n    ContentModelListLevel,\n    CloneModelOptions,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelBlockGroupBase,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelFormatContainer,\n    ReadonlyContentModelBlockBase,\n    ReadonlyContentModelGeneralBlock,\n    ReadonlyContentModelListItem,\n    ReadonlyContentModelSelectionMarker,\n    ReadonlyContentModelSegmentBase,\n    ReadonlyContentModelWithDataset,\n    ReadonlyContentModelDivider,\n    ReadonlyContentModelListLevel,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n    ReadonlyContentModelTable,\n    ReadonlyContentModelTableRow,\n    ReadonlyContentModelTableCell,\n    ReadonlyContentModelGeneralSegment,\n    ReadonlyContentModelImage,\n    ReadonlyContentModelText,\n} from 'roosterjs-content-model-types';\n\n/**\n * Clone a content model\n * @param model The content model to clone\n * @param options @optional Options to specify customize the clone behavior\n */\nexport function cloneModel(\n    model: ReadonlyContentModelDocument,\n    options?: CloneModelOptions\n): ContentModelDocument {\n    const newModel: ContentModelDocument = cloneBlockGroupBase(model, options || {});\n\n    if (model.format) {\n        newModel.format = Object.assign({}, model.format);\n    }\n\n    return newModel;\n}\n\nfunction cloneBlock(\n    block: ReadonlyContentModelBlock,\n    options: CloneModelOptions\n): ContentModelBlock {\n    switch (block.blockType) {\n        case 'BlockGroup':\n            switch (block.blockGroupType) {\n                case 'FormatContainer':\n                    return cloneFormatContainer(block, options);\n                case 'General':\n                    return cloneGeneralBlock(block, options);\n                case 'ListItem':\n                    return cloneListItem(block, options);\n            }\n            break;\n        case 'Divider':\n            return cloneDivider(block, options);\n        case 'Entity':\n            return cloneEntity(block, options);\n        case 'Paragraph':\n            return cloneParagraph(block, options);\n        case 'Table':\n            return cloneTable(block, options);\n    }\n}\n\nfunction cloneSegment(\n    segment: ReadonlyContentModelSegment,\n    options: CloneModelOptions\n): ContentModelSegment {\n    switch (segment.segmentType) {\n        case 'Br':\n            return cloneSegmentBase(segment);\n        case 'Entity':\n            return cloneEntity(segment, options);\n        case 'General':\n            return cloneGeneralSegment(segment, options);\n        case 'Image':\n            return cloneImage(segment);\n        case 'SelectionMarker':\n            return cloneSelectionMarker(segment);\n        case 'Text':\n            return cloneText(segment);\n    }\n}\n\nfunction cloneModelWithFormat<T extends ContentModelFormatBase>(\n    model: ContentModelWithFormat<T>\n): ContentModelWithFormat<T> {\n    return {\n        format: Object.assign({}, model.format),\n    };\n}\n\nfunction cloneModelWithDataset<T>(\n    model: ReadonlyContentModelWithDataset<T>\n): ContentModelWithDataset<T> {\n    return {\n        dataset: Object.assign({}, model.dataset),\n    };\n}\n\nfunction cloneBlockBase<T extends ContentModelBlockType>(\n    block: ReadonlyContentModelBlockBase<T>\n): ContentModelBlockBase<T> {\n    const { blockType } = block;\n\n    return Object.assign(\n        {\n            blockType,\n        },\n        cloneModelWithFormat(block)\n    );\n}\n\nfunction cloneBlockGroupBase<T extends ContentModelBlockGroupType>(\n    group: ReadonlyContentModelBlockGroupBase<T>,\n    options: CloneModelOptions\n): ContentModelBlockGroupBase<T> {\n    const { blockGroupType, blocks } = group;\n\n    return {\n        blockGroupType: blockGroupType,\n        blocks: blocks.map(block => cloneBlock(block, options)),\n    };\n}\n\nfunction cloneSegmentBase<T extends ContentModelSegmentType>(\n    segment: ReadonlyContentModelSegmentBase<T>\n): ContentModelSegmentBase<T> {\n    const { segmentType, isSelected, code, link } = segment;\n\n    const newSegment: ContentModelSegmentBase<T> = Object.assign(\n        {\n            segmentType,\n            isSelected,\n        },\n        cloneModelWithFormat(segment)\n    );\n\n    if (code) {\n        newSegment.code = cloneModelWithFormat(code);\n    }\n    if (link) {\n        newSegment.link = Object.assign(cloneModelWithFormat(link), cloneModelWithDataset(link));\n    }\n\n    return newSegment;\n}\n\nfunction cloneEntity(entity: ContentModelEntity, options: CloneModelOptions): ContentModelEntity {\n    const { wrapper, entityFormat } = entity;\n\n    return Object.assign(\n        {\n            wrapper: handleCachedElement(wrapper, 'entity', options),\n            entityFormat: { ...entityFormat },\n        },\n        cloneBlockBase(entity),\n        cloneSegmentBase(entity)\n    );\n}\n\nfunction cloneParagraph(\n    paragraph: ReadonlyContentModelParagraph,\n    options: CloneModelOptions\n): ContentModelParagraph {\n    const { cachedElement, segments, isImplicit, decorator, segmentFormat } = paragraph;\n\n    const newParagraph: ContentModelParagraph = Object.assign(\n        {\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n            isImplicit,\n            segments: segments.map(segment => cloneSegment(segment, options)),\n            segmentFormat: segmentFormat ? { ...segmentFormat } : undefined,\n        },\n        cloneBlockBase(paragraph),\n        cloneModelWithFormat(paragraph)\n    );\n\n    if (decorator) {\n        newParagraph.decorator = Object.assign(\n            {\n                tagName: decorator.tagName,\n            },\n            cloneModelWithFormat(decorator)\n        );\n    }\n\n    return newParagraph;\n}\n\nfunction cloneTable(\n    table: ReadonlyContentModelTable,\n    options: CloneModelOptions\n): ContentModelTable {\n    const { cachedElement, widths, rows } = table;\n\n    return Object.assign(\n        {\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n            widths: Array.from(widths),\n            rows: rows.map(row => cloneTableRow(row, options)),\n        },\n        cloneBlockBase(table),\n        cloneModelWithDataset(table)\n    );\n}\n\nfunction cloneTableRow(\n    row: ReadonlyContentModelTableRow,\n    options: CloneModelOptions\n): ContentModelTableRow {\n    const { height, cells, cachedElement } = row;\n\n    return Object.assign(\n        {\n            height,\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n            cells: cells.map(cell => cloneTableCell(cell, options)),\n        },\n        cloneModelWithFormat(row)\n    );\n}\n\nfunction cloneTableCell(\n    cell: ReadonlyContentModelTableCell,\n    options: CloneModelOptions\n): ContentModelTableCell {\n    const { cachedElement, isSelected, spanAbove, spanLeft, isHeader } = cell;\n\n    return Object.assign(\n        {\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n            isSelected,\n            spanAbove,\n            spanLeft,\n            isHeader,\n        },\n        cloneBlockGroupBase(cell, options),\n        cloneModelWithFormat(cell),\n        cloneModelWithDataset(cell)\n    );\n}\n\nfunction cloneFormatContainer(\n    container: ReadonlyContentModelFormatContainer,\n    options: CloneModelOptions\n): ContentModelFormatContainer {\n    const { tagName, cachedElement } = container;\n    const newContainer: ContentModelFormatContainer = Object.assign(\n        { tagName, cachedElement: handleCachedElement(cachedElement, 'cache', options) },\n        cloneBlockBase(container),\n        cloneBlockGroupBase(container, options)\n    );\n\n    if (container.zeroFontSize) {\n        newContainer.zeroFontSize = true;\n    }\n\n    return newContainer;\n}\n\nfunction cloneListItem(\n    item: ReadonlyContentModelListItem,\n    options: CloneModelOptions\n): ContentModelListItem {\n    const { formatHolder, levels, cachedElement } = item;\n\n    return Object.assign(\n        {\n            formatHolder: cloneSelectionMarker(formatHolder),\n            levels: levels.map(cloneListLevel),\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n        },\n        cloneBlockBase(item),\n        cloneBlockGroupBase(item, options)\n    );\n}\n\nfunction cloneListLevel(level: ReadonlyContentModelListLevel): ContentModelListLevel {\n    const { listType } = level;\n\n    return Object.assign({ listType }, cloneModelWithFormat(level), cloneModelWithDataset(level));\n}\nfunction cloneDivider(\n    divider: ReadonlyContentModelDivider,\n    options: CloneModelOptions\n): ContentModelDivider {\n    const { tagName, isSelected, cachedElement } = divider;\n\n    return Object.assign(\n        {\n            isSelected,\n            tagName,\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n        },\n        cloneBlockBase(divider)\n    );\n}\n\nfunction cloneGeneralBlock(\n    general: ReadonlyContentModelGeneralBlock,\n    options: CloneModelOptions\n): ContentModelGeneralBlock {\n    const { element } = general;\n\n    return Object.assign(\n        {\n            element: handleCachedElement(element, 'general', options),\n        },\n        cloneBlockBase(general),\n        cloneBlockGroupBase(general, options)\n    );\n}\n\nfunction cloneSelectionMarker(\n    marker: ReadonlyContentModelSelectionMarker\n): ContentModelSelectionMarker {\n    return Object.assign({ isSelected: marker.isSelected }, cloneSegmentBase(marker));\n}\n\nfunction cloneImage(image: ReadonlyContentModelImage): ContentModelImage {\n    const { src, alt, title, isSelectedAsImageSelection } = image;\n\n    return Object.assign(\n        { src, alt, title, isSelectedAsImageSelection },\n        cloneSegmentBase(image),\n        cloneModelWithDataset(image)\n    );\n}\n\nfunction cloneGeneralSegment(\n    general: ReadonlyContentModelGeneralSegment,\n    options: CloneModelOptions\n): ContentModelGeneralSegment {\n    return Object.assign(cloneGeneralBlock(general, options), cloneSegmentBase(general));\n}\n\nfunction cloneText(textSegment: ReadonlyContentModelText): ContentModelText {\n    const { text } = textSegment;\n    return Object.assign({ text }, cloneSegmentBase(textSegment));\n}\n\nfunction handleCachedElement<T extends HTMLElement>(\n    node: T,\n    type: 'general' | 'entity',\n    options: CloneModelOptions\n): T;\n\nfunction handleCachedElement<T extends HTMLElement>(\n    node: T | undefined,\n    type: 'cache',\n    options: CloneModelOptions\n): T | undefined;\n\nfunction handleCachedElement<T extends HTMLElement>(\n    node: T | undefined,\n    type: 'general' | 'entity' | 'cache',\n    options: CloneModelOptions\n): T | undefined {\n    const { includeCachedElement } = options;\n\n    if (!node) {\n        return undefined;\n    } else if (!includeCachedElement) {\n        return type == 'cache' ? undefined : (node.cloneNode(true /*deep*/) as T);\n    } else if (includeCachedElement === true) {\n        return node;\n    } else {\n        const result = includeCachedElement(node, type) as T | undefined;\n\n        if ((type == 'general' || type == 'entity') && !result) {\n            throw new Error('Entity and General Model must has wrapper element');\n        }\n\n        return result;\n    }\n}\n","import type {\n    EntityRemovalOperation,\n    FormatContentModelContext,\n    ReadonlyContentModelBlock,\n} from 'roosterjs-content-model-types';\n\n/**\n * Delete a content model block from current selection\n * @param blocks Array of the block to delete\n * @param blockToDelete The block to delete\n * @param replacement @optional If specified, use this block to replace the deleted block\n * @param context @optional Context object provided by formatContentModel API\n * @param direction @optional Whether this is deleting forward or backward. This is only used for deleting entity.\n * If not specified, only selected entity will be deleted\n */\nexport function deleteBlock(\n    blocks: ReadonlyContentModelBlock[],\n    blockToDelete: ReadonlyContentModelBlock,\n    replacement?: ReadonlyContentModelBlock,\n    context?: FormatContentModelContext,\n    direction?: 'forward' | 'backward'\n): boolean {\n    const index = blocks.indexOf(blockToDelete);\n\n    switch (blockToDelete.blockType) {\n        case 'Table':\n        case 'Divider':\n            replacement ? blocks.splice(index, 1, replacement) : blocks.splice(index, 1);\n            return true;\n\n        case 'Entity':\n            const operation: EntityRemovalOperation | undefined = blockToDelete.isSelected\n                ? 'overwrite'\n                : direction == 'forward'\n                ? 'removeFromStart'\n                : direction == 'backward'\n                ? 'removeFromEnd'\n                : undefined;\n\n            if (operation !== undefined) {\n                replacement ? blocks.splice(index, 1, replacement) : blocks.splice(index, 1);\n                context?.deletedEntities.push({\n                    entity: blockToDelete,\n                    operation,\n                });\n            }\n\n            return true;\n\n        case 'BlockGroup':\n            switch (blockToDelete.blockGroupType) {\n                case 'General':\n                    if (replacement) {\n                        blocks.splice(index, 1, replacement);\n                        return true;\n                    } else {\n                        // no op, let browser handle it\n                        return false;\n                    }\n\n                case 'ListItem':\n                case 'FormatContainer':\n                    blocks.splice(index, 1);\n                    return true;\n            }\n    }\n\n    return false;\n}\n","import { createBr } from '../creators/createBr';\nimport { createParagraph } from '../creators/createParagraph';\nimport { createSelectionMarker } from '../creators/createSelectionMarker';\nimport { deleteBlock } from './deleteBlock';\nimport { deleteSegment } from './deleteSegment';\nimport { getSegmentTextFormat } from './getSegmentTextFormat';\nimport { iterateSelections } from '../selection/iterateSelections';\nimport { mutateBlock, mutateSegments } from '../common/mutate';\nimport { setParagraphNotImplicit } from '../block/setParagraphNotImplicit';\nimport type {\n    ContentModelSelectionMarker,\n    DeleteSelectionContext,\n    FormatContentModelContext,\n    InsertPoint,\n    IterateSelectionsOption,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n    ReadonlyTableSelectionContext,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\nconst DeleteSelectionIteratingOptions: IterateSelectionsOption = {\n    contentUnderSelectedTableCell: 'ignoreForTableOrCell', // When a table cell is selected, we replace all content for this cell, so no need to go into its content\n    contentUnderSelectedGeneralElement: 'generalElementOnly', // When a general element is selected, we replace the whole element so no need to go into its content\n    includeListFormatHolder: 'never',\n};\n\n/**\n * @internal\n * Iterate the model and find all selected content if any, delete them, and keep/create an insert point\n * at the first deleted position so that we know where to put cursor to after delete\n */\nexport function deleteExpandedSelection(\n    model: ReadonlyContentModelDocument,\n    formatContext?: FormatContentModelContext\n): DeleteSelectionContext {\n    const context: DeleteSelectionContext = {\n        deleteResult: 'notDeleted',\n        insertPoint: null,\n        formatContext,\n        undeletableSegments: [],\n    };\n\n    iterateSelections(\n        model,\n        (path, tableContext, readonlyBlock, readonlySegments) => {\n            // Set paragraph, format and index for default position where we will put cursor to.\n            // Later we can overwrite these info when process the selections\n            let paragraph: ShallowMutableContentModelParagraph = createParagraph(\n                true /*implicit*/,\n                undefined /*blockFormat*/,\n                model.format\n            );\n            let markerFormat = model.format;\n            let insertMarkerIndex = 0;\n\n            if (readonlySegments && readonlyBlock?.blockType == 'Paragraph') {\n                const [block, segments, indexes] = mutateSegments(readonlyBlock, readonlySegments);\n\n                // Delete segments inside a paragraph\n                if (segments[0]) {\n                    // Now that we have found a paragraph with selections, we can overwrite the default paragraph with this one\n                    // so we can put cursor here after delete\n                    paragraph = block;\n                    insertMarkerIndex = indexes[0];\n                    markerFormat = getSegmentTextFormat(segments[0], true /*includingBIU*/);\n\n                    const isFirstDeletingParagraph = !context.lastParagraph;\n\n                    context.lastParagraph = paragraph;\n                    context.lastTableContext = tableContext;\n\n                    segments.forEach((segment, i) => {\n                        if (\n                            i == 0 &&\n                            !context.insertPoint &&\n                            segment.segmentType == 'SelectionMarker'\n                        ) {\n                            // First time we hit a selection and it is a selection marker, just mark it and not need to delete\n                            // because this is possible a collapsed selection, then it will be handled later\n                            context.insertPoint = createInsertPoint(\n                                segment,\n                                block,\n                                path,\n                                tableContext\n                            );\n                        } else if (\n                            deleteSegment(\n                                block,\n                                segment,\n                                context.formatContext,\n                                undefined /*direction*/,\n                                isFirstDeletingParagraph ? undefined : context.undeletableSegments // For first paragraph we can keep undeletable segments so no need to merge it later\n                            )\n                        ) {\n                            context.deleteResult = 'range';\n                        }\n                    });\n\n                    // Since we are operating on this paragraph and it possible we delete everything from this paragraph,\n                    // Need to make it \"not implicit\" so that it will always have a container element, so that when we do normalization\n                    // of this paragraph, a BR can be added if need\n                    if (context.deleteResult == 'range') {\n                        setParagraphNotImplicit(block);\n                    }\n                }\n            } else if (readonlyBlock) {\n                // Delete a whole block (divider, table, ...)\n                const blocks = mutateBlock(path[0]).blocks;\n\n                if (deleteBlock(blocks, readonlyBlock, paragraph, context.formatContext)) {\n                    context.deleteResult = 'range';\n                }\n            } else if (tableContext) {\n                // Delete a whole table cell\n                const { table, colIndex, rowIndex } = tableContext;\n                const mutableTable = mutateBlock(table);\n                const row = mutableTable.rows[rowIndex];\n                const cell = mutateBlock(row.cells[colIndex]);\n\n                path = [cell, ...path];\n                paragraph.segments.push(createBr(model.format));\n                cell.blocks = [paragraph];\n\n                context.deleteResult = 'range';\n            }\n\n            if (!context.insertPoint) {\n                // If we have not got a insert point after delete and we have a paragraph to put an insert point in, create insert point now\n                const marker = createSelectionMarker(markerFormat);\n\n                setParagraphNotImplicit(paragraph);\n                paragraph.segments.splice(insertMarkerIndex, 0, marker);\n                context.insertPoint = createInsertPoint(marker, paragraph, path, tableContext);\n            }\n        },\n        DeleteSelectionIteratingOptions\n    );\n\n    return context;\n}\n\nfunction createInsertPoint(\n    marker: ContentModelSelectionMarker,\n    paragraph: ShallowMutableContentModelParagraph,\n    path: ReadonlyContentModelBlockGroup[],\n    tableContext: ReadonlyTableSelectionContext | undefined\n): InsertPoint {\n    return {\n        marker,\n        paragraph,\n        path,\n        tableContext,\n    };\n}\n","import { deleteSingleChar } from './deleteSingleChar';\nimport { isWhiteSpacePreserved } from '../../domUtils/isWhiteSpacePreserved';\nimport { mutateSegment } from '../common/mutate';\nimport { normalizeSingleSegment } from '../common/normalizeSegment';\nimport { normalizeText } from '../../domUtils/stringUtil';\nimport type {\n    EntityRemovalOperation,\n    FormatContentModelContext,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n    ShallowMutableContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * Delete a content model segment from current selection\n * @param readonlyParagraph Parent paragraph of the segment to delete\n * @param readonlySegmentToDelete The segment to delete\n * @param context @optional Context object provided by formatContentModel API\n * @param direction @optional Whether this is deleting forward or backward. This is only used for deleting entity.\n * @param undeletableSegments @optional When passed, if this segment is undeletable, it will be added to this array instead of being deleted.\n * If not specified, only selected entity will be deleted\n */\nexport function deleteSegment(\n    readonlyParagraph: ReadonlyContentModelParagraph,\n    readonlySegmentToDelete: ReadonlyContentModelSegment,\n    context?: FormatContentModelContext,\n    direction?: 'forward' | 'backward',\n    undeletableSegments?: ShallowMutableContentModelSegment[]\n): boolean {\n    const [paragraph, segmentToDelete, index] = mutateSegment(\n        readonlyParagraph,\n        readonlySegmentToDelete\n    );\n    const segments = paragraph.segments;\n    const preserveWhiteSpace = isWhiteSpacePreserved(paragraph.format.whiteSpace);\n    const isForward = direction == 'forward';\n    const isBackward = direction == 'backward';\n\n    if (!preserveWhiteSpace) {\n        normalizePreviousSegment(paragraph, segments, index);\n    }\n\n    switch (segmentToDelete?.segmentType) {\n        case 'Br':\n        case 'Image':\n        case 'SelectionMarker':\n            removeSegment(segments, index, direction, undeletableSegments);\n            return true;\n\n        case 'Entity':\n            const operation: EntityRemovalOperation | undefined = segmentToDelete.isSelected\n                ? 'overwrite'\n                : isForward\n                ? 'removeFromStart'\n                : isBackward\n                ? 'removeFromEnd'\n                : undefined;\n            if (operation !== undefined) {\n                removeSegment(segments, index, direction, undeletableSegments);\n                context?.deletedEntities.push({\n                    entity: segmentToDelete,\n                    operation,\n                });\n            }\n\n            return true;\n\n        case 'Text':\n            if (segmentToDelete.text.length == 0 || segmentToDelete.isSelected) {\n                segmentToDelete.text = '';\n                removeSegment(segments, index, direction, undeletableSegments);\n            } else if (direction) {\n                let text = segmentToDelete.text;\n\n                text = deleteSingleChar(text, isForward); //  isForward ? text.substring(1) : text.substring(0, text.length - 1);\n\n                if (!preserveWhiteSpace) {\n                    text = normalizeText(text, isForward);\n                }\n\n                segmentToDelete.text = text;\n\n                if (text == '') {\n                    removeSegment(segments, index, direction, undeletableSegments);\n                }\n            }\n\n            return true;\n\n        case 'General':\n            if (segmentToDelete.isSelected) {\n                removeSegment(segments, index, direction, undeletableSegments);\n                return true;\n            } else {\n                return false;\n            }\n\n        default:\n            return false;\n    }\n}\n\nfunction removeSegment(\n    segments: ShallowMutableContentModelSegment[],\n    index: number,\n    direction?: 'forward' | 'backward',\n    undeletableSegments?: ShallowMutableContentModelSegment[]\n) {\n    const segment = segments.splice(index, 1)[0];\n\n    if (segment.link?.format.undeletable) {\n        // Segment is not deletable, but at least we should unselect it\n        delete segment.isSelected;\n\n        if (undeletableSegments) {\n            // For undeletable segments, if an undeletableSegments array is passed in,\n            // put it into this array after we delete it, so caller knows that we have deleted some undeletable segments\n            // and do proper handling\n            undeletableSegments.push(segment);\n        } else {\n            // Otherwise, we need to reinsert it back to the segments array to keep the model consistent.\n            // We need to find the right place to insert it back based on the direction of deletion\n            let insertIndex: number;\n\n            switch (direction) {\n                case 'forward':\n                    insertIndex =\n                        index > 0 && segments[index - 1].segmentType == 'SelectionMarker'\n                            ? index - 1\n                            : index;\n                    break;\n\n                case 'backward':\n                    insertIndex =\n                        index < segments.length && segments[index].segmentType == 'SelectionMarker'\n                            ? index + 1\n                            : index;\n                    break;\n\n                default:\n                    insertIndex = index;\n            }\n\n            segments.splice(insertIndex, 0, segment);\n        }\n    }\n}\n\nfunction normalizePreviousSegment(\n    paragraph: ReadonlyContentModelParagraph,\n    segments: ReadonlyArray<ReadonlyContentModelSegment>,\n    currentIndex: number\n) {\n    let index = currentIndex - 1;\n\n    while (segments[index]?.segmentType == 'SelectionMarker') {\n        index--;\n    }\n\n    const segment = segments[index];\n\n    if (segment) {\n        normalizeSingleSegment(paragraph, segment);\n    }\n}\n","import { deleteExpandedSelection } from './deleteExpandedSelection';\nimport { mutateBlock } from '../common/mutate';\nimport { runEditSteps } from './runEditSteps';\nimport type {\n    DeleteSelectionContext,\n    DeleteSelectionResult,\n    DeleteSelectionStep,\n    FormatContentModelContext,\n    ReadonlyContentModelDocument,\n} from 'roosterjs-content-model-types';\n\n/**\n * Delete selected content from Content Model\n * @param model The model to delete selected content from\n * @param additionalSteps @optional Addition delete steps\n * @param formatContext @optional A context object provided by formatContentModel API\n * @returns A DeleteSelectionResult object to specify the deletion result\n */\nexport function deleteSelection(\n    model: ReadonlyContentModelDocument,\n    additionalSteps: (DeleteSelectionStep | null)[] = [],\n    formatContext?: FormatContentModelContext\n): DeleteSelectionResult {\n    const context = deleteExpandedSelection(model, formatContext);\n    const steps = additionalSteps.filter(\n        (x: DeleteSelectionStep | null): x is DeleteSelectionStep => !!x\n    );\n\n    runEditSteps(steps, context);\n\n    mergeParagraphAfterDelete(context);\n    return context;\n}\n\n// If we end up with multiple paragraphs impacted, we need to merge them\nfunction mergeParagraphAfterDelete(context: DeleteSelectionContext) {\n    const {\n        insertPoint,\n        deleteResult,\n        lastParagraph,\n        lastTableContext,\n        undeletableSegments,\n    } = context;\n\n    if (\n        insertPoint &&\n        deleteResult != 'notDeleted' &&\n        deleteResult != 'nothingToDelete' &&\n        lastParagraph &&\n        lastParagraph != insertPoint.paragraph &&\n        lastTableContext == insertPoint.tableContext\n    ) {\n        const mutableLastParagraph = mutateBlock(lastParagraph);\n        const mutableInsertingParagraph = mutateBlock(insertPoint.paragraph);\n\n        if (undeletableSegments) {\n            mutableLastParagraph.segments.unshift(...undeletableSegments);\n        }\n\n        mutableInsertingParagraph.segments.push(...mutableLastParagraph.segments);\n        mutableLastParagraph.segments = [];\n    }\n}\n","/**\n * @internal\n */\nexport function deleteSingleChar(text: string, isForward: boolean) {\n    // In case of emoji that occupies multiple characters, we need to delete the whole emoji\n    const array = [...text];\n    let deleteLength = 0;\n\n    for (\n        let i = isForward ? 0 : array.length - 1,\n            deleteState: 'notDeleted' | 'waiting' | 'done' = 'notDeleted';\n        i >= 0 && i < array.length && deleteState != 'done';\n        i += isForward ? 1 : -1\n    ) {\n        switch (array[i]) {\n            case '\\u200D': // ZERO WIDTH JOINER\n            case '\\u20E3': // COMBINING ENCLOSING KEYCAP\n            case '\\uFE0E': // VARIATION SELECTOR-15\n            case '\\uFE0F': // VARIATION SELECTOR-16\n                deleteState = 'notDeleted';\n                deleteLength++;\n                break;\n\n            default:\n                if (deleteState == 'notDeleted') {\n                    deleteState = 'waiting';\n                    deleteLength++;\n                } else if (deleteState == 'waiting') {\n                    deleteState = 'done';\n                }\n                break;\n        }\n    }\n\n    array.splice(isForward ? 0 : array.length - deleteLength, deleteLength);\n\n    return array.join('');\n}\n","import type {\n    ContentModelBlockGroup,\n    ContentModelBlockGroupType,\n    ReadonlyContentModelBlockGroup,\n    TypeOfBlockGroup,\n} from 'roosterjs-content-model-types';\n\n/**\n * Get index of closest ancestor block group of the expected block group type. If not found, return -1\n * @param path The block group path, from the closest one to root\n * @param blockGroupTypes The expected block group types\n * @param stopTypes @optional Block group types that will cause stop searching\n * @param isValidTarget @optional An additional callback to validate whether a matching block group is a valid target\n */\nexport function getClosestAncestorBlockGroupIndex<T extends ContentModelBlockGroup>(\n    path: ReadonlyContentModelBlockGroup[],\n    blockGroupTypes: TypeOfBlockGroup<T>[],\n    stopTypes: ContentModelBlockGroupType[] = [],\n    isValidTarget?: (block: ReadonlyContentModelBlockGroup) => boolean\n): number {\n    for (let i = 0; i < path.length; i++) {\n        const group = path[i];\n\n        if (\n            (blockGroupTypes as string[]).indexOf(group.blockGroupType) >= 0 &&\n            (!isValidTarget || isValidTarget(group))\n        ) {\n            return i;\n        } else if (stopTypes.indexOf(group.blockGroupType) >= 0) {\n            // Do not go across boundary specified by stopTypes.\n            // For example, in most case we will set table as the boundary,\n            // in order to allow modify list item under a table when the table itself is in another list item\n            // Although this is not very likely to happen in most case, but we still need to handle it\n            return -1;\n        }\n    }\n\n    return -1;\n}\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport { OrderedListStyleMap } from '../../constants/OrderedListStyleMap';\nimport { UnorderedListStyleMap } from '../../constants/UnorderedListStyleMap';\n\n/**\n * Gets the list style type that the bullet is part of, using the Constant record\n * @param listType whether the list is ordered or unordered\n * @param bullet bullet string\n * @returns the number of the style override or undefined if was not found in the Record\n */\nexport function getListStyleTypeFromString(listType: 'OL' | 'UL', bullet: string) {\n    const map = listType == 'OL' ? OrderedListStyleMap : UnorderedListStyleMap;\n    const keys = getObjectKeys(map);\n    const result = keys.find(key => map[key] == bullet);\n    if (result) {\n        return typeof result == 'string' ? parseInt(result) : result;\n    }\n    return result;\n}\n","import type {\n    ContentModelSegmentFormat,\n    ReadonlyContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * Get the text format of a segment, this function will return only format that is applicable to text\n * @param segment The segment to get format from\n * @param includingBIU When pass true, also get Bold/Italic/Underline format\n * @returns\n */\nexport function getSegmentTextFormat(\n    segment: ReadonlyContentModelSegment,\n    includingBIU?: boolean\n): ContentModelSegmentFormat {\n    const format = segment.format ?? {};\n    const textFormat: ContentModelSegmentFormat = {\n        fontFamily: format.fontFamily,\n        fontSize: format.fontSize,\n        textColor: format.textColor,\n        backgroundColor: format.backgroundColor,\n        letterSpacing: format.letterSpacing,\n        lineHeight: format.lineHeight,\n        fontWeight: includingBIU ? format.fontWeight : undefined,\n        italic: includingBIU ? format.italic : undefined,\n        underline: includingBIU ? format.underline : undefined,\n    };\n\n    return removeUndefinedValues(textFormat);\n}\n\nconst removeUndefinedValues = (format: ContentModelSegmentFormat): ContentModelSegmentFormat => {\n    const textFormat: Record<string, string | undefined | boolean | never[]> = {};\n    Object.keys(format).filter(key => {\n        const value = format[key as keyof ContentModelSegmentFormat];\n\n        if (value !== undefined) {\n            textFormat[key] = value;\n        }\n    });\n    return textFormat;\n};\n","import { addBlock } from '../common/addBlock';\nimport { addSegment } from '../common/addSegment';\nimport { applyTableFormat } from './applyTableFormat';\nimport { createListItem } from '../creators/createListItem';\nimport { createParagraph } from '../creators/createParagraph';\nimport { createSelectionMarker } from '../creators/createSelectionMarker';\nimport { createTableCell } from '../creators/createTableCell';\nimport { deleteSelection } from './deleteSelection';\nimport { EmptySegmentFormat } from '../../constants/EmptySegmentFormat';\nimport { getClosestAncestorBlockGroupIndex } from './getClosestAncestorBlockGroupIndex';\nimport { getObjectKeys } from '../..//domUtils/getObjectKeys';\nimport { mutateBlock } from '../common/mutate';\nimport { normalizeContentModel } from '../common/normalizeContentModel';\nimport { normalizeTable } from './normalizeTable';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockFormat,\n    ContentModelDocument,\n    ContentModelHyperLinkFormat,\n    ContentModelListItem,\n    ContentModelParagraph,\n    ContentModelSegmentFormat,\n    ContentModelTable,\n    FormatContentModelContext,\n    InsertPoint,\n    MergeModelOption,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\nconst HeadingTags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\nconst KeysOfSegmentFormat = getObjectKeys(EmptySegmentFormat);\n\ntype MergeFormatTypes = 'mergeAll' | 'keepSourceEmphasisFormat' | 'preferSource' | 'preferTarget';\n\n/**\n * Merge source model into target mode\n * @param target Target Content Model that will merge content into\n * @param source Source Content Model will be merged to target model\n * @param context Format context. When call this function inside formatContentModel, provide this context so that formatContentModel will do extra handling to the result\n * @param options More options, see MergeModelOption\n * @returns Insert point after merge, or null if there is no insert point\n */\nexport function mergeModel(\n    target: ReadonlyContentModelDocument,\n    source: ContentModelDocument,\n    context?: FormatContentModelContext,\n    options?: MergeModelOption\n): InsertPoint | null {\n    const insertPosition =\n        options?.insertPosition ?? deleteSelection(target, [], context).insertPoint;\n\n    const { addParagraphAfterMergedContent, mergeFormat, mergeTable } = options || {};\n\n    if (addParagraphAfterMergedContent && !mergeTable) {\n        const { paragraph, marker } = insertPosition || {};\n        const newPara = createParagraph(false /* isImplicit */, paragraph?.format, marker?.format);\n        addBlock(source, newPara);\n    }\n\n    if (insertPosition) {\n        if (mergeFormat && mergeFormat != 'none') {\n            const newFormat: ContentModelSegmentFormat = {\n                ...(target.format || {}),\n                ...insertPosition.marker.format,\n            };\n\n            applyDefaultFormat(source, newFormat, mergeFormat);\n        }\n\n        for (let i = 0; i < source.blocks.length; i++) {\n            const block = source.blocks[i];\n\n            switch (block.blockType) {\n                case 'Paragraph':\n                    mergeParagraph(insertPosition, block, i == 0, context, options);\n                    break;\n\n                case 'Divider':\n                    insertBlock(insertPosition, block);\n                    break;\n\n                case 'Entity':\n                    insertBlock(insertPosition, block);\n                    context?.newEntities.push(block);\n                    break;\n\n                case 'Table':\n                    if (source.blocks.length == 1 && mergeTable) {\n                        mergeTables(insertPosition, block, source);\n                    } else {\n                        insertBlock(insertPosition, block);\n                    }\n                    break;\n\n                case 'BlockGroup':\n                    switch (block.blockGroupType) {\n                        case 'General':\n                        case 'FormatContainer':\n                            insertBlock(insertPosition, block);\n                            break;\n                        case 'ListItem':\n                            mergeList(insertPosition, block);\n                            break;\n                    }\n                    break;\n            }\n        }\n    }\n\n    normalizeContentModel(target);\n\n    return insertPosition;\n}\n\nfunction mergeParagraph(\n    markerPosition: InsertPoint,\n    newPara: ContentModelParagraph,\n    mergeToCurrentParagraph: boolean,\n    context?: FormatContentModelContext,\n    option?: MergeModelOption\n) {\n    const { paragraph, marker } = markerPosition;\n    const newParagraph = mergeToCurrentParagraph\n        ? paragraph\n        : splitParagraph(markerPosition, newPara.format);\n    const segmentIndex = newParagraph.segments.indexOf(marker);\n\n    if (option?.mergeFormat == 'none' && mergeToCurrentParagraph) {\n        newParagraph.segments.forEach(segment => {\n            segment.format = { ...(newParagraph.segmentFormat || {}), ...segment.format };\n        });\n        delete newParagraph.segmentFormat;\n    }\n    if (segmentIndex >= 0) {\n        for (let i = 0; i < newPara.segments.length; i++) {\n            const segment = newPara.segments[i];\n\n            newParagraph.segments.splice(segmentIndex + i, 0, segment);\n\n            if (context) {\n                if (segment.segmentType == 'Entity') {\n                    context.newEntities.push(segment);\n                }\n\n                if (segment.segmentType == 'Image') {\n                    context.newImages.push(segment);\n                }\n            }\n        }\n    }\n\n    if (newPara.decorator) {\n        newParagraph.decorator = { ...newPara.decorator };\n        if (HeadingTags.indexOf(newParagraph.decorator.tagName) > -1) {\n            const sourceKeys: (keyof ContentModelSegmentFormat)[] = getObjectKeys(\n                newParagraph.decorator.format\n            );\n            const segmentDecoratorKeys: (keyof ContentModelSegmentFormat)[] = getObjectKeys(\n                newParagraph.segmentFormat || {}\n            );\n\n            sourceKeys.forEach(key => {\n                if (segmentDecoratorKeys.indexOf(key) > -1) {\n                    delete newParagraph.segmentFormat?.[key];\n                }\n            });\n        }\n    }\n\n    if (!mergeToCurrentParagraph) {\n        newParagraph.format = newPara.format;\n    } else {\n        newParagraph.format = {\n            ...newParagraph.format,\n            ...newPara.format,\n        };\n    }\n}\n\nfunction mergeTables(\n    markerPosition: InsertPoint,\n    newTable: ContentModelTable,\n    source: ContentModelDocument\n) {\n    const { tableContext, marker } = markerPosition;\n\n    if (tableContext && source.blocks.length == 1 && source.blocks[0] == newTable) {\n        const { table: readonlyTable, colIndex, rowIndex } = tableContext;\n        const table = mutateBlock(readonlyTable);\n\n        for (let i = 0; i < newTable.rows.length; i++) {\n            for (let j = 0; j < newTable.rows[i].cells.length; j++) {\n                const newCell = newTable.rows[i].cells[j];\n\n                if (i == 0 && colIndex + j >= table.rows[0].cells.length) {\n                    for (let k = 0; k < table.rows.length; k++) {\n                        const leftCell = table.rows[k]?.cells[colIndex + j - 1];\n                        table.rows[k].cells[colIndex + j] = createTableCell(\n                            false /*spanLeft*/,\n                            false /*spanAbove*/,\n                            leftCell?.isHeader,\n                            leftCell?.format\n                        );\n                    }\n                }\n\n                if (j == 0 && rowIndex + i >= table.rows.length) {\n                    if (!table.rows[rowIndex + i]) {\n                        table.rows[rowIndex + i] = {\n                            cells: [],\n                            format: {},\n                            height: 0,\n                        };\n                    }\n\n                    for (let k = 0; k < table.rows[rowIndex].cells.length; k++) {\n                        const aboveCell = table.rows[rowIndex + i - 1]?.cells[k];\n                        table.rows[rowIndex + i].cells[k] = createTableCell(\n                            false /*spanLeft*/,\n                            false /*spanAbove*/,\n                            false /*isHeader*/,\n                            aboveCell?.format\n                        );\n                    }\n                }\n\n                const oldCell = table.rows[rowIndex + i].cells[colIndex + j];\n                table.rows[rowIndex + i].cells[colIndex + j] = newCell;\n\n                if (i == 0 && j == 0) {\n                    const newMarker = createSelectionMarker(marker.format);\n                    const newPara = addSegment(newCell, newMarker);\n\n                    if (markerPosition.path[0] == oldCell) {\n                        // Update insert point to match the change result\n                        markerPosition.path[0] = newCell;\n                        markerPosition.marker = newMarker;\n                        markerPosition.paragraph = newPara;\n                    }\n                }\n            }\n        }\n\n        normalizeTable(table, markerPosition.marker.format);\n        applyTableFormat(table, undefined /*newFormat*/, true /*keepCellShade*/);\n    } else {\n        insertBlock(markerPosition, newTable);\n    }\n}\n\nfunction mergeList(markerPosition: InsertPoint, newList: ContentModelListItem) {\n    splitParagraph(markerPosition, newList.format);\n\n    const { path, paragraph } = markerPosition;\n\n    const listItemIndex = getClosestAncestorBlockGroupIndex(path, ['ListItem'], ['TableCell']);\n    const listItem = path[listItemIndex] as ContentModelListItem;\n    const listParent = path[listItemIndex + 1]; // It is ok here when index is -1, that means there is no list and we just insert a new paragraph and use path[0] as its parent\n    const blockIndex = listParent.blocks.indexOf(listItem || paragraph);\n\n    if (blockIndex >= 0) {\n        mutateBlock(listParent).blocks.splice(blockIndex, 0, newList);\n    }\n\n    if (listItem) {\n        listItem?.levels.forEach((level, i) => {\n            newList.levels[i] = { ...level };\n        });\n    }\n}\n\nfunction splitParagraph(markerPosition: InsertPoint, newParaFormat: ContentModelBlockFormat) {\n    const { paragraph, marker, path } = markerPosition;\n    const segmentIndex = paragraph.segments.indexOf(marker);\n    const paraIndex = path[0].blocks.indexOf(paragraph);\n    const newParagraph: ShallowMutableContentModelParagraph = createParagraph(\n        false /*isImplicit*/,\n        { ...paragraph.format, ...newParaFormat },\n        paragraph.segmentFormat\n    );\n\n    if (segmentIndex >= 0) {\n        newParagraph.segments = paragraph.segments.splice(segmentIndex);\n    }\n\n    if (paraIndex >= 0) {\n        mutateBlock(path[0]).blocks.splice(paraIndex + 1, 0, newParagraph);\n    }\n\n    const listItemIndex = getClosestAncestorBlockGroupIndex(\n        path,\n        ['ListItem'],\n        ['FormatContainer', 'TableCell']\n    );\n    const listItem = path[listItemIndex] as ContentModelListItem;\n\n    if (listItem) {\n        const listParent = listItemIndex >= 0 ? path[listItemIndex + 1] : null;\n        const blockIndex = listParent ? listParent.blocks.indexOf(listItem) : -1;\n\n        if (blockIndex >= 0 && listParent) {\n            const newListItem = createListItem(listItem.levels, listItem.formatHolder.format);\n\n            if (paraIndex >= 0) {\n                newListItem.blocks = listItem.blocks.splice(paraIndex + 1);\n            }\n\n            if (blockIndex >= 0) {\n                mutateBlock(listParent).blocks.splice(blockIndex + 1, 0, newListItem);\n            }\n\n            path[listItemIndex] = newListItem;\n        }\n    }\n\n    markerPosition.paragraph = newParagraph;\n\n    return newParagraph;\n}\n\nfunction insertBlock(markerPosition: InsertPoint, block: ContentModelBlock) {\n    const { path } = markerPosition;\n    const newParaFormat = block.blockType !== 'Paragraph' ? {} : block.format;\n    const newPara = splitParagraph(markerPosition, newParaFormat);\n    const blockIndex = path[0].blocks.indexOf(newPara);\n\n    if (blockIndex >= 0) {\n        mutateBlock(path[0]).blocks.splice(blockIndex, 0, block);\n    }\n}\n\nfunction applyDefaultFormat(\n    group: ReadonlyContentModelBlockGroup,\n    format: ContentModelSegmentFormat,\n    applyDefaultFormatOption: MergeFormatTypes\n) {\n    group.blocks.forEach(block => {\n        mergeBlockFormat(applyDefaultFormatOption, block);\n\n        switch (block.blockType) {\n            case 'BlockGroup':\n                if (block.blockGroupType == 'ListItem') {\n                    mutateBlock(block).formatHolder.format = mergeSegmentFormat(\n                        applyDefaultFormatOption,\n                        format,\n                        block.formatHolder.format\n                    );\n                }\n                applyDefaultFormat(block, format, applyDefaultFormatOption);\n                break;\n\n            case 'Table':\n                block.rows.forEach(row =>\n                    row.cells.forEach(cell => {\n                        applyDefaultFormat(cell, format, applyDefaultFormatOption);\n                    })\n                );\n                break;\n\n            case 'Paragraph':\n                const paragraphFormat = block.decorator?.format || {};\n                const paragraph = mutateBlock(block);\n\n                paragraph.segments.forEach(segment => {\n                    if (segment.segmentType == 'General') {\n                        applyDefaultFormat(segment, format, applyDefaultFormatOption);\n                    }\n\n                    segment.format = mergeSegmentFormat(applyDefaultFormatOption, format, {\n                        ...paragraphFormat,\n                        ...segment.format,\n                    });\n\n                    if (segment.link) {\n                        segment.link.format = mergeLinkFormat(\n                            applyDefaultFormatOption,\n                            format,\n                            segment.link.format\n                        );\n                    }\n                });\n\n                if (applyDefaultFormatOption === 'keepSourceEmphasisFormat') {\n                    delete paragraph.decorator;\n                }\n                break;\n        }\n    });\n}\n\nfunction mergeBlockFormat(applyDefaultFormatOption: string, block: ReadonlyContentModelBlock) {\n    if (applyDefaultFormatOption == 'keepSourceEmphasisFormat' && block.format.backgroundColor) {\n        delete mutateBlock(block).format.backgroundColor;\n    }\n}\n\n/**\n * Hyperlink format type definition only contains backgroundColor and underline.\n * So create a minimum object with the styles supported in Hyperlink to be used in merge.\n */\nfunction getSegmentFormatInLinkFormat(\n    targetFormat: ContentModelSegmentFormat\n): ContentModelSegmentFormat {\n    const result: ContentModelHyperLinkFormat = {};\n    if (targetFormat.backgroundColor) {\n        result.backgroundColor = targetFormat.backgroundColor;\n    }\n    if (targetFormat.underline) {\n        result.underline = targetFormat.underline;\n    }\n\n    return result;\n}\n\nfunction mergeLinkFormat(\n    applyDefaultFormatOption: MergeFormatTypes,\n    targetFormat: ContentModelSegmentFormat,\n    sourceFormat: ContentModelHyperLinkFormat\n) {\n    switch (applyDefaultFormatOption) {\n        case 'mergeAll':\n        case 'preferSource':\n            return { ...getSegmentFormatInLinkFormat(targetFormat), ...sourceFormat };\n        case 'keepSourceEmphasisFormat':\n            return {\n                // Hyperlink segment format contains other attributes such as LinkFormat\n                // so we have to retain them\n                ...getFormatWithoutSegmentFormat(sourceFormat),\n                // Link format only have Text color, background color, Underline, but only\n                // text color + background color should be merged from the target\n                ...getSegmentFormatInLinkFormat(targetFormat),\n                // Get the semantic format of the source\n                ...getSemanticFormat(sourceFormat),\n                // The text color of the hyperlink should not be merged and\n                // we should always retain the source text color\n                ...getHyperlinkTextColor(sourceFormat),\n            };\n        case 'preferTarget':\n            return { ...sourceFormat, ...getSegmentFormatInLinkFormat(targetFormat) };\n    }\n}\n\nfunction mergeSegmentFormat(\n    applyDefaultFormatOption: MergeFormatTypes,\n    targetFormat: ContentModelSegmentFormat,\n    sourceFormat: ContentModelSegmentFormat\n): ContentModelSegmentFormat {\n    switch (applyDefaultFormatOption) {\n        case 'mergeAll':\n        case 'preferSource':\n            return { ...targetFormat, ...sourceFormat };\n        case 'preferTarget':\n            return { ...sourceFormat, ...targetFormat };\n        case 'keepSourceEmphasisFormat':\n            return {\n                ...getFormatWithoutSegmentFormat(sourceFormat),\n                ...targetFormat,\n                ...getSemanticFormat(sourceFormat),\n            };\n    }\n}\n\nfunction getSemanticFormat(segmentFormat: ContentModelSegmentFormat): ContentModelSegmentFormat {\n    const result: ContentModelSegmentFormat = {};\n\n    const { fontWeight, italic, underline } = segmentFormat;\n\n    if (fontWeight && fontWeight != 'normal') {\n        result.fontWeight = fontWeight;\n    }\n    if (italic) {\n        result.italic = italic;\n    }\n    if (underline) {\n        result.underline = underline;\n    }\n\n    return result;\n}\n\n/**\n * Segment format can also contain other type of metadata, for example in Images/Hyperlink,\n * we want to preserve these properties when merging format\n */\nfunction getFormatWithoutSegmentFormat(\n    sourceFormat: ContentModelSegmentFormat\n): ContentModelSegmentFormat {\n    const resultFormat = {\n        ...sourceFormat,\n    };\n    KeysOfSegmentFormat.forEach(key => delete resultFormat[key]);\n    return resultFormat;\n}\nfunction getHyperlinkTextColor(sourceFormat: ContentModelHyperLinkFormat) {\n    const result: ContentModelHyperLinkFormat = {};\n    if (sourceFormat.textColor) {\n        result.textColor = sourceFormat.textColor;\n    }\n\n    return result;\n}\n","import { addBlock } from '../common/addBlock';\nimport { addSegment } from '../common/addSegment';\nimport { createBr } from '../creators/createBr';\nimport { createParagraph } from '../creators/createParagraph';\nimport { mutateBlock } from '../common/mutate';\nimport type {\n    ContentModelSegmentFormat,\n    ReadonlyContentModelSegment,\n    ReadonlyContentModelTable,\n    ReadonlyContentModelTableCell,\n} from 'roosterjs-content-model-types';\n\n/**\n * Minimum width for a table cell\n */\nexport const MIN_ALLOWED_TABLE_CELL_WIDTH: number = 30;\n/**\n * Minimum height for a table cell\n */\nexport const MIN_ALLOWED_TABLE_CELL_HEIGHT: number = 22;\n\n/**\n * Normalize a Content Model table, make sure:\n * 1. Fist cells are not spanned\n * 2. Only first column and row can have headers\n * 3. All cells have content\n * 4. Table and table row have correct width/height\n * 5. Spanned cell has no child blocks\n * 6. default format is correctly applied\n * @param readonlyTable The table to normalize\n * @param defaultSegmentFormat @optional Default segment format to apply to cell\n */\nexport function normalizeTable(\n    readonlyTable: ReadonlyContentModelTable,\n    defaultSegmentFormat?: ContentModelSegmentFormat\n) {\n    const table = mutateBlock(readonlyTable);\n\n    // Collapse border and use border box for table in roosterjs to make layout simpler\n    // But if this is a legacy style table (table with deprecated border attributes), we should not change its border model\n    const format = table.format;\n\n    if (!format.cellSpacing && !format.cellPadding && !format.legacyTableBorder) {\n        format.borderCollapse = true;\n        format.useBorderBox = true;\n    }\n\n    // Make sure all first cells are not spanned\n    // Make sure all inner cells are not header\n    // Make sure all cells have content and width\n    table.rows.forEach((row, rowIndex) => {\n        row.cells.forEach((readonlyCell, colIndex) => {\n            const cell = mutateBlock(readonlyCell);\n\n            if (cell.blocks.length == 0) {\n                const format = cell.format.textColor\n                    ? {\n                          ...defaultSegmentFormat,\n                          textColor: cell.format.textColor,\n                      }\n                    : defaultSegmentFormat;\n                addBlock(\n                    cell,\n                    createParagraph(undefined /*isImplicit*/, undefined /*blockFormat*/, format)\n                );\n                addSegment(cell, createBr(format));\n            }\n\n            if (rowIndex == 0) {\n                cell.spanAbove = false;\n            } else if (rowIndex > 0 && colIndex > 0 && cell.isHeader) {\n                cell.isHeader = false;\n            }\n\n            if (colIndex == 0) {\n                cell.spanLeft = false;\n            }\n\n            cell.format.useBorderBox = true;\n        });\n\n        // Make sure table has correct width and height array\n        if (row.height < MIN_ALLOWED_TABLE_CELL_HEIGHT) {\n            row.height = MIN_ALLOWED_TABLE_CELL_HEIGHT;\n        }\n    });\n\n    // Move blocks from spanned cell to its main cell if any,\n    // and remove rows/columns if all cells in it are spanned\n    const colCount = table.rows[0]?.cells.length || 0;\n\n    for (let colIndex = colCount - 1; colIndex > 0; colIndex--) {\n        table.rows.forEach(row => {\n            const cell = row.cells[colIndex];\n            const leftCell = row.cells[colIndex - 1];\n            if (cell && leftCell && cell.spanLeft) {\n                tryMoveBlocks(leftCell, cell);\n            }\n        });\n\n        if (table.rows.every(row => row.cells[colIndex]?.spanLeft)) {\n            table.rows.forEach(row => row.cells.splice(colIndex, 1));\n\n            if (\n                typeof table.widths[colIndex] === 'number' &&\n                typeof table.widths[colIndex - 1] === 'number'\n            ) {\n                table.widths.splice(\n                    colIndex - 1,\n                    2,\n                    table.widths[colIndex - 1] + table.widths[colIndex]\n                );\n            } else {\n                table.widths.splice(colIndex, 1);\n            }\n        }\n    }\n\n    for (let rowIndex = table.rows.length - 1; rowIndex > 0; rowIndex--) {\n        const row = table.rows[rowIndex];\n\n        row.cells.forEach((cell, colIndex) => {\n            const aboveCell = table.rows[rowIndex - 1]?.cells[colIndex];\n            if (aboveCell && cell.spanAbove) {\n                tryMoveBlocks(aboveCell, cell);\n            }\n        });\n\n        if (row.cells.every(cell => cell.spanAbove)) {\n            table.rows[rowIndex - 1].height += row.height;\n            table.rows.splice(rowIndex, 1);\n        }\n    }\n}\n\nfunction tryMoveBlocks(\n    targetCell: ReadonlyContentModelTableCell,\n    sourceCell: ReadonlyContentModelTableCell\n) {\n    const onlyHasEmptyOrBr = sourceCell.blocks.every(\n        block => block.blockType == 'Paragraph' && hasOnlyBrSegment(block.segments)\n    );\n\n    if (!onlyHasEmptyOrBr) {\n        mutateBlock(targetCell).blocks.push(...sourceCell.blocks);\n        mutateBlock(sourceCell).blocks = [];\n    }\n}\n\nfunction hasOnlyBrSegment(segments: ReadonlyArray<ReadonlyContentModelSegment>): boolean {\n    segments = segments.filter(s => s.segmentType != 'SelectionMarker');\n\n    return segments.length == 0 || (segments.length == 1 && segments[0].segmentType == 'Br');\n}\n","import { extractBorderValues } from '../../domUtils/style/borderValues';\nimport { getClosestAncestorBlockGroupIndex } from './getClosestAncestorBlockGroupIndex';\nimport { getImageMetadata } from '../metadata/updateImageMetadata';\nimport { getTableMetadata } from '../metadata/updateTableMetadata';\nimport { isBold } from '../../domUtils/style/isBold';\nimport { iterateSelections } from '../selection/iterateSelections';\nimport { parseValueWithUnit } from '../../formatHandlers/utils/parseValueWithUnit';\nimport type {\n    ConflictFormatSolution,\n    ContentModelFormatState,\n    ContentModelSegmentFormat,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelImage,\n    ReadonlyTableSelectionContext,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelFormatContainer,\n    ReadonlyContentModelListItem,\n    ReadonlyContentModelDocument,\n    DOMHelper,\n    DarkColorHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * Retrieve format state from the given Content Model\n * @param model The Content Model to retrieve format state from\n * @param pendingFormat Existing pending format, if any\n * @param formatState Existing format state object, used for receiving the result\n * @param conflictSolution The strategy for handling format conflicts\n * @param domHelper Optional DOMHelper to retrieve container format\n * @param isInDarkMode Optional flag to indicate if the environment is in dark mode\n * @param colorHandler Optional DarkColorHandler to handle dark mode colors\n *\n */\nexport function retrieveModelFormatState(\n    model: ReadonlyContentModelDocument,\n    pendingFormat: ContentModelSegmentFormat | null,\n    formatState: ContentModelFormatState,\n    conflictSolution: ConflictFormatSolution = 'remove',\n    domHelper?: DOMHelper,\n    isInDarkMode?: boolean,\n    colorHandler?: DarkColorHandler\n) {\n    let firstTableContext: ReadonlyTableSelectionContext | undefined;\n    let firstBlock: ReadonlyContentModelBlock | undefined;\n    let isFirst = true;\n    let isFirstImage = true;\n    let isFirstSegment = true;\n    let containerFormat: ContentModelSegmentFormat | undefined = undefined;\n\n    const modelFormat = { ...model.format };\n\n    delete modelFormat.italic;\n    delete modelFormat.underline;\n    delete modelFormat.fontWeight;\n\n    iterateSelections(\n        model,\n        (path, tableContext, block, segments) => {\n            // Structure formats\n            retrieveStructureFormat(formatState, path, isFirst, conflictSolution);\n\n            // Multiple line format\n            if (block) {\n                if (firstBlock) {\n                    formatState.isMultilineSelection = true;\n                } else {\n                    firstBlock = block;\n                }\n            }\n\n            if (block?.blockType == 'Paragraph') {\n                // Paragraph formats\n                retrieveParagraphFormat(formatState, block, isFirst, conflictSolution);\n\n                // Segment formats\n                segments?.forEach(segment => {\n                    if (isFirstSegment || segment.segmentType != 'SelectionMarker') {\n                        let currentFormat = Object.assign(\n                            {},\n                            block.format,\n                            block.decorator?.format,\n                            segment.format,\n                            segment.code?.format,\n                            segment.link?.format,\n                            pendingFormat\n                        );\n\n                        // Sometimes the content may not specify all required format but just leverage the container format to do so.\n                        // In this case, we need to merge the container format into the current format\n                        // to make sure the current format contains all required format.\n                        if (!hasAllRequiredFormat(currentFormat)) {\n                            if (!containerFormat) {\n                                containerFormat =\n                                    domHelper?.getContainerFormat(isInDarkMode, colorHandler) ??\n                                    modelFormat;\n                            }\n\n                            currentFormat = Object.assign({}, containerFormat, currentFormat);\n                        }\n\n                        retrieveSegmentFormat(\n                            formatState,\n                            isFirst,\n                            currentFormat,\n                            conflictSolution\n                        );\n\n                        mergeValue(\n                            formatState,\n                            'isCodeInline',\n                            !!segment?.code,\n                            isFirst,\n                            conflictSolution\n                        );\n                    }\n\n                    // We only care the format of selection marker when it is the first selected segment. This is because when selection marker\n                    // is after some other selected segments, it mostly like appears at the beginning of a seconde line when the whole first line\n                    // is selected (e.g. triple-click on a line) then the second selection marker doesn't contain a correct format, so we need to\n                    // ignore it\n                    isFirstSegment = false;\n\n                    formatState.canUnlink = formatState.canUnlink || !!segment.link;\n                    formatState.canAddImageAltText =\n                        formatState.canAddImageAltText ||\n                        segments.some(segment => segment.segmentType == 'Image');\n\n                    isFirst = false;\n\n                    if (segment.segmentType === 'Image') {\n                        if (isFirstImage) {\n                            retrieveImageFormat(segment, formatState);\n                            isFirstImage = false;\n                        } else {\n                            formatState.imageFormat = undefined;\n                            formatState.imageEditingMetadata = undefined;\n                        }\n                    }\n                });\n\n                isFirst = false;\n            }\n\n            if (tableContext) {\n                if (firstTableContext) {\n                    const { table, colIndex, rowIndex } = firstTableContext;\n\n                    // Merge table format\n                    if (\n                        tableContext.table == table &&\n                        (tableContext.colIndex != colIndex || tableContext.rowIndex != rowIndex)\n                    ) {\n                        formatState.canMergeTableCell = true;\n                        formatState.isMultilineSelection = true;\n                    }\n                } else {\n                    // Table formats\n                    retrieveTableFormat(tableContext, formatState);\n                    firstTableContext = tableContext;\n                }\n            }\n        },\n        {\n            includeListFormatHolder: 'never',\n        }\n    );\n\n    if (formatState.fontSize) {\n        formatState.fontSize = px2Pt(formatState.fontSize);\n    }\n}\n\nfunction retrieveSegmentFormat(\n    result: ContentModelFormatState,\n    isFirst: boolean,\n    mergedFormat: ContentModelSegmentFormat,\n    conflictSolution: ConflictFormatSolution = 'remove'\n) {\n    const superOrSubscript = mergedFormat.superOrSubScriptSequence?.split(' ')?.pop();\n\n    mergeValue(result, 'isBold', isBold(mergedFormat.fontWeight), isFirst, conflictSolution);\n    mergeValue(result, 'isItalic', mergedFormat.italic, isFirst, conflictSolution);\n    mergeValue(result, 'isUnderline', mergedFormat.underline, isFirst, conflictSolution);\n    mergeValue(result, 'isStrikeThrough', mergedFormat.strikethrough, isFirst, conflictSolution);\n    mergeValue(result, 'isSuperscript', superOrSubscript == 'super', isFirst, conflictSolution);\n    mergeValue(result, 'isSubscript', superOrSubscript == 'sub', isFirst, conflictSolution);\n    mergeValue(result, 'letterSpacing', mergedFormat.letterSpacing, isFirst, conflictSolution);\n\n    mergeValue(result, 'fontName', mergedFormat.fontFamily, isFirst, conflictSolution);\n    mergeValue(\n        result,\n        'fontSize',\n        mergedFormat.fontSize,\n        isFirst,\n        conflictSolution,\n        val => parseValueWithUnit(val, undefined, 'pt') + 'pt'\n    );\n    mergeValue(result, 'backgroundColor', mergedFormat.backgroundColor, isFirst, conflictSolution);\n    mergeValue(result, 'textColor', mergedFormat.textColor, isFirst, conflictSolution);\n    mergeValue(result, 'fontWeight', mergedFormat.fontWeight, isFirst, conflictSolution);\n    mergeValue(result, 'lineHeight', mergedFormat.lineHeight, isFirst, conflictSolution);\n}\n\nfunction retrieveParagraphFormat(\n    result: ContentModelFormatState,\n    paragraph: ReadonlyContentModelParagraph,\n    isFirst: boolean,\n    conflictSolution: ConflictFormatSolution = 'remove'\n) {\n    const headingLevel = parseInt((paragraph.decorator?.tagName || '').substring(1));\n    const validHeadingLevel = headingLevel >= 1 && headingLevel <= 6 ? headingLevel : undefined;\n\n    mergeValue(result, 'marginBottom', paragraph.format.marginBottom, isFirst, conflictSolution);\n    mergeValue(result, 'marginTop', paragraph.format.marginTop, isFirst, conflictSolution);\n    mergeValue(result, 'headingLevel', validHeadingLevel, isFirst, conflictSolution);\n    mergeValue(result, 'textAlign', paragraph.format.textAlign, isFirst, conflictSolution);\n    mergeValue(result, 'direction', paragraph.format.direction, isFirst, conflictSolution);\n}\n\nfunction retrieveStructureFormat(\n    result: ContentModelFormatState,\n    path: ReadonlyContentModelBlockGroup[],\n    isFirst: boolean,\n    conflictSolution: ConflictFormatSolution = 'remove'\n) {\n    const listItemIndex = getClosestAncestorBlockGroupIndex(path, ['ListItem'], []);\n    const containerIndex = getClosestAncestorBlockGroupIndex(path, ['FormatContainer'], []);\n\n    if (listItemIndex >= 0) {\n        const listItem = path[listItemIndex] as ReadonlyContentModelListItem;\n        const listType = listItem?.levels[listItem.levels.length - 1]?.listType;\n\n        mergeValue(result, 'isBullet', listType == 'UL', isFirst, conflictSolution);\n        mergeValue(result, 'isNumbering', listType == 'OL', isFirst, conflictSolution);\n    }\n\n    mergeValue(\n        result,\n        'isBlockQuote',\n        containerIndex >= 0 &&\n            (path[containerIndex] as ReadonlyContentModelFormatContainer)?.tagName == 'blockquote',\n        isFirst,\n        conflictSolution\n    );\n}\n\nfunction retrieveTableFormat(\n    tableContext: ReadonlyTableSelectionContext,\n    result: ContentModelFormatState\n) {\n    const tableFormat = getTableMetadata(tableContext.table);\n\n    result.isInTable = true;\n    result.tableHasHeader = tableContext.table.rows.some(row =>\n        row.cells.some(cell => cell.isHeader)\n    );\n\n    if (tableFormat) {\n        result.tableFormat = tableFormat;\n    }\n}\n\nfunction retrieveImageFormat(image: ReadonlyContentModelImage, result: ContentModelFormatState) {\n    const { format } = image;\n    const borderKey = 'borderTop';\n    const extractedBorder = extractBorderValues(format[borderKey]);\n    const borderColor = extractedBorder.color;\n    const borderWidth = extractedBorder.width;\n    const borderStyle = extractedBorder.style;\n\n    result.imageFormat = {\n        borderColor,\n        borderWidth,\n        borderStyle,\n        boxShadow: format.boxShadow,\n        borderRadius: format.borderRadius,\n    };\n    result.imageEditingMetadata = getImageMetadata(image);\n}\n\nfunction mergeValue<K extends keyof ContentModelFormatState>(\n    format: ContentModelFormatState,\n    key: K,\n    newValue: ContentModelFormatState[K] | undefined,\n    isFirst: boolean,\n    conflictSolution: ConflictFormatSolution = 'remove',\n    parseFn: (val: ContentModelFormatState[K]) => ContentModelFormatState[K] = val => val\n) {\n    if (isFirst) {\n        if (newValue !== undefined) {\n            format[key] = newValue;\n        }\n    } else if (parseFn(newValue) !== parseFn(format[key])) {\n        switch (conflictSolution) {\n            case 'remove':\n                delete format[key];\n                break;\n            case 'keepFirst':\n                break;\n            case 'returnMultiple':\n                if (typeof format[key] === 'string') {\n                    (format[key] as string) = 'Multiple';\n                } else {\n                    delete format[key];\n                }\n                break;\n        }\n    }\n}\n\nfunction px2Pt(px: string) {\n    if (px) {\n        const index = px.indexOf('px');\n        if (index !== -1 && index === px.length - 2) {\n            // Edge may not handle the floating computing well which causes the calculated value to be a little less than the actual value\n            // So add 0.05 to fix it\n            return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\n        }\n    }\n    return px;\n}\n\nfunction hasAllRequiredFormat(format: ContentModelSegmentFormat) {\n    return !!format.fontFamily && !!format.fontSize && !!format.textColor;\n}\n","import type {\n    DeleteSelectionContext,\n    DeleteSelectionResult,\n    DeleteSelectionStep,\n    ValidDeleteSelectionContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Run editing steps on top of a given context object which includes current insert point and previous editing result\n * @param steps The editing steps to run\n * @param context Context for the editing steps.\n */\nexport function runEditSteps(steps: DeleteSelectionStep[], context: DeleteSelectionResult) {\n    steps.forEach(step => {\n        if (step && isValidDeleteSelectionContext(context)) {\n            step(context);\n        }\n    });\n}\n\nfunction isValidDeleteSelectionContext(\n    context: DeleteSelectionContext\n): context is ValidDeleteSelectionContext {\n    return !!context.insertPoint;\n}\n","import { mutateBlock } from '../common/mutate';\nimport { parseColor } from '../../formatHandlers/utils/color';\nimport { updateTableCellMetadata } from '../metadata/updateTableCellMetadata';\nimport type { ShallowMutableContentModelTableCell } from 'roosterjs-content-model-types';\n\n// Using the HSL (hue, saturation and lightness) representation for RGB color values.\n// If the value of the lightness is less than 20, the color is dark.\n// If the value of the lightness is more than 80, the color is bright\nconst DARK_COLORS_LIGHTNESS = 20;\nconst BRIGHT_COLORS_LIGHTNESS = 80;\nconst White = '#ffffff';\nconst Black = '#000000';\n\n/**\n * Set shade color of table cell\n * @param cell The cell to set shade color to\n * @param color The color to set\n * @param isColorOverride @optional When pass true, it means this shade color is not part of table format, so it can be preserved when apply table format\n * @param applyToSegments @optional When pass true, we will also apply text color from table cell to its child blocks and segments\n */\nexport function setTableCellBackgroundColor(\n    cell: ShallowMutableContentModelTableCell,\n    color: string | null | undefined,\n    isColorOverride?: boolean,\n    applyToSegments?: boolean\n) {\n    if (color) {\n        cell.format.backgroundColor = color;\n\n        if (isColorOverride) {\n            updateTableCellMetadata(cell, metadata => {\n                metadata = metadata || {};\n                metadata.bgColorOverride = true;\n                return metadata;\n            });\n        }\n\n        const lightness = calculateLightness(color);\n\n        if (lightness < DARK_COLORS_LIGHTNESS) {\n            cell.format.textColor = White;\n        } else if (lightness > BRIGHT_COLORS_LIGHTNESS) {\n            cell.format.textColor = Black;\n        } else {\n            delete cell.format.textColor;\n        }\n\n        if (applyToSegments) {\n            setAdaptiveCellColor(cell, color);\n        }\n    } else {\n        delete cell.format.backgroundColor;\n        delete cell.format.textColor;\n        if (applyToSegments) {\n            removeAdaptiveCellColor(cell);\n        }\n    }\n}\n\nfunction removeAdaptiveCellColor(cell: ShallowMutableContentModelTableCell) {\n    cell.blocks.forEach(readonlyBlock => {\n        if (readonlyBlock.blockType == 'Paragraph') {\n            const block = mutateBlock(readonlyBlock);\n\n            if (\n                block.segmentFormat?.textColor &&\n                (areSameColor(block.segmentFormat.textColor, White) ||\n                    areSameColor(block.segmentFormat.textColor, Black))\n            ) {\n                delete block.segmentFormat.textColor;\n            }\n            block.segments.forEach(segment => {\n                if (\n                    segment.format.textColor &&\n                    (areSameColor(segment.format.textColor, White) ||\n                        areSameColor(segment.format.textColor, Black))\n                ) {\n                    delete segment.format.textColor;\n                }\n            });\n        }\n    });\n}\n\nfunction setAdaptiveCellColor(cell: ShallowMutableContentModelTableCell, backgroundColor: string) {\n    if (cell.format.textColor) {\n        cell.blocks.forEach(readonlyBlock => {\n            if (readonlyBlock.blockType == 'Paragraph') {\n                const block = mutateBlock(readonlyBlock);\n\n                if (\n                    !block.segmentFormat?.textColor ||\n                    areSameColor(backgroundColor, block.segmentFormat.textColor)\n                ) {\n                    block.segmentFormat = {\n                        ...block.segmentFormat,\n                        textColor: cell.format.textColor,\n                    };\n                }\n                block.segments.forEach(segment => {\n                    if (\n                        !segment.format?.textColor ||\n                        areSameColor(backgroundColor, segment.format.textColor)\n                    ) {\n                        segment.format = {\n                            ...segment.format,\n                            textColor: cell.format.textColor,\n                        };\n                    }\n                });\n            }\n        });\n    }\n}\n\nfunction calculateLightness(color: string) {\n    const colorValues = parseColor(color);\n\n    // Use the values of r,g,b to calculate the lightness in the HSl representation\n    //First calculate the fraction of the light in each color, since in css the value of r,g,b is in the interval of [0,255], we have\n    if (colorValues) {\n        const red = colorValues[0] / 255;\n        const green = colorValues[1] / 255;\n        const blue = colorValues[2] / 255;\n\n        //Then the lightness in the HSL representation is the average between maximum fraction of r,g,b and the minimum fraction\n        return (Math.max(red, green, blue) + Math.min(red, green, blue)) * 50;\n    } else {\n        return 255;\n    }\n}\n\n/**\n * Check if two colors are the same by comparing their RGB values\n */\nfunction areSameColor(color1: string, color2: string): boolean {\n    const rgb1 = parseColor(color1);\n    const rgb2 = parseColor(color2);\n\n    if (rgb1 && rgb2) {\n        return rgb1[0] === rgb2[0] && rgb1[1] === rgb2[1] && rgb1[2] === rgb2[2];\n    }\n    return false;\n}\n","import { BulletListType } from '../../constants/BulletListType';\nimport { NumberingListType } from '../../constants/NumberingListType';\nimport type { ListMetadataFormat } from 'roosterjs-content-model-types';\n\nconst DefaultOrderedListStyles = [\n    NumberingListType.Decimal,\n    NumberingListType.LowerAlpha,\n    NumberingListType.LowerRoman,\n];\nconst DefaultUnorderedListStyles = [\n    BulletListType.Disc,\n    BulletListType.Circle,\n    BulletListType.Square,\n];\nconst OrderedListStyleRevertMap: Record<string, number> = {\n    'lower-alpha': NumberingListType.LowerAlpha,\n    'lower-latin': NumberingListType.LowerAlpha,\n    'upper-alpha': NumberingListType.UpperAlpha,\n    'upper-latin': NumberingListType.UpperAlpha,\n    'lower-roman': NumberingListType.LowerRoman,\n    'upper-roman': NumberingListType.UpperRoman,\n};\nconst UnorderedListStyleRevertMap: Record<string, number> = {\n    disc: BulletListType.Disc,\n    circle: BulletListType.Circle,\n    square: BulletListType.Square,\n};\n\n/**\n * Get automatic list style of a list item according to its lis type and metadata.\n * @param listType The list type, either OL or UL\n * @param metadata Metadata of this list item from list item model\n * @param depth Depth of list level, start from 0\n * @param existingStyleType Existing list style type in format, if any\n * @returns A number to represent list style type.\n * This will be the value of either NumberingListType (when listType is OL) or BulletListType (when listType is UL).\n * When there is a specified list style in its metadata, return this value, otherwise\n * When specified \"applyListStyleFromLevel\" in metadata, calculate auto list type from its depth, otherwise\n * When there is already listStyleType in list level format, find a related style type index, otherwise\n * return undefined\n */\nexport function getAutoListStyleType(\n    listType: 'OL' | 'UL',\n    metadata: ListMetadataFormat,\n    depth: number,\n    existingStyleType?: string\n): number | undefined {\n    const { orderedStyleType, unorderedStyleType, applyListStyleFromLevel } = metadata;\n\n    if (listType == 'OL') {\n        return typeof orderedStyleType == 'number'\n            ? orderedStyleType\n            : applyListStyleFromLevel\n            ? DefaultOrderedListStyles[depth % DefaultOrderedListStyles.length]\n            : existingStyleType\n            ? OrderedListStyleRevertMap[existingStyleType]\n            : undefined;\n    } else {\n        return typeof unorderedStyleType == 'number'\n            ? unorderedStyleType\n            : applyListStyleFromLevel\n            ? DefaultUnorderedListStyles[depth % DefaultUnorderedListStyles.length]\n            : existingStyleType\n            ? UnorderedListStyleRevertMap[existingStyleType]\n            : undefined;\n    }\n}\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport { NumberingListType } from '../../constants/NumberingListType';\n\nconst CharCodeOfA = 65;\nconst RomanValues: Record<string, number> = {\n    M: 1000,\n    CM: 900,\n    D: 500,\n    CD: 400,\n    C: 100,\n    XC: 90,\n    L: 50,\n    XL: 40,\n    X: 10,\n    IX: 9,\n    V: 5,\n    IV: 4,\n    I: 1,\n};\n\n/**\n * Get the list number for a list item according to list style type and its index number\n * @param styleType The list style number, should be a value of NumberingListType type\n * @param listNumber List number, start from 1\n * @returns A string for this list item. For example, when pass in NumberingListType.LowerAlpha and 2, it returns \"b\"\n */\nexport function getOrderedListNumberStr(styleType: number, listNumber: number): string {\n    switch (styleType) {\n        case NumberingListType.LowerAlpha:\n        case NumberingListType.LowerAlphaDash:\n        case NumberingListType.LowerAlphaDoubleParenthesis:\n        case NumberingListType.LowerAlphaParenthesis:\n            return convertDecimalsToAlpha(listNumber, true /*isLowerCase*/);\n\n        case NumberingListType.UpperAlpha:\n        case NumberingListType.UpperAlphaDash:\n        case NumberingListType.UpperAlphaDoubleParenthesis:\n        case NumberingListType.UpperAlphaParenthesis:\n            return convertDecimalsToAlpha(listNumber, false /*isLowerCase*/);\n\n        case NumberingListType.LowerRoman:\n        case NumberingListType.LowerRomanDash:\n        case NumberingListType.LowerRomanDoubleParenthesis:\n        case NumberingListType.LowerRomanParenthesis:\n            return convertDecimalsToRoman(listNumber, true /*isLowerCase*/);\n\n        case NumberingListType.UpperRoman:\n        case NumberingListType.UpperRomanDash:\n        case NumberingListType.UpperRomanDoubleParenthesis:\n        case NumberingListType.UpperRomanParenthesis:\n            return convertDecimalsToRoman(listNumber, false /*isLowerCase*/);\n\n        default:\n            return listNumber + '';\n    }\n}\n\nfunction convertDecimalsToAlpha(decimal: number, isLowerCase?: boolean): string {\n    let alpha = '';\n    decimal--;\n\n    while (decimal >= 0) {\n        alpha = String.fromCharCode((decimal % 26) + CharCodeOfA) + alpha;\n        decimal = Math.floor(decimal / 26) - 1;\n    }\n    return isLowerCase ? alpha.toLowerCase() : alpha;\n}\n\nfunction convertDecimalsToRoman(decimal: number, isLowerCase?: boolean) {\n    let romanValue = '';\n\n    for (const i of getObjectKeys(RomanValues)) {\n        const timesRomanCharAppear = Math.floor(decimal / RomanValues[i]);\n        decimal = decimal - timesRomanCharAppear * RomanValues[i];\n        romanValue = romanValue + i.repeat(timesRomanCharAppear);\n    }\n    return isLowerCase ? romanValue.toLocaleLowerCase() : romanValue;\n}\n","import type {\n    ArrayDefinition,\n    BooleanDefinition,\n    Definition,\n    NumberDefinition,\n    ObjectDefinition,\n    ObjectPropertyDefinition,\n    StringDefinition,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create a number definition\n * @param isOptional Whether this property is optional\n * @param value Optional value of the number\n * @param minValue Optional minimum value\n * @param maxValue Optional maximum value\n * @param allowNull Allow the property to be null\n * @returns The number definition object\n */\nexport function createNumberDefinition(\n    isOptional?: boolean,\n    value?: number,\n    minValue?: number,\n    maxValue?: number,\n    allowNull?: boolean\n): NumberDefinition {\n    return {\n        type: 'number',\n        isOptional,\n        value,\n        maxValue,\n        minValue,\n        allowNull,\n    };\n}\n\n/**\n * @internal\n * Create a boolean definition\n * @param isOptional  Whether this property is optional\n * @param value Optional expected boolean value\n * @param allowNull Allow the property to be null\n * @returns  The boolean definition object\n */\nexport function createBooleanDefinition(\n    isOptional?: boolean,\n    value?: boolean,\n    allowNull?: boolean\n): BooleanDefinition {\n    return {\n        type: 'boolean',\n        isOptional,\n        value,\n        allowNull,\n    };\n}\n\n/**\n * @internal\n * Create a string definition\n * @param isOptional  Whether this property is optional\n * @param value Optional expected string value\n * @param allowNull Allow the property to be null\n * @returns  The string definition object\n */\nexport function createStringDefinition(\n    isOptional?: boolean,\n    value?: string,\n    allowNull?: boolean\n): StringDefinition {\n    return {\n        type: 'string',\n        isOptional,\n        value,\n        allowNull,\n    };\n}\n\n/**\n * @internal\n * Create an array definition\n * @param itemDef Definition of each item of the related array\n * @param isOptional  Whether this property is optional\n * @param allowNull Allow the property to be null\n * @returns  The array definition object\n */\nexport function createArrayDefinition<T>(\n    itemDef: Definition<T>,\n    isOptional?: boolean,\n    minLength?: number,\n    maxLength?: number,\n    allowNull?: boolean\n): ArrayDefinition<T[]> {\n    return {\n        type: 'array',\n        isOptional,\n        itemDef,\n        minLength,\n        maxLength,\n        allowNull,\n    };\n}\n\n/**\n * @internal\n * Create an object definition\n * @param propertyDef Definition of each property of the related object\n * @param isOptional  Whether this property is optional\n * @param allowNull Allow the property to be null\n * @returns  The object definition object\n */\nexport function createObjectDefinition<T extends Object>(\n    propertyDef: ObjectPropertyDefinition<T>,\n    isOptional?: boolean,\n    allowNull?: boolean\n): ObjectDefinition<T> {\n    return {\n        type: 'object',\n        isOptional,\n        propertyDef,\n        allowNull,\n    };\n}\n","import { getMetadata, updateMetadata } from './updateMetadata';\nimport {\n    createBooleanDefinition,\n    createNumberDefinition,\n    createObjectDefinition,\n    createStringDefinition,\n} from './definitionCreators';\nimport type {\n    ContentModelImage,\n    ImageMetadataFormat,\n    ReadonlyContentModelImage,\n} from 'roosterjs-content-model-types';\n\nconst NumberDefinition = createNumberDefinition(true);\nconst BooleanDefinition = createBooleanDefinition(true);\n\n/**\n * @internal\n * Definition of ImageMetadataFormat\n */\nconst ImageMetadataFormatDefinition = createObjectDefinition<Required<ImageMetadataFormat>>({\n    widthPx: NumberDefinition,\n    heightPx: NumberDefinition,\n    leftPercent: NumberDefinition,\n    rightPercent: NumberDefinition,\n    topPercent: NumberDefinition,\n    bottomPercent: NumberDefinition,\n    angleRad: NumberDefinition,\n    src: createStringDefinition(),\n    naturalHeight: NumberDefinition,\n    naturalWidth: NumberDefinition,\n    flippedHorizontal: BooleanDefinition,\n    flippedVertical: BooleanDefinition,\n});\n\n/**\n * Get image metadata\n * @param image The image Content Model\n */\nexport function getImageMetadata(image: ReadonlyContentModelImage): ImageMetadataFormat | null {\n    return getMetadata(image, ImageMetadataFormatDefinition);\n}\n\n/**\n * Update image metadata with a callback\n * @param image The image Content Model\n * @param callback The callback function used for updating metadata\n */\nexport function updateImageMetadata(\n    image: ContentModelImage,\n    callback?: (format: ImageMetadataFormat | null) => ImageMetadataFormat | null\n): ImageMetadataFormat | null {\n    return updateMetadata(image, callback, ImageMetadataFormatDefinition);\n}\n","import { BulletListType } from '../../constants/BulletListType';\nimport { getMetadata, updateMetadata } from './updateMetadata';\nimport { NumberingListType } from '../../constants/NumberingListType';\nimport {\n    createBooleanDefinition,\n    createNumberDefinition,\n    createObjectDefinition,\n} from './definitionCreators';\nimport type {\n    ListMetadataFormat,\n    ObjectDefinition,\n    ReadonlyContentModelWithDataset,\n    ShallowMutableContentModelWithDataset,\n} from 'roosterjs-content-model-types';\n\n/**\n * Metadata definition for List\n */\nexport const ListMetadataDefinition: ObjectDefinition<ListMetadataFormat> = createObjectDefinition<\n    ListMetadataFormat\n>(\n    {\n        orderedStyleType: createNumberDefinition(\n            true /** isOptional */,\n            undefined /** value **/,\n            NumberingListType.Min,\n            NumberingListType.Max\n        ),\n        unorderedStyleType: createNumberDefinition(\n            true /** isOptional */,\n            undefined /** value **/,\n            BulletListType.Min,\n            BulletListType.Max\n        ),\n        applyListStyleFromLevel: createBooleanDefinition(true /*isOptional*/),\n    },\n    true /** isOptional */,\n    true /** allowNull */\n);\n\n/**\n * Get list metadata\n * @param list The list Content Model (metadata holder)\n */\nexport function getListMetadata(\n    list: ReadonlyContentModelWithDataset<ListMetadataFormat>\n): ListMetadataFormat | null {\n    return getMetadata(list, ListMetadataDefinition);\n}\n\n/**\n * Update list metadata with a callback\n * @param list The list Content Model (metadata holder)\n * @param callback The callback function used for updating metadata\n */\nexport function updateListMetadata(\n    list: ShallowMutableContentModelWithDataset<ListMetadataFormat>,\n    callback?: (format: ListMetadataFormat | null) => ListMetadataFormat | null\n): ListMetadataFormat | null {\n    return updateMetadata(list, callback, ListMetadataDefinition);\n}\n","import { validate } from './validate';\nimport type {\n    Definition,\n    ReadonlyContentModelWithDataset,\n    ShallowMutableContentModelWithDataset,\n} from 'roosterjs-content-model-types';\n\nconst EditingInfoDatasetName = 'editingInfo';\n\n/**\n * Retrieve metadata from the given model.\n * @param model The Content Model to retrieve metadata from\n * @param definition Definition of this metadata type, used for validate the metadata object\n * @returns Metadata of the model, or null if it does not contain a valid metadata\n */\nexport function getMetadata<T>(\n    model: ReadonlyContentModelWithDataset<T>,\n    definition?: Definition<T>\n): T | null {\n    const metadataString = model.dataset[EditingInfoDatasetName];\n    let obj: Object | null = null;\n\n    try {\n        obj = JSON.parse(metadataString);\n    } catch {}\n\n    return !definition || validate(obj, definition) ? (obj as T) : null;\n}\n\n/**\n * Update metadata of the given model\n * @param model The model to update metadata to\n * @param callback A callback function to update metadata\n * @param definition @optional Metadata definition used for verify the metadata object\n * @returns The metadata object if any, or null\n */\nexport function updateMetadata<T>(\n    model: ShallowMutableContentModelWithDataset<T>,\n    callback?: (metadata: T | null) => T | null,\n    definition?: Definition<T>\n): T | null {\n    let obj = getMetadata(model, definition);\n\n    if (callback) {\n        obj = callback(obj);\n\n        if (!obj) {\n            delete model.dataset[EditingInfoDatasetName];\n        } else if (!definition || validate(obj, definition)) {\n            model.dataset[EditingInfoDatasetName] = JSON.stringify(obj);\n        }\n    }\n\n    return obj;\n}\n\n/**\n * Check if the given model has metadata\n * @param model The content model to check\n */\nexport function hasMetadata<T>(model: ReadonlyContentModelWithDataset<T> | HTMLElement): boolean {\n    return !!model.dataset[EditingInfoDatasetName];\n}\n","import { createBooleanDefinition, createObjectDefinition } from './definitionCreators';\nimport { getMetadata, updateMetadata } from './updateMetadata';\nimport type {\n    ReadonlyContentModelTableCell,\n    ShallowMutableContentModelTableCell,\n    TableCellMetadataFormat,\n} from 'roosterjs-content-model-types';\n\nconst TableCellMetadataFormatDefinition = createObjectDefinition<Required<TableCellMetadataFormat>>(\n    {\n        bgColorOverride: createBooleanDefinition(true /** isOptional */),\n        vAlignOverride: createBooleanDefinition(true /** isOptional */),\n        borderOverride: createBooleanDefinition(true /** isOptional */),\n    },\n    false /* isOptional */,\n    true /** allowNull */\n);\n\n/**\n * Get table cell metadata\n * @param cell The table cell Content Model\n */\nexport function getTableCellMetadata(\n    cell: ReadonlyContentModelTableCell\n): TableCellMetadataFormat | null {\n    return getMetadata(cell, TableCellMetadataFormatDefinition);\n}\n\n/**\n * Update table cell metadata with a callback\n * @param cell The table cell Content Model\n * @param callback The callback function used for updating metadata\n */\nexport function updateTableCellMetadata(\n    cell: ShallowMutableContentModelTableCell,\n    callback?: (format: TableCellMetadataFormat | null) => TableCellMetadataFormat | null\n): TableCellMetadataFormat | null {\n    return updateMetadata(cell, callback, TableCellMetadataFormatDefinition);\n}\n","import { getMetadata, updateMetadata } from './updateMetadata';\nimport { TableBorderFormat } from '../../constants/TableBorderFormat';\nimport {\n    createBooleanDefinition,\n    createNumberDefinition,\n    createObjectDefinition,\n    createStringDefinition,\n} from './definitionCreators';\nimport type {\n    ReadonlyContentModelTable,\n    ShallowMutableContentModelTable,\n    TableMetadataFormat,\n} from 'roosterjs-content-model-types';\n\nconst NullStringDefinition = createStringDefinition(\n    false /** isOptional */,\n    undefined /** value */,\n    true /** allowNull */\n);\n\nconst BooleanDefinition = createBooleanDefinition(false /** isOptional */);\n\nconst TableFormatDefinition = createObjectDefinition<Required<TableMetadataFormat>>(\n    {\n        topBorderColor: NullStringDefinition,\n        bottomBorderColor: NullStringDefinition,\n        verticalBorderColor: NullStringDefinition,\n        hasHeaderRow: BooleanDefinition,\n        headerRowColor: NullStringDefinition,\n        hasFirstColumn: BooleanDefinition,\n        hasBandedColumns: BooleanDefinition,\n        hasBandedRows: BooleanDefinition,\n        bgColorEven: NullStringDefinition,\n        bgColorOdd: NullStringDefinition,\n        tableBorderFormat: createNumberDefinition(\n            false /** isOptional */,\n            undefined /* value */,\n            TableBorderFormat.Min /* first table border format */,\n            TableBorderFormat.Max /* last table border format */\n        ),\n        verticalAlign: NullStringDefinition,\n    },\n    false /* isOptional */,\n    true /** allowNull */\n);\n\n/**\n * Get table metadata\n * @param table The table Content Model\n */\nexport function getTableMetadata(table: ReadonlyContentModelTable): TableMetadataFormat | null {\n    return getMetadata(table, TableFormatDefinition);\n}\n\n/**\n * Update table metadata with a callback\n * @param table The table Content Model\n * @param callback The callback function used for updating metadata\n */\nexport function updateTableMetadata(\n    table: ShallowMutableContentModelTable,\n    callback?: (format: TableMetadataFormat | null) => TableMetadataFormat | null\n): TableMetadataFormat | null {\n    return updateMetadata(table, callback, TableFormatDefinition);\n}\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport type { Definition } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Validate the given object with a type definition object\n * @param input The object to validate\n * @param def The type definition object used for validation\n * @returns True if the object passed the validation, otherwise false\n */\nexport function validate<T>(input: any, def: Definition<T>): input is T {\n    let result = false;\n    if ((def.isOptional && typeof input === 'undefined') || (def.allowNull && input === null)) {\n        result = true;\n    } else if (\n        (!def.isOptional && typeof input === 'undefined') ||\n        (!def.allowNull && input === null)\n    ) {\n        return false;\n    } else {\n        switch (def.type) {\n            case 'string':\n                result =\n                    typeof input === 'string' &&\n                    (typeof def.value === 'undefined' || input === def.value);\n                break;\n\n            case 'number':\n                result =\n                    typeof input === 'number' &&\n                    (typeof def.value === 'undefined' || areSameNumbers(def.value, input)) &&\n                    (typeof def.minValue === 'undefined' || input >= def.minValue) &&\n                    (typeof def.maxValue === 'undefined' || input <= def.maxValue);\n                break;\n\n            case 'boolean':\n                result =\n                    typeof input === 'boolean' &&\n                    (typeof def.value === 'undefined' || input === def.value);\n                break;\n\n            case 'array':\n                result =\n                    Array.isArray(input) &&\n                    (typeof def.minLength === 'undefined' || input.length >= def.minLength) &&\n                    (typeof def.maxLength === 'undefined' || input.length <= def.maxLength) &&\n                    input.every(x => validate(x, def.itemDef));\n                break;\n\n            case 'object':\n                result =\n                    typeof input === 'object' &&\n                    getObjectKeys(def.propertyDef).every(x =>\n                        validate(input[x], def.propertyDef[x])\n                    );\n                break;\n        }\n    }\n\n    return result;\n}\n\nfunction areSameNumbers(n1: number, n2: number) {\n    return Math.abs(n1 - n2) < 1e-3;\n}\n","import { getClosestAncestorBlockGroupIndex } from '../editing/getClosestAncestorBlockGroupIndex';\nimport { isBlockGroupOfType } from '../typeCheck/isBlockGroupOfType';\nimport { iterateSelections } from './iterateSelections';\nimport { mutateBlock } from '../common/mutate';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelBlockGroupType,\n    ContentModelDocument,\n    ContentModelListItem,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelTable,\n    IterateSelectionsOption,\n    OperationalBlocks,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelListItem,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n    ReadonlyContentModelTable,\n    ReadonlyOperationalBlocks,\n    ReadonlyTableSelectionContext,\n    ShallowMutableContentModelParagraph,\n    ShallowMutableContentModelSegment,\n    TableSelectionContext,\n    TypeOfBlockGroup,\n} from 'roosterjs-content-model-types';\n\n//#region getSelectedSegmentsAndParagraphs\n/**\n * Get an array of selected parent paragraph and child segment pair\n * @param model The Content Model to get selection from\n * @param includingFormatHolder True means also include format holder as segment from list item, in that case paragraph will be null\n * @param includingEntity True to include entity in result as well\n */\nexport function getSelectedSegmentsAndParagraphs(\n    model: ContentModelDocument,\n    includingFormatHolder: boolean,\n    includingEntity?: boolean\n): [ContentModelSegment, ContentModelParagraph | null, ContentModelBlockGroup[]][];\n\n/**\n * Get an array of selected parent paragraph and child segment pair, return mutable paragraph and segments\n * @param model The Content Model to get selection from\n * @param includingFormatHolder True means also include format holder as segment from list item, in that case paragraph will be null\n * @param includingEntity True to include entity in result as well\n * @param mutate Set to true to indicate we will mutate the selected paragraphs\n */\nexport function getSelectedSegmentsAndParagraphs(\n    model: ReadonlyContentModelDocument,\n    includingFormatHolder: boolean,\n    includingEntity: boolean,\n    mutate: true\n): [\n    ShallowMutableContentModelSegment,\n    ContentModelParagraph | null,\n    ReadonlyContentModelBlockGroup[]\n][];\n\n/**\n * Get an array of selected parent paragraph and child segment pair (Readonly)\n * @param model The Content Model to get selection from\n * @param includingFormatHolder True means also include format holder as segment from list item, in that case paragraph will be null\n * @param includingEntity True to include entity in result as well\n */\nexport function getSelectedSegmentsAndParagraphs(\n    model: ReadonlyContentModelDocument,\n    includingFormatHolder: boolean,\n    includingEntity?: boolean\n): [\n    ReadonlyContentModelSegment,\n    ReadonlyContentModelParagraph | null,\n    ReadonlyContentModelBlockGroup[]\n][];\n\nexport function getSelectedSegmentsAndParagraphs(\n    model: ReadonlyContentModelDocument,\n    includingFormatHolder: boolean,\n    includingEntity?: boolean,\n    mutate?: boolean\n): [\n    ReadonlyContentModelSegment,\n    ReadonlyContentModelParagraph | null,\n    ReadonlyContentModelBlockGroup[]\n][] {\n    const selections = collectSelections(model, {\n        includeListFormatHolder: includingFormatHolder ? 'allSegments' : 'never',\n    });\n    const result: [\n        ReadonlyContentModelSegment,\n        ReadonlyContentModelParagraph | null,\n        ReadonlyContentModelBlockGroup[]\n    ][] = [];\n\n    selections.forEach(({ segments, block, path }) => {\n        if (segments) {\n            if (\n                includingFormatHolder &&\n                !block &&\n                segments.length == 1 &&\n                path[0].blockGroupType == 'ListItem' &&\n                segments[0] == path[0].formatHolder\n            ) {\n                const list = path[0];\n\n                if (mutate) {\n                    mutateBlock(list);\n                }\n\n                result.push([list.formatHolder, null, path]);\n            } else if (block?.blockType == 'Paragraph') {\n                if (mutate) {\n                    mutateBlock(block);\n                }\n\n                segments.forEach(segment => {\n                    if (\n                        includingEntity ||\n                        segment.segmentType != 'Entity' ||\n                        !segment.entityFormat.isReadonly\n                    ) {\n                        result.push([segment, block, path]);\n                    }\n                });\n            }\n        } else if (block?.blockType == 'Entity' && includingEntity) {\n            // Here we treat the entity as segment since they are compatible, then it has no parent paragraph\n            result.push([block, null /*paragraph*/, path]);\n        }\n    });\n\n    return result;\n}\n//#endregion\n\n//#region getSelectedSegments\n/**\n * Get an array of selected segments from a content model\n * @param model The Content Model to get selection from\n * @param includingFormatHolder True means also include format holder as segment from list item\n */\nexport function getSelectedSegments(\n    model: ContentModelDocument,\n    includingFormatHolder: boolean\n): ContentModelSegment[];\n\n/**\n * Get an array of selected segments from a content model, return mutable segments\n * @param model The Content Model to get selection from\n * @param includingFormatHolder True means also include format holder as segment from list item\n * @param mutate Set to true to indicate we will mutate the selected paragraphs\n */\nexport function getSelectedSegments(\n    model: ReadonlyContentModelDocument,\n    includingFormatHolder: boolean,\n    mutate: true\n): ShallowMutableContentModelSegment[];\n\n/**\n * Get an array of selected segments from a content model (Readonly)\n * @param model The Content Model to get selection from\n * @param includingFormatHolder True means also include format holder as segment from list item\n */\nexport function getSelectedSegments(\n    model: ReadonlyContentModelDocument,\n    includingFormatHolder: boolean\n): ReadonlyContentModelSegment[];\n\nexport function getSelectedSegments(\n    model: ReadonlyContentModelDocument,\n    includingFormatHolder: boolean,\n    mutate?: boolean\n): ReadonlyContentModelSegment[] {\n    const segments = mutate\n        ? getSelectedSegmentsAndParagraphs(\n              model,\n              includingFormatHolder,\n              false /*includeEntity*/,\n              true /*mutate*/\n          )\n        : getSelectedSegmentsAndParagraphs(model, includingFormatHolder);\n\n    return segments.map(x => x[0]);\n}\n//#endregion\n\n//#region getSelectedParagraphs\n/**\n * Get any array of selected paragraphs from a content model\n * @param model The Content Model to get selection from\n */\nexport function getSelectedParagraphs(model: ContentModelDocument): ContentModelParagraph[];\n\n/**\n * Get any array of selected paragraphs from a content model, return mutable paragraphs\n * @param model The Content Model to get selection from\n * @param mutate Set to true to indicate we will mutate the selected paragraphs\n */\nexport function getSelectedParagraphs(\n    model: ReadonlyContentModelDocument,\n    mutate: true\n): ShallowMutableContentModelParagraph[];\n\n/**\n * Get any array of selected paragraphs from a content model (Readonly)\n * @param model The Content Model to get selection from\n */\nexport function getSelectedParagraphs(\n    model: ReadonlyContentModelDocument\n): ReadonlyContentModelParagraph[];\n\nexport function getSelectedParagraphs(\n    model: ReadonlyContentModelDocument,\n    mutate?: boolean\n): ReadonlyContentModelParagraph[] {\n    const selections = collectSelections(model, { includeListFormatHolder: 'never' });\n    const result: ReadonlyContentModelParagraph[] = [];\n\n    removeUnmeaningfulSelections(selections);\n\n    selections.forEach(({ block }) => {\n        if (block?.blockType == 'Paragraph') {\n            result.push(mutate ? mutateBlock(block) : block);\n        }\n    });\n\n    return result;\n}\n//#endregion\n\n//#region getOperationalBlocks\n/**\n * Get an array of block group - block pair that is of the expected block group type from selection\n * @param group The root block group to search\n * @param blockGroupTypes The expected block group types\n * @param stopTypes Block group types that will stop searching when hit\n * @param deepFirst True means search in deep first, otherwise wide first\n * @param isValidTarget @optional An additional callback to validate whether a matching block group is a valid target\n */\nexport function getOperationalBlocks<T extends ContentModelBlockGroup>(\n    group: ContentModelBlockGroup,\n    blockGroupTypes: TypeOfBlockGroup<T>[],\n    stopTypes: ContentModelBlockGroupType[],\n    deepFirst?: boolean,\n    isValidTarget?: (block: ReadonlyContentModelBlockGroup) => boolean\n): OperationalBlocks<T>[];\n\n/**\n * Get an array of block group - block pair that is of the expected block group type from selection (Readonly)\n * @param group The root block group to search\n * @param blockGroupTypes The expected block group types\n * @param stopTypes Block group types that will stop searching when hit\n * @param deepFirst True means search in deep first, otherwise wide first\n * @param isValidTarget @optional An additional callback to validate whether a matching block group is a valid target\n */\nexport function getOperationalBlocks<T extends ReadonlyContentModelBlockGroup>(\n    group: ReadonlyContentModelBlockGroup,\n    blockGroupTypes: TypeOfBlockGroup<T>[],\n    stopTypes: ContentModelBlockGroupType[],\n    deepFirst?: boolean,\n    isValidTarget?: (block: ReadonlyContentModelBlockGroup) => boolean\n): ReadonlyOperationalBlocks<T>[];\n\nexport function getOperationalBlocks<T extends ContentModelBlockGroup>(\n    group: ReadonlyContentModelBlockGroup,\n    blockGroupTypes: TypeOfBlockGroup<T>[],\n    stopTypes: ContentModelBlockGroupType[],\n    deepFirst?: boolean,\n    isValidTarget?: (block: ReadonlyContentModelBlockGroup) => boolean\n): ReadonlyOperationalBlocks<T>[] {\n    const result: ReadonlyOperationalBlocks<T>[] = [];\n    const findSequence = deepFirst ? blockGroupTypes.map(type => [type]) : [blockGroupTypes];\n    const selections = collectSelections(group, {\n        includeListFormatHolder: 'never',\n        contentUnderSelectedTableCell: 'ignoreForTable', // When whole table is selected, we treat the table as a single block\n    });\n\n    removeUnmeaningfulSelections(selections);\n\n    selections.forEach(({ path, block }) => {\n        for (let i = 0; i < findSequence.length; i++) {\n            const groupIndex = getClosestAncestorBlockGroupIndex(\n                path,\n                findSequence[i],\n                stopTypes,\n                isValidTarget\n            );\n\n            if (groupIndex >= 0) {\n                if (result.filter(x => x.block == path[groupIndex]).length <= 0) {\n                    result.push({\n                        parent: path[groupIndex + 1],\n                        block: path[groupIndex] as T,\n                        path: path.slice(groupIndex + 1),\n                    });\n                }\n                break;\n            } else if (i == findSequence.length - 1 && block) {\n                result.push({\n                    parent: path[0],\n                    block: block,\n                    path,\n                });\n                break;\n            }\n        }\n    });\n\n    return result;\n}\n//#endregion\n\n//#region getFirstSelectedTable\n/**\n * Get the first selected table from content model\n * @param model The Content Model to get selection from\n */\nexport function getFirstSelectedTable(\n    model: ContentModelDocument\n): [ContentModelTable | undefined, ContentModelBlockGroup[]];\n\n/**\n * Get the first selected table from content model (Readonly)\n * @param model The Content Model to get selection from\n */\nexport function getFirstSelectedTable(\n    model: ReadonlyContentModelDocument\n): [ReadonlyContentModelTable | undefined, ReadonlyContentModelBlockGroup[]];\n\nexport function getFirstSelectedTable(\n    model: ReadonlyContentModelDocument\n): [ReadonlyContentModelTable | undefined, ReadonlyContentModelBlockGroup[]] {\n    const selections = collectSelections(model, { includeListFormatHolder: 'never' });\n    let table: ReadonlyContentModelTable | undefined;\n    let resultPath: ReadonlyContentModelBlockGroup[] = [];\n\n    removeUnmeaningfulSelections(selections);\n\n    selections.forEach(({ block, tableContext, path }) => {\n        if (!table) {\n            if (block?.blockType == 'Table') {\n                table = block;\n                resultPath = [...path];\n            } else if (tableContext?.table) {\n                table = tableContext.table;\n\n                const parent = path.filter(\n                    group => group.blocks.indexOf(tableContext.table) >= 0\n                )[0];\n                const index = path.indexOf(parent);\n                resultPath = index >= 0 ? path.slice(index) : [];\n            }\n        }\n    });\n\n    return [table, resultPath];\n}\n//#endregion\n\n//#region getFirstSelectedListItem\n/**\n * Get the first selected list item from content model\n * @param model The Content Model to get selection from\n */\nexport function getFirstSelectedListItem(\n    model: ContentModelDocument\n): ContentModelListItem | undefined;\n\n/**\n * Get the first selected list item from content model (Readonly)\n * @param model The Content Model to get selection from\n */\nexport function getFirstSelectedListItem(\n    model: ReadonlyContentModelDocument\n): ReadonlyContentModelListItem | undefined;\n\nexport function getFirstSelectedListItem(\n    model: ReadonlyContentModelDocument\n): ReadonlyContentModelListItem | undefined {\n    let listItem: ContentModelListItem | undefined;\n\n    getOperationalBlocks(model, ['ListItem'], ['TableCell']).forEach(r => {\n        if (!listItem && isBlockGroupOfType<ContentModelListItem>(r.block, 'ListItem')) {\n            listItem = r.block;\n        }\n    });\n\n    return listItem;\n}\n//#endregion\n\n//#region collectSelections\ninterface SelectionInfo {\n    path: ContentModelBlockGroup[];\n    segments?: ContentModelSegment[];\n    block?: ContentModelBlock;\n    tableContext?: TableSelectionContext;\n}\n\ninterface ReadonlySelectionInfo {\n    path: ReadonlyContentModelBlockGroup[];\n    segments?: ReadonlyContentModelSegment[];\n    block?: ReadonlyContentModelBlock;\n    tableContext?: ReadonlyTableSelectionContext;\n}\n\nfunction collectSelections(\n    group: ContentModelBlockGroup,\n    option?: IterateSelectionsOption\n): SelectionInfo[];\n\nfunction collectSelections(\n    group: ReadonlyContentModelBlockGroup,\n    option?: IterateSelectionsOption\n): ReadonlySelectionInfo[];\n\nfunction collectSelections(\n    group: ReadonlyContentModelBlockGroup,\n    option?: IterateSelectionsOption\n): ReadonlySelectionInfo[] {\n    const selections: ReadonlySelectionInfo[] = [];\n\n    iterateSelections(\n        group,\n        (path, tableContext, block, segments) => {\n            selections.push({\n                path,\n                tableContext,\n                block,\n                segments,\n            });\n        },\n        option\n    );\n\n    return selections;\n}\n//#endregion\n\n//#region utils\nfunction removeUnmeaningfulSelections(selections: ReadonlySelectionInfo[]) {\n    if (\n        selections.length > 1 &&\n        isOnlySelectionMarkerSelected(selections, false /*checkFirstParagraph*/)\n    ) {\n        selections.pop();\n    }\n\n    // Remove head paragraph if first selection marker is the only selection\n    if (\n        selections.length > 1 &&\n        isOnlySelectionMarkerSelected(selections, true /*checkFirstParagraph*/)\n    ) {\n        selections.shift();\n    }\n}\n\nfunction isOnlySelectionMarkerSelected(\n    selections: ReadonlySelectionInfo[],\n    checkFirstParagraph: boolean\n): boolean {\n    const selection = selections[checkFirstParagraph ? 0 : selections.length - 1];\n\n    if (\n        selection.block?.blockType == 'Paragraph' &&\n        selection.segments &&\n        selection.segments.length > 0\n    ) {\n        const allSegments = selection.block.segments;\n        const segment = selection.segments[0];\n\n        return (\n            selection.segments.length == 1 &&\n            segment.segmentType == 'SelectionMarker' &&\n            segment == allSegments[checkFirstParagraph ? allSegments.length - 1 : 0]\n        );\n    } else {\n        return false;\n    }\n}\n//#endregion\n","import { hasSelectionInBlockGroup } from '../selection/hasSelectionInBlockGroup';\nimport type {\n    ReadonlyContentModelTable,\n    TableSelectionCoordinates,\n} from 'roosterjs-content-model-types';\n\n/**\n * Get selection coordinates of a table. If there is no selection, return null\n * @param table The table model to get selection from\n */\nexport function getSelectedCells(\n    table: ReadonlyContentModelTable\n): TableSelectionCoordinates | null {\n    let firstRow = -1;\n    let firstColumn = -1;\n    let lastRow = -1;\n    let lastColumn = -1;\n    let hasSelection = false;\n\n    table.rows.forEach((row, rowIndex) =>\n        row.cells.forEach((cell, colIndex) => {\n            if (hasSelectionInBlockGroup(cell)) {\n                hasSelection = true;\n\n                if (firstRow < 0) {\n                    firstRow = rowIndex;\n                }\n\n                if (firstColumn < 0) {\n                    firstColumn = colIndex;\n                }\n\n                lastRow = Math.max(lastRow, rowIndex);\n                lastColumn = Math.max(lastColumn, colIndex);\n            }\n        })\n    );\n\n    return hasSelection ? { firstRow, firstColumn, lastRow, lastColumn } : null;\n}\n","import { hasSelectionInBlockGroup } from './hasSelectionInBlockGroup';\nimport { hasSelectionInSegment } from './hasSelectionInSegment';\nimport type { ReadonlyContentModelBlock } from 'roosterjs-content-model-types';\n\n/**\n * Check if there is selection within the given block\n * @param block The block to check\n */\nexport function hasSelectionInBlock(block: ReadonlyContentModelBlock): boolean {\n    switch (block.blockType) {\n        case 'Paragraph':\n            return block.segments.some(hasSelectionInSegment);\n\n        case 'Table':\n            return block.rows.some(row => row.cells.some(hasSelectionInBlockGroup));\n\n        case 'BlockGroup':\n            return hasSelectionInBlockGroup(block);\n\n        case 'Divider':\n        case 'Entity':\n            return !!block.isSelected;\n\n        default:\n            return false;\n    }\n}\n","import { hasSelectionInBlock } from './hasSelectionInBlock';\nimport type { ReadonlyContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * Check if there is selection within the given block\n * @param block The block to check\n */\nexport function hasSelectionInBlockGroup(group: ReadonlyContentModelBlockGroup): boolean {\n    if (group.blockGroupType == 'TableCell' && group.isSelected) {\n        return true;\n    }\n\n    if (group.blocks.some(hasSelectionInBlock)) {\n        return true;\n    }\n\n    return false;\n}\n","import { hasSelectionInBlock } from './hasSelectionInBlock';\nimport type { ReadonlyContentModelSegment } from 'roosterjs-content-model-types';\n\n/**\n * Check if there is selection within the given segment\n * @param segment The segment to check\n */\nexport function hasSelectionInSegment(segment: ReadonlyContentModelSegment): boolean {\n    return (\n        segment.isSelected ||\n        (segment.segmentType == 'General' && segment.blocks.some(hasSelectionInBlock))\n    );\n}\n","import type {\n    ContentModelBlockGroup,\n    IterateSelectionsCallback,\n    IterateSelectionsOption,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelSegment,\n    ReadonlyIterateSelectionsCallback,\n    ReadonlyTableSelectionContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Iterate all selected elements in a given model\n * @param group The given Content Model to iterate selection from\n * @param callback The callback function to access the selected element\n * @param option Option to determine how to iterate\n */\nexport function iterateSelections(\n    group: ContentModelBlockGroup,\n    callback: IterateSelectionsCallback,\n    option?: IterateSelectionsOption\n): void;\n\n/**\n * Iterate all selected elements in a given model (Readonly)\n * @param group The given Content Model to iterate selection from\n * @param callback The callback function to access the selected element\n * @param option Option to determine how to iterate\n */\nexport function iterateSelections(\n    group: ReadonlyContentModelBlockGroup,\n    callback: ReadonlyIterateSelectionsCallback,\n    option?: IterateSelectionsOption\n): void;\n\nexport function iterateSelections(\n    group: ReadonlyContentModelBlockGroup,\n    callback: ReadonlyIterateSelectionsCallback | IterateSelectionsCallback,\n    option?: IterateSelectionsOption\n): void {\n    internalIterateSelections([group], callback as ReadonlyIterateSelectionsCallback, option);\n}\n\nfunction internalIterateSelections(\n    path: ReadonlyContentModelBlockGroup[],\n    callback: ReadonlyIterateSelectionsCallback,\n    option?: IterateSelectionsOption,\n    table?: ReadonlyTableSelectionContext,\n    treatAllAsSelect?: boolean\n): boolean {\n    const parent = path[0];\n    const includeListFormatHolder = option?.includeListFormatHolder || 'allSegments';\n    const contentUnderSelectedTableCell = option?.contentUnderSelectedTableCell || 'include';\n    const contentUnderSelectedGeneralElement =\n        option?.contentUnderSelectedGeneralElement || 'contentOnly';\n\n    let hasSelectedSegment = false;\n    let hasUnselectedSegment = false;\n\n    for (let i = 0; i < parent.blocks.length; i++) {\n        const block = parent.blocks[i];\n\n        switch (block.blockType) {\n            case 'BlockGroup':\n                const newPath = [block, ...path];\n\n                if (block.blockGroupType == 'General') {\n                    const isSelected = treatAllAsSelect || block.isSelected;\n                    const handleGeneralContent =\n                        !isSelected ||\n                        contentUnderSelectedGeneralElement == 'both' ||\n                        contentUnderSelectedGeneralElement == 'contentOnly';\n                    const handleGeneralElement =\n                        isSelected &&\n                        (contentUnderSelectedGeneralElement == 'both' ||\n                            contentUnderSelectedGeneralElement == 'generalElementOnly' ||\n                            block.blocks.length == 0);\n\n                    if (\n                        (handleGeneralContent &&\n                            internalIterateSelections(\n                                newPath,\n                                callback,\n                                option,\n                                table,\n                                isSelected\n                            )) ||\n                        (handleGeneralElement && callback(path, table, block))\n                    ) {\n                        return true;\n                    }\n                } else if (\n                    internalIterateSelections(newPath, callback, option, table, treatAllAsSelect)\n                ) {\n                    return true;\n                }\n                break;\n\n            case 'Table':\n                const rows = block.rows;\n                const isWholeTableSelected = rows.every(row =>\n                    row.cells.every(cell => cell.isSelected)\n                );\n\n                if (contentUnderSelectedTableCell != 'include' && isWholeTableSelected) {\n                    if (callback(path, table, block)) {\n                        return true;\n                    }\n                } else {\n                    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n                        const row = rows[rowIndex];\n\n                        for (let colIndex = 0; colIndex < row.cells.length; colIndex++) {\n                            const cell = row.cells[colIndex];\n                            if (!cell) {\n                                continue;\n                            }\n\n                            const newTable: ReadonlyTableSelectionContext = {\n                                table: block,\n                                rowIndex,\n                                colIndex,\n                                isWholeTableSelected,\n                            };\n\n                            if (cell.isSelected && callback(path, newTable)) {\n                                return true;\n                            }\n\n                            if (\n                                !cell.isSelected ||\n                                contentUnderSelectedTableCell != 'ignoreForTableOrCell'\n                            ) {\n                                const newPath = [cell, ...path];\n                                const isSelected = treatAllAsSelect || cell.isSelected;\n\n                                if (\n                                    internalIterateSelections(\n                                        newPath,\n                                        callback,\n                                        option,\n                                        newTable,\n                                        isSelected\n                                    )\n                                ) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                break;\n\n            case 'Paragraph':\n                const segments: ReadonlyContentModelSegment[] = [];\n\n                for (let i = 0; i < block.segments.length; i++) {\n                    const segment = block.segments[i];\n                    const isSelected = treatAllAsSelect || segment.isSelected;\n\n                    if (segment.segmentType == 'General') {\n                        const handleGeneralContent =\n                            !isSelected ||\n                            contentUnderSelectedGeneralElement == 'both' ||\n                            contentUnderSelectedGeneralElement == 'contentOnly';\n                        const handleGeneralElement =\n                            isSelected &&\n                            (contentUnderSelectedGeneralElement == 'both' ||\n                                contentUnderSelectedGeneralElement == 'generalElementOnly' ||\n                                segment.blocks.length == 0);\n\n                        if (\n                            handleGeneralContent &&\n                            internalIterateSelections(\n                                [segment, ...path],\n                                callback,\n                                option,\n                                table,\n                                isSelected\n                            )\n                        ) {\n                            return true;\n                        }\n\n                        if (handleGeneralElement) {\n                            segments.push(segment);\n                        }\n                    } else if (isSelected) {\n                        segments.push(segment);\n                    }\n\n                    if (isSelected) {\n                        hasSelectedSegment = true;\n                    } else {\n                        hasUnselectedSegment = true;\n                    }\n                }\n\n                if (segments.length > 0 && callback(path, table, block, segments)) {\n                    return true;\n                }\n                break;\n\n            case 'Divider':\n            case 'Entity':\n                if ((treatAllAsSelect || block.isSelected) && callback(path, table, block)) {\n                    return true;\n                }\n\n                break;\n        }\n    }\n\n    if (\n        includeListFormatHolder != 'never' &&\n        parent.blockGroupType == 'ListItem' &&\n        hasSelectedSegment &&\n        (!hasUnselectedSegment || includeListFormatHolder == 'anySegment') &&\n        // When whole list item is selected, also add its format holder as selected segment\n        callback(path, table, undefined /*block*/, [parent.formatHolder])\n    ) {\n        return true;\n    }\n\n    return false;\n}\n","import { isGeneralSegment } from '../typeCheck/isGeneralSegment';\nimport { mutateBlock, mutateSegment } from '../common/mutate';\nimport type {\n    MutableType,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n    ReadonlyContentModelTable,\n    ReadonlySelectable,\n    ShallowMutableSelectable,\n    TableCellCoordinate,\n} from 'roosterjs-content-model-types';\n\n/**\n * Set selection into Content Model. If the Content Model already has selection, existing selection will be overwritten by the new one.\n * @param group The root level group of Content Model\n * @param start The start selected element. If not passed, existing selection of content model will be cleared\n * @param end The end selected element. If not passed, only the start element will be selected. If passed, all elements between start and end elements will be selected\n */\nexport function setSelection(\n    group: ReadonlyContentModelBlockGroup,\n    start?: ReadonlySelectable,\n    end?: ReadonlySelectable\n) {\n    setSelectionToBlockGroup(group, false /*isInSelection*/, start || null, end || null);\n}\n\nfunction setSelectionToBlockGroup(\n    group: ReadonlyContentModelBlockGroup,\n    isInSelection: boolean,\n    start: ReadonlySelectable | null,\n    end: ReadonlySelectable | null\n): boolean {\n    return handleSelection(isInSelection, group, start, end, isInSelection => {\n        if (isGeneralSegment(group) && needToSetSelection(group, isInSelection)) {\n            setIsSelected(mutateBlock(group), isInSelection);\n        }\n\n        const blocksToDelete: number[] = [];\n\n        group.blocks.forEach((block, i) => {\n            isInSelection = setSelectionToBlock(block, isInSelection, start, end);\n\n            if (block.blockType == 'Paragraph' && block.segments.length == 0 && block.isImplicit) {\n                blocksToDelete.push(i);\n            }\n        });\n\n        let index: number | undefined;\n\n        if (blocksToDelete.length > 0) {\n            const mutableGroup = mutateBlock(group);\n\n            while ((index = blocksToDelete.pop()) !== undefined) {\n                if (index >= 0) {\n                    mutableGroup.blocks.splice(index, 1);\n                }\n            }\n        }\n\n        return isInSelection;\n    });\n}\n\nfunction setSelectionToBlock(\n    block: ReadonlyContentModelBlock,\n    isInSelection: boolean,\n    start: ReadonlySelectable | null,\n    end: ReadonlySelectable | null\n) {\n    switch (block.blockType) {\n        case 'BlockGroup':\n            return setSelectionToBlockGroup(block, isInSelection, start, end);\n\n        case 'Table':\n            return setSelectionToTable(block, isInSelection, start, end);\n\n        case 'Divider':\n        case 'Entity':\n            return handleSelection(isInSelection, block, start, end, isInSelection => {\n                if (needToSetSelection(block, isInSelection)) {\n                    const mutableBlock = mutateBlock(block);\n\n                    if (isInSelection) {\n                        mutableBlock.isSelected = true;\n                    } else {\n                        delete mutableBlock.isSelected;\n                    }\n                }\n\n                return isInSelection;\n            });\n\n        case 'Paragraph':\n            const segmentsToDelete: number[] = [];\n\n            block.segments.forEach((segment, i) => {\n                isInSelection = handleSelection(\n                    isInSelection,\n                    segment,\n                    start,\n                    end,\n                    isInSelection => {\n                        return setSelectionToSegment(\n                            block,\n                            segment,\n                            isInSelection,\n                            segmentsToDelete,\n                            start,\n                            end,\n                            i\n                        );\n                    }\n                );\n            });\n\n            if (segmentsToDelete.length > 0) {\n                const mutablePara = mutateBlock(block);\n\n                let index: number | undefined;\n\n                while ((index = segmentsToDelete.pop()) !== undefined) {\n                    if (index >= 0) {\n                        mutablePara.segments.splice(index, 1);\n                    }\n                }\n            }\n\n            return isInSelection;\n\n        default:\n            return isInSelection;\n    }\n}\n\nfunction setSelectionToTable(\n    table: ReadonlyContentModelTable,\n    isInSelection: boolean,\n    start: ReadonlySelectable | null,\n    end: ReadonlySelectable | null\n): boolean {\n    const first = findCell(table, start);\n    const last = end ? findCell(table, end) : first;\n\n    if (!isInSelection) {\n        for (let row = 0; row < table.rows.length; row++) {\n            const currentRow = table.rows[row];\n            for (let col = 0; col < currentRow.cells.length; col++) {\n                const currentCell = table.rows[row].cells[col];\n                const isSelected =\n                    row >= first.row && row <= last.row && col >= first.col && col <= last.col;\n\n                if (needToSetSelection(currentCell, isSelected)) {\n                    setIsSelected(mutateBlock(currentCell), isSelected);\n                }\n\n                if (!isSelected) {\n                    setSelectionToBlockGroup(currentCell, false /*isInSelection*/, start, end);\n                }\n            }\n        }\n    } else {\n        table.rows.forEach(row =>\n            row.cells.forEach(cell => {\n                const wasInSelection = isInSelection;\n\n                isInSelection = setSelectionToBlockGroup(cell, isInSelection, start, end);\n\n                if (wasInSelection && isInSelection) {\n                    mutateBlock(cell).isSelected = true;\n                }\n            })\n        );\n    }\n\n    return isInSelection;\n}\n\nfunction findCell(\n    table: ReadonlyContentModelTable,\n    cell: ReadonlySelectable | null\n): TableCellCoordinate {\n    let col = -1;\n    const row = cell\n        ? table.rows.findIndex(\n              row => (col = (row.cells as ReadonlyArray<ReadonlySelectable>).indexOf(cell)) >= 0\n          )\n        : -1;\n\n    return { row, col };\n}\n\nfunction setSelectionToSegment(\n    paragraph: ReadonlyContentModelParagraph,\n    segment: ReadonlyContentModelSegment,\n    isInSelection: boolean,\n    segmentsToDelete: number[],\n    start: ReadonlySelectable | null,\n    end: ReadonlySelectable | null,\n    i: number\n) {\n    switch (segment.segmentType) {\n        case 'SelectionMarker':\n            if (!isInSelection || (segment != start && segment != end)) {\n                // Delete the selection marker when\n                // 1. It is not in selection any more. Or\n                // 2. It is in middle of selection, so no need to have it\n                segmentsToDelete.push(i);\n            }\n            return isInSelection;\n\n        case 'General':\n            internalSetSelectionToSegment(paragraph, segment, isInSelection);\n\n            return segment != start && segment != end\n                ? setSelectionToBlockGroup(segment, isInSelection, start, end)\n                : isInSelection;\n\n        case 'Image':\n            const isSelectedAsImageSelection = start == segment && (!end || end == segment);\n\n            internalSetSelectionToSegment(\n                paragraph,\n                segment,\n                isInSelection,\n                !segment.isSelectedAsImageSelection != !isSelectedAsImageSelection\n                    ? image => (image.isSelectedAsImageSelection = isSelectedAsImageSelection)\n                    : undefined\n            );\n\n            return isInSelection;\n        default:\n            internalSetSelectionToSegment(paragraph, segment, isInSelection);\n            return isInSelection;\n    }\n}\n\nfunction internalSetSelectionToSegment<T extends ReadonlyContentModelSegment>(\n    paragraph: ReadonlyContentModelParagraph,\n    segment: T,\n    isInSelection: boolean,\n    additionAction?: (segment: MutableType<T>) => void\n) {\n    if (additionAction || needToSetSelection(segment, isInSelection)) {\n        mutateSegment(paragraph, segment, mutableSegment => {\n            setIsSelected(mutableSegment, isInSelection);\n            additionAction?.(mutableSegment);\n        });\n    }\n}\n\nfunction needToSetSelection(selectable: ReadonlySelectable, isSelected: boolean) {\n    return !selectable.isSelected != !isSelected;\n}\n\nfunction setIsSelected(selectable: ShallowMutableSelectable, value: boolean) {\n    if (value) {\n        selectable.isSelected = true;\n    } else {\n        delete selectable.isSelected;\n    }\n\n    return value;\n}\n\nfunction handleSelection(\n    isInSelection: boolean,\n    model: ReadonlyContentModelBlockGroup | ReadonlyContentModelBlock | ReadonlyContentModelSegment,\n    start: ReadonlySelectable | null,\n    end: ReadonlySelectable | null,\n    callback: (isInSelection: boolean) => boolean\n) {\n    isInSelection = isInSelection || model == start;\n    isInSelection = callback(isInSelection);\n    return isInSelection && !!end && model != end;\n}\n","import type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    TypeOfBlockGroup,\n} from 'roosterjs-content-model-types';\n\n/**\n * Check if the given content model block or block group is of the expected block group type\n * @param input The object to check\n * @param type The expected type\n */\nexport function isBlockGroupOfType<T extends ContentModelBlockGroup>(\n    input: ContentModelBlock | ContentModelBlockGroup | null | undefined,\n    type: TypeOfBlockGroup<T>\n): input is T;\n\n/**\n * Check if the given content model block or block group is of the expected block group type (Readonly)\n * @param input The object to check\n * @param type The expected type\n */\nexport function isBlockGroupOfType<T extends ReadonlyContentModelBlockGroup>(\n    input: ReadonlyContentModelBlock | ReadonlyContentModelBlockGroup | null | undefined,\n    type: TypeOfBlockGroup<T>\n): input is T;\n\nexport function isBlockGroupOfType<\n    T extends ContentModelBlockGroup | ReadonlyContentModelBlockGroup\n>(\n    input:\n        | ReadonlyContentModelBlock\n        | ReadonlyContentModelBlockGroup\n        | ContentModelBlock\n        | ContentModelBlockGroup\n        | null\n        | undefined,\n    type: TypeOfBlockGroup<T>\n): input is T {\n    const item = <T | null | undefined>input;\n\n    return item?.blockGroupType == type;\n}\n","import type {\n    ContentModelBlockGroup,\n    ContentModelGeneralSegment,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelGeneralSegment,\n    ShallowMutableContentModelBlockGroup,\n    ShallowMutableContentModelGeneralSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * Check if the given block group is a general segment\n * @param group The group to check\n */\nexport function isGeneralSegment(\n    group: ContentModelBlockGroup | ContentModelGeneralSegment\n): group is ContentModelGeneralSegment;\n\n/**\n * Check if the given block group is a general segment (Shallow mutable)\n * @param group The group to check\n */\nexport function isGeneralSegment(\n    group: ShallowMutableContentModelBlockGroup | ShallowMutableContentModelGeneralSegment\n): group is ShallowMutableContentModelGeneralSegment;\n\n/**\n * Check if the given block group is a general segment (Readonly)\n * @param group The group to check\n */\nexport function isGeneralSegment(\n    group: ReadonlyContentModelBlockGroup | ReadonlyContentModelGeneralSegment\n): group is ReadonlyContentModelGeneralSegment;\n\nexport function isGeneralSegment(\n    group: ReadonlyContentModelBlockGroup | ReadonlyContentModelGeneralSegment\n): group is ContentModelGeneralSegment {\n    return (\n        group.blockGroupType == 'General' &&\n        (<ContentModelGeneralSegment>group).segmentType == 'General'\n    );\n}\n","import { isNodeOfType } from '../domUtils/isNodeOfType';\nimport { toArray } from '../domUtils/toArray';\nimport type {\n    ContentModelDocument,\n    DOMSelection,\n    ModelToDomBlockAndSegmentNode,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create DOM tree fragment from Content Model document\n * @param doc Document object of the target DOM tree\n * @param root Target node that will become the container of new DOM tree.\n * When a DOM node with existing node is passed, it will be merged with content model so that unchanged blocks\n * won't be touched.\n * @param model The content model document to generate DOM tree from\n * @param context The context object for Content Model to DOM conversion\n * @returns The selection range created in DOM tree from this model, or null when there is no selection\n */\nexport function contentModelToDom(\n    doc: Document,\n    root: Node,\n    model: ContentModelDocument,\n    context: ModelToDomContext\n): DOMSelection | null {\n    context.modelHandlers.blockGroupChildren(doc, root, model, context);\n\n    const range = extractSelectionRange(doc, context);\n\n    if (model.hasRevertedRangeSelection && range?.type == 'range') {\n        range.isReverted = true;\n    }\n\n    root.normalize();\n\n    return range;\n}\n\nfunction extractSelectionRange(doc: Document, context: ModelToDomContext): DOMSelection | null {\n    const {\n        regularSelection: { start, end },\n        tableSelection,\n        imageSelection,\n    } = context;\n\n    let startPosition: { container: Node; offset: number } | undefined;\n    let endPosition: { container: Node; offset: number } | undefined;\n\n    if (imageSelection) {\n        return imageSelection;\n    } else if (\n        (startPosition = start && calcPosition(start)) &&\n        (endPosition = end && calcPosition(end))\n    ) {\n        const range = doc.createRange();\n\n        range.setStart(startPosition.container, startPosition.offset);\n        range.setEnd(endPosition.container, endPosition.offset);\n\n        return {\n            type: 'range',\n            range,\n            isReverted: false,\n        };\n    } else if (tableSelection) {\n        return tableSelection;\n    } else {\n        return null;\n    }\n}\n\nfunction calcPosition(\n    pos: ModelToDomBlockAndSegmentNode\n): { container: Node; offset: number } | undefined {\n    let result: { container: Node; offset: number } | undefined;\n\n    if (pos.block) {\n        if (!pos.segment) {\n            result = { container: pos.block, offset: 0 };\n        } else if (isNodeOfType(pos.segment, 'TEXT_NODE')) {\n            result = {\n                container: pos.segment,\n                offset: pos.offset ?? pos.segment.nodeValue?.length ?? 0,\n            };\n        } else if (pos.segment.parentNode) {\n            result = {\n                container: pos.segment.parentNode,\n                offset:\n                    toArray(pos.segment.parentNode.childNodes as NodeListOf<Node>).indexOf(\n                        pos.segment\n                    ) + 1,\n            };\n        }\n    }\n\n    if (result && isNodeOfType(result.container, 'DOCUMENT_FRAGMENT_NODE')) {\n        const childNodes = result.container.childNodes;\n\n        if (childNodes.length > result.offset) {\n            result = { container: childNodes[result.offset], offset: 0 };\n        } else if (result.container.lastChild) {\n            const container = result.container.lastChild;\n            result = {\n                container,\n                offset: isNodeOfType(container, 'TEXT_NODE')\n                    ? container.nodeValue?.length ?? 0\n                    : container.childNodes.length,\n            };\n        } else {\n            result = undefined;\n        }\n    }\n\n    return result;\n}\n","import { defaultContentModelFormatMap } from '../../config/defaultContentModelFormatMap';\nimport { defaultContentModelHandlers } from './defaultContentModelHandlers';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport {\n    defaultFormatAppliers,\n    defaultFormatKeysPerCategory,\n} from '../../formatHandlers/defaultFormatHandlers';\nimport type {\n    RewriteFromModelContext,\n    EditorContext,\n    FormatApplier,\n    FormatAppliers,\n    FormatAppliersPerCategory,\n    ModelToDomContext,\n    ModelToDomFormatContext,\n    ModelToDomOption,\n    ModelToDomSelectionContext,\n    ModelToDomSettings,\n    TextFormatApplier,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create context object fro Content Model to DOM conversion\n * @param editorContext Context of editor\n * @param options Option array to customize the Model to DOM conversion behavior\n */\nexport function createModelToDomContext(\n    editorContext?: EditorContext,\n    ...options: (ModelToDomOption | undefined)[]\n): ModelToDomContext {\n    return createModelToDomContextWithConfig(createModelToDomConfig(options), editorContext);\n}\n\n/**\n * Create context object for Content Model to DOM conversion with an existing configure\n * @param config A full config object to define how to convert Content Model to DOM tree\n * @param editorContext Context of editor\n */\nexport function createModelToDomContextWithConfig(\n    config: ModelToDomSettings,\n    editorContext?: EditorContext\n): ModelToDomContext {\n    return Object.assign(\n        {},\n        editorContext,\n        createModelToDomSelectionContext(),\n        createModelToDomFormatContext(),\n        createRewriteFromModelContext(),\n        config\n    );\n}\n\nfunction createModelToDomSelectionContext(): ModelToDomSelectionContext {\n    return {\n        regularSelection: {\n            current: {\n                block: null,\n                segment: null,\n            },\n        },\n    };\n}\n\nfunction createModelToDomFormatContext(): ModelToDomFormatContext {\n    return {\n        listFormat: {\n            threadItemCounts: [],\n            nodeStack: [],\n        },\n        implicitFormat: {},\n    };\n}\n\nfunction createRewriteFromModelContext(): RewriteFromModelContext {\n    return {\n        rewriteFromModel: {\n            addedBlockElements: [],\n            removedBlockElements: [],\n        },\n    };\n}\n\n/**\n * Create Content Model to DOM Config object\n * @param options All customizations of DOM creation\n */\nexport function createModelToDomConfig(\n    options: (ModelToDomOption | undefined)[]\n): ModelToDomSettings {\n    return {\n        modelHandlers: Object.assign(\n            {},\n            defaultContentModelHandlers,\n            ...options.map(x => x?.modelHandlerOverride)\n        ),\n        formatAppliers: buildFormatAppliers(\n            options.map(x => x?.formatApplierOverride),\n            options.map(x => x?.additionalFormatAppliers)\n        ),\n        defaultModelHandlers: defaultContentModelHandlers,\n        defaultFormatAppliers,\n        metadataAppliers: Object.assign({}, ...options.map(x => x?.metadataAppliers)),\n        defaultContentModelFormatMap: Object.assign(\n            {},\n            defaultContentModelFormatMap,\n            ...options.map(x => x?.defaultContentModelFormatOverride)\n        ),\n    };\n}\n\n/**\n * @internal Export for test only\n * Build format appliers used by Content Model to DOM conversion\n */\nexport function buildFormatAppliers(\n    overrides: (Partial<FormatAppliers> | undefined)[] = [],\n    additionalAppliersArray: (Partial<FormatAppliersPerCategory> | undefined)[] = []\n): FormatAppliersPerCategory {\n    const combinedOverrides = Object.assign({}, ...overrides);\n\n    const result = getObjectKeys(defaultFormatKeysPerCategory).reduce(\n        (result, key) => {\n            const value = defaultFormatKeysPerCategory[key]\n                .map(\n                    formatKey =>\n                        (combinedOverrides[formatKey] === undefined\n                            ? defaultFormatAppliers[formatKey]\n                            : combinedOverrides[formatKey]) as FormatApplier<any>\n                )\n                .concat(\n                    ...additionalAppliersArray.map(\n                        appliers => (appliers?.[key] ?? []) as FormatApplier<any>[]\n                    )\n                );\n\n            result[key] = value;\n\n            return result;\n        },\n        {\n            text: [] as TextFormatApplier[],\n        } as FormatAppliersPerCategory\n    );\n\n    additionalAppliersArray.forEach(appliers => {\n        if (appliers?.text) {\n            result.text = result.text.concat(appliers.text);\n        }\n    });\n\n    return result;\n}\n","import { handleBlock } from '../handlers/handleBlock';\nimport { handleBlockGroupChildren } from '../handlers/handleBlockGroupChildren';\nimport { handleBr } from '../handlers/handleBr';\nimport { handleDivider } from '../handlers/handleDivider';\nimport { handleEntityBlock, handleEntitySegment } from '../handlers/handleEntity';\nimport { handleFormatContainer } from '../handlers/handleFormatContainer';\nimport { handleGeneralBlock, handleGeneralSegment } from '../handlers/handleGeneralModel';\nimport { handleImage } from '../handlers/handleImage';\nimport { handleList } from '../handlers/handleList';\nimport { handleListItem } from '../handlers/handleListItem';\nimport { handleParagraph } from '../handlers/handleParagraph';\nimport { handleSegment } from '../handlers/handleSegment';\nimport { handleSegmentDecorator } from '../handlers/handleSegmentDecorator';\nimport { handleTable } from '../handlers/handleTable';\nimport { handleText } from '../handlers/handleText';\nimport type { ContentModelHandlerMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const defaultContentModelHandlers: ContentModelHandlerMap = {\n    block: handleBlock,\n    blockGroupChildren: handleBlockGroupChildren,\n    br: handleBr,\n    entityBlock: handleEntityBlock,\n    entitySegment: handleEntitySegment,\n    generalBlock: handleGeneralBlock,\n    generalSegment: handleGeneralSegment,\n    divider: handleDivider,\n    image: handleImage,\n    list: handleList,\n    listItem: handleListItem,\n    paragraph: handleParagraph,\n    formatContainer: handleFormatContainer,\n    segment: handleSegment,\n    segmentDecorator: handleSegmentDecorator,\n    table: handleTable,\n    text: handleText,\n};\n","import type {\n    ContentModelBlock,\n    ContentModelBlockHandler,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleBlock: ContentModelBlockHandler<ContentModelBlock> = (\n    doc: Document,\n    parent: Node,\n    block: ContentModelBlock,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    const handlers = context.modelHandlers;\n\n    switch (block.blockType) {\n        case 'Table':\n            refNode = handlers.table(doc, parent, block, context, refNode);\n            break;\n        case 'Paragraph':\n            refNode = handlers.paragraph(doc, parent, block, context, refNode);\n            break;\n        case 'Entity':\n            refNode = handlers.entityBlock(doc, parent, block, context, refNode);\n            break;\n        case 'Divider':\n            refNode = handlers.divider(doc, parent, block, context, refNode);\n            break;\n        case 'BlockGroup':\n            switch (block.blockGroupType) {\n                case 'General':\n                    refNode = handlers.generalBlock(doc, parent, block, context, refNode);\n                    break;\n\n                case 'FormatContainer':\n                    refNode = handlers.formatContainer(doc, parent, block, context, refNode);\n                    break;\n\n                case 'ListItem':\n                    refNode = handlers.listItem(doc, parent, block, context, refNode);\n                    break;\n            }\n\n            break;\n    }\n\n    return refNode;\n};\n","import { cleanUpRestNodes } from '../utils/cleanUpRestNodes';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelHandler,\n    ModelToDomContext,\n    ModelToDomListStackItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleBlockGroupChildren: ContentModelHandler<ContentModelBlockGroup> = (\n    doc: Document,\n    parent: Node,\n    group: ContentModelBlockGroup,\n    context: ModelToDomContext\n) => {\n    const { listFormat } = context;\n    const nodeStack = listFormat.nodeStack;\n    let refNode: Node | null = parent.firstChild;\n\n    try {\n        group.blocks.forEach((childBlock, index) => {\n            // When process list, we need a node stack.\n            // When there are two continuous lists, they should share the same stack\n            // so that list items with same type/threadId can be merged into the same list element\n            // In other cases, clear the stack so that two separate lists won't share the same list element\n            if (\n                index == 0 ||\n                childBlock.blockType != 'BlockGroup' ||\n                childBlock.blockGroupType != 'ListItem'\n            ) {\n                cleanUpNodeStack(listFormat.nodeStack, context);\n\n                if (listFormat.nodeStack.length > 0) {\n                    listFormat.nodeStack = [];\n                }\n            }\n\n            refNode = context.modelHandlers.block(doc, parent, childBlock, context, refNode);\n\n            if (childBlock.blockType == 'Entity') {\n                context.domIndexer?.onBlockEntity(childBlock, group);\n            }\n        });\n\n        cleanUpNodeStack(listFormat.nodeStack, context);\n\n        // Remove all rest node if any since they don't appear in content model\n        cleanUpRestNodes(refNode, context.rewriteFromModel);\n    } finally {\n        listFormat.nodeStack = nodeStack;\n    }\n};\n\nfunction cleanUpNodeStack(nodeStack: ModelToDomListStackItem[], context: ModelToDomContext) {\n    if (context.allowCacheListItem && nodeStack.length > 0) {\n        // Clear list stack, only run to nodeStack[1] because nodeStack[0] is the parent node\n        for (let i = nodeStack.length - 1; i > 0; i--) {\n            const node = nodeStack.pop()?.refNode ?? null;\n\n            cleanUpRestNodes(node, context.rewriteFromModel);\n        }\n    }\n}\n","import { handleSegmentCommon } from '../utils/handleSegmentCommon';\nimport type { ContentModelBr, ContentModelSegmentHandler } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleBr: ContentModelSegmentHandler<ContentModelBr> = (\n    doc,\n    parent,\n    segment,\n    context,\n    segmentNodes\n) => {\n    const br = doc.createElement('br');\n    const element = doc.createElement('span');\n    element.appendChild(br);\n    parent.appendChild(element);\n\n    handleSegmentCommon(doc, br, element, segment, context, segmentNodes);\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { reuseCachedElement } from '../../domUtils/reuseCachedElement';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelDivider,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleDivider: ContentModelBlockHandler<ContentModelDivider> = (\n    doc: Document,\n    parent: Node,\n    divider: ContentModelDivider,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    let element = context.allowCacheElement ? divider.cachedElement : undefined;\n\n    if (element && !divider.isSelected) {\n        refNode = reuseCachedElement(parent, element, refNode, context.rewriteFromModel);\n    } else {\n        element = doc.createElement(divider.tagName);\n\n        if (context.allowCacheElement) {\n            divider.cachedElement = element;\n        }\n\n        parent.insertBefore(element, refNode);\n        context.rewriteFromModel.addedBlockElements.push(element);\n\n        applyFormat(element, context.formatAppliers.divider, divider.format, context);\n\n        if (divider.size) {\n            element.setAttribute('size', divider.size);\n        }\n    }\n\n    context.onNodeCreated?.(divider, element);\n\n    return refNode;\n};\n","import { addDelimiters } from '../../domUtils/entityUtils';\nimport { applyFormat } from '../utils/applyFormat';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport { reuseCachedElement } from '../../domUtils/reuseCachedElement';\nimport { wrap } from '../../domUtils/wrap';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelEntity,\n    ContentModelSegmentFormat,\n    ContentModelSegmentHandler,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\nconst BlockEntityContainer = '_E_EBlockEntityContainer';\n\n/**\n * @internal\n */\nexport const handleEntityBlock: ContentModelBlockHandler<ContentModelEntity> = (\n    doc,\n    parent,\n    entityModel,\n    context,\n    refNode\n) => {\n    const { entityFormat, wrapper } = entityModel;\n\n    applyFormat(wrapper, context.formatAppliers.entity, entityFormat, context);\n\n    const isCursorAroundEntity =\n        context.addDelimiterForEntity &&\n        wrapper.style.display == 'inline-block' &&\n        wrapper.style.width == '100%';\n    const isContained = wrapper.parentElement?.classList.contains(BlockEntityContainer);\n    const elementToReuse = isContained && isCursorAroundEntity ? wrapper.parentElement! : wrapper;\n\n    refNode = reuseCachedElement(parent, elementToReuse, refNode, context.rewriteFromModel);\n\n    if (isCursorAroundEntity) {\n        if (!isContained) {\n            const element = wrap(doc, wrapper, 'div');\n            element.classList.add(BlockEntityContainer);\n        }\n        addDelimiters(doc, wrapper, getSegmentFormat(context), context);\n    }\n\n    context.onNodeCreated?.(entityModel, wrapper);\n\n    return refNode;\n};\n\n/**\n * @internal\n */\nexport const handleEntitySegment: ContentModelSegmentHandler<ContentModelEntity> = (\n    doc,\n    parent,\n    entityModel,\n    context,\n    newSegments\n) => {\n    const { entityFormat, wrapper, format } = entityModel;\n\n    parent.appendChild(wrapper);\n    newSegments?.push(wrapper);\n\n    if (getObjectKeys(format).length > 0) {\n        const span = wrap(doc, wrapper, 'span');\n\n        applyFormat(span, context.formatAppliers.segment, format, context);\n    }\n\n    applyFormat(wrapper, context.formatAppliers.entity, entityFormat, context);\n\n    if (context.addDelimiterForEntity && entityFormat.isReadonly) {\n        const [after, before] = addDelimiters(doc, wrapper, getSegmentFormat(context), context);\n\n        if (newSegments) {\n            newSegments.push(after, before);\n\n            if (after.firstChild) {\n                newSegments.push(after.firstChild);\n            }\n\n            if (before.firstChild) {\n                newSegments.push(before.firstChild);\n            }\n        }\n\n        context.regularSelection.current.segment = after;\n    } else {\n        context.regularSelection.current.segment = wrapper;\n    }\n\n    context.onNodeCreated?.(entityModel, wrapper);\n};\nfunction getSegmentFormat(\n    context: ModelToDomContext\n): ContentModelSegmentFormat | null | undefined {\n    return {\n        ...context.pendingFormat?.format,\n        ...context.defaultFormat,\n    };\n}\n","import { applyFormat } from '../utils/applyFormat';\nimport { isBlockGroupEmpty } from '../../modelApi/common/isEmpty';\nimport { reuseCachedElement } from '../../domUtils/reuseCachedElement';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelBlockHandler,\n    ContentModelFormatContainer,\n    ContentModelSegmentFormat,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\nconst PreChildFormat: ContentModelSegmentFormat & ContentModelBlockFormat = {\n    fontFamily: 'monospace',\n    whiteSpace: 'pre',\n};\n\n/**\n * @internal\n */\nexport const handleFormatContainer: ContentModelBlockHandler<ContentModelFormatContainer> = (\n    doc: Document,\n    parent: Node,\n    container: ContentModelFormatContainer,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    let element = context.allowCacheElement ? container.cachedElement : undefined;\n\n    if (element) {\n        refNode = reuseCachedElement(parent, element, refNode, context.rewriteFromModel);\n\n        context.modelHandlers.blockGroupChildren(doc, element, container, context);\n    } else if (!isBlockGroupEmpty(container)) {\n        const containerNode = doc.createElement(container.tagName);\n\n        if (context.allowCacheElement) {\n            container.cachedElement = containerNode;\n        }\n\n        parent.insertBefore(containerNode, refNode);\n        context.rewriteFromModel.addedBlockElements.push(containerNode);\n\n        stackFormat(context, container.tagName, () => {\n            applyFormat(containerNode, context.formatAppliers.container, container.format, context);\n            applyFormat(\n                containerNode,\n                context.formatAppliers.segmentOnBlock,\n                container.format,\n                context\n            );\n\n            applyFormat(containerNode, context.formatAppliers.container, container.format, context);\n        });\n\n        if (container.tagName == 'pre') {\n            stackFormat(context, PreChildFormat, () => {\n                context.modelHandlers.blockGroupChildren(doc, containerNode, container, context);\n            });\n        } else {\n            context.modelHandlers.blockGroupChildren(doc, containerNode, container, context);\n        }\n\n        element = containerNode;\n    }\n\n    if (element) {\n        context.onNodeCreated?.(container, element);\n    }\n\n    return refNode;\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { handleSegmentCommon } from '../utils/handleSegmentCommon';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport { reuseCachedElement } from '../../domUtils/reuseCachedElement';\nimport { wrap } from '../../domUtils/wrap';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelGeneralBlock,\n    ContentModelGeneralSegment,\n    ContentModelSegmentHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleGeneralBlock: ContentModelBlockHandler<ContentModelGeneralBlock> = (\n    doc,\n    parent,\n    group,\n    context,\n    refNode\n) => {\n    let node: HTMLElement = group.element;\n\n    if (refNode && node.parentNode == parent) {\n        refNode = reuseCachedElement(parent, node, refNode, context.rewriteFromModel);\n    } else {\n        node = node.cloneNode() as HTMLElement;\n        group.element = node as HTMLElement;\n\n        applyFormat(node, context.formatAppliers.general, group.format, context);\n\n        parent.insertBefore(node, refNode);\n        context.rewriteFromModel.addedBlockElements.push(node);\n    }\n\n    context.onNodeCreated?.(group, node);\n    context.modelHandlers.blockGroupChildren(doc, node, group, context);\n\n    return refNode;\n};\n\n/**\n * @internal\n */\nexport const handleGeneralSegment: ContentModelSegmentHandler<ContentModelGeneralSegment> = (\n    doc,\n    parent,\n    group,\n    context,\n    segmentNodes\n) => {\n    const node = group.element.cloneNode() as HTMLElement;\n    group.element = node;\n    parent.appendChild(node);\n\n    if (isNodeOfType(node, 'ELEMENT_NODE')) {\n        const element = wrap(doc, node, 'span');\n\n        handleSegmentCommon(doc, node, element, group, context, segmentNodes);\n        applyFormat(node, context.formatAppliers.general, group.format, context);\n\n        context.onNodeCreated?.(group, node);\n    }\n\n    context.modelHandlers.blockGroupChildren(doc, node, group, context);\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { handleSegmentCommon } from '../utils/handleSegmentCommon';\nimport { parseValueWithUnit } from '../../formatHandlers/utils/parseValueWithUnit';\nimport type { ContentModelImage, ContentModelSegmentHandler } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleImage: ContentModelSegmentHandler<ContentModelImage> = (\n    doc,\n    parent,\n    imageModel,\n    context,\n    segmentNodes\n) => {\n    const img = doc.createElement('img');\n    const element = doc.createElement('span');\n\n    parent.appendChild(element);\n    element.appendChild(img);\n\n    img.src = imageModel.src;\n\n    if (imageModel.alt) {\n        img.alt = imageModel.alt;\n    }\n\n    if (imageModel.title) {\n        img.title = imageModel.title;\n    }\n\n    applyFormat(img, context.formatAppliers.image, imageModel.format, context);\n    applyFormat(img, context.formatAppliers.dataset, imageModel.dataset, context);\n\n    const { width, height } = imageModel.format;\n    const widthNum = width ? parseValueWithUnit(width) : 0;\n    const heightNum = height ? parseValueWithUnit(height) : 0;\n\n    if (widthNum > 0) {\n        img.width = widthNum;\n    }\n\n    if (heightNum > 0) {\n        img.height = heightNum;\n    }\n\n    if (imageModel.isSelectedAsImageSelection) {\n        context.imageSelection = {\n            type: 'image',\n            image: img,\n        };\n    }\n\n    handleSegmentCommon(doc, img, element, imageModel, context, segmentNodes);\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { applyMetadata } from '../utils/applyMetadata';\nimport { cleanUpRestNodes } from '../utils/cleanUpRestNodes';\nimport { reuseCachedElement } from '../../domUtils/reuseCachedElement';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelListItem,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleList: ContentModelBlockHandler<ContentModelListItem> = (\n    doc: Document,\n    parent: Node,\n    listItem: ContentModelListItem,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    let layer = 0;\n    const { nodeStack } = context.listFormat;\n\n    if (nodeStack.length == 0) {\n        nodeStack.push({\n            node: parent,\n            refNode,\n        });\n    }\n\n    // Skip existing list levels that has same properties so we can reuse them\n    for (; layer < listItem.levels.length && layer + 1 < nodeStack.length; layer++) {\n        const parentLevel = nodeStack[layer];\n        const stackLevel = nodeStack[layer + 1];\n        const itemLevel = listItem.levels[layer];\n\n        if (\n            stackLevel.listType != itemLevel.listType ||\n            stackLevel.dataset?.editingInfo != itemLevel.dataset.editingInfo ||\n            (itemLevel.listType == 'OL' &&\n                typeof itemLevel.format.startNumberOverride === 'number') ||\n            (itemLevel.listType == 'UL' &&\n                itemLevel.format.listStyleType != stackLevel.format?.listStyleType)\n        ) {\n            break;\n        }\n\n        if (\n            context.allowCacheListItem &&\n            parentLevel.refNode &&\n            itemLevel.cachedElement == parentLevel.refNode\n        ) {\n            // Move refNode to next node since we are reusing this cached element\n            parentLevel.refNode = parentLevel.refNode.nextSibling;\n        }\n    }\n\n    // Cut off remained list levels that we can't reuse\n    if (context.allowCacheListItem) {\n        // Clean up all rest nodes in the reused list levels\n        for (let i = layer + 1; i < nodeStack.length; i++) {\n            const stackLevel = nodeStack[i];\n\n            cleanUpRestNodes(stackLevel.refNode, context.rewriteFromModel);\n        }\n    }\n\n    nodeStack.splice(layer + 1);\n\n    // Create new list levels that are after reused ones\n    for (; layer < listItem.levels.length; layer++) {\n        const level = listItem.levels[layer];\n        const lastParent = nodeStack[nodeStack.length - 1].node;\n\n        let newList: HTMLOListElement | HTMLUListElement;\n        let isNewlyCreated = false;\n        const levelRefNode = nodeStack[layer].refNode ?? null;\n\n        if (context.allowCacheListItem && level.cachedElement) {\n            newList = level.cachedElement;\n\n            nodeStack[layer].refNode = reuseCachedElement(\n                lastParent,\n                level.cachedElement,\n                levelRefNode,\n                context.rewriteFromModel\n            );\n            nodeStack.push({\n                node: newList,\n                refNode: newList.firstChild,\n                listType: level.listType,\n                format: { ...level.format },\n                dataset: { ...level.dataset },\n            });\n        } else {\n            newList = doc.createElement(level.listType == 'OL' ? 'ol' : 'ul');\n            isNewlyCreated = true;\n\n            lastParent.insertBefore(newList, levelRefNode);\n            nodeStack.push({\n                node: newList,\n                refNode: null,\n                listType: level.listType,\n                format: { ...level.format },\n                dataset: { ...level.dataset },\n            });\n\n            if (context.allowCacheListItem) {\n                level.cachedElement = newList;\n            }\n        }\n\n        applyFormat(newList, context.formatAppliers.listLevelThread, level.format, context);\n\n        // Need to apply metadata after applying list level format since the list numbers value relies on the result of list thread handling\n        applyMetadata(level, context.metadataAppliers.listLevel, level.format, context);\n\n        // Need to apply listItemElement formats after applying metadata since the list numbers value relies on the result of metadata handling\n        applyFormat(newList, context.formatAppliers.listLevel, level.format, context);\n        applyFormat(newList, context.formatAppliers.dataset, level.dataset, context);\n\n        if (isNewlyCreated) {\n            context.onNodeCreated?.(level, newList);\n        }\n    }\n\n    return nodeStack[0].refNode;\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { applyMetadata } from '../utils/applyMetadata';\nimport { isGenericRoleElement } from '../../domUtils/isGenericRoleElement';\nimport { reuseCachedElement } from '../../domUtils/reuseCachedElement';\nimport { setParagraphNotImplicit } from '../../modelApi/block/setParagraphNotImplicit';\nimport { stackFormat } from '../utils/stackFormat';\nimport { unwrap } from '../../domUtils/unwrap';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelListItem,\n    ModelToDomContext,\n    ModelToDomListStackItem,\n} from 'roosterjs-content-model-types';\n\nconst HtmlRoleAttribute = 'role';\nconst PresentationRoleValue = 'presentation';\n\n/**\n * @internal\n */\nexport const handleListItem: ContentModelBlockHandler<ContentModelListItem> = (\n    doc: Document,\n    parent: Node,\n    listItem: ContentModelListItem,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    refNode = context.modelHandlers.list(doc, parent, listItem, context, refNode);\n\n    const { nodeStack } = context.listFormat;\n    const leafLevel: Partial<ModelToDomListStackItem> = nodeStack?.[nodeStack.length - 1] ?? {};\n    const itemRefNode = leafLevel.refNode || null;\n    const listParent = leafLevel.node || parent;\n    const level = listItem.levels[listItem.levels.length - 1];\n\n    let li: HTMLLIElement;\n    let isNewlyCreated = false;\n\n    if (context.allowCacheListItem && listItem.cachedElement) {\n        li = listItem.cachedElement;\n\n        // Check if the cached LI is used as refNode under another list level,\n        // since we know we are going to move it under the current listParent,\n        // we need to update the refNode of the previous list level to avoid removing it later\n        for (let i = 0; i < nodeStack.length - 1; i++) {\n            if (nodeStack[i].refNode === li) {\n                nodeStack[i].refNode = li.nextSibling;\n            }\n        }\n\n        leafLevel.refNode = reuseCachedElement(\n            listParent,\n            li,\n            itemRefNode,\n            context.rewriteFromModel\n        );\n    } else {\n        li = doc.createElement('li');\n        isNewlyCreated = true;\n\n        // It is possible listParent is the same with parent param.\n        // This happens when outdent a list item to cause it has no list level\n        listParent.insertBefore(li, itemRefNode?.parentNode == listParent ? itemRefNode : null);\n        context.rewriteFromModel.addedBlockElements.push(li);\n\n        if (context.allowCacheListItem) {\n            listItem.cachedElement = li;\n        }\n    }\n\n    if (level) {\n        applyFormat(li, context.formatAppliers.segment, listItem.formatHolder.format, context);\n        applyFormat(li, context.formatAppliers.listItemThread, level.format, context);\n\n        // Need to apply metadata after applying listItem format since the list numbers value relies on the result of list thread handling\n        applyMetadata(level, context.metadataAppliers.listItem, listItem.format, context);\n\n        // Need to apply listItemElement formats after applying metadata since the list numbers value relies on the result of metadata handling\n        applyFormat(li, context.formatAppliers.listItemElement, listItem.format, context);\n\n        stackFormat(context, listItem.formatHolder.format, () => {\n            context.modelHandlers.blockGroupChildren(doc, li, listItem, context);\n        });\n    } else {\n        // There is no level for this list item, that means it should be moved out of the list\n        // For each paragraph, make it not implicit so it will have a DIV around it, to avoid more paragraphs connected together\n        listItem.blocks.forEach(setParagraphNotImplicit);\n\n        context.modelHandlers.blockGroupChildren(doc, li, listItem, context);\n\n        unwrap(li);\n    }\n\n    // Add role=\"presentation\" to all generic role elements inside the LI element\n    // This is to make sure the elements are announced correctly by screen readers\n    // when using arrow keys to navigate the list.\n    for (let index = 0; index < li.children.length; index++) {\n        const element = li.children.item(index);\n        if (isGenericRoleElement(element)) {\n            element.setAttribute(HtmlRoleAttribute, PresentationRoleValue);\n        }\n    }\n\n    if (isNewlyCreated) {\n        context.onNodeCreated?.(listItem, li);\n    }\n\n    return refNode;\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport { optimize } from '../optimizers/optimize';\nimport { reuseCachedElement } from '../../domUtils/reuseCachedElement';\nimport { stackFormat } from '../utils/stackFormat';\nimport { unwrap } from '../../domUtils/unwrap';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelParagraph,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\nconst DefaultParagraphTag = 'div';\n\n/**\n * @internal\n */\nexport const handleParagraph: ContentModelBlockHandler<ContentModelParagraph> = (\n    doc: Document,\n    parent: Node,\n    paragraph: ContentModelParagraph,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    let container = context.allowCacheElement ? paragraph.cachedElement : undefined;\n\n    if (container && paragraph.segments.every(x => x.segmentType != 'General' && !x.isSelected)) {\n        refNode = reuseCachedElement(parent, container, refNode, context.rewriteFromModel);\n    } else {\n        stackFormat(context, paragraph.decorator?.tagName || null, () => {\n            const needParagraphWrapper =\n                !paragraph.isImplicit ||\n                !!paragraph.decorator ||\n                (getObjectKeys(paragraph.format).length > 0 &&\n                    paragraph.segments.some(segment => segment.segmentType != 'SelectionMarker'));\n            const formatOnWrapper = needParagraphWrapper\n                ? {\n                      ...(paragraph.decorator?.format || {}),\n                      ...paragraph.segmentFormat,\n                  }\n                : {};\n\n            container = doc.createElement(paragraph.decorator?.tagName || DefaultParagraphTag);\n\n            parent.insertBefore(container, refNode);\n\n            context.regularSelection.current = {\n                block: needParagraphWrapper ? container : container.parentNode,\n                segment: null,\n            };\n\n            const handleSegments = () => {\n                const parent = container;\n\n                if (parent) {\n                    const firstSegment = paragraph.segments[0];\n\n                    if (firstSegment?.segmentType == 'SelectionMarker') {\n                        // Make sure there is a segment created before selection marker.\n                        // If selection marker is the first selected segment in a paragraph, create a dummy text node,\n                        // so after rewrite, the regularSelection object can have a valid segment object set to the text node.\n                        context.modelHandlers.text(\n                            doc,\n                            parent,\n                            {\n                                ...firstSegment,\n                                segmentType: 'Text',\n                                text: '',\n                            },\n                            context,\n                            []\n                        );\n                    }\n\n                    paragraph.segments.forEach(segment => {\n                        const newSegments: Node[] = [];\n                        context.modelHandlers.segment(doc, parent, segment, context, newSegments);\n\n                        newSegments.forEach(node => {\n                            context.domIndexer?.onSegment(node, paragraph, [segment]);\n                        });\n                    });\n                }\n            };\n\n            if (needParagraphWrapper) {\n                stackFormat(context, formatOnWrapper, handleSegments);\n\n                applyFormat(container, context.formatAppliers.block, paragraph.format, context);\n                applyFormat(container, context.formatAppliers.container, paragraph.format, context);\n                applyFormat(\n                    container,\n                    context.formatAppliers.segmentOnBlock,\n                    formatOnWrapper,\n                    context\n                );\n\n                context.paragraphMap?.applyMarkerToDom(container, paragraph);\n            } else {\n                handleSegments();\n            }\n\n            optimize(container, context);\n\n            // It is possible the next sibling node is changed during processing child segments\n            // e.g. When this paragraph is an implicit paragraph and it contains an inline entity segment\n            // The segment will be appended to container as child then the container will be removed\n            // since this paragraph it is implicit. In that case container.nextSibling will become original\n            // inline entity's next sibling. So reset refNode to its real next sibling (after change) here\n            // to make sure the value is correct.\n            refNode = container.nextSibling;\n\n            if (container) {\n                context.onNodeCreated?.(paragraph, container);\n                context.domIndexer?.onParagraph(container);\n            }\n\n            if (needParagraphWrapper) {\n                if (context.allowCacheElement) {\n                    paragraph.cachedElement = container;\n                }\n\n                context.rewriteFromModel.addedBlockElements.push(container);\n            } else {\n                unwrap(container);\n                container = undefined;\n            }\n        });\n    }\n\n    return refNode;\n};\n","import type {\n    ContentModelSegment,\n    ContentModelSegmentHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleSegment: ContentModelSegmentHandler<ContentModelSegment> = (\n    doc,\n    parent,\n    segment,\n    context,\n    segmentNodes\n) => {\n    const regularSelection = context.regularSelection;\n\n    // If start position is not set yet, and current segment is in selection, set start position\n    if (segment.isSelected && !regularSelection.start) {\n        regularSelection.start = {\n            ...regularSelection.current,\n        };\n    }\n\n    switch (segment.segmentType) {\n        case 'Text':\n            context.modelHandlers.text(doc, parent, segment, context, segmentNodes);\n            break;\n\n        case 'Br':\n            context.modelHandlers.br(doc, parent, segment, context, segmentNodes);\n            break;\n\n        case 'Image':\n            context.modelHandlers.image(doc, parent, segment, context, segmentNodes);\n            break;\n\n        case 'General':\n            context.modelHandlers.generalSegment(doc, parent, segment, context, segmentNodes);\n            break;\n\n        case 'Entity':\n            context.modelHandlers.entitySegment(doc, parent, segment, context, segmentNodes);\n            break;\n    }\n\n    // If end position is not set, or it is not finalized, and current segment is still in selection, set end position\n    // If there is other selection, we will overwrite regularSelection.end when we process that segment\n    if (segment.isSelected && regularSelection.start) {\n        regularSelection.end = {\n            ...regularSelection.current,\n        };\n    }\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport { stackFormat } from '../utils/stackFormat';\nimport { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type {\n    ContentModelSegment,\n    ContentModelSegmentHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleSegmentDecorator: ContentModelSegmentHandler<ContentModelSegment> = (\n    _,\n    parent,\n    segment,\n    context\n) => {\n    const { code, link } = segment;\n\n    if (isNodeOfType(parent, 'ELEMENT_NODE')) {\n        if (link) {\n            stackFormat(context, 'a', () => {\n                const a = wrapAllChildNodes(parent, 'a');\n\n                applyFormat(a, context.formatAppliers.link, link.format, context);\n                applyFormat(a, context.formatAppliers.dataset, link.dataset, context);\n\n                context.onNodeCreated?.(link, a);\n            });\n        }\n\n        if (code) {\n            stackFormat(context, 'code', () => {\n                const codeNode = wrapAllChildNodes(parent, 'code');\n\n                applyFormat(codeNode, context.formatAppliers.code, code.format, context);\n\n                context.onNodeCreated?.(code, codeNode);\n            });\n        }\n    }\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { hasMetadata } from '../../modelApi/metadata/updateMetadata';\nimport { isBlockEmpty } from '../../modelApi/common/isEmpty';\nimport { moveChildNodes } from '../../domUtils/moveChildNodes';\nimport { reuseCachedElement } from '../../domUtils/reuseCachedElement';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelTable,\n    ModelToDomContext,\n    TableSelection,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleTable: ContentModelBlockHandler<ContentModelTable> = (\n    doc: Document,\n    parent: Node,\n    table: ContentModelTable,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    if (isBlockEmpty(table)) {\n        // Empty table, do not create TABLE element and just return\n        return refNode;\n    }\n\n    let tableNode = context.allowCacheElement ? table.cachedElement : undefined;\n\n    if (tableNode) {\n        refNode = reuseCachedElement(parent, tableNode, refNode, context.rewriteFromModel);\n\n        moveChildNodes(tableNode);\n    } else {\n        tableNode = doc.createElement('table');\n\n        if (context.allowCacheElement) {\n            table.cachedElement = tableNode;\n        }\n\n        parent.insertBefore(tableNode, refNode);\n        context.rewriteFromModel.addedBlockElements.push(tableNode);\n\n        applyFormat(tableNode, context.formatAppliers.block, table.format, context);\n        applyFormat(tableNode, context.formatAppliers.table, table.format, context);\n        applyFormat(tableNode, context.formatAppliers.tableBorder, table.format, context);\n        applyFormat(tableNode, context.formatAppliers.dataset, table.dataset, context);\n    }\n\n    context.onNodeCreated?.(table, tableNode);\n\n    const tbody = doc.createElement('tbody');\n    tableNode.appendChild(tbody);\n\n    for (let row = 0; row < table.rows.length; row++) {\n        const tableRow = table.rows[row];\n\n        if (tableRow.cells.length == 0) {\n            // Skip empty row\n            continue;\n        }\n\n        const tr = (context.allowCacheElement && tableRow.cachedElement) || doc.createElement('tr');\n        tbody.appendChild(tr);\n        moveChildNodes(tr);\n\n        if (!tableRow.cachedElement) {\n            if (context.allowCacheElement) {\n                tableRow.cachedElement = tr;\n            }\n\n            applyFormat(tr, context.formatAppliers.tableRow, tableRow.format, context);\n        }\n\n        context.onNodeCreated?.(tableRow, tr);\n\n        for (let col = 0; col < tableRow.cells.length; col++) {\n            const cell = tableRow.cells[col];\n\n            if (cell.isSelected) {\n                const tableSelection: TableSelection = context.tableSelection || {\n                    type: 'table',\n                    table: tableNode,\n                    firstColumn: col,\n                    lastColumn: col,\n                    firstRow: row,\n                    lastRow: row,\n                };\n\n                if (tableSelection.table == tableNode) {\n                    tableSelection.lastColumn = Math.max(tableSelection.lastColumn, col);\n                    tableSelection.lastRow = Math.max(tableSelection.lastRow, row);\n                }\n\n                context.tableSelection = tableSelection;\n            }\n\n            if (!cell.spanAbove && !cell.spanLeft) {\n                const tag = cell.isHeader ? 'th' : 'td';\n                const td =\n                    (context.allowCacheElement && cell.cachedElement) || doc.createElement(tag);\n\n                tr.appendChild(td);\n\n                let rowSpan = 1;\n                let colSpan = 1;\n                let width = table.widths[col];\n                let height = tableRow.height;\n\n                for (; table.rows[row + rowSpan]?.cells[col]?.spanAbove; rowSpan++) {\n                    height += table.rows[row + rowSpan].height;\n                }\n                for (; tableRow.cells[col + colSpan]?.spanLeft; colSpan++) {\n                    width += table.widths[col + colSpan];\n                }\n\n                if (rowSpan > 1) {\n                    td.rowSpan = rowSpan;\n                }\n\n                if (colSpan > 1) {\n                    td.colSpan = colSpan;\n                }\n\n                if (!cell.cachedElement || (cell.format.useBorderBox && hasMetadata(table))) {\n                    if (width > 0 && !td.style.width) {\n                        td.style.width = width + 'px';\n                    }\n\n                    if (height > 0 && !td.style.height) {\n                        td.style.height = height + 'px';\n                    }\n                }\n\n                stackFormat(context, tag, () => {\n                    if (!cell.cachedElement) {\n                        if (context.allowCacheElement) {\n                            cell.cachedElement = td;\n                        }\n\n                        applyFormat(td, context.formatAppliers.block, cell.format, context);\n                        applyFormat(td, context.formatAppliers.tableCell, cell.format, context);\n                        applyFormat(\n                            td,\n                            context.formatAppliers.tableCellBorder,\n                            cell.format,\n                            context\n                        );\n                        applyFormat(td, context.formatAppliers.dataset, cell.dataset, context);\n                    }\n\n                    context.modelHandlers.blockGroupChildren(doc, td, cell, context);\n                });\n\n                context.onNodeCreated?.(cell, td);\n            }\n        }\n    }\n\n    context.domIndexer?.onTable(tableNode, table);\n\n    return refNode;\n};\n","import { handleSegmentCommon } from '../utils/handleSegmentCommon';\nimport type { ContentModelSegmentHandler, ContentModelText } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleText: ContentModelSegmentHandler<ContentModelText> = (\n    doc,\n    parent,\n    segment,\n    context,\n    segmentNodes\n) => {\n    const txt = doc.createTextNode(segment.text);\n    const element = doc.createElement('span');\n\n    parent.appendChild(element);\n    element.appendChild(txt);\n\n    context.formatAppliers.text.forEach(applier => applier(segment.format, txt, context));\n\n    handleSegmentCommon(doc, txt, element, segment, context, segmentNodes);\n};\n","import { isNodeOfType } from '../../domUtils/isNodeOfType';\n\nconst OptimizeTags = ['SPAN', 'B', 'EM', 'I', 'U', 'SUB', 'SUP', 'STRIKE', 'S', 'A', 'CODE'];\n\n/**\n * @internal\n */\nexport function mergeNode(root: Node) {\n    for (let child = root.firstChild; child; ) {\n        const next = child.nextSibling;\n\n        if (\n            next &&\n            isNodeOfType(child, 'ELEMENT_NODE') &&\n            isNodeOfType(next, 'ELEMENT_NODE') &&\n            child.tagName == next.tagName &&\n            OptimizeTags.indexOf(child.tagName) >= 0 &&\n            hasSameAttributes(child, next)\n        ) {\n            while (next.firstChild) {\n                child.appendChild(next.firstChild);\n            }\n\n            next.parentNode!.removeChild(next);\n        } else {\n            child = next;\n        }\n    }\n}\n\nfunction hasSameAttributes(element1: HTMLElement, element2: HTMLElement) {\n    const attr1 = element1.attributes;\n    const attr2 = element2.attributes;\n\n    if (attr1.length != attr2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < attr1.length; i++) {\n        if (attr1[i].name != attr2[i].name || attr1[i].value != attr2[i].value) {\n            return false;\n        }\n    }\n\n    return true;\n}\n","import { isEntityElement } from '../../domUtils/entityUtils';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport { mergeNode } from './mergeNode';\nimport { removeUnnecessarySpan } from './removeUnnecessarySpan';\nimport type {\n    ModelToDomBlockAndSegmentNode,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function optimize(root: Node, context: ModelToDomContext) {\n    /**\n     * Do no do any optimization to entity\n     */\n    if (isEntityElement(root)) {\n        return;\n    }\n\n    removeUnnecessarySpan(root);\n    mergeNode(root);\n\n    for (let child = root.firstChild; child; child = child.nextSibling) {\n        optimize(child, context);\n    }\n\n    normalizeTextNode(root, context);\n}\n\n// Merge continuous text nodes into one single node (same with normalize()),\n// and update selection and dom indexes\nfunction normalizeTextNode(root: Node, context: ModelToDomContext) {\n    let lastText: Text | null = null;\n    let child: Node | null;\n    let next: Node | null;\n    const selection = context.regularSelection;\n\n    for (\n        child = root.firstChild, next = child ? child.nextSibling : null;\n        child;\n        child = next, next = child ? child.nextSibling : null\n    ) {\n        if (!isNodeOfType(child, 'TEXT_NODE')) {\n            lastText = null;\n        } else if (!lastText) {\n            lastText = child;\n        } else {\n            const originalLength = lastText.nodeValue?.length ?? 0;\n\n            context.domIndexer?.onMergeText(lastText, child);\n            lastText.nodeValue += child.nodeValue ?? '';\n\n            if (selection) {\n                updateSelection(selection.start, lastText, child, originalLength);\n                updateSelection(selection.end, lastText, child, originalLength);\n            }\n\n            root.removeChild(child);\n        }\n    }\n}\n\nfunction updateSelection(\n    mark: ModelToDomBlockAndSegmentNode | undefined,\n    lastText: Text,\n    nextText: Text,\n    lastTextOriginalLength: number\n) {\n    if (mark && mark.offset == undefined) {\n        if (mark.segment == lastText) {\n            mark.offset = lastTextOriginalLength;\n        } else if (mark.segment == nextText) {\n            mark.segment = lastText;\n        }\n    }\n}\n","import { isNodeOfType } from '../../domUtils/isNodeOfType';\n\n/**\n * @internal\n */\nexport function removeUnnecessarySpan(root: Node) {\n    for (let child = root.firstChild; child; ) {\n        if (\n            isNodeOfType(child, 'ELEMENT_NODE') &&\n            child.tagName == 'SPAN' &&\n            child.attributes.length == 0\n        ) {\n            const node = child;\n            let refNode = child.nextSibling;\n            child = child.nextSibling;\n\n            while (node.lastChild) {\n                const newNode = node.lastChild;\n                root.insertBefore(newNode, refNode);\n                refNode = newNode;\n            }\n\n            root.removeChild(node);\n        } else {\n            child = child.nextSibling;\n        }\n    }\n}\n","import type {\n    ContentModelFormatBase,\n    FormatApplier,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Apply formats to the given HTML element using specified appliers\n * @param element The element to apply formats to\n * @param appliers The appliers we are using to apply formats\n * @param format The format object we get format info from\n * @param context Content Model to DOM context\n */\nexport function applyFormat<T extends ContentModelFormatBase>(\n    element: HTMLElement,\n    appliers: (FormatApplier<T> | null)[],\n    format: T,\n    context: ModelToDomContext\n) {\n    appliers.forEach(applier => {\n        applier?.(format, element, context);\n    });\n}\n","import { updateMetadata } from '../../modelApi/metadata/updateMetadata';\nimport type {\n    ContentModelFormatBase,\n    ContentModelWithDataset,\n    MetadataApplier,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function applyMetadata<TMetadata, TFormat extends ContentModelFormatBase>(\n    model: ContentModelWithDataset<TMetadata>,\n    applier: MetadataApplier<TMetadata, TFormat> | undefined,\n    format: TFormat,\n    context: ModelToDomContext\n) {\n    if (applier) {\n        updateMetadata(\n            model,\n            metadata => {\n                applier.applierFunction(metadata, format, context);\n                return metadata;\n            },\n            applier.metadataDefinition\n        );\n    }\n}\n","import { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport type { RewriteFromModel } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Cleans up all rest nodes starting from refNode\n * @param refNode The reference node to start cleaning up\n * @param rewriteContext The context for rewrite process\n */\nexport function cleanUpRestNodes(refNode: Node | null, rewriteContext: RewriteFromModel) {\n    while (refNode) {\n        const next = refNode.nextSibling;\n\n        if (refNode.parentNode) {\n            if (isNodeOfType(refNode, 'ELEMENT_NODE')) {\n                rewriteContext.removedBlockElements.push(refNode);\n            }\n\n            refNode.parentNode.removeChild(refNode);\n        }\n\n        refNode = next;\n    }\n}\n","import { applyFormat } from './applyFormat';\nimport type { ContentModelSegment, ModelToDomContext } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function handleSegmentCommon(\n    doc: Document,\n    segmentNode: Node,\n    containerNode: HTMLElement,\n    segment: ContentModelSegment,\n    context: ModelToDomContext,\n    segmentNodes: Node[]\n) {\n    if (!segmentNode.firstChild) {\n        context.regularSelection.current.segment = segmentNode;\n    }\n\n    applyFormat(containerNode, context.formatAppliers.styleBasedSegment, segment.format, context);\n\n    segmentNodes?.push(segmentNode);\n    context.modelHandlers.segmentDecorator(doc, containerNode, segment, context, segmentNodes);\n\n    applyFormat(containerNode, context.formatAppliers.elementBasedSegment, segment.format, context);\n\n    context.onNodeCreated?.(segment, segmentNode);\n}\n","import type {\n    ContentModelBlockFormat,\n    ContentModelSegmentFormat,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function stackFormat(\n    context: ModelToDomContext,\n    tagNameOrFormat: string | (ContentModelSegmentFormat & ContentModelBlockFormat) | null,\n    callback: () => void\n) {\n    const newFormat =\n        typeof tagNameOrFormat === 'string'\n            ? context.defaultContentModelFormatMap[tagNameOrFormat]\n            : tagNameOrFormat;\n\n    if (newFormat) {\n        const implicitFormat = context.implicitFormat;\n        const nodeStack = context.listFormat.nodeStack;\n\n        try {\n            context.implicitFormat = {\n                ...implicitFormat,\n                ...newFormat,\n            };\n            context.listFormat.nodeStack = [];\n\n            callback();\n        } finally {\n            context.implicitFormat = implicitFormat;\n            context.listFormat.nodeStack = nodeStack;\n        }\n    } else {\n        callback();\n    }\n}\n","import type {\n    ModelToTextCallbacks,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n} from 'roosterjs-content-model-types';\n\nconst TextForHR = '________________________________________';\nconst defaultCallbacks: Required<ModelToTextCallbacks> = {\n    onDivider: divider => (divider.tagName == 'hr' ? TextForHR : ''),\n    onEntityBlock: () => '',\n    onEntitySegment: entity => entity.wrapper.textContent ?? '',\n    onGeneralSegment: segment => segment.element.textContent ?? '',\n    onImage: () => ' ',\n    onText: text => text.text,\n    onParagraph: () => true,\n    onTable: () => true,\n    onBlockGroup: () => true,\n};\n\n/**\n * Convert Content Model to plain text\n * @param model The source Content Model\n * @param [separator='\\r\\n'] The separator string used for connect lines\n * @param callbacks  Callbacks to customize the behavior of contentModelToText function\n */\nexport function contentModelToText(\n    model: ReadonlyContentModelDocument,\n    separator: string = '\\r\\n',\n    callbacks?: ModelToTextCallbacks\n): string {\n    const textArray: string[] = [];\n    const fullCallbacks = Object.assign({}, defaultCallbacks, callbacks);\n\n    contentModelToTextArray(model, textArray, fullCallbacks);\n\n    return textArray.join(separator);\n}\n\nfunction contentModelToTextArray(\n    group: ReadonlyContentModelBlockGroup,\n    textArray: string[],\n    callbacks: Required<ModelToTextCallbacks>\n) {\n    if (callbacks.onBlockGroup(group)) {\n        group.blocks.forEach(block => {\n            switch (block.blockType) {\n                case 'Paragraph':\n                    if (callbacks.onParagraph(block)) {\n                        let text = '';\n\n                        block.segments.forEach(segment => {\n                            switch (segment.segmentType) {\n                                case 'Br':\n                                    textArray.push(text);\n                                    text = '';\n                                    break;\n\n                                case 'Entity':\n                                    text += callbacks.onEntitySegment(segment);\n                                    break;\n\n                                case 'General':\n                                    text += callbacks.onGeneralSegment(segment);\n                                    break;\n\n                                case 'Text':\n                                    text += callbacks.onText(segment);\n                                    break;\n\n                                case 'Image':\n                                    text += callbacks.onImage(segment);\n                                    break;\n                            }\n                        });\n\n                        if (text) {\n                            textArray.push(text);\n                        }\n                    }\n\n                    break;\n\n                case 'Divider':\n                    textArray.push(callbacks.onDivider(block));\n                    break;\n                case 'Entity':\n                    textArray.push(callbacks.onEntityBlock(block));\n                    break;\n\n                case 'Table':\n                    if (callbacks.onTable(block)) {\n                        block.rows.forEach(row =>\n                            row.cells.forEach(cell => {\n                                contentModelToTextArray(cell, textArray, callbacks);\n                            })\n                        );\n                    }\n                    break;\n\n                case 'BlockGroup':\n                    contentModelToTextArray(block, textArray, callbacks);\n                    break;\n            }\n        });\n    }\n}\n","type HeadingLevelTags = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n\nconst HeaderFontSizes: Record<HeadingLevelTags, string> = {\n    h1: '2em',\n    h2: '1.5em',\n    h3: '1.17em',\n    h4: '1em',\n    h5: '0.83em',\n    h6: '0.67em',\n};\n\n/**\n * @internal\n */\nexport const headingLevels = [\n    { prefix: '# ', tagName: 'h1', fontSize: HeaderFontSizes.h1 },\n    { prefix: '## ', tagName: 'h2', fontSize: HeaderFontSizes.h2 },\n    { prefix: '### ', tagName: 'h3', fontSize: HeaderFontSizes.h3 },\n    { prefix: '#### ', tagName: 'h4', fontSize: HeaderFontSizes.h4 },\n    { prefix: '##### ', tagName: 'h5', fontSize: HeaderFontSizes.h5 },\n    { prefix: '###### ', tagName: 'h6', fontSize: HeaderFontSizes.h6 },\n];\n\n/**\n * @internal\n */\nexport const MarkdownHeadings: Record<string, string> = {\n    h1: '# ',\n    h2: '## ',\n    h3: '### ',\n    h4: '#### ',\n    h5: '##### ',\n    h6: '###### ',\n};\n","export { convertMarkdownToContentModel } from './markdownToModel/convertMarkdownToContentModel';\nexport { convertContentModelToMarkdown } from './modelToMarkdown/convertContentModelToMarkdown';\nexport { MarkdownLineBreaks } from '../lib/constants/markdownLineBreaks';\nexport { MarkdownToModelOptions } from './markdownToModel/types/MarkdownToModelOptions';\n","import type { ContentModelText } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function applyLink(\n    textSegment: ContentModelText,\n    text: string,\n    url: string\n): ContentModelText {\n    textSegment.text = text;\n    textSegment.link = {\n        dataset: {},\n        format: {\n            href: url,\n            underline: true,\n        },\n    };\n\n    return textSegment;\n}\n","import { adjustHeading } from '../utils/adjustHeading';\nimport { applyLink } from './applyLink';\nimport { applyTextFormatting } from './applyTextFormatting';\nimport { createBr, createText } from 'roosterjs-content-model-dom';\nimport { createImageSegment } from '../creators/createImageSegment';\nimport { splitParagraphSegments } from '../utils/splitParagraphSegments';\n\nimport type {\n    ContentModelParagraph,\n    ContentModelParagraphDecorator,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function applySegmentFormatting(\n    text: string,\n    paragraph: ContentModelParagraph,\n    decorator?: ContentModelParagraphDecorator\n): ContentModelParagraph | undefined {\n    if (text.length === 0) {\n        const br = createBr();\n        paragraph.segments.push(br);\n    } else {\n        const textSegments = splitParagraphSegments(text);\n        for (const segment of textSegments) {\n            const formattedSegment = createText(segment.text);\n            if (segment.type === 'image') {\n                const image = createImageSegment(segment.text, segment.url);\n                paragraph.segments.push(image);\n            } else {\n                if (segment.type === 'link') {\n                    applyLink(formattedSegment, segment.text, segment.url);\n                }\n                const segmentWithAdjustedHeading = adjustHeading(formattedSegment, decorator);\n                if (segmentWithAdjustedHeading) {\n                    const formattedSegments = applyTextFormatting(formattedSegment);\n                    paragraph.segments.push(...formattedSegments);\n                }\n            }\n        }\n    }\n\n    return paragraph;\n}\n","import { createText } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelLink,\n    ContentModelSegmentFormat,\n    ContentModelText,\n} from 'roosterjs-content-model-types';\n\ninterface FormattingState {\n    bold: boolean;\n    italic: boolean;\n    strikethrough: boolean;\n}\n\ninterface FormatMarker {\n    type: 'bold' | 'italic' | 'strikethrough';\n    length: number;\n}\n\n/**\n * @internal\n */\nexport function applyTextFormatting(textSegment: ContentModelText) {\n    const text = textSegment.text;\n\n    // Quick check: if the text contains only formatting markers, return original\n    if (isOnlyFormattingMarkers(text)) {\n        return [textSegment];\n    }\n\n    const textSegments: ContentModelText[] = [];\n    const currentState: FormattingState = { bold: false, italic: false, strikethrough: false };\n\n    let currentText = '';\n    let i = 0;\n\n    while (i < text.length) {\n        const marker = parseMarkerAt(text, i);\n\n        if (marker) {\n            // Check if this marker should be treated as formatting or as literal text\n            if (shouldToggleFormatting(text, i, marker, currentState)) {\n                // If we have accumulated text, create a segment for it\n                if (currentText.length > 0) {\n                    textSegments.push(\n                        createFormattedSegment(\n                            currentText,\n                            textSegment.format,\n                            currentState,\n                            textSegment.link\n                        )\n                    );\n                    currentText = '';\n                }\n\n                // Toggle the formatting state\n                toggleFormatting(currentState, marker.type);\n\n                // Skip the marker characters\n                i += marker.length;\n            } else {\n                // Treat as regular text if marker is not valid in this context\n                currentText += text[i];\n                i++;\n            }\n        } else {\n            // Regular character, add to current text\n            currentText += text[i];\n            i++;\n        }\n    }\n\n    // Add any remaining text as a final segment\n    if (currentText.length > 0) {\n        textSegments.push(\n            createFormattedSegment(currentText, textSegment.format, currentState, textSegment.link)\n        );\n    }\n\n    // If no meaningful formatting was applied, return the original segment\n    if (\n        textSegments.length === 0 ||\n        (textSegments.length === 1 && textSegments[0].text === textSegment.text)\n    ) {\n        return [textSegment];\n    }\n\n    return textSegments;\n}\n\nfunction isOnlyFormattingMarkers(text: string): boolean {\n    // Remove all potential formatting markers and see if anything remains\n    let remaining = text;\n    remaining = remaining.replace(/\\*\\*/g, ''); // Remove **\n    remaining = remaining.replace(/~~/g, ''); // Remove ~~\n    remaining = remaining.replace(/\\*/g, ''); // Remove *\n\n    // If nothing remains after removing all markers, it was only markers\n    return remaining.length === 0;\n}\n\nfunction parseMarkerAt(text: string, index: number): FormatMarker | null {\n    const remaining = text.substring(index);\n\n    if (remaining.startsWith('~~')) {\n        return { type: 'strikethrough', length: 2 };\n    }\n\n    if (remaining.startsWith('**')) {\n        return { type: 'bold', length: 2 };\n    }\n\n    if (remaining.startsWith('*')) {\n        return { type: 'italic', length: 1 };\n    }\n\n    return null;\n}\n\nfunction shouldToggleFormatting(\n    text: string,\n    index: number,\n    marker: FormatMarker,\n    currentState: FormattingState\n): boolean {\n    const nextChar = index + marker.length < text.length ? text.charAt(index + marker.length) : '';\n\n    const isCurrentlyActive = getCurrentFormatState(currentState, marker.type);\n\n    if (isCurrentlyActive) {\n        // We're currently in this format, so any marker can close it\n        return true;\n    } else {\n        // We're not in this format, so this marker would open it\n        // Opening markers must be followed by non-whitespace\n        return nextChar.length > 0 && !isWhitespace(nextChar);\n    }\n}\n\nfunction isWhitespace(char: string): boolean {\n    return /\\s/.test(char);\n}\n\nfunction toggleFormatting(state: FormattingState, type: 'bold' | 'italic' | 'strikethrough'): void {\n    switch (type) {\n        case 'bold':\n            state.bold = !state.bold;\n            break;\n        case 'italic':\n            state.italic = !state.italic;\n            break;\n        case 'strikethrough':\n            state.strikethrough = !state.strikethrough;\n            break;\n    }\n}\n\nfunction getCurrentFormatState(\n    state: FormattingState,\n    type: 'bold' | 'italic' | 'strikethrough'\n): boolean {\n    switch (type) {\n        case 'bold':\n            return state.bold;\n        case 'italic':\n            return state.italic;\n        case 'strikethrough':\n            return state.strikethrough;\n    }\n}\n\nfunction createFormattedSegment(\n    text: string,\n    baseFormat: ContentModelSegmentFormat,\n    state: FormattingState,\n    link?: ContentModelLink\n): ContentModelText {\n    const format: ContentModelSegmentFormat = { ...baseFormat };\n\n    if (state.bold) {\n        format.fontWeight = 'bold';\n    }\n\n    if (state.italic) {\n        format.italic = true;\n    }\n\n    if (state.strikethrough) {\n        format.strikethrough = true;\n    }\n\n    return createText(text, format, link);\n}\n","import { markdownProcessor } from './processor/markdownProcessor';\nimport type { MarkdownToModelOptions } from './types/MarkdownToModelOptions';\nimport type { ContentModelDocument } from 'roosterjs-content-model-types';\n\n/**\n * Convert the whole content to ContentModel with the given plain text\n * @param text The markdown text\n * @param splitLinesPattern The pattern to split lines. Default is /\\r\\n|\\r|\\\\n|\\n/\n * @returns The ContentModelDocument\n */\nexport function convertMarkdownToContentModel(\n    text: string,\n    splitLinesPattern?: string\n): ContentModelDocument;\n\n/**\n * Convert the whole content to ContentModel with the given plain text\n * @param text The markdown text\n * @param options The markdown options\n * @returns The ContentModelDocument\n */\nexport function convertMarkdownToContentModel(\n    text: string,\n    options?: MarkdownToModelOptions\n): ContentModelDocument;\n\nexport function convertMarkdownToContentModel(\n    text: string,\n    splitLinesPatternOrOptions?: string | MarkdownToModelOptions\n): ContentModelDocument {\n    const options: MarkdownToModelOptions =\n        (typeof splitLinesPatternOrOptions === 'string'\n            ? {\n                  splitLinesPattern: splitLinesPatternOrOptions,\n              }\n            : splitLinesPatternOrOptions) ?? {};\n\n    return markdownProcessor(text, options);\n}\n","import { createBlockQuoteFromMarkdown } from './createBlockQuoteFromMarkdown';\nimport { createListFromMarkdown } from './createListFromMarkdown';\nimport type {\n    ContentModelBlockGroupType,\n    ContentModelFormatContainer,\n    ContentModelListItem,\n} from 'roosterjs-content-model-types';\nimport type { MarkdownToModelOptions } from '../types/MarkdownToModelOptions';\n\nconst MarkdownBlockGroupType: Record<string, ContentModelBlockGroupType> = {\n    unordered_list: 'ListItem',\n    ordered_list: 'ListItem',\n    blockquote: 'FormatContainer',\n};\n\n/**\n * @internal\n */\nexport function createBlockGroupFromMarkdown(\n    text: string,\n    patternName: string,\n    options: MarkdownToModelOptions,\n    group?: ContentModelFormatContainer\n): ContentModelFormatContainer | ContentModelListItem {\n    if (MarkdownBlockGroupType[patternName] === 'ListItem') {\n        return createListFromMarkdown(text, patternName === 'ordered_list' ? 'OL' : 'UL', options);\n    } else {\n        return createBlockQuoteFromMarkdown(text, options, group);\n    }\n}\n","import { createFormatContainer } from 'roosterjs-content-model-dom';\nimport { createParagraphFromMarkdown } from './createParagraphFromMarkdown';\nimport type {\n    ContentModelFormatContainer,\n    ContentModelFormatContainerFormat,\n} from 'roosterjs-content-model-types';\nimport type { MarkdownToModelOptions } from '../types/MarkdownToModelOptions';\n\nconst QuoteFormat: ContentModelFormatContainerFormat = {\n    borderLeft: '3px solid rgb(200, 200, 200)',\n    textColor: 'rgb(102, 102, 102)',\n    marginTop: '1em',\n    marginBottom: '1em',\n    marginLeft: '40px',\n    marginRight: '40px',\n    paddingLeft: '10px',\n};\n\n/**\n * @internal\n */\nexport function createBlockQuoteFromMarkdown(\n    text: string,\n    options: MarkdownToModelOptions,\n    blockquote?: ContentModelFormatContainer\n): ContentModelFormatContainer {\n    text = text.replace('>', '');\n    const paragraph = createParagraphFromMarkdown(text, options);\n    const quote =\n        blockquote ||\n        createFormatContainer(\n            'blockquote',\n            options.direction ? { ...QuoteFormat, direction: options.direction } : QuoteFormat\n        );\n\n    quote.blocks.push(paragraph);\n    return quote;\n}\n","import { createImage } from 'roosterjs-content-model-dom';\nimport type { ContentModelImage } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function createImageSegment(text: string, url: string): ContentModelImage {\n    const image = createImage(url);\n    image.alt = text;\n    return image;\n}\n","import { createListItem, createListLevel } from 'roosterjs-content-model-dom';\nimport { createParagraphFromMarkdown } from './createParagraphFromMarkdown';\nimport type { ContentModelListItem } from 'roosterjs-content-model-types';\nimport type { MarkdownToModelOptions } from '../types/MarkdownToModelOptions';\n\n/**\n * @internal\n */\nexport function createListFromMarkdown(\n    text: string,\n    listType: 'OL' | 'UL',\n    options: MarkdownToModelOptions\n): ContentModelListItem {\n    const marker = text.trim().split(' ')[0];\n    const isDummy = isDummyListItem(marker);\n    const itemText = isDummy ? text : text.trim().substring(marker.length);\n    const paragraph = createParagraphFromMarkdown(itemText.trim(), options);\n    const levels = createLevels(text, listType, isDummy, options);\n    const listModel = createListItem(levels);\n    if (options.direction) {\n        listModel.format.direction = options.direction;\n    }\n\n    listModel.blocks.push(paragraph);\n    return listModel;\n}\n\nfunction createLevels(\n    text: string,\n    listType: 'OL' | 'UL',\n    isDummy: boolean,\n    options: MarkdownToModelOptions\n) {\n    const level = createListLevel(\n        listType,\n        options.direction ? { direction: options.direction } : undefined\n    );\n    if (isDummy) {\n        level.format.displayForDummyItem = 'block';\n    }\n    const levels = [level];\n    if (isSubListItem(text)) {\n        levels.push(level);\n    }\n    return levels;\n}\n\nfunction isSubListItem(item: string): boolean {\n    return item.startsWith(' ');\n}\n\nconst isDummyListItem = (item: string) => {\n    return item != '-' && item != '+' && item != '*' && !item.endsWith('.');\n};\n","import { applySegmentFormatting } from '../appliers/applySegmentFormatting';\nimport { createParagraph } from 'roosterjs-content-model-dom';\nimport { getHeadingDecorator } from '../utils/getHeadingDecorator';\nimport type { MarkdownToModelOptions } from '../types/MarkdownToModelOptions';\nimport type { ContentModelParagraph } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function createParagraphFromMarkdown(\n    text: string,\n    options: MarkdownToModelOptions\n): ContentModelParagraph {\n    const paragraph = createParagraph(\n        undefined /* isImplicit */,\n        options.direction ? { direction: options.direction } : undefined\n    );\n\n    const headingType = getHeadingDecorator(text);\n    if (headingType) {\n        paragraph.decorator = headingType;\n    }\n    applySegmentFormatting(text, paragraph, headingType);\n    return paragraph;\n}\n","import { createParagraphFromMarkdown } from './createParagraphFromMarkdown';\nimport type { ContentModelTable } from 'roosterjs-content-model-types';\nimport {\n    applyTableFormat,\n    createTable,\n    createTableCell,\n    createTableRow,\n} from 'roosterjs-content-model-dom';\nimport type { MarkdownToModelOptions } from '../types/MarkdownToModelOptions';\n\n/**\n * @internal\n */\nexport function createTableFromMarkdown(\n    tableLines: string[],\n    options: MarkdownToModelOptions\n): ContentModelTable {\n    const tableDivider = tableLines[1].split('|').filter(content => content.trim() !== '');\n    tableLines.splice(1, 1);\n    const table = createTable(\n        0,\n        options.direction\n            ? { borderCollapse: true, direction: options.direction }\n            : { borderCollapse: true }\n    );\n\n    for (const line of tableLines) {\n        createTableModel(line, table, tableDivider, options);\n    }\n    applyTableFormat(table, {\n        hasHeaderRow: true,\n    });\n    return table;\n}\n\nfunction createTableModel(\n    markdown: string,\n    table: ContentModelTable,\n    tableDivider: string[],\n    options: MarkdownToModelOptions\n) {\n    const contents = markdown.split('|');\n    if (contents[0].trim() === '') {\n        contents.shift();\n    }\n    if (contents[contents.length - 1].trim() === '') {\n        contents.pop();\n    }\n\n    addTableRow(table, contents, tableDivider, options);\n}\n\nfunction addTableRow(\n    table: ContentModelTable,\n    contents: string[],\n    tableDivider: string[],\n    options: MarkdownToModelOptions\n) {\n    const row = createTableRow(options.direction ? { direction: options.direction } : undefined);\n\n    let index = 0;\n    for (const content of contents) {\n        const paragraph = createParagraphFromMarkdown(content, options);\n        const cell = createTableCell(\n            undefined /* spanLeftOrColSpan */,\n            undefined /* spanAboveOrRowSpan */,\n            undefined /* isHeader */,\n            options.direction ? { direction: options.direction } : undefined\n        );\n\n        cell.blocks.push(paragraph);\n        if (tableDivider[index]) {\n            cell.format.textAlign = getCellAlignment(tableDivider[index]);\n        }\n        row.cells.push(cell);\n        index++;\n    }\n    table.rows.push(row);\n}\n\nfunction getCellAlignment(content: string) {\n    if (content.startsWith(':') && content.endsWith(':')) {\n        return 'center';\n    }\n    if (content.endsWith(':')) {\n        return 'end';\n    }\n    return 'start';\n}\n","import { createBlockGroupFromMarkdown } from '../creators/createBlockGroupFromMarkdown';\nimport { createContentModelDocument, createDivider } from 'roosterjs-content-model-dom';\nimport { createParagraphFromMarkdown } from '../creators/createParagraphFromMarkdown';\nimport { createTableFromMarkdown } from '../creators/createTableFromMarkdown';\nimport { isMarkdownTable } from '../utils/isMarkdownTable';\n\nimport type { MarkdownToModelOptions } from '../types/MarkdownToModelOptions';\nimport type {\n    ContentModelBlockType,\n    ContentModelDocument,\n    ContentModelFormatContainer,\n    ContentModelListItem,\n    ShallowMutableContentModelDocument,\n} from 'roosterjs-content-model-types';\n\ninterface MarkdownContext {\n    lastQuote?: ContentModelFormatContainer;\n    lastList?: ContentModelListItem;\n    emptyLineState?: 'notEmpty' | 'lineEnded' | 'empty';\n    tableLines: string[];\n}\n\nconst MarkdownPattern: Record<string, RegExp> = {\n    heading: /^#{1,6} .*/,\n    horizontal_line: /^---$/,\n    table: /^\\|.*\\|\\s*$/,\n    blockquote: /^>\\s.*$/,\n    unordered_list: /^\\s*[\\*\\-\\+] .*/,\n    ordered_list: /^\\s*\\d+\\. .*/,\n    space: /^\\s*$/,\n    paragraph: /^[^#\\-\\*\\d\\|].*/,\n};\n\nconst MarkdownBlockType: Record<string, ContentModelBlockType> = {\n    heading: 'Paragraph',\n    horizontal_line: 'Divider',\n    paragraph: 'Paragraph',\n    unordered_list: 'BlockGroup',\n    ordered_list: 'BlockGroup',\n    table: 'Table',\n    blockquote: 'BlockGroup',\n    space: 'Paragraph',\n};\n\n/**\n * @internal\n * Process markdown text and convert it to ContentModelDocument\n * @param text The markdown text\n * @param splitLinesPattern The pattern to split lines. Default is /\\r\\n|\\r|\\\\n|\\n/\n * @returns The ContentModelDocument\n */\n\nexport function markdownProcessor(\n    text: string,\n    options: MarkdownToModelOptions\n): ContentModelDocument {\n    const splitLinesPattern = options.splitLinesPattern || /\\r\\n|\\r|\\\\n|\\n/;\n    const emptyLine = options.emptyLine ?? 'merge';\n    const markdownText = text.split(splitLinesPattern);\n\n    markdownText.push(''); // Add an empty line to make sure the last block is processed\n\n    const doc = createContentModelDocument();\n    const model = convertMarkdownText(doc, markdownText, options);\n    const lastBlock = model.blocks[model.blocks.length - 1];\n\n    if (\n        emptyLine != 'remove' &&\n        lastBlock &&\n        lastBlock.blockType == 'Paragraph' &&\n        lastBlock.segments.every(x => x.segmentType == 'Br')\n    ) {\n        model.blocks.pop();\n    }\n\n    return model;\n}\n\nfunction addMarkdownBlockToModel(\n    model: ShallowMutableContentModelDocument,\n    blockType: ContentModelBlockType,\n    markdown: string,\n    patternName: string,\n    markdownContext: MarkdownContext,\n    options: MarkdownToModelOptions\n) {\n    if (\n        blockType !== 'Table' &&\n        markdownContext.tableLines &&\n        markdownContext.tableLines.length > 0\n    ) {\n        if (\n            markdownContext.tableLines.length > 2 &&\n            markdownContext.tableLines[1].trim().length > 0 &&\n            isMarkdownTable(markdownContext.tableLines[1]) &&\n            markdownContext.tableLines.length > 1\n        ) {\n            const tableModel = createTableFromMarkdown(markdownContext.tableLines, options);\n            model.blocks.push(tableModel);\n        } else {\n            for (const line of markdownContext.tableLines) {\n                const paragraph = createParagraphFromMarkdown(line, options);\n                model.blocks.push(paragraph);\n            }\n        }\n        markdownContext.tableLines.length = 0;\n    }\n\n    if (patternName == 'space') {\n        if (\n            markdownContext.tableLines.length > 0 ||\n            markdownContext.lastQuote ||\n            markdownContext.lastList\n        ) {\n            markdownContext.tableLines = [];\n            markdownContext.lastQuote = undefined;\n            markdownContext.lastList = undefined;\n\n            return;\n        }\n\n        switch (options.emptyLine) {\n            case 'remove':\n                // no op, ignore this line\n                return;\n            case 'merge':\n                switch (markdownContext.emptyLineState) {\n                    case 'notEmpty':\n                    default:\n                        // Last line is not empty line, so this empty line is treated as the line end of last paragraph\n                        markdownContext.emptyLineState = 'lineEnded';\n                        return;\n\n                    case 'lineEnded':\n                        // We already see an empty line for paragraph ends, so this line is treated as a real empty line\n                        markdownContext.emptyLineState = 'empty';\n\n                        // Keep going, process as a normal paragraph\n                        break;\n\n                    case 'empty':\n                        // Already processed empty line, so this one should be ignored\n                        return;\n                }\n                break;\n            case 'preserve':\n            default:\n                // no op, treat it as paragraph\n                break;\n        }\n    } else {\n        markdownContext.emptyLineState = 'notEmpty';\n    }\n\n    if (blockType == 'Paragraph' && (markdownContext.lastList || markdownContext.lastQuote)) {\n        blockType = 'BlockGroup';\n        patternName = markdownContext.lastList\n            ? markdownContext.lastList.levels[0].listType == 'OL'\n                ? 'ordered_list'\n                : 'unordered_list'\n            : 'blockquote';\n    }\n\n    switch (blockType) {\n        case 'Paragraph':\n            const paragraph = createParagraphFromMarkdown(markdown, options);\n            model.blocks.push(paragraph);\n            break;\n        case 'Divider':\n            const divider = createDivider('hr');\n            model.blocks.push(divider);\n            break;\n        case 'BlockGroup':\n            const blockGroup = createBlockGroupFromMarkdown(\n                markdown,\n                patternName,\n                options,\n                markdownContext.lastQuote\n            );\n            if (!markdownContext.lastQuote) {\n                model.blocks.push(blockGroup);\n            }\n            markdownContext.lastQuote =\n                blockGroup.blockGroupType == 'FormatContainer' ? blockGroup : undefined;\n            markdownContext.lastList =\n                blockGroup.blockGroupType == 'ListItem' ? blockGroup : undefined;\n            break;\n        case 'Table':\n            markdownContext.tableLines = markdownContext.tableLines || [];\n            markdownContext.tableLines.push(markdown);\n            break;\n    }\n\n    if (blockType !== 'BlockGroup') {\n        markdownContext.lastQuote = undefined;\n        markdownContext.lastList = undefined;\n    }\n}\n\nfunction convertMarkdownText(\n    model: ContentModelDocument,\n    lines: string[],\n    options: MarkdownToModelOptions\n): ContentModelDocument {\n    const markdownContext: MarkdownContext = {\n        lastQuote: undefined,\n        lastList: undefined,\n        tableLines: [],\n    };\n    for (const line of lines) {\n        let matched = false;\n        for (const patternName in MarkdownPattern) {\n            if (MarkdownPattern.hasOwnProperty(patternName)) {\n                const pattern = MarkdownPattern[patternName];\n                if (pattern.test(line)) {\n                    addMarkdownBlockToModel(\n                        model,\n                        MarkdownBlockType[patternName],\n                        line,\n                        patternName,\n                        markdownContext,\n                        options\n                    );\n                    matched = true;\n                    break;\n                }\n            }\n        }\n\n        if (!matched) {\n            addMarkdownBlockToModel(\n                model,\n                'Paragraph',\n                line,\n                'paragraph',\n                markdownContext,\n                options\n            );\n        }\n    }\n    return model;\n}\n","import { MarkdownHeadings } from '../../constants/headings';\nimport type {\n    ContentModelParagraphDecorator,\n    ContentModelText,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function adjustHeading(\n    textSegment: ContentModelText,\n    decorator?: ContentModelParagraphDecorator\n): ContentModelText | null {\n    const markdownToBeRemoved = MarkdownHeadings[decorator?.tagName || ''];\n    if (markdownToBeRemoved) {\n        textSegment.text = textSegment.text.replace(markdownToBeRemoved, '');\n        if (textSegment.text.length === 0) {\n            // If the text becomes empty after removing the heading markdown, we can remove the segment\n            return null;\n        }\n    }\n    return textSegment;\n}\n","import { headingLevels } from '../../constants/headings';\nimport type { ContentModelParagraphDecorator } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function getHeadingDecorator(text: string): ContentModelParagraphDecorator | undefined {\n    for (const level of headingLevels) {\n        if (text.startsWith(level.prefix)) {\n            return {\n                tagName: level.tagName,\n                format: {\n                    fontWeight: 'bold',\n                    fontSize: level.fontSize,\n                },\n            };\n        }\n    }\n\n    return undefined;\n}\n","/**\n * @internal\n */\nexport function isMarkdownTable(text: string): boolean {\n    const columns = text.split('|').filter(s => s !== '');\n    const pattern = /^:?-+:?$/;\n\n    return columns.length > 0 && columns.every(c => pattern.test(c.trim()));\n}\n","const linkRegex = /(\\[([^\\[]+)\\]\\((https?:\\/\\/[^\\)]+)\\))|(\\!\\[([^\\[]+)\\]\\((https?:\\/\\/[^\\)]+)\\))/g;\n\n/**\n * @internal\n */\ninterface MarkdownSegment {\n    text: string;\n    url: string;\n    type: 'text' | 'link' | 'image';\n}\n\nconst isValidUrl = (url: string) => {\n    try {\n        new URL(url);\n        return true;\n    } catch (_) {\n        return false;\n    }\n};\n\n/**\n * @internal\n */\nexport function splitParagraphSegments(text: string): MarkdownSegment[] {\n    const result: MarkdownSegment[] = [];\n    let lastIndex = 0;\n    let match: RegExpExecArray | null = null;\n\n    while ((match = linkRegex.exec(text)) !== null) {\n        if (match.index > lastIndex) {\n            result.push({ type: 'text', text: text.slice(lastIndex, match.index), url: '' });\n        }\n\n        if (match[2] && match[3]) {\n            result.push(\n                isValidUrl(match[3])\n                    ? { type: 'link', text: match[2], url: match[3] }\n                    : { type: 'text', text: match[0], url: '' }\n            );\n        } else if (match[5] && match[6]) {\n            result.push(\n                isValidUrl(match[6])\n                    ? { type: 'image', text: match[5], url: match[6] }\n                    : { type: 'text', text: match[0], url: '' }\n            );\n        }\n\n        lastIndex = linkRegex.lastIndex;\n    }\n\n    if (lastIndex < text.length) {\n        result.push({ type: 'text', text: text.slice(lastIndex), url: '' });\n    }\n\n    return result;\n}\n","import { modelProcessor } from './processor/modelProcessor';\nimport type { MarkdownLineBreaks } from '../constants/markdownLineBreaks';\nimport type { ContentModelDocument } from 'roosterjs-content-model-types';\n\n/**\n * Export content model document to markdown\n * @param selection The editor selection\n * @param newLine The new line string to use. Default is '\\n\\n'\n * @returns The markdown string\n */\nexport function convertContentModelToMarkdown(\n    model: ContentModelDocument,\n    newLine?: MarkdownLineBreaks\n): string {\n    return modelProcessor(model, newLine);\n}\n","import { createMarkdownBlockGroup } from './createMarkdownBlockGroup';\nimport { createMarkdownParagraph } from './createMarkdownParagraph';\nimport { createMarkdownTable } from './createMarkdownTable';\nimport type { ParagraphContext } from './createMarkdownParagraph';\nimport type { ContentModelBlock } from 'roosterjs-content-model-types';\nimport type { ListCounter } from './createMarkdownBlockGroup';\nimport type { MarkdownLineBreaks } from '../../constants/markdownLineBreaks';\n\n/**\n * @internal\n */\nexport interface MarkdownLineBreaksByBlockType {\n    table: string;\n    paragraph: string;\n    divider: string;\n}\n\nconst DEFAULT_NEW_LINE: MarkdownLineBreaksByBlockType = {\n    table: '',\n    paragraph: '',\n    divider: '\\n\\n',\n};\n\n/**\n * @internal\n */\nexport function createMarkdownBlock(\n    block: ContentModelBlock,\n    newLinePattern: MarkdownLineBreaks,\n    listCounter: ListCounter,\n    newLines?: Partial<MarkdownLineBreaksByBlockType>,\n    paragraphContext?: ParagraphContext\n): string {\n    let markdownString = '';\n    const lines = { ...DEFAULT_NEW_LINE, ...newLines };\n    switch (block.blockType) {\n        case 'Paragraph':\n            markdownString += createMarkdownParagraph(block, paragraphContext) + lines.paragraph;\n            break;\n        case 'BlockGroup':\n            markdownString += createMarkdownBlockGroup(block, newLinePattern, listCounter);\n            break;\n        case 'Table':\n            markdownString += createMarkdownTable(block, newLinePattern, listCounter) + lines.table;\n            break;\n        case 'Divider':\n            if (!paragraphContext?.ignoreLineBreaks) {\n                markdownString += '---' + lines.divider;\n            }\n\n            break;\n        case 'Entity':\n            break;\n        default:\n            break;\n    }\n    return markdownString;\n}\n","import { createMarkdownBlock } from './createMarkdownBlock';\nimport type { MarkdownLineBreaks } from '../../constants/markdownLineBreaks';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelFormatContainer,\n    ContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport interface ListCounter {\n    listItemCount: number;\n    subListItemCount: number;\n}\n\n/**\n * @internal\n */\nexport function createMarkdownBlockGroup(\n    blockGroup: ContentModelBlockGroup,\n    newLinePattern: MarkdownLineBreaks,\n    listCounter: ListCounter\n): string {\n    let markdownString = '';\n    switch (blockGroup.blockGroupType) {\n        case 'ListItem':\n            if (listCounter) {\n                markdownString += createMarkdownListItem(blockGroup, newLinePattern, listCounter);\n            }\n            break;\n        case 'FormatContainer':\n            markdownString += createMarkdownBlockQuote(blockGroup, newLinePattern, listCounter);\n            break;\n        default:\n            const { blocks } = blockGroup;\n            for (const block of blocks) {\n                markdownString += createMarkdownBlock(block, newLinePattern, listCounter);\n            }\n            break;\n    }\n    return markdownString;\n}\n\nfunction createMarkdownListItem(\n    listItem: ContentModelListItem,\n    newLinePattern: MarkdownLineBreaks,\n    listCounter: ListCounter\n): string {\n    let markdownString = '';\n    const { blocks } = listItem;\n    for (const block of blocks) {\n        markdownString += createMarkdownBlock(\n            block,\n            newLinePattern,\n            listCounter,\n            undefined /* newLines */,\n            {\n                ignoreLineBreaks: true,\n            }\n        );\n    }\n    const lastIndex = listItem.levels.length - 1;\n    const isSubList = lastIndex + 1 > 1;\n    const dummyFormat = listItem.levels[lastIndex].format.displayForDummyItem;\n    if (dummyFormat && dummyFormat !== 'listItem') {\n        return (markdownString = ` ${markdownString}`);\n    }\n\n    if (isSubList) {\n        listCounter.subListItemCount++;\n        if (listItem.levels[lastIndex].listType == 'OL') {\n            markdownString = `   ${listCounter.subListItemCount}. ${markdownString}`;\n        } else {\n            markdownString = `  - ${markdownString}`;\n        }\n    } else {\n        listCounter.listItemCount++;\n        if (listItem.levels[lastIndex].listType == 'OL') {\n            markdownString = `${listCounter.listItemCount}. ${markdownString}`;\n        } else {\n            markdownString = `- ${markdownString}`;\n        }\n    }\n\n    return markdownString + newLinePattern.newLine;\n}\n\nfunction createMarkdownBlockQuote(\n    blockquote: ContentModelFormatContainer,\n    newLinePattern: MarkdownLineBreaks,\n    listCounter: ListCounter\n): string {\n    let markdownString = '';\n    if (blockquote.tagName == 'blockquote') {\n        const { blocks } = blockquote;\n        for (const block of blocks) {\n            markdownString +=\n                '> ' +\n                createMarkdownBlock(block, newLinePattern, listCounter, undefined /* newLines */, {\n                    ignoreLineBreaks: true,\n                }) +\n                newLinePattern.newLine;\n        }\n    }\n\n    return `${markdownString}\\n`;\n}\n","import { MarkdownHeadings } from '../../constants/headings';\r\nimport type { ContentModelParagraph, ContentModelText } from 'roosterjs-content-model-types';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ParagraphContext {\r\n    ignoreLineBreaks: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function createMarkdownParagraph(\r\n    paragraph: ContentModelParagraph,\r\n    context?: ParagraphContext\r\n): string {\r\n    const { segments } = paragraph;\r\n    let markdownString = '';\r\n    for (const segment of segments) {\r\n        switch (segment.segmentType) {\r\n            case 'Text':\r\n                markdownString += textProcessor(segment);\r\n                break;\r\n            case 'Image':\r\n                markdownString += `![${segment.alt || 'image'}](${segment.src})`;\r\n                break;\r\n            case 'Br':\r\n                if (!context?.ignoreLineBreaks) {\r\n                    markdownString += '\\n';\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    if (paragraph.decorator) {\r\n        const { tagName } = paragraph.decorator;\r\n        const prefix = MarkdownHeadings[tagName];\r\n        if (prefix) {\r\n            markdownString = `${prefix}${markdownString}`;\r\n        }\r\n    }\r\n\r\n    return markdownString;\r\n}\r\n\r\nfunction textProcessor(text: ContentModelText): string {\r\n    let markdownString = text.text;\r\n    if (text.link) {\r\n        markdownString = `[${text.text}](${text.link.format.href})`;\r\n    }\r\n    if (text.format.fontWeight == 'bold') {\r\n        markdownString = `**${markdownString}**`;\r\n    }\r\n    if (text.format.strikethrough) {\r\n        markdownString = `~~${markdownString}~~`;\r\n    }\r\n    if (text.format.italic) {\r\n        markdownString = `*${markdownString}*`;\r\n    }\r\n    return markdownString;\r\n}\r\n","import { createMarkdownBlock } from './createMarkdownBlock';\nimport type { MarkdownLineBreaks } from '../../constants/markdownLineBreaks';\nimport type { ListCounter } from './createMarkdownBlockGroup';\nimport type { ContentModelTable, ContentModelTableRow } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function createMarkdownTable(\n    table: ContentModelTable,\n    newLinePattern: MarkdownLineBreaks,\n    listCounter: ListCounter\n): string {\n    let markdownString = '';\n    const { rows } = table;\n    let firstRow = true;\n    for (const row of rows) {\n        markdownString += '|';\n        for (const cell of row.cells) {\n            for (const block of cell.blocks) {\n                markdownString += createMarkdownBlock(\n                    block,\n                    newLinePattern,\n                    listCounter,\n                    {\n                        divider: '',\n                    },\n                    {\n                        ignoreLineBreaks: true,\n                    }\n                );\n            }\n            markdownString += '|';\n        }\n        markdownString += newLinePattern.newLine;\n        if (firstRow) {\n            markdownString += addTableDivider(row);\n            firstRow = false;\n        }\n    }\n\n    return markdownString;\n}\n\nfunction addTableDivider(headerRow: ContentModelTableRow) {\n    let divider = '|';\n    const { cells } = headerRow;\n    for (const cell of cells) {\n        switch (cell.format.textAlign) {\n            case 'center':\n                divider += ':----:|';\n                break;\n            case 'end':\n                divider += '----:|';\n                break;\n            default:\n                divider += '----|';\n                break;\n        }\n    }\n    return divider + '\\n';\n}\n","import { createMarkdownBlock } from '../creators/createMarkdownBlock';\nimport type { MarkdownLineBreaks } from '../../constants/markdownLineBreaks';\nimport type { ListCounter } from '../creators/createMarkdownBlockGroup';\nimport type { ContentModelDocument } from 'roosterjs-content-model-types';\n\nconst DEFAULT_NEW_LINE: MarkdownLineBreaks = {\n    lineBreak: '\\n\\n',\n    newLine: '\\n',\n};\n\n/**\n * @internal\n */\nexport function modelProcessor(\n    model: ContentModelDocument,\n    newLine: MarkdownLineBreaks = DEFAULT_NEW_LINE\n): string {\n    let markdown = '';\n    const listCounter: ListCounter = {\n        listItemCount: 0,\n        subListItemCount: 0,\n    };\n    for (const block of model.blocks) {\n        const isListItem = block.blockType === 'BlockGroup' && block.blockGroupType === 'ListItem';\n        if (!isListItem && (listCounter.listItemCount > 0 || listCounter.subListItemCount > 0)) {\n            listCounter.listItemCount = 0;\n            listCounter.subListItemCount = 0;\n            markdown += newLine.newLine;\n        }\n\n        markdown += createMarkdownBlock(block, newLine, listCounter, {\n            table: newLine.newLine,\n            paragraph: newLine.lineBreak,\n            divider: newLine.lineBreak,\n        });\n    }\n\n    return markdown;\n}\n","import { getIsSelectingOrUnselecting, retrieveStringFromParsedTable } from './tableSelectionUtils';\nimport type {\n    IEditor,\n    PluginEvent,\n    EditorPlugin,\n    DOMSelection,\n} from 'roosterjs-content-model-types';\n\n/**\n * AnnouncePlugin helps editor announce table selection changes for accessibility\n */\nexport class AnnouncePlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private previousSelection: DOMSelection | null = null;\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'Announce';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n        this.previousSelection = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n\n        if (event.eventType == 'selectionChanged') {\n            if (event.newSelection?.type == 'table') {\n                const action = getIsSelectingOrUnselecting(\n                    this.previousSelection?.type == 'table' ? this.previousSelection : null,\n                    event.newSelection\n                );\n                if (action && event.newSelection.tableSelectionInfo) {\n                    this.editor.announce({\n                        defaultStrings: action === 'unselecting' ? 'unselected' : 'selected',\n                        formatStrings: [\n                            retrieveStringFromParsedTable(event.newSelection.tableSelectionInfo),\n                        ],\n                    });\n                }\n            }\n\n            this.previousSelection = event.newSelection;\n        }\n    }\n}\n","import type { TableSelectionInfo, TableSelection } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Retrieves text content from selected table cells in a parsed table structure\n * @param tsInfo Table selection information containing the parsed table and coordinates\n * @returns Combined text content from all selected cells, separated by spaces\n */\nexport function retrieveStringFromParsedTable(tsInfo: TableSelectionInfo): string {\n    const { parsedTable, firstCo, lastCo } = tsInfo;\n    let result = '';\n\n    if (lastCo) {\n        const firstCol = Math.min(firstCo.col, lastCo.col);\n        const lastCol = Math.max(firstCo.col, lastCo.col);\n        const firstRow = Math.min(firstCo.row, lastCo.row);\n        const lastRow = Math.max(firstCo.row, lastCo.row);\n\n        for (let r = firstRow; r <= lastRow; r++) {\n            for (let c = firstCol; c <= lastCol; c++) {\n                const cell = parsedTable[r] && parsedTable[r][c];\n                if (cell && typeof cell != 'string') {\n                    result += ' ' + cell.innerText + ',';\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * @internal\n * Determines whether the table selection is expanding (selecting more) or contracting (selecting less)\n * @param prevTableSelection Previous table selection object containing firstRow, lastRow, firstColumn, and lastColumn properties\n * @param firstCo Current first coordinate of the selection (with row, col properties)\n * @param lastCo Current last coordinate of the selection (with row, col properties)\n * @returns 'selecting' if expanding selection, 'unselecting' if contracting, or null if no change\n */\nexport function getIsSelectingOrUnselecting(\n    prevTableSelection: TableSelection | null,\n    newTableSelection: TableSelection\n): 'selecting' | 'unselecting' | null {\n    if (!prevTableSelection) {\n        return 'selecting';\n    }\n\n    const {\n        firstRow: prevFirstRow,\n        lastRow: prevLastRow,\n        firstColumn: prevFirstColumn,\n        lastColumn: prevLastColumn,\n    } = prevTableSelection;\n\n    const {\n        firstRow: newFirstRow,\n        lastRow: newLastRow,\n        firstColumn: newFirstColumn,\n        lastColumn: newLastColumn,\n    } = newTableSelection;\n\n    const prevRowSpan = Math.abs(prevLastRow - prevFirstRow) + 1;\n    const prevColSpan = Math.abs(prevLastColumn - prevFirstColumn) + 1;\n    const prevArea = prevRowSpan * prevColSpan;\n\n    const newRowSpan = Math.abs(newLastRow - newFirstRow) + 1;\n    const newColSpan = Math.abs(newLastColumn - newFirstColumn) + 1;\n    const newArea = newRowSpan * newColSpan;\n\n    // Check if selections are identical\n    if (\n        prevFirstRow === newFirstRow &&\n        prevLastRow === newLastRow &&\n        prevFirstColumn === newFirstColumn &&\n        prevLastColumn === newLastColumn\n    ) {\n        return null;\n    }\n\n    if (newArea > prevArea) {\n        return 'selecting';\n    } else if (newArea < prevArea) {\n        return 'unselecting';\n    } else {\n        // Same area but different positions\n        return 'selecting';\n    }\n}\n","import { ChangeSource } from 'roosterjs-content-model-dom';\nimport { checkAndInsertHorizontalLine } from './horizontalLine/checkAndInsertHorizontalLine';\nimport { createLink } from './link/createLink';\nimport { getListTypeStyle } from './list/getListTypeStyle';\nimport { keyboardListTrigger } from './list/keyboardListTrigger';\nimport { transformFraction } from './numbers/transformFraction';\nimport { transformHyphen } from './hyphen/transformHyphen';\nimport { transformOrdinals } from './numbers/transformOrdinals';\nimport { unlink } from './link/unlink';\nimport {\n    formatTextSegmentBeforeSelectionMarker,\n    promoteLink,\n    getPromoteLink,\n} from 'roosterjs-content-model-api';\nimport type { AutoFormatOptions } from './interface/AutoFormatOptions';\nimport type {\n    ContentChangedEvent,\n    ContentModelText,\n    EditorInputEvent,\n    EditorPlugin,\n    FormatContentModelContext,\n    FormatContentModelOptions,\n    IEditor,\n    KeyDownEvent,\n    PluginEvent,\n    ReadonlyContentModelDocument,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\ninterface Feature {\n    enabled: boolean;\n    transformFunction: (\n        model: ReadonlyContentModelDocument,\n        previousSegment: ContentModelText,\n        paragraph: ShallowMutableContentModelParagraph,\n        context: FormatContentModelContext\n    ) => boolean | HTMLElement;\n    changeSource: string;\n    apiName: string;\n}\n\n/**\n * @internal\n */\nconst DefaultOptions: Partial<AutoFormatOptions> = {\n    autoBullet: false,\n    autoNumbering: false,\n    autoUnlink: false,\n    autoLink: false,\n    autoHyphen: false,\n    autoFraction: false,\n    autoOrdinals: false,\n    removeListMargins: false,\n    autoHorizontalLine: false,\n};\n\n/**\n * Auto Format plugin handles auto formatting, such as transforming * characters into a bullet list.\n * It can be customized with options to enable or disable auto list features.\n */\nexport class AutoFormatPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    /**\n     * @param options An optional parameter that takes in an object of type AutoFormatOptions, which includes the following properties:\n     *  - autoBullet: A boolean that enables or disables automatic bullet list formatting. Defaults to false.\n     *  - autoNumbering: A boolean that enables or disables automatic numbering formatting. Defaults to false.\n     *  - removeListMargins: A boolean to remove list margins when it is automatically triggered. Defaults to false.\n     *  - autoHyphen: A boolean that enables or disables automatic hyphen transformation. Defaults to false.\n     *  - autoFraction: A boolean that enables or disables automatic fraction transformation. Defaults to false.\n     *  - autoOrdinals: A boolean that enables or disables automatic ordinal number transformation. Defaults to false.\n     *  - autoLink: A boolean that enables or disables automatic hyperlink url address creation when pasting or typing content. Defaults to false.\n     *  - autoUnlink: A boolean that enables or disables automatic hyperlink removal when pressing backspace. Defaults to false.\n     *  - autoTel: A boolean that enables or disables automatic hyperlink telephone numbers transformation. Defaults to false.\n     *  - autoMailto: A boolean that enables or disables automatic hyperlink email address transformation. Defaults to false.\n     *  - autoHorizontalLine: A boolean that enables or disables automatic horizontal line creation. Defaults to false.\n     */\n    constructor(private options: AutoFormatOptions = DefaultOptions) {}\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'AutoFormat';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    private shouldHandleInputEventExclusively(editor: IEditor, event: EditorInputEvent) {\n        const rawEvent = event.rawEvent;\n        const selection = editor.getDOMSelection();\n        let shouldHandle = false;\n        if (\n            rawEvent.inputType === 'insertText' &&\n            selection &&\n            selection.type === 'range' &&\n            selection.range.collapsed &&\n            rawEvent.data == ' '\n        ) {\n            const { autoLink, autoTel, autoMailto, autoBullet, autoNumbering } = this.options;\n\n            formatTextSegmentBeforeSelectionMarker(\n                editor,\n                (model, previousSegment, _paragraph, _markerFormat) => {\n                    const list = getListTypeStyle(model, autoBullet, autoNumbering);\n                    const promotedLink = getPromoteLink(previousSegment, {\n                        autoLink,\n                        autoTel,\n                        autoMailto,\n                    });\n                    shouldHandle = !!promotedLink || !!list;\n\n                    return false;\n                }\n            );\n        }\n        return shouldHandle;\n    }\n\n    willHandleEventExclusively(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case 'input':\n                    return this.shouldHandleInputEventExclusively(this.editor, event);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case 'input':\n                    this.handleEditorInputEvent(this.editor, event);\n                    break;\n                case 'keyDown':\n                    this.handleKeyDownEvent(this.editor, event);\n                    break;\n                case 'contentChanged':\n                    this.handleContentChangedEvent(this.editor, event);\n                    break;\n            }\n        }\n    }\n\n    private autoLink: Feature = {\n        enabled: !!(this.options.autoLink || this.options.autoTel || this.options.autoMailto),\n        transformFunction: (_model, previousSegment, paragraph, context) => {\n            const { autoLink, autoTel, autoMailto } = this.options;\n            const linkSegment = promoteLink(previousSegment, paragraph, {\n                autoLink,\n                autoTel,\n                autoMailto,\n            });\n\n            if (linkSegment && this.editor) {\n                return createAnchor(\n                    this.editor.getDocument(),\n                    linkSegment.link?.format.href || '',\n                    linkSegment.text\n                );\n            }\n            return false;\n        },\n        apiName: 'autoLink',\n        changeSource: ChangeSource.AutoLink,\n    };\n\n    private tabFeatures: Feature[] = [\n        {\n            enabled: !!(this.options.autoBullet || this.options.autoNumbering),\n            transformFunction: (model, _previousSegment, paragraph, context) =>\n                keyboardListTrigger(\n                    model,\n                    paragraph,\n                    context,\n                    this.options.autoBullet,\n                    this.options.autoNumbering,\n                    this.options.removeListMargins\n                ),\n            apiName: 'autoToggleList',\n            changeSource: ChangeSource.AutoFormat,\n        },\n        this.autoLink,\n    ];\n\n    private features: Feature[] = [\n        ...this.tabFeatures,\n        {\n            enabled: !!this.options.autoHyphen,\n            apiName: 'autoHyphen',\n            changeSource: ChangeSource.Format,\n            transformFunction: (_model, previousSegment, paragraph, context) =>\n                transformHyphen(previousSegment, paragraph, context),\n        },\n        {\n            enabled: !!this.options.autoFraction,\n            apiName: 'autoFraction',\n            changeSource: ChangeSource.Format,\n            transformFunction: (_model, previousSegment, paragraph, context) =>\n                transformFraction(previousSegment, paragraph, context),\n        },\n        {\n            enabled: !!this.options.autoOrdinals,\n            apiName: 'autoOrdinal',\n            changeSource: ChangeSource.Format,\n            transformFunction: (_model, previousSegment, paragraph, context) =>\n                transformOrdinals(previousSegment, paragraph, context),\n        },\n    ];\n\n    private enterFeatures: Feature[] = [\n        {\n            enabled: !!this.options.autoHorizontalLine,\n            transformFunction: (model, _previousSegment, paragraph, context) =>\n                checkAndInsertHorizontalLine(model, paragraph, context),\n            apiName: 'autoHorizontalLine',\n            changeSource: ChangeSource.AutoFormat,\n        },\n        this.autoLink,\n    ];\n\n    private handleKeyboardEvents(editor: IEditor, features: Feature[]): FormatContentModelOptions {\n        const formatOptions: FormatContentModelOptions = {\n            changeSource: '',\n            apiName: '',\n            getChangeData: undefined,\n        };\n\n        formatTextSegmentBeforeSelectionMarker(\n            editor,\n            (model, previousSegment, paragraph, _markerFormat, context) => {\n                let featureApplied: Feature | undefined = undefined;\n                for (const feature of features) {\n                    if (feature.enabled) {\n                        const result = feature.transformFunction(\n                            model,\n                            previousSegment,\n                            paragraph,\n                            context\n                        );\n\n                        if (result) {\n                            if (typeof result !== 'boolean') {\n                                formatOptions.getChangeData = () => result;\n                            }\n                            featureApplied = feature;\n                            break;\n                        }\n                    }\n                }\n\n                if (featureApplied) {\n                    formatOptions.changeSource = featureApplied.changeSource;\n                    formatOptions.apiName = featureApplied.apiName;\n                }\n\n                return !!featureApplied;\n            },\n            formatOptions\n        );\n        return formatOptions;\n    }\n\n    private handleEditorInputEvent(editor: IEditor, event: EditorInputEvent) {\n        const rawEvent = event.rawEvent;\n        const selection = editor.getDOMSelection();\n        if (\n            rawEvent.inputType === 'insertText' &&\n            selection &&\n            selection.type === 'range' &&\n            selection.range.collapsed\n        ) {\n            switch (rawEvent.data) {\n                case ' ':\n                    this.handleKeyboardEvents(editor, this.features);\n                    break;\n            }\n        }\n    }\n\n    private handleKeyDownEvent(editor: IEditor, event: KeyDownEvent) {\n        const rawEvent = event.rawEvent;\n        if (!rawEvent.defaultPrevented && !event.handledByEditFeature) {\n            switch (rawEvent.key) {\n                case 'Backspace':\n                    if (this.options.autoUnlink) {\n                        unlink(editor, rawEvent);\n                    }\n                    break;\n                case 'Tab':\n                    if (!rawEvent.shiftKey) {\n                        const eventHandled = this.handleKeyboardEvents(editor, this.tabFeatures);\n                        if (eventHandled.apiName == 'autoToggleList') {\n                            event.rawEvent.preventDefault();\n                        }\n                    }\n                    break;\n                case 'Enter':\n                    const eventHandled = this.handleKeyboardEvents(editor, this.enterFeatures);\n                    if (eventHandled.apiName == 'autoHorizontalLine') {\n                        event.rawEvent.preventDefault();\n                    }\n                    break;\n            }\n        }\n    }\n\n    private handleContentChangedEvent(editor: IEditor, event: ContentChangedEvent) {\n        const { autoLink, autoTel, autoMailto } = this.options;\n        if (event.source == 'Paste' && (autoLink || autoTel || autoMailto)) {\n            createLink(editor, {\n                autoLink,\n                autoTel,\n                autoMailto,\n            });\n        }\n    }\n}\n\nconst createAnchor = (doc: Document, url: string, text: string) => {\n    const anchor = doc.createElement('a');\n    anchor.href = url;\n    anchor.textContent = text;\n    return anchor;\n};\n","import type {\n    ContentModelDividerFormat,\n    ContentModelListItem,\n    FormatContentModelContext,\n    ReadonlyContentModelDocument,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\nimport {\n    addBlock,\n    createContentModelDocument,\n    createDivider,\n    getOperationalBlocks,\n    mergeModel,\n} from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n */\nexport type HorizontalLineTriggerCharacter = '-' | '=' | '_' | '*' | '~' | '#';\nconst HorizontalLineTriggerCharacters: HorizontalLineTriggerCharacter[] = [\n    '-',\n    '=',\n    '_',\n    '*',\n    '~',\n    '#',\n];\n\nconst commonStyles: ContentModelDividerFormat = {\n    width: '98%',\n    display: 'inline-block',\n};\n\nconst HorizontalLineStyles: Map<\n    HorizontalLineTriggerCharacter,\n    ContentModelDividerFormat\n> = new Map([\n    [\n        '-',\n        {\n            borderTop: '1px none',\n            borderRight: '1px none',\n            borderBottom: '1px solid',\n            borderLeft: '1px none',\n            ...commonStyles,\n        },\n    ],\n    [\n        '=',\n        {\n            borderTop: '3pt double',\n            borderRight: '3pt none',\n            borderBottom: '3pt none',\n            borderLeft: '3pt none',\n            ...commonStyles,\n        },\n    ],\n    [\n        '_',\n        {\n            borderTop: '1px solid',\n            borderRight: '1px none',\n            borderBottom: '1px solid',\n            borderLeft: '1px none',\n            ...commonStyles,\n        },\n    ],\n    [\n        '*',\n        {\n            borderTop: '1px none',\n            borderRight: '1px none',\n            borderBottom: '3px dotted',\n            borderLeft: '1px none',\n            ...commonStyles,\n        },\n    ],\n    [\n        '~',\n        {\n            borderTop: '1px none',\n            borderRight: '1px none',\n            borderBottom: '1px solid',\n            borderLeft: '1px none',\n            ...commonStyles,\n        },\n    ],\n    [\n        '#',\n        {\n            borderTop: '3pt double',\n            borderRight: '3pt none',\n            borderBottom: '3pt double',\n            borderLeft: '3pt none',\n            ...commonStyles,\n        },\n    ],\n]);\n\n/**\n * @internal exported only for unit test\n *\n * Create a horizontal line and insert it into the model\n *\n * @param model the model to insert horizontal line into\n * @param context the formatting context\n */\nexport function insertHorizontalLineIntoModel(\n    model: ReadonlyContentModelDocument,\n    context: FormatContentModelContext,\n    triggerChar: HorizontalLineTriggerCharacter\n) {\n    const hr = createDivider('hr', HorizontalLineStyles.get(triggerChar));\n    const doc = createContentModelDocument();\n    addBlock(doc, hr);\n    mergeModel(model, doc, context);\n}\n\n/**\n * @internal\n *\n * Check if the current line should be formatted as horizontal line, and insert horizontal line if needed\n *\n * @param editor The editor to check and insert horizontal line\n * @param event The keydown event\n * @returns True if horizontal line is inserted, otherwise false\n */\nexport const checkAndInsertHorizontalLine = (\n    model: ReadonlyContentModelDocument,\n    paragraph: ShallowMutableContentModelParagraph,\n    context: FormatContentModelContext\n) => {\n    // Do not create horizontal lines inside a list\n    const blocks = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        ['TableCell', 'FormatContainer']\n    );\n    if (\n        blocks[0] &&\n        blocks[0].block.blockType == 'BlockGroup' &&\n        blocks[0].block.blockGroupType == 'ListItem'\n    ) {\n        return false;\n    }\n\n    const allText = paragraph.segments.reduce(\n        (acc, segment) => (segment.segmentType === 'Text' ? acc + segment.text : acc),\n        ''\n    );\n    // At least 3 characters are needed to trigger horizontal line\n    if (allText.length < 3) {\n        return false;\n    }\n\n    return HorizontalLineTriggerCharacters.some(triggerCharacter => {\n        const shouldFormat = allText.split('').every(char => char === triggerCharacter);\n        if (shouldFormat) {\n            paragraph.segments = paragraph.segments.filter(s => s.segmentType != 'Text');\n            insertHorizontalLineIntoModel(model, context, triggerCharacter);\n            context.canUndoByBackspace = true;\n        }\n        return shouldFormat;\n    });\n};\n","import { splitTextSegment } from 'roosterjs-content-model-api';\nimport type {\n    ContentModelText,\n    FormatContentModelContext,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function transformHyphen(\n    previousSegment: ContentModelText,\n    paragraph: ShallowMutableContentModelParagraph,\n    context: FormatContentModelContext\n): boolean {\n    const segments = previousSegment.text.split(' ');\n    const dashes = segments[segments.length - 2];\n    if (dashes === '--') {\n        const textIndex = previousSegment.text.lastIndexOf('--');\n        const textSegment = splitTextSegment(previousSegment, paragraph, textIndex, textIndex + 2);\n        textSegment.text = textSegment.text.replace('--', '');\n        context.canUndoByBackspace = true;\n        return true;\n    } else {\n        const text = segments.pop();\n        const hasDashes = text && text?.indexOf('--') > -1;\n        if (hasDashes && text.trim() !== '--') {\n            const textIndex = previousSegment.text.indexOf(text);\n            const textSegment = splitTextSegment(\n                previousSegment,\n                paragraph,\n                textIndex,\n                textIndex + text.length - 1\n            );\n\n            const textLength = textSegment.text.length;\n            if (textSegment.text[0] !== '-' && textSegment.text[textLength - 1] !== '-') {\n                textSegment.text = textSegment.text.replace('--', '');\n                context.canUndoByBackspace = true;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n","import { ChangeSource } from 'roosterjs-content-model-dom';\nimport { formatTextSegmentBeforeSelectionMarker, promoteLink } from 'roosterjs-content-model-api';\nimport type {\n    ContentModelLink,\n    IEditor,\n    ContentModelText,\n    AutoLinkOptions,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function createLink(editor: IEditor, autoLinkOptions: AutoLinkOptions) {\n    let anchorNode: Node | null = null;\n    const links: ContentModelLink[] = [];\n\n    formatTextSegmentBeforeSelectionMarker(\n        editor,\n        (_model, segment, paragraph) => {\n            let promotedSegment: ContentModelText | null = null;\n\n            if (segment.link) {\n                return false;\n            } else if (\n                (promotedSegment = promoteLink(segment, paragraph, autoLinkOptions)) &&\n                promotedSegment.link\n            ) {\n                links.push(promotedSegment.link);\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            changeSource: ChangeSource.AutoLink,\n            onNodeCreated: (modelElement, node) => {\n                if (!anchorNode && links.indexOf(modelElement as ContentModelLink) >= 0) {\n                    anchorNode = node;\n                }\n            },\n            getChangeData: () => anchorNode,\n        }\n    );\n}\n","import { formatTextSegmentBeforeSelectionMarker } from 'roosterjs-content-model-api';\n\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function unlink(editor: IEditor, rawEvent: KeyboardEvent) {\n    formatTextSegmentBeforeSelectionMarker(editor, (_model, linkSegment, _paragraph) => {\n        if (linkSegment?.link) {\n            linkSegment.link = undefined;\n            rawEvent.preventDefault();\n\n            return true;\n        }\n        return false;\n    });\n}\n","/**\n * @internal\n * Convert english alphabet numbers into decimal numbers\n * @param letter The letter that needs to be converted\n * @returns\n */\nexport function convertAlphaToDecimals(letter: string): number | undefined {\n    const alpha = letter.toUpperCase();\n    if (alpha) {\n        let result = 0;\n        for (let i = 0; i < alpha.length; i++) {\n            const charCode = alpha.charCodeAt(i) - 65 + 1;\n            result = result * 26 + charCode;\n        }\n\n        return result;\n    }\n    return undefined;\n}\n","import { convertAlphaToDecimals } from './convertAlphaToDecimals';\n\n/**\n * @internal\n */\nexport function getIndex(listIndex: string) {\n    const index = listIndex.replace(/[^a-zA-Z0-9 ]/g, '');\n    const indexNumber = parseInt(index);\n    return !isNaN(indexNumber) ? indexNumber : convertAlphaToDecimals(index);\n}\n","import { findListItemsInSameThread } from 'roosterjs-content-model-api';\nimport { getNumberingListStyle } from './getNumberingListStyle';\nimport type {\n    ContentModelListItem,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelListItem,\n    ReadonlyContentModelParagraph,\n} from 'roosterjs-content-model-types';\nimport {\n    BulletListType,\n    isBlockGroupOfType,\n    updateListMetadata,\n    getOperationalBlocks,\n    getSelectedSegmentsAndParagraphs,\n} from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n */\ninterface ListTypeStyle {\n    listType: 'UL' | 'OL';\n    styleType: number;\n    index?: number;\n}\n\n/**\n * @internal\n */\nexport function getListTypeStyle(\n    model: ReadonlyContentModelDocument,\n    shouldSearchForBullet: boolean = true,\n    shouldSearchForNumbering: boolean = true\n): ListTypeStyle | undefined {\n    const selectedSegmentsAndParagraphs = getSelectedSegmentsAndParagraphs(model, true);\n    if (!selectedSegmentsAndParagraphs[0]) {\n        return undefined;\n    }\n    const marker = selectedSegmentsAndParagraphs[0][0];\n    const paragraph = selectedSegmentsAndParagraphs[0][1];\n    const listMarkerSegment = paragraph?.segments[0];\n\n    if (\n        marker &&\n        marker.segmentType == 'SelectionMarker' &&\n        listMarkerSegment &&\n        listMarkerSegment.segmentType == 'Text'\n    ) {\n        const listMarker = listMarkerSegment.text.trim();\n        const bulletType = bulletListType.get(listMarker);\n\n        if (bulletType && shouldSearchForBullet) {\n            return { listType: 'UL', styleType: bulletType };\n        } else if (shouldSearchForNumbering) {\n            const { previousList, hasSpaceBetween } = getPreviousListLevel(model, paragraph);\n            const previousIndex = getPreviousListIndex(model, previousList);\n            const previousListStyle = getPreviousListStyle(previousList);\n            const numberingType = getNumberingListStyle(\n                listMarker,\n                previousIndex,\n                previousListStyle\n            );\n\n            if (numberingType) {\n                return {\n                    listType: 'OL',\n                    styleType: numberingType,\n                    index: getIndex(\n                        listMarker,\n                        previousListStyle,\n                        numberingType,\n                        previousIndex,\n                        hasSpaceBetween\n                    ),\n                };\n            }\n        }\n    }\n    return undefined;\n}\n\nconst getIndex = (\n    listMarker: string,\n    previousListStyle?: number,\n    numberingType?: number,\n    previousIndex?: number,\n    hasSpaceBetween?: boolean\n) => {\n    const newList = isNewList(listMarker);\n    return previousListStyle && previousListStyle !== numberingType && newList\n        ? 1\n        : !newList && previousListStyle === numberingType && hasSpaceBetween && previousIndex\n        ? previousIndex + 1\n        : undefined;\n};\n\nconst getPreviousListIndex = (\n    model: ReadonlyContentModelDocument,\n    previousListItem?: ReadonlyContentModelListItem\n) => {\n    return previousListItem ? findListItemsInSameThread(model, previousListItem).length : undefined;\n};\n\nconst getPreviousListLevel = (\n    model: ReadonlyContentModelDocument,\n    paragraph: ReadonlyContentModelParagraph\n) => {\n    const blocks = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        ['TableCell']\n    )[0];\n    let previousList: ContentModelListItem | undefined = undefined;\n    let hasSpaceBetween = false;\n    if (blocks) {\n        const listBlockIndex = blocks.parent.blocks.indexOf(paragraph);\n\n        if (listBlockIndex > -1) {\n            for (let i = listBlockIndex - 1; i > -1; i--) {\n                const item = blocks.parent.blocks[i];\n                if (isBlockGroupOfType<ContentModelListItem>(item, 'ListItem')) {\n                    previousList = item;\n                    break;\n                } else {\n                    hasSpaceBetween = listBlockIndex > 0 ? true : false;\n                }\n            }\n        }\n    }\n\n    return { previousList, hasSpaceBetween };\n};\n\nconst getPreviousListStyle = (list?: ContentModelListItem) => {\n    if (!list || list.levels.length < 1) {\n        return undefined;\n    }\n    return updateListMetadata(list.levels[0])?.orderedStyleType;\n};\n\nconst bulletListType: Map<string, number> = new Map<string, number>([\n    ['*', BulletListType.Disc],\n    ['-', BulletListType.Dash],\n    ['--', BulletListType.Square],\n    ['->', BulletListType.LongArrow],\n    ['-->', BulletListType.DoubleLongArrow],\n    ['=>', BulletListType.UnfilledArrow],\n    ['>', BulletListType.ShortArrow],\n    ['', BulletListType.Hyphen],\n]);\n\nconst isNewList = (listMarker: string) => {\n    const marker = listMarker.replace(/[^\\w\\s]/g, '');\n    const pattern = /^[1aAiI]$/;\n    return pattern.test(marker);\n};\n","import { getIndex } from './getIndex';\nimport { NumberingListType } from 'roosterjs-content-model-dom';\n\nconst enum NumberingTypes {\n    Decimal = 1,\n    LowerAlpha = 2,\n    UpperAlpha = 3,\n    LowerRoman = 4,\n    UpperRoman = 5,\n}\n\nconst enum Character {\n    Dot = 1,\n    Dash = 2,\n    Parenthesis = 3,\n    DoubleParenthesis = 4,\n}\n\nconst characters: Record<string, number> = {\n    '.': Character.Dot,\n    '-': Character.Dash,\n    ')': Character.Parenthesis,\n};\n\nconst lowerRomanTypes = [\n    NumberingListType.LowerRoman,\n    NumberingListType.LowerRomanDash,\n    NumberingListType.LowerRomanDoubleParenthesis,\n    NumberingListType.LowerRomanParenthesis,\n];\nconst upperRomanTypes = [\n    NumberingListType.UpperRoman,\n    NumberingListType.UpperRomanDash,\n    NumberingListType.UpperRomanDoubleParenthesis,\n    NumberingListType.UpperRomanParenthesis,\n];\nconst numberingTriggers = ['1', 'a', 'A', 'I', 'i'];\nconst lowerRomanNumbers = ['i', 'v', 'x', 'l', 'c', 'd', 'm'];\nconst upperRomanNumbers = ['I', 'V', 'X', 'L', 'C', 'D', 'M'];\n\nconst identifyNumberingType = (text: string, previousListStyle?: number) => {\n    if (!isNaN(parseInt(text))) {\n        return NumberingTypes.Decimal;\n    } else if (/[a-z]+/g.test(text)) {\n        if (\n            (previousListStyle === NumberingTypes.LowerRoman &&\n                lowerRomanTypes.indexOf(previousListStyle) > -1 &&\n                lowerRomanNumbers.indexOf(text[0]) > -1) ||\n            (!previousListStyle && text === 'i')\n        ) {\n            return NumberingTypes.LowerRoman;\n        } else if (\n            previousListStyle === NumberingTypes.LowerAlpha ||\n            (!previousListStyle && text === 'a')\n        ) {\n            return NumberingTypes.LowerAlpha;\n        }\n    } else if (/[A-Z]+/g.test(text)) {\n        if (\n            (previousListStyle == NumberingTypes.UpperRoman &&\n                upperRomanTypes.indexOf(previousListStyle) > -1 &&\n                upperRomanNumbers.indexOf(text[0]) > -1) ||\n            (!previousListStyle && text === 'I')\n        ) {\n            return NumberingTypes.UpperRoman;\n        } else if (\n            previousListStyle == NumberingTypes.UpperAlpha ||\n            (!previousListStyle && text === 'A')\n        ) {\n            return NumberingTypes.UpperAlpha;\n        }\n    }\n};\n\nconst numberingListTypes: Record<number, (char: number) => number | undefined> = {\n    [NumberingTypes.Decimal]: char => DecimalsTypes[char] || undefined,\n    [NumberingTypes.LowerAlpha]: char => LowerAlphaTypes[char] || undefined,\n    [NumberingTypes.UpperAlpha]: char => UpperAlphaTypes[char] || undefined,\n    [NumberingTypes.LowerRoman]: char => LowerRomanTypes[char] || undefined,\n    [NumberingTypes.UpperRoman]: char => UpperRomanTypes[char] || undefined,\n};\n\nconst UpperRomanTypes: Record<number, number> = {\n    [Character.Dot]: NumberingListType.UpperRoman,\n    [Character.Dash]: NumberingListType.UpperRomanDash,\n    [Character.Parenthesis]: NumberingListType.UpperRomanParenthesis,\n    [Character.DoubleParenthesis]: NumberingListType.UpperRomanDoubleParenthesis,\n};\n\nconst LowerRomanTypes: Record<number, number> = {\n    [Character.Dot]: NumberingListType.LowerRoman,\n    [Character.Dash]: NumberingListType.LowerRomanDash,\n    [Character.Parenthesis]: NumberingListType.LowerRomanParenthesis,\n    [Character.DoubleParenthesis]: NumberingListType.LowerRomanDoubleParenthesis,\n};\n\nconst UpperAlphaTypes: Record<number, number> = {\n    [Character.Dot]: NumberingListType.UpperAlpha,\n    [Character.Dash]: NumberingListType.UpperAlphaDash,\n    [Character.Parenthesis]: NumberingListType.UpperAlphaParenthesis,\n    [Character.DoubleParenthesis]: NumberingListType.UpperAlphaDoubleParenthesis,\n};\n\nconst LowerAlphaTypes: Record<number, number> = {\n    [Character.Dot]: NumberingListType.LowerAlpha,\n    [Character.Dash]: NumberingListType.LowerAlphaDash,\n    [Character.Parenthesis]: NumberingListType.LowerAlphaParenthesis,\n    [Character.DoubleParenthesis]: NumberingListType.LowerAlphaDoubleParenthesis,\n};\n\nconst DecimalsTypes: Record<number, number> = {\n    [Character.Dot]: NumberingListType.Decimal,\n    [Character.Dash]: NumberingListType.DecimalDash,\n    [Character.Parenthesis]: NumberingListType.DecimalParenthesis,\n    [Character.DoubleParenthesis]: NumberingListType.DecimalDoubleParenthesis,\n};\n\nconst identifyNumberingListType = (\n    numbering: string,\n    isDoubleParenthesis: boolean,\n    previousListStyle?: number\n): number | undefined => {\n    const separatorCharacter = isDoubleParenthesis\n        ? Character.DoubleParenthesis\n        : characters[numbering[numbering.length - 1]];\n    // if separator is not valid, no need to check if the number is valid.\n    if (separatorCharacter) {\n        const number = isDoubleParenthesis ? numbering.slice(1, -1) : numbering.slice(0, -1);\n        const numberingType = identifyNumberingType(number, previousListStyle);\n        return numberingType ? numberingListTypes[numberingType](separatorCharacter) : undefined;\n    }\n    return undefined;\n};\n\n/**\n * @internal\n */\nexport function getNumberingListStyle(\n    textBeforeCursor: string,\n    previousListIndex?: number,\n    previousListStyle?: number\n): number | undefined {\n    const trigger = textBeforeCursor.trim();\n    const isDoubleParenthesis = trigger[0] === '(' && trigger[trigger.length - 1] === ')';\n    //Only the staring items ['1', 'a', 'A', 'I', 'i'] must trigger a new list. All the other triggers is used to keep the list chain.\n    //The index is always the characters before the last character\n    const listIndex = isDoubleParenthesis ? trigger.slice(1, -1) : trigger.slice(0, -1);\n    const index = getIndex(listIndex);\n    const isContinuosList = numberingTriggers.indexOf(listIndex) < 0;\n\n    if (\n        !index ||\n        index < 1 ||\n        (!previousListIndex && isContinuosList) ||\n        (previousListIndex && isContinuosList && !canAppendList(index, previousListIndex))\n    ) {\n        return undefined;\n    }\n\n    const numberingType = isValidNumbering(listIndex)\n        ? identifyNumberingListType(\n              trigger,\n              isDoubleParenthesis,\n              isContinuosList ? previousListStyle : undefined\n          )\n        : undefined;\n    return numberingType;\n}\n\n/**\n * Check if index has only numbers or only letters to avoid sequence of character such 1:1. trigger a list.\n * @param index\n * @returns\n */\nfunction isValidNumbering(index: string) {\n    return Number(index) || /^[A-Za-z\\s]*$/.test(index);\n}\n\nfunction canAppendList(index?: number, previousListIndex?: number) {\n    return previousListIndex && index && previousListIndex + 1 === index;\n}\n","import { getListTypeStyle } from './getListTypeStyle';\nimport { getOperationalBlocks, isBlockGroupOfType } from 'roosterjs-content-model-dom';\nimport {\n    getListAnnounceData,\n    setListType,\n    setModelListStartNumber,\n    setModelListStyle,\n} from 'roosterjs-content-model-api';\nimport type {\n    ContentModelListItem,\n    FormatContentModelContext,\n    ReadonlyContentModelDocument,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function keyboardListTrigger(\n    model: ReadonlyContentModelDocument,\n    paragraph: ShallowMutableContentModelParagraph,\n    context: FormatContentModelContext,\n    shouldSearchForBullet: boolean = true,\n    shouldSearchForNumbering: boolean = true,\n    removeListMargins?: boolean\n) {\n    const listStyleType = getListTypeStyle(model, shouldSearchForBullet, shouldSearchForNumbering);\n    if (listStyleType) {\n        paragraph.segments.splice(0, 1);\n        const { listType, styleType, index } = listStyleType;\n        triggerList(model, listType, styleType, index, removeListMargins);\n        context.canUndoByBackspace = true;\n        setAnnounceData(model, context);\n\n        return true;\n    }\n    return false;\n}\n\nconst triggerList = (\n    model: ReadonlyContentModelDocument,\n    listType: 'OL' | 'UL',\n    styleType: number,\n    index?: number,\n    removeListMargins?: boolean\n) => {\n    setListType(model, listType, removeListMargins);\n    const isOrderedList = listType == 'OL';\n    if (index && index > 0 && isOrderedList) {\n        setModelListStartNumber(model, index);\n    }\n    setModelListStyle(\n        model,\n        isOrderedList\n            ? {\n                  orderedStyleType: styleType,\n                  applyListStyleFromLevel: false,\n              }\n            : {\n                  unorderedStyleType: styleType,\n                  applyListStyleFromLevel: false,\n              }\n    );\n};\nfunction setAnnounceData(model: ReadonlyContentModelDocument, context: FormatContentModelContext) {\n    const [paragraphOrListItems] = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        [] // Set stop types to be empty so we can find list items even cross the boundary of table, then we can always operation on the list item if any\n    );\n\n    if (paragraphOrListItems && isBlockGroupOfType(paragraphOrListItems.block, 'ListItem')) {\n        const { path, block } = paragraphOrListItems;\n        context.announceData = getListAnnounceData([block, ...path]);\n    }\n}\n","import { splitTextSegment } from 'roosterjs-content-model-api';\nimport type {\n    ContentModelText,\n    FormatContentModelContext,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\nconst FRACTIONS: Map<string, string> = new Map<string, string>([\n    ['1/2', ''],\n    ['1/4', ''],\n    ['3/4', ''],\n]);\n\n/**\n * @internal\n */\nexport function transformFraction(\n    previousSegment: ContentModelText,\n    paragraph: ShallowMutableContentModelParagraph,\n    context: FormatContentModelContext\n): boolean {\n    const fraction = previousSegment.text.split(' ').pop()?.trim();\n    const text = fraction ? FRACTIONS.get(fraction) : undefined;\n\n    if (fraction && text) {\n        const textLength = previousSegment.text.length - 1;\n        const textIndex = textLength - fraction.length;\n        const textSegment = splitTextSegment(previousSegment, paragraph, textIndex, textLength);\n        textSegment.text = text;\n\n        context.canUndoByBackspace = true;\n        return true;\n    }\n\n    return false;\n}\n","import { splitTextSegment } from 'roosterjs-content-model-api';\n\nimport type {\n    ContentModelText,\n    FormatContentModelContext,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\nconst getOrdinal = (value: number) => {\n    const ORDINALS: Record<number, string> = {\n        1: 'st',\n        2: 'nd',\n        3: 'rd',\n    };\n    return ORDINALS[value] || 'th';\n};\n\nconst ORDINALS = ['st', 'nd', 'rd', 'th'];\n\n/**\n * The two last characters of ordinal number (st, nd, rd, th)\n */\nconst ORDINAL_LENGTH = 2;\n\n/**\n * @internal\n */ export function transformOrdinals(\n    previousSegment: ContentModelText,\n    paragraph: ShallowMutableContentModelParagraph,\n    context: FormatContentModelContext\n): boolean {\n    const value = previousSegment.text.split(' ').pop()?.trim();\n    let shouldAddSuperScript = false;\n    if (value) {\n        const isOrdinal = ORDINALS.indexOf(value) > -1;\n        if (isOrdinal) {\n            const index = paragraph.segments.indexOf(previousSegment);\n            const numberSegment = paragraph.segments[index - 1];\n            let numericValue: number | null = null;\n            if (\n                numberSegment &&\n                numberSegment.segmentType == 'Text' &&\n                ((numericValue = getNumericValue(numberSegment.text, true /* checkFullText */)) !== null) &&\n                getOrdinal(numericValue) === value\n            ) {\n                shouldAddSuperScript = true;\n            }\n        } else {\n            const ordinal = value.substring(value.length - ORDINAL_LENGTH); // This value  is equal st, nd, rd, th\n            const numericValue = getNumericValue(value); //This is the numeric part. Ex: 10th, numeric value =\n            if (numericValue !== null && getOrdinal(numericValue) === ordinal) {\n                shouldAddSuperScript = true;\n            }\n        }\n\n        if (shouldAddSuperScript) {\n            const ordinalSegment = splitTextSegment(\n                previousSegment,\n                paragraph,\n                previousSegment.text.length - 3,\n                previousSegment.text.length - 1\n            );\n\n            ordinalSegment.format.superOrSubScriptSequence = 'super';\n            context.canUndoByBackspace = true;\n        }\n    }\n    return shouldAddSuperScript;\n}\n\nfunction getNumericValue(text: string, checkFullText: boolean = false): number | null {\n    const number = checkFullText ? text : text.substring(0, text.length - ORDINAL_LENGTH);\n    const isNumber = /^-?\\d+$/.test(number);\n    if (isNumber) {\n        const numericValue = parseInt(number);\n        return Math.abs(numericValue) < 20\n            ? numericValue\n            : parseInt(number.substring(number.length - 1));\n    }\n    return null;\n}\n","import type { EditorPlugin, IEditor, PluginEvent } from 'roosterjs-content-model-types';\n\n/**\n * Context Menu options for ContextMenu plugin\n */\nexport interface ContextMenuOptions<T> {\n    /**\n     * Render function for the context menu\n     * @param container The container HTML element, it will be located at the mouse click position,\n     * so the callback just need to render menu content into this container\n     * @param onDismiss The onDismiss callback, some menu render need to know this callback so that\n     * it can handle the dismiss event\n     */\n    render: (container: HTMLElement, items: (T | null)[], onDismiss: () => void) => void;\n\n    /**\n     * Dismiss function for the context menu, it will be called when user wants to dismiss this context menu\n     * e.g. user click away so the menu should be dismissed\n     * @param container The container HTML element\n     */\n    dismiss?: (container: HTMLElement) => void;\n\n    /**\n     * Whether the default context menu is allowed. @default false\n     */\n    allowDefaultMenu?: boolean;\n}\n\n/**\n * An editor plugin that support showing a context menu using render() function from options parameter\n */\nexport class ContextMenuPluginBase<T> implements EditorPlugin {\n    private container: HTMLElement | null = null;\n    private editor: IEditor | null = null;\n    private isMenuShowing: boolean = false;\n\n    /**\n     * Create a new instance of ContextMenu class\n     * @param options An options object to determine how to show/hide the context menu\n     */\n    constructor(private options: ContextMenuOptions<T>) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContextMenu';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onDismiss();\n\n        if (this.container?.parentNode) {\n            this.container.parentNode.removeChild(this.container);\n            this.container = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == 'contextMenu' && event.items.length > 0) {\n            const { rawEvent, items } = event;\n\n            this.onDismiss();\n\n            if (!this.options.allowDefaultMenu) {\n                rawEvent.preventDefault();\n            }\n\n            if (this.initContainer(rawEvent.pageX, rawEvent.pageY)) {\n                this.options.render(this.container!, items as T[], this.onDismiss);\n                this.isMenuShowing = true;\n            }\n        }\n    }\n\n    private initContainer(x: number, y: number) {\n        if (!this.container && this.editor) {\n            this.container = this.editor.getDocument().createElement('div');\n\n            this.container.style.position = 'fixed';\n            this.container.style.width = '0';\n            this.container.style.height = '0';\n            this.editor.getDocument().body.appendChild(this.container);\n        }\n        this.container?.style.setProperty('left', x + 'px');\n        this.container?.style.setProperty('top', y + 'px');\n        return !!this.container;\n    }\n\n    private onDismiss = () => {\n        if (this.container && this.isMenuShowing) {\n            this.options.dismiss?.(this.container);\n            this.isMenuShowing = false;\n        }\n    };\n}\n","import { formatTextSegmentBeforeSelectionMarker } from 'roosterjs-content-model-api';\nimport type {\n    ContentModelText,\n    EditorInputEvent,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * The CustomReplace interface defines a custom replacement that can be used in CustomReplacePlugin.\n */\nexport interface CustomReplace {\n    /**\n     * The string to replace in the editor.\n     */\n    stringToReplace: string;\n\n    /**\n     * The string to replace with.\n     */\n    replacementString: string;\n\n    /**\n     * The handler to replace the string.\n     * @param previousSegment The text segment to replace.\n     * @param stringToReplace The string to replace.\n     * @param replacementString The string to replace with.\n     * @param paragraph The paragraph that contains the text segment.\n     * @returns True if the string is replaced successfully, otherwise false.\n     */\n    replacementHandler: (\n        previousSegment: ContentModelText,\n        stringToReplace: string,\n        replacementString: string,\n        paragraph?: ShallowMutableContentModelParagraph\n    ) => boolean;\n}\n\n/**\n * CustomReplacePlugin is a plugin that allows you to replace a string with another string in the editor.\n */\nexport class CustomReplacePlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private triggerKeys: string[] = [];\n\n    /**\n     * @param customReplacements Custom replacement rules.\n     * Ex: [{ stringToReplace: ':)', replacementString: '', replacementHandler: replaceEmojis }]\n     */\n    constructor(private customReplacements: CustomReplace[]) {}\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'CustomReplace';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.triggerKeys = this.customReplacements.map(replacement =>\n            replacement.stringToReplace.slice(-1)\n        );\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case 'input':\n                    this.handleEditorInputEvent(this.editor, event);\n                    break;\n            }\n        }\n    }\n\n    private handleEditorInputEvent(editor: IEditor, event: EditorInputEvent) {\n        const rawEvent = event.rawEvent;\n        const selection = editor.getDOMSelection();\n        const key = rawEvent.data;\n        if (\n            this.customReplacements.length > 0 &&\n            rawEvent.inputType === 'insertText' &&\n            selection &&\n            selection.type === 'range' &&\n            selection.range.collapsed &&\n            key &&\n            this.triggerKeys.indexOf(key) > -1\n        ) {\n            formatTextSegmentBeforeSelectionMarker(\n                editor,\n                (_model, previousSegment, paragraph, _markerFormat, context) => {\n                    const replaced = this.customReplacements.some(\n                        ({ stringToReplace, replacementString, replacementHandler }) => {\n                            return replacementHandler(\n                                previousSegment,\n                                stringToReplace,\n                                replacementString,\n                                paragraph\n                            );\n                        }\n                    );\n                    if (replaced) {\n                        context.canUndoByBackspace = true;\n                        return true;\n                    }\n                    return false;\n                }\n            );\n        }\n    }\n}\n","import { keyboardDelete } from './keyboardDelete';\nimport { keyboardEnter } from './keyboardEnter';\nimport { keyboardInput } from './keyboardInput';\nimport { keyboardTab } from './keyboardTab';\nimport { parseTableCells } from 'roosterjs-content-model-dom';\nimport type { EditOptions, HandleTabOptions } from './EditOptions';\nimport type {\n    DOMSelection,\n    EditorPlugin,\n    IEditor,\n    KeyDownEvent,\n    PluginEvent,\n} from 'roosterjs-content-model-types';\n\nconst BACKSPACE_KEY = 8;\nconst DELETE_KEY = 46;\n/**\n * According to https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n * 229 can be sent in variants generated when Long press (iOS) or using IM.\n *\n * Other cases: https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n */\nconst DEAD_KEY = 229;\n\nconst DefaultHandleTabOptions: Required<HandleTabOptions> = {\n    indentMultipleBlocks: true,\n    indentTable: true,\n    appendTableRow: true,\n    indentList: true,\n    indentParagraph: true,\n};\n\nconst DisabledHandleTabOptions: Required<HandleTabOptions> = {\n    indentMultipleBlocks: false,\n    indentTable: false,\n    appendTableRow: false,\n    indentList: false,\n    indentParagraph: false,\n};\n\nconst DefaultOptions: Partial<EditOptions> & { handleTabKey: Required<HandleTabOptions> } = {\n    handleTabKey: DefaultHandleTabOptions,\n    handleExpandedSelectionOnDelete: true,\n};\n\n/**\n * Edit plugins helps editor to do editing operation on top of content model.\n * This includes:\n * 1. Delete Key\n * 2. Backspace Key\n * 3. Tab Key\n */\nexport class EditPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private disposer: (() => void) | null = null;\n    private shouldHandleNextInputEvent = false;\n    private selectionAfterDelete: DOMSelection | null = null;\n    private handleNormalEnter: (editor: IEditor) => boolean = () => false;\n    private options: EditOptions & { handleTabKey: Required<HandleTabOptions> };\n\n    /**\n     * @param options An optional parameter that takes in an object of type EditOptions, which includes the following properties:\n     * handleTabKey: A boolean or HandleTabOptions object that controls Tab key handling. When a boolean, true enables all features and false disables all. When an object, individual features can be controlled. Defaults to all enabled.\n     */\n    constructor(options: EditOptions = DefaultOptions) {\n        const tabOptions =\n            options.handleTabKey === false\n                ? DisabledHandleTabOptions\n                : options.handleTabKey === true || !options.handleTabKey\n                ? DefaultHandleTabOptions\n                : { ...DefaultHandleTabOptions, ...options.handleTabKey };\n        this.options = { ...DefaultOptions, ...options, handleTabKey: tabOptions };\n    }\n\n    private createNormalEnterChecker(result: boolean) {\n        return result ? () => true : () => false;\n    }\n\n    private getHandleNormalEnter(editor: IEditor) {\n        switch (typeof this.options.shouldHandleEnterKey) {\n            case 'function':\n                return this.options.shouldHandleEnterKey;\n            case 'boolean':\n                return this.createNormalEnterChecker(this.options.shouldHandleEnterKey);\n            default:\n                return this.createNormalEnterChecker(\n                    editor.isExperimentalFeatureEnabled('HandleEnterKey')\n                );\n        }\n    }\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'Edit';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.handleNormalEnter = this.getHandleNormalEnter(editor);\n\n        if (editor.getEnvironment().isAndroid) {\n            this.disposer = this.editor.attachDomEvent({\n                beforeinput: {\n                    beforeDispatch: e => this.handleBeforeInputEvent(editor, e),\n                },\n            });\n        }\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n        this.disposer?.();\n        this.disposer = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case 'keyDown':\n                    this.handleKeyDownEvent(this.editor, event);\n                    break;\n                case 'keyUp':\n                    if (this.selectionAfterDelete) {\n                        this.editor.setDOMSelection(this.selectionAfterDelete);\n                        this.selectionAfterDelete = null;\n                    }\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check:\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        if (\n            this.editor &&\n            this.options.handleTabKey.appendTableRow &&\n            event.eventType == 'keyDown' &&\n            event.rawEvent.key == 'Tab' &&\n            !event.rawEvent.shiftKey\n        ) {\n            const selection = this.editor.getDOMSelection();\n            const startContainer =\n                selection?.type == 'range' ? selection.range.startContainer : null;\n            const table = startContainer\n                ? this.editor.getDOMHelper().findClosestElementAncestor(startContainer, 'table')\n                : null;\n            const parsedTable = table && parseTableCells(table);\n\n            if (parsedTable) {\n                const lastRow = parsedTable[parsedTable.length - 1];\n                const lastCell = lastRow && lastRow[lastRow.length - 1];\n\n                if (typeof lastCell == 'object' && lastCell.contains(startContainer)) {\n                    // When TAB in the last cell of a table, we will generate new table row, so prevent other plugins handling this event\n                    // e.g. SelectionPlugin will move the focus out of table, which is conflict with this behavior\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private handleKeyDownEvent(editor: IEditor, event: KeyDownEvent) {\n        const rawEvent = event.rawEvent;\n        const hasCtrlOrMetaKey = rawEvent.ctrlKey || rawEvent.metaKey;\n\n        if (!rawEvent.defaultPrevented && !event.handledByEditFeature) {\n            switch (rawEvent.key) {\n                case 'Backspace':\n                    // Use our API to handle BACKSPACE/DELETE key.\n                    // No need to clear cache here since if we rely on browser's behavior, there will be Input event and its handler will reconcile cache\n                    if (!this.shouldBrowserHandleBackspace(editor)) {\n                        keyboardDelete(editor, rawEvent, this.options);\n                    }\n                    break;\n\n                case 'Delete':\n                    // Use our API to handle BACKSPACE/DELETE key.\n                    // No need to clear cache here since if we rely on browser's behavior, there will be Input event and its handler will reconcile cache\n                    // And leave it to browser when shift key is pressed so that browser will trigger cut event\n                    if (!event.rawEvent.shiftKey) {\n                        keyboardDelete(editor, rawEvent, this.options);\n                    }\n                    break;\n\n                case 'Tab':\n                    if (!hasCtrlOrMetaKey) {\n                        keyboardTab(editor, rawEvent, this.options.handleTabKey);\n                    }\n                    break;\n                case 'Unidentified':\n                    if (editor.getEnvironment().isAndroid) {\n                        this.shouldHandleNextInputEvent = true;\n                    }\n                    break;\n\n                case 'Enter':\n                    if (\n                        !hasCtrlOrMetaKey &&\n                        !event.rawEvent.isComposing &&\n                        event.rawEvent.keyCode !== DEAD_KEY\n                    ) {\n                        keyboardEnter(\n                            editor,\n                            rawEvent,\n                            this.handleNormalEnter(editor),\n                            this.options.formatsToPreserveOnMerge\n                        );\n                    }\n                    break;\n\n                default:\n                    keyboardInput(editor, rawEvent);\n                    break;\n            }\n        }\n    }\n\n    private handleBeforeInputEvent(editor: IEditor, rawEvent: Event) {\n        // Some Android IMEs doesn't fire correct keydown event for BACKSPACE/DELETE key\n        // Here we translate input event to BACKSPACE/DELETE keydown event to be compatible with existing logic\n        if (\n            !this.shouldHandleNextInputEvent ||\n            !(rawEvent instanceof InputEvent) ||\n            rawEvent.defaultPrevented\n        ) {\n            return;\n        }\n        this.shouldHandleNextInputEvent = false;\n\n        let handled = false;\n        switch (rawEvent.inputType) {\n            case 'deleteContentBackward':\n                if (!this.shouldBrowserHandleBackspace(editor)) {\n                    // This logic is Android specific. It's because some Android keyboard doesn't support key and keycode, the value of them is always Unidentified, so we have to manually create a new one.\n                    handled = keyboardDelete(\n                        editor,\n                        new KeyboardEvent('keydown', {\n                            key: 'Backspace',\n                            keyCode: BACKSPACE_KEY,\n                            which: BACKSPACE_KEY,\n                        }),\n                        this.options\n                    );\n                }\n                break;\n            case 'deleteContentForward':\n                handled = keyboardDelete(\n                    editor,\n                    new KeyboardEvent('keydown', {\n                        key: 'Delete',\n                        keyCode: DELETE_KEY,\n                        which: DELETE_KEY,\n                    }),\n                    this.options\n                );\n                break;\n        }\n\n        if (handled) {\n            rawEvent.preventDefault();\n\n            // Restore the selection on keyup event to avoid the cursor jump issue\n            // See: https://issues.chromium.org/issues/330596261\n            this.selectionAfterDelete = editor.getDOMSelection();\n        }\n    }\n\n    private shouldBrowserHandleBackspace(editor: IEditor): boolean {\n        const opt = this.options.shouldHandleBackspaceKey;\n        switch (typeof opt) {\n            case 'function':\n                return opt(editor);\n            case 'boolean':\n                return opt;\n            default:\n                return false;\n        }\n    }\n}\n","import { deleteSegment, mutateBlock } from 'roosterjs-content-model-dom';\nimport type { DeleteSelectionStep } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const deleteAllSegmentBefore: DeleteSelectionStep = context => {\n    if (context.deleteResult != 'notDeleted') {\n        return;\n    }\n\n    const { paragraph, marker } = context.insertPoint;\n    const index = paragraph.segments.indexOf(marker);\n    const mutableParagraph = mutateBlock(paragraph);\n\n    for (let i = index - 1; i >= 0; i--) {\n        const segment = mutableParagraph.segments[i];\n\n        segment.isSelected = true;\n\n        if (deleteSegment(paragraph, segment, context.formatContext)) {\n            context.deleteResult = 'range';\n        }\n    }\n};\n","import { getLeafSiblingBlock } from '../utils/getLeafSiblingBlock';\nimport { preserveParagraphFormat } from '../utils/preserveParagraphFormat';\nimport { setModelIndentation } from 'roosterjs-content-model-api';\nimport {\n    deleteBlock,\n    deleteSegment,\n    getClosestAncestorBlockGroupIndex,\n    mutateBlock,\n    setParagraphNotImplicit,\n} from 'roosterjs-content-model-dom';\nimport type { ReadonlyBlockAndPath } from '../utils/getLeafSiblingBlock';\nimport type {\n    DeleteSelectionStep,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelParagraph,\n    ReadonlyContentModelSegment,\n} from 'roosterjs-content-model-types';\nimport type { EditOptions } from '../EditOptions';\n\n/**\n * @internal\n * Get a delete step for collapsed selection at specified direction\n * @param direction The direction to delete\n * @param options Options for the delete operation\n * @returns A delete step\n */\nexport function getDeleteCollapsedSelection(\n    direction: 'forward' | 'backward',\n    options: EditOptions\n): DeleteSelectionStep {\n    return context => {\n        if (context.deleteResult != 'notDeleted') {\n            return;\n        }\n\n        const isForward = direction == 'forward';\n        const { paragraph, marker, path, tableContext } = context.insertPoint;\n        const segments = paragraph.segments;\n\n        fixupBr(paragraph);\n\n        const index = segments.indexOf(marker) + (isForward ? 1 : -1);\n        const segmentToDelete = segments[index];\n        let blockToDelete: ReadonlyBlockAndPath | null;\n        let root: ReadonlyContentModelDocument | null;\n\n        if (segmentToDelete) {\n            if (deleteSegment(paragraph, segmentToDelete, context.formatContext, direction)) {\n                context.deleteResult = 'singleChar';\n\n                // It is possible that we have deleted everything from this paragraph, so we need to mark it as not implicit\n                // to avoid losing its format. See https://github.com/microsoft/roosterjs/issues/1953\n                setParagraphNotImplicit(paragraph);\n            }\n        } else if (\n            shouldOutdentParagraph(isForward, segments, paragraph, path) &&\n            (root = getRoot(path))\n        ) {\n            setModelIndentation(root, 'outdent');\n            context.deleteResult = 'range';\n        } else if ((blockToDelete = getLeafSiblingBlock(path, paragraph, isForward))) {\n            const { block: readonlyBlock, path, siblingSegment } = blockToDelete;\n\n            if (readonlyBlock.blockType == 'Paragraph') {\n                const block = mutateBlock(readonlyBlock);\n\n                if (siblingSegment) {\n                    // When selection is under general segment, need to check if it has a sibling sibling, and delete from it\n                    if (deleteSegment(block, siblingSegment, context.formatContext, direction)) {\n                        context.deleteResult = 'range';\n                    }\n                } else {\n                    if (isForward) {\n                        context.lastParagraph = block;\n                    } else {\n                        if (block.segments[block.segments.length - 1]?.segmentType == 'Br') {\n                            mutateBlock(block).segments.pop();\n                        }\n\n                        context.insertPoint = {\n                            marker,\n                            paragraph: block,\n                            path,\n                            tableContext,\n                        };\n                        context.lastParagraph = paragraph;\n                    }\n\n                    preserveParagraphFormat(\n                        options.formatsToPreserveOnMerge,\n                        context.insertPoint.paragraph,\n                        context.lastParagraph\n                    );\n\n                    context.deleteResult = 'range';\n                }\n\n                // When go across table, getLeafSiblingBlock will return null, when we are here, we must be in the same table context\n                context.lastTableContext = tableContext;\n            } else {\n                if (\n                    deleteBlock(\n                        mutateBlock(path[0]).blocks,\n                        readonlyBlock,\n                        undefined /*replacement*/,\n                        context.formatContext,\n                        direction\n                    )\n                ) {\n                    context.deleteResult = 'range';\n                }\n            }\n        } else {\n            // We have nothing to delete, in this case we don't want browser handle it as well.\n            // Because when Backspace on an empty document, it will also delete the only DIV and SPAN element, causes\n            // editor is really empty. We don't want that happen. So the handling should stop here.\n            context.deleteResult = 'nothingToDelete';\n        }\n    };\n}\n\nfunction getRoot(path: ReadonlyContentModelBlockGroup[]): ReadonlyContentModelDocument | null {\n    const lastInPath = path[path.length - 1];\n    return lastInPath.blockGroupType == 'Document' ? lastInPath : null;\n}\n\nfunction shouldOutdentParagraph(\n    isForward: boolean,\n    segments: ReadonlyContentModelSegment[],\n    paragraph: ReadonlyContentModelParagraph,\n    path: ReadonlyContentModelBlockGroup[]\n) {\n    return (\n        !isForward &&\n        segments.length == 1 &&\n        segments[0].segmentType == 'SelectionMarker' &&\n        paragraph.format.marginLeft &&\n        parseInt(paragraph.format.marginLeft) &&\n        getClosestAncestorBlockGroupIndex(path, ['Document', 'TableCell'], ['ListItem']) > -1\n    );\n}\n\n/**\n * If the last segment is BR, remove it for now. We may add it back later when normalize model.\n * So that if this is an empty paragraph, it will start to delete next block\n */\nfunction fixupBr(paragraph: ReadonlyContentModelParagraph) {\n    const { segments } = paragraph;\n\n    if (segments[segments.length - 1]?.segmentType == 'Br') {\n        const segmentsWithoutBr = segments.filter(x => x.segmentType != 'SelectionMarker');\n\n        if (segmentsWithoutBr[segmentsWithoutBr.length - 2]?.segmentType != 'Br') {\n            mutateBlock(paragraph).segments.pop();\n        }\n    }\n}\n","import {\n    unwrapBlock,\n    getClosestAncestorBlockGroupIndex,\n    createFormatContainer,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DeleteSelectionStep,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelFormatContainer,\n    ReadonlyContentModelParagraph,\n    ShallowMutableContentModelFormatContainer,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const deleteEmptyQuote: DeleteSelectionStep = context => {\n    const { deleteResult } = context;\n\n    if (\n        deleteResult == 'nothingToDelete' ||\n        deleteResult == 'notDeleted' ||\n        deleteResult == 'range'\n    ) {\n        const { insertPoint, formatContext } = context;\n        const { path, paragraph } = insertPoint;\n        const rawEvent = formatContext?.rawEvent as KeyboardEvent;\n        const index = getClosestAncestorBlockGroupIndex(\n            path,\n            ['FormatContainer'],\n            ['TableCell', 'ListItem']\n        );\n        const quote = path[index];\n\n        if (quote && quote.blockGroupType === 'FormatContainer' && quote.tagName == 'blockquote') {\n            const parent = path[index + 1];\n            const quoteBlockIndex = parent.blocks.indexOf(quote);\n\n            if (isEmptyQuote(quote)) {\n                unwrapBlock(parent, quote);\n                rawEvent?.preventDefault();\n                context.deleteResult = 'range';\n            } else if (\n                rawEvent?.key === 'Enter' &&\n                quote.blocks.indexOf(paragraph) >= 0 &&\n                isEmptyParagraph(paragraph)\n            ) {\n                insertNewLine(mutateBlock(quote), parent, quoteBlockIndex, paragraph);\n                rawEvent?.preventDefault();\n                context.deleteResult = 'range';\n            }\n        }\n    }\n};\n\nconst isEmptyQuote = (quote: ReadonlyContentModelFormatContainer) => {\n    return (\n        quote.blocks.length === 1 &&\n        quote.blocks[0].blockType === 'Paragraph' &&\n        isEmptyParagraph(quote.blocks[0])\n    );\n};\n\nconst isEmptyParagraph = (paragraph: ReadonlyContentModelParagraph) => {\n    return paragraph.segments.every(\n        s => s.segmentType === 'SelectionMarker' || s.segmentType === 'Br'\n    );\n};\n\nconst insertNewLine = (\n    quote: ShallowMutableContentModelFormatContainer,\n    parent: ReadonlyContentModelBlockGroup,\n    quoteIndex: number,\n    paragraph: ShallowMutableContentModelParagraph\n) => {\n    const paraIndex = quote.blocks.indexOf(paragraph);\n\n    if (paraIndex >= 0) {\n        const mutableParent = mutateBlock(parent);\n\n        if (paraIndex < quote.blocks.length - 1) {\n            const newQuote: ShallowMutableContentModelFormatContainer = createFormatContainer(\n                quote.tagName,\n                quote.format\n            );\n\n            newQuote.blocks.push(\n                ...quote.blocks.splice(paraIndex + 1, quote.blocks.length - paraIndex - 1)\n            );\n\n            mutableParent.blocks.splice(quoteIndex + 1, 0, newQuote);\n        }\n\n        mutableParent.blocks.splice(quoteIndex + 1, 0, paragraph);\n        quote.blocks.splice(paraIndex, 1);\n\n        if (quote.blocks.length == 0) {\n            mutableParent.blocks.splice(quoteIndex, 0);\n        }\n    }\n};\n","import {\n    createListItem,\n    getClosestAncestorBlockGroupIndex,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DeleteSelectionStep,\n    ContentModelListItem,\n    ContentModelBlock,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const deleteList: DeleteSelectionStep = context => {\n    if (context.deleteResult != 'notDeleted') {\n        return;\n    }\n\n    const { paragraph, marker, path } = context.insertPoint;\n    const index = getClosestAncestorBlockGroupIndex<ContentModelListItem>(\n        path,\n        ['ListItem'],\n        ['TableCell', 'FormatContainer']\n    );\n    const item = path[index];\n    const parent = path[index + 1];\n\n    if (\n        item?.blockGroupType == 'ListItem' &&\n        item.levels.length > 0 &&\n        paragraph.segments[0] == marker &&\n        parent\n    ) {\n        const mutableList = mutateBlock(item);\n        const lastLevel = mutableList.levels[mutableList.levels.length - 1];\n        const listItemIndex = parent.blocks.indexOf(item);\n        const previousItem = parent.blocks[listItemIndex - 1];\n\n        // 1. If the last level is dummy, just remove it (legacy behavior)\n        // 2. If focus is at the beginning of list item and previous block is a list item with the same level count,\n        //    merge current list item into previous one\n        // 3. Otherwise, split the list item. Keep the blocks before the paragraph in the current list item,\n        //    move the rest to a new list item (if there are multiple levels) or directly to parent (if only one level)\n        if (lastLevel.format.displayForDummyItem == 'block') {\n            mutableList.levels.pop();\n\n            context.deleteResult = 'range';\n        } else if (\n            item.blocks[0] == paragraph &&\n            previousItem?.blockType == 'BlockGroup' &&\n            previousItem.blockGroupType == 'ListItem' &&\n            previousItem.levels.length == mutableList.levels.length\n        ) {\n            const mutablePreviousItem = mutateBlock(previousItem);\n\n            mutablePreviousItem.blocks.push(...mutableList.blocks);\n            mutateBlock(parent).blocks.splice(listItemIndex, 1);\n\n            context.deleteResult = 'range';\n        } else {\n            const removedBlocks = mutableList.blocks.splice(\n                mutableList.blocks.indexOf(paragraph),\n                mutableList.blocks.length\n            );\n\n            if (mutableList.levels.length > 1) {\n                const newListItem = createListItem(\n                    mutableList.levels.slice(0, -1),\n                    mutableList.formatHolder.format\n                );\n\n                newListItem.blocks = removedBlocks.map(\n                    block => mutateBlock(block) as ContentModelBlock\n                );\n\n                mutateBlock(parent).blocks.splice(listItemIndex + 1, 0, newListItem);\n            } else {\n                mutateBlock(parent).blocks.splice(listItemIndex + 1, 0, ...removedBlocks);\n            }\n\n            context.deleteResult = 'range';\n        }\n    }\n};\n","import { unwrapBlock } from 'roosterjs-content-model-dom';\nimport type { DeleteSelectionStep } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const deleteParagraphStyle: DeleteSelectionStep = context => {\n    if (context.deleteResult === 'nothingToDelete') {\n        const { insertPoint } = context;\n        const { paragraph, path } = insertPoint;\n        const group = path[0];\n        const parentGroup = path[1];\n\n        // If the paragraph is empty, we will delete any style in it\n        // This is to ensure the paragraph style is reset to default when there is no content in the paragraph\n        if (\n            paragraph.segments.every(\n                s => s.segmentType === 'SelectionMarker' || s.segmentType === 'Br'\n            ) &&\n            paragraph.segments.filter(s => s.segmentType === 'Br').length <= 1\n        ) {\n            if (Object.keys(paragraph.format).length > 0) {\n                paragraph.format = {};\n                context.deleteResult = 'range';\n            } else if (\n                group.blocks.length == 1 &&\n                group.blocks[0] == paragraph &&\n                parentGroup &&\n                (group.blockGroupType == 'FormatContainer' ||\n                    group.blockGroupType == 'ListItem' ||\n                    group.blockGroupType == 'General')\n            ) {\n                // Still has nothing to delete, try to unwrap parent container\n                unwrapBlock(parentGroup, group);\n\n                path.shift();\n                context.deleteResult = 'range';\n            }\n        }\n    }\n};\n","import {\n    isPunctuation,\n    isSpace,\n    isWhiteSpacePreserved,\n    mutateBlock,\n    normalizeText,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DeleteSelectionContext,\n    DeleteSelectionStep,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\nconst enum DeleteWordState {\n    Start,\n    Punctuation,\n    Text,\n    NonText,\n    Space,\n    End,\n}\n\ninterface CharInfo {\n    text: boolean;\n    space: boolean;\n    punctuation: boolean;\n}\n\nfunction getDeleteWordSelection(direction: 'forward' | 'backward'): DeleteSelectionStep {\n    return context => {\n        if (context.deleteResult != 'notDeleted') {\n            return;\n        }\n\n        const { marker, paragraph } = context.insertPoint;\n        const startIndex = paragraph.segments.indexOf(marker);\n        const deleteNext = direction == 'forward';\n\n        const iterator = iterateSegments(mutateBlock(paragraph), startIndex, deleteNext, context);\n        let curr = iterator.next();\n\n        for (let state = DeleteWordState.Start; state != DeleteWordState.End && !curr.done; ) {\n            const { punctuation, space, text } = curr.value;\n\n            // This is a state machine of how to delete a whole word together with space and punctuations.\n            // For a full state machine chart, see\n            // Forward delete: https://github.com/microsoft/roosterjs/blob/master/assets/design-charts/ForwardDeleteWord.png\n            // Backward delete: https://github.com/microsoft/roosterjs/blob/master/assets/design-charts/BackwardDeleteWord.png\n            switch (state) {\n                case DeleteWordState.Start:\n                    state = space\n                        ? DeleteWordState.Space\n                        : punctuation\n                        ? DeleteWordState.Punctuation\n                        : DeleteWordState.Text;\n                    curr = iterator.next(true /*delete*/);\n                    break;\n\n                case DeleteWordState.Punctuation:\n                    if (deleteNext && space) {\n                        state = DeleteWordState.NonText;\n                        curr = iterator.next(true /*delete*/);\n                    } else if (punctuation) {\n                        curr = iterator.next(true /*delete*/);\n                    } else {\n                        state = DeleteWordState.End;\n                    }\n                    break;\n\n                case DeleteWordState.Text:\n                    if (deleteNext && space) {\n                        state = DeleteWordState.NonText;\n                        curr = iterator.next(true /*delete*/);\n                    } else if (text) {\n                        curr = iterator.next(true /*delete*/);\n                    } else {\n                        state = DeleteWordState.End;\n                    }\n                    break;\n\n                case DeleteWordState.NonText:\n                    if (punctuation || !space) {\n                        state = DeleteWordState.End;\n                    } else {\n                        curr = iterator.next(true /*delete*/);\n                    }\n                    break;\n\n                case DeleteWordState.Space:\n                    if (space) {\n                        curr = iterator.next(true /*delete*/);\n                    } else if (punctuation) {\n                        state = deleteNext ? DeleteWordState.NonText : DeleteWordState.Punctuation;\n                        curr = iterator.next(true /*delete*/);\n                    } else {\n                        state = deleteNext ? DeleteWordState.End : DeleteWordState.Text;\n                    }\n                    break;\n            }\n        }\n    };\n}\n\nfunction* iterateSegments(\n    paragraph: ShallowMutableContentModelParagraph,\n    markerIndex: number,\n    forward: boolean,\n    context: DeleteSelectionContext\n): Generator<CharInfo, null, boolean> {\n    const step = forward ? 1 : -1;\n    const segments = paragraph.segments;\n    const preserveWhiteSpace = isWhiteSpacePreserved(paragraph.format.whiteSpace);\n\n    for (let i = markerIndex + step; i >= 0 && i < segments.length; i += step) {\n        const segment = segments[i];\n\n        switch (segment.segmentType) {\n            case 'Text':\n                for (\n                    let j = forward ? 0 : segment.text.length - 1;\n                    j >= 0 && j < segment.text.length;\n                    j += step\n                ) {\n                    const c = segment.text[j];\n                    const punctuation = isPunctuation(c);\n                    const space = isSpace(c);\n                    const text = !punctuation && !space;\n\n                    if (yield { punctuation, space, text }) {\n                        let newText = segment.text;\n\n                        newText = newText.substring(0, j) + newText.substring(j + 1);\n\n                        if (!preserveWhiteSpace) {\n                            newText = normalizeText(newText, forward);\n                        }\n\n                        context.deleteResult = 'range';\n\n                        if (newText) {\n                            segment.text = newText;\n\n                            if (step > 0) {\n                                j -= step;\n                            }\n                        } else {\n                            segments.splice(i, 1);\n\n                            if (step > 0) {\n                                i -= step;\n                            }\n\n                            break;\n                        }\n                    }\n                }\n                break;\n\n            case 'Image':\n                if (\n                    yield { punctuation: true, space: false, text: false } // Treat image as punctuation since they have the same behavior.\n                ) {\n                    segments.splice(i, 1);\n\n                    if (step > 0) {\n                        i -= step;\n                    }\n\n                    context.deleteResult = 'range';\n                }\n                break;\n\n            case 'SelectionMarker':\n                break;\n\n            default:\n                return null;\n        }\n    }\n\n    return null;\n}\n\n/**\n * @internal\n */\nexport const forwardDeleteWordSelection = getDeleteWordSelection('forward');\n\n/**\n * @internal\n */\nexport const backwardDeleteWordSelection = getDeleteWordSelection('backward');\n","import {\n    mutateBlock,\n    normalizeContentModel,\n    setParagraphNotImplicit,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DeleteResult,\n    FormatContentModelContext,\n    IEditor,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelDocument,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * @return True means content is changed, so need to rewrite content model to editor. Otherwise false\n */\nexport function handleKeyboardEventResult(\n    editor: IEditor,\n    model: ReadonlyContentModelDocument,\n    rawEvent: KeyboardEvent,\n    result: DeleteResult,\n    context: FormatContentModelContext\n): boolean {\n    context.skipUndoSnapshot = true;\n    context.clearModelCache = false;\n\n    switch (result) {\n        case 'notDeleted':\n            // We have not delete anything, we will let browser handle this event, so that current cached model may be invalid\n            context.clearModelCache = true;\n\n            // Return false here since we didn't do any change to Content Model, so no need to rewrite with Content Model\n            return false;\n\n        case 'nothingToDelete':\n            // We known there is nothing to delete, no need to let browser keep handling the event\n            rawEvent.preventDefault();\n            return false;\n\n        case 'range':\n        case 'singleChar':\n            // We have deleted what we need from content model, no need to let browser keep handling the event\n            rawEvent.preventDefault();\n            normalizeContentModel(model);\n            deleteEmptyBlockGroups(model);\n\n            if (result == 'range') {\n                // A range is about to be deleted, so add an undo snapshot immediately\n                context.skipUndoSnapshot = false;\n            }\n\n            // Trigger an event to let plugins know the content is about to be changed by Content Model keyboard editing.\n            // So plugins can do proper handling. e.g. UndoPlugin can decide whether take a snapshot before this change happens.\n            editor.triggerEvent('beforeKeyboardEditing', {\n                rawEvent,\n            });\n\n            return true;\n    }\n}\n\n/**\n * @internal\n */\nexport function shouldDeleteWord(rawEvent: KeyboardEvent, isMac: boolean) {\n    return (\n        (isMac && rawEvent.altKey && !rawEvent.metaKey) ||\n        (!isMac && rawEvent.ctrlKey && !rawEvent.altKey)\n    );\n}\n\n/**\n * @internal\n */\nexport function shouldDeleteAllSegmentsBefore(rawEvent: KeyboardEvent) {\n    return rawEvent.metaKey && !rawEvent.altKey;\n}\n\nfunction deleteEmptyBlockGroups(group: ReadonlyContentModelBlockGroup) {\n    let modified = false;\n\n    for (let i = group.blocks.length - 1; i >= 0; i--) {\n        const block = group.blocks[i];\n\n        if (block.blockType == 'BlockGroup') {\n            deleteEmptyBlockGroups(block);\n\n            if (block.blocks.length == 0) {\n                mutateBlock(group).blocks.splice(i, 1);\n                modified = true;\n            }\n        }\n    }\n\n    if (modified) {\n        group.blocks.forEach(setParagraphNotImplicit);\n    }\n}\n","import { promoteLink } from 'roosterjs-content-model-api';\nimport type { DeleteSelectionStep } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleAutoLink: DeleteSelectionStep = context => {\n    const { deleteResult, insertPoint } = context;\n\n    if (deleteResult == 'notDeleted' || deleteResult == 'nothingToDelete') {\n        const { marker, paragraph } = insertPoint;\n        const index = paragraph.segments.indexOf(marker);\n        const segBefore = index > 0 ? paragraph.segments[index - 1] : null;\n\n        if (\n            segBefore?.segmentType == 'Text' &&\n            promoteLink(segBefore, paragraph, {\n                autoLink: true,\n            }) &&\n            context.formatContext\n        ) {\n            context.formatContext.canUndoByBackspace = true;\n        }\n\n        // Do not set deleteResult here since we haven't really start a new paragraph, we need other delete step to keep working on it\n    }\n};\n","import { getListAnnounceData } from 'roosterjs-content-model-api';\nimport { splitParagraph } from '../utils/splitParagraph';\nimport {\n    copyFormat,\n    createListItem,\n    createListLevel,\n    getClosestAncestorBlockGroupIndex,\n    ListFormats,\n    mutateBlock,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlockFormat,\n    DeleteSelectionStep,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelListItem,\n    ShallowMutableContentModelListItem,\n    ValidDeleteSelectionContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleEnterOnList: DeleteSelectionStep = context => {\n    const { deleteResult, insertPoint } = context;\n\n    if (deleteResult == 'notDeleted' || deleteResult == 'nothingToDelete') {\n        const { path } = insertPoint;\n        const index = getClosestAncestorBlockGroupIndex(\n            path,\n            ['ListItem'],\n            ['TableCell', 'FormatContainer']\n        );\n\n        const readonlyListItem = path[index];\n        const listParent = path[index + 1];\n\n        if (readonlyListItem?.blockGroupType === 'ListItem' && listParent) {\n            let listItem = mutateBlock(readonlyListItem);\n\n            if (isEmptyListItem(listItem)) {\n                listItem.levels.pop();\n            } else {\n                listItem = createNewListItem(context, listItem, listParent);\n\n                if (context.formatContext) {\n                    context.formatContext.announceData = getListAnnounceData([\n                        listItem,\n                        ...path.slice(index + 1),\n                    ]);\n                }\n            }\n\n            context.deleteResult = 'range';\n        }\n    }\n};\n\nconst isEmptyListItem = (listItem: ReadonlyContentModelListItem) => {\n    return listItem.blocks.length === 1 && isEmptyParagraph(listItem.blocks[0]);\n};\n\nconst isEmptyParagraph = (block: ReadonlyContentModelBlock) => {\n    return (\n        block.blockType === 'Paragraph' &&\n        block.segments.length === 2 &&\n        block.segments[0].segmentType === 'SelectionMarker' &&\n        block.segments[1].segmentType === 'Br'\n    );\n};\n\nconst createNewListItem = (\n    context: ValidDeleteSelectionContext,\n    listItem: ReadonlyContentModelListItem,\n    listParent: ReadonlyContentModelBlockGroup\n) => {\n    const { insertPoint } = context;\n    const listIndex = listParent.blocks.indexOf(listItem);\n    const currentPara = insertPoint.paragraph;\n    const paraIndex = listItem.blocks.indexOf(currentPara);\n    const newParagraph = splitParagraph(insertPoint);\n\n    const levels = createNewListLevel(listItem);\n    const newListItem: ShallowMutableContentModelListItem = createListItem(\n        levels,\n        listItem.formatHolder.format\n    );\n\n    newListItem.blocks.push(newParagraph);\n\n    copyFormat<ContentModelBlockFormat>(newListItem.format, listItem.format, ListFormats);\n\n    const remainingBlockCount = listItem.blocks.length - paraIndex - 1;\n\n    if (paraIndex >= 0 && remainingBlockCount > 0) {\n        newListItem.blocks.push(\n            ...mutateBlock(listItem).blocks.splice(paraIndex + 1, remainingBlockCount)\n        );\n    }\n\n    insertPoint.paragraph = newParagraph;\n    mutateBlock(listParent).blocks.splice(listIndex + 1, 0, newListItem);\n\n    if (context.lastParagraph == currentPara) {\n        context.lastParagraph = newParagraph;\n    }\n\n    return newListItem;\n};\n\nconst createNewListLevel = (listItem: ReadonlyContentModelListItem) => {\n    return listItem.levels.map(level => {\n        return createListLevel(\n            level.listType,\n            {\n                ...level.format,\n                startNumberOverride: undefined,\n                displayForDummyItem: undefined, // When ENTER, we should create a new regular list item, so force its dummy item display to undefined\n            },\n            level.dataset\n        );\n    });\n};\n","import { mutateBlock } from 'roosterjs-content-model-dom';\nimport { splitParagraph } from '../utils/splitParagraph';\nimport type { DeleteSelectionStep } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleEnterOnParagraph: (\n    formatsToPreserveOnMerge: string[]\n) => DeleteSelectionStep = formatsToPreserveOnMerge => context => {\n    const { paragraph, path } = context.insertPoint;\n    const paraIndex = path[0]?.blocks.indexOf(paragraph) ?? -1;\n\n    if (context.deleteResult == 'notDeleted' && paraIndex >= 0) {\n        const newPara = splitParagraph(\n            context.insertPoint,\n            false /* removeImplicitParagraph */,\n            formatsToPreserveOnMerge\n        );\n\n        mutateBlock(path[0]).blocks.splice(paraIndex + 1, 0, newPara);\n\n        context.deleteResult = 'range';\n        context.lastParagraph = newPara;\n        context.insertPoint.paragraph = newPara;\n    }\n};\n","import { deleteAllSegmentBefore } from './deleteSteps/deleteAllSegmentBefore';\nimport { deleteEmptyQuote } from './deleteSteps/deleteEmptyQuote';\nimport { deleteList } from './deleteSteps/deleteList';\nimport { deleteParagraphStyle } from './deleteSteps/deleteParagraphStyle';\nimport { getDeleteCollapsedSelection } from './deleteSteps/deleteCollapsedSelection';\nimport {\n    ChangeSource,\n    deleteSelection,\n    isElementOfType,\n    isLinkUndeletable,\n    isModifierKey,\n    isNodeOfType,\n} from 'roosterjs-content-model-dom';\nimport {\n    handleKeyboardEventResult,\n    shouldDeleteAllSegmentsBefore,\n    shouldDeleteWord,\n} from './handleKeyboardEventCommon';\nimport {\n    backwardDeleteWordSelection,\n    forwardDeleteWordSelection,\n} from './deleteSteps/deleteWordSelection';\nimport type { DOMSelection, DeleteSelectionStep, IEditor } from 'roosterjs-content-model-types';\nimport type { EditOptions } from './EditOptions';\n\n/**\n * @internal\n * Do keyboard event handling for DELETE/BACKSPACE key\n * @param editor The editor object\n * @param rawEvent DOM keyboard event\n * @param handleExpandedSelection Whether to handle expanded selection within a text node by CM\n * @returns True if the event is handled by content model, otherwise false\n */\nexport function keyboardDelete(editor: IEditor, rawEvent: KeyboardEvent, options: EditOptions) {\n    let handled = false;\n    const selection = editor.getDOMSelection();\n    const { handleExpandedSelectionOnDelete } = options;\n\n    if (shouldDeleteWithContentModel(selection, rawEvent, !!handleExpandedSelectionOnDelete)) {\n        editor.formatContentModel(\n            (model, context) => {\n                const result = deleteSelection(\n                    model,\n                    getDeleteSteps(rawEvent, !!editor.getEnvironment().isMac, options),\n                    context\n                ).deleteResult;\n\n                handled = handleKeyboardEventResult(editor, model, rawEvent, result, context);\n                return handled;\n            },\n            {\n                rawEvent,\n                changeSource: ChangeSource.Keyboard,\n                getChangeData: () => rawEvent.which,\n                scrollCaretIntoView: true,\n                apiName: rawEvent.key == 'Delete' ? 'handleDeleteKey' : 'handleBackspaceKey',\n            }\n        );\n    }\n\n    return handled;\n}\n\nfunction getDeleteSteps(\n    rawEvent: KeyboardEvent,\n    isMac: boolean,\n    options: EditOptions\n): (DeleteSelectionStep | null)[] {\n    const isForward = rawEvent.key == 'Delete';\n    const deleteAllSegmentBeforeStep =\n        shouldDeleteAllSegmentsBefore(rawEvent) && !isForward ? deleteAllSegmentBefore : null;\n    const deleteWordSelection = shouldDeleteWord(rawEvent, isMac)\n        ? isForward\n            ? forwardDeleteWordSelection\n            : backwardDeleteWordSelection\n        : null;\n\n    const deleteCollapsedSelection = getDeleteCollapsedSelection(\n        isForward ? 'forward' : 'backward',\n        options\n    );\n\n    const deleteQuote = !isForward ? deleteEmptyQuote : null;\n    return [\n        deleteAllSegmentBeforeStep,\n        deleteWordSelection,\n        isForward ? null : deleteList,\n        deleteCollapsedSelection,\n        deleteQuote,\n        deleteParagraphStyle,\n    ];\n}\n\nfunction shouldDeleteWithContentModel(\n    selection: DOMSelection | null,\n    rawEvent: KeyboardEvent,\n    handleExpandedSelection: boolean\n) {\n    if (!selection) {\n        return false; // Nothing to delete\n    } else if (selection.type != 'range') {\n        return true;\n    } else if (!selection.range.collapsed) {\n        if (handleExpandedSelection) {\n            return true; // Selection is not collapsed, need to delete all selections\n        }\n\n        const range = selection.range;\n        const { startContainer, endContainer } = selection.range;\n        const isInSameTextNode =\n            startContainer === endContainer && isNodeOfType(startContainer, 'TEXT_NODE');\n        return !(\n            isInSameTextNode &&\n            !isModifierKey(rawEvent) &&\n            range.endOffset - range.startOffset < (startContainer.nodeValue?.length ?? 0)\n        );\n    } else {\n        const range = selection.range;\n        const startContainer = range.startContainer;\n        const startOffset = range.startOffset;\n\n        // When selection is collapsed and is in middle of text node, no need to use Content Model to delete\n        return !(\n            isNodeOfType(startContainer, 'TEXT_NODE') &&\n            !isModifierKey(rawEvent) &&\n            (canDeleteBefore(rawEvent, startContainer, startOffset) ||\n                canDeleteAfter(rawEvent, startContainer, startOffset))\n        );\n    }\n}\n\nfunction canDeleteBefore(rawEvent: KeyboardEvent, text: Text, offset: number) {\n    if (rawEvent.key != 'Backspace' || offset <= 1) {\n        return false;\n    }\n\n    const length = text.nodeValue?.length ?? 0;\n\n    if (offset == length) {\n        // At the end of text, need to check if next segment is deletable\n        const nextSibling = text.nextSibling;\n        const isNextSiblingUndeletable =\n            isNodeOfType(nextSibling, 'ELEMENT_NODE') &&\n            isElementOfType(nextSibling, 'a') &&\n            isLinkUndeletable(nextSibling) &&\n            !nextSibling.firstChild;\n\n        // If next sibling is undeletable, we cannot let browser handle it since it will remove the anchor\n        // So we return false here to let Content Model handle it\n        return !isNextSiblingUndeletable;\n    } else {\n        // In middle of text, we can safely let browser handle deletion\n        return true;\n    }\n}\n\nfunction canDeleteAfter(rawEvent: KeyboardEvent, text: Text, offset: number) {\n    return rawEvent.key == 'Delete' && offset < (text.nodeValue?.length ?? 0) - 1;\n}\n","import { deleteEmptyQuote } from './deleteSteps/deleteEmptyQuote';\nimport { handleAutoLink } from './inputSteps/handleAutoLink';\nimport { handleEnterOnList } from './inputSteps/handleEnterOnList';\nimport { handleEnterOnParagraph } from './inputSteps/handleEnterOnParagraph';\nimport {\n    ChangeSource,\n    deleteSelection,\n    normalizeContentModel,\n    runEditSteps,\n} from 'roosterjs-content-model-dom';\nimport type { IEditor, ReadonlyContentModelParagraph } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function keyboardEnter(\n    editor: IEditor,\n    rawEvent: KeyboardEvent,\n    handleNormalEnter: boolean,\n    formatsToPreserveOnMerge: string[] = []\n) {\n    const selection = editor.getDOMSelection();\n\n    editor.formatContentModel(\n        (model, context) => {\n            // 1. delete the expanded selection if any, then merge paragraph\n            const result = deleteSelection(model, [], context);\n\n            // 2. Add line break\n            if (selection && selection.type != 'table') {\n                // For ENTER key, although we may have deleted something, since we still need to split the line, we always treat it as not delete\n                // so further delete steps can keep working\n                result.deleteResult = 'notDeleted';\n\n                const steps = rawEvent.shiftKey\n                    ? []\n                    : [handleAutoLink, handleEnterOnList, deleteEmptyQuote];\n\n                if (handleNormalEnter || handleEnterForEntity(result.insertPoint?.paragraph)) {\n                    steps.push(handleEnterOnParagraph(formatsToPreserveOnMerge));\n                }\n\n                runEditSteps(steps, result);\n            }\n\n            if (result.deleteResult == 'range') {\n                // We have deleted something, next input should inherit the segment format from deleted content, so set pending format here\n                context.newPendingFormat = result.insertPoint?.marker.format;\n\n                normalizeContentModel(model);\n\n                rawEvent.preventDefault();\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            rawEvent,\n            scrollCaretIntoView: true,\n            changeSource: ChangeSource.Keyboard,\n            getChangeData: () => rawEvent.which,\n            apiName: 'handleEnterKey',\n        }\n    );\n}\n\nfunction handleEnterForEntity(paragraph: ReadonlyContentModelParagraph | undefined) {\n    return (\n        paragraph &&\n        (paragraph.isImplicit || paragraph.segments.some(x => x.segmentType == 'Entity'))\n    );\n}\n","import {\n    ChangeSource,\n    createText,\n    deleteSelection,\n    isModifierKey,\n    normalizeContentModel,\n} from 'roosterjs-content-model-dom';\nimport type { DeleteSelectionStep, DOMSelection, IEditor } from 'roosterjs-content-model-types';\n\n// Insert a ZeroWidthSpace(ZWS) segment with selection before selection marker\n// so that later browser will replace this selection with inputted text and keep format\nconst ZWS = '\\u200B';\nconst insertZWS: DeleteSelectionStep = context => {\n    if (context.deleteResult == 'range') {\n        const { marker, paragraph } = context.insertPoint;\n        const index = paragraph.segments.indexOf(marker);\n\n        if (index >= 0) {\n            const text = createText(ZWS, marker.format, marker.link, marker.code);\n\n            text.isSelected = true;\n\n            paragraph.segments.splice(index, 0, text);\n        }\n    }\n};\n\n/**\n * @internal\n */\nexport function keyboardInput(editor: IEditor, rawEvent: KeyboardEvent) {\n    const selection = editor.getDOMSelection();\n\n    if (shouldInputWithContentModel(selection, rawEvent)) {\n        editor.takeSnapshot();\n\n        editor.formatContentModel(\n            (model, context) => {\n                const result = deleteSelection(model, [insertZWS], context);\n\n                // Skip undo snapshot here and add undo snapshot before the operation so that we don't add another undo snapshot in middle of this replace operation\n                context.skipUndoSnapshot = true;\n\n                if (result.deleteResult == 'range') {\n                    // We have deleted something, next input should inherit the segment format from deleted content, so set pending format here\n                    context.newPendingFormat = result.insertPoint?.marker.format;\n\n                    normalizeContentModel(model);\n\n                    // Do not preventDefault since we still want browser to handle the final input for now\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            {\n                scrollCaretIntoView: true,\n                rawEvent,\n                changeSource: ChangeSource.Keyboard,\n                getChangeData: () => rawEvent.which,\n                apiName: 'handleInputKey',\n            }\n        );\n\n        return true;\n    }\n}\n\nfunction shouldInputWithContentModel(selection: DOMSelection | null, rawEvent: KeyboardEvent) {\n    if (!selection) {\n        return false; // Nothing to delete\n    } else if (\n        !isModifierKey(rawEvent) &&\n        rawEvent.key &&\n        (rawEvent.key == 'Space' || rawEvent.key.length == 1)\n    ) {\n        return selection.type != 'range' || !selection.range.collapsed;\n    } else {\n        return false;\n    }\n}\n","import { handleTabOnList } from './tabUtils/handleTabOnList';\nimport { handleTabOnParagraph } from './tabUtils/handleTabOnParagraph';\nimport { handleTabOnTable } from './tabUtils/handleTabOnTable';\nimport { handleTabOnTableCell } from './tabUtils/handleTabOnTableCell';\nimport { setModelIndentation } from 'roosterjs-content-model-api';\nimport type { HandleTabOptions } from './EditOptions';\nimport {\n    ChangeSource,\n    getOperationalBlocks,\n    isBlockGroupOfType,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelListItem,\n    ContentModelTableCell,\n    FormatContentModelContext,\n    IEditor,\n    ReadonlyContentModelDocument,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function keyboardTab(\n    editor: IEditor,\n    rawEvent: KeyboardEvent,\n    options: Required<HandleTabOptions>\n) {\n    const selection = editor.getDOMSelection();\n\n    switch (selection?.type) {\n        case 'range':\n            editor.formatContentModel(\n                (model, context) => {\n                    return handleTab(model, rawEvent, context, options);\n                },\n                {\n                    apiName: 'handleTabKey',\n                    rawEvent,\n                    changeSource: ChangeSource.Keyboard,\n                    getChangeData: () => rawEvent.which,\n                }\n            );\n            break;\n\n        case 'table':\n            if (options.indentTable) {\n                editor.formatContentModel(\n                    model => {\n                        return handleTabOnTable(model, rawEvent);\n                    },\n                    {\n                        apiName: 'handleTabKey',\n                        rawEvent,\n                        changeSource: ChangeSource.Keyboard,\n                        getChangeData: () => rawEvent.which,\n                    }\n                );\n            }\n            break;\n    }\n}\n\n/**\n * If multiple blocks are selected, indent or outdent the selected blocks with setModelIndentation.\n * If only one block is selected:\n * - If it is a table cell, call handleTabOnTableCell to handle the tab key.\n * - If it is a paragraph, call handleTabOnParagraph to handle the tab key.\n * - If it is a list item, call handleTabOnList to handle the tab key.\n */\nfunction handleTab(\n    model: ReadonlyContentModelDocument,\n    rawEvent: KeyboardEvent,\n    context: FormatContentModelContext,\n    options: Required<HandleTabOptions>\n) {\n    const blocks = getOperationalBlocks<ContentModelListItem | ContentModelTableCell>(\n        model,\n        ['ListItem', 'TableCell'],\n        []\n    );\n    const block = blocks.length > 0 ? blocks[0].block : undefined;\n\n    if (blocks.length > 1) {\n        if (options.indentMultipleBlocks) {\n            setModelIndentation(model, rawEvent.shiftKey ? 'outdent' : 'indent');\n            rawEvent.preventDefault();\n            return true;\n        }\n    } else if (isBlockGroupOfType<ContentModelTableCell>(block, 'TableCell')) {\n        if (options.appendTableRow) {\n            return handleTabOnTableCell(model, block, rawEvent);\n        }\n    } else if (block?.blockType === 'Paragraph') {\n        if (options.indentParagraph) {\n            return handleTabOnParagraph(model, block, rawEvent, context);\n        }\n    } else if (isBlockGroupOfType<ContentModelListItem>(block, 'ListItem')) {\n        if (options.indentList) {\n            return handleTabOnList(model, block, rawEvent, context);\n        }\n    }\n    return false;\n}\n","import { handleTabOnParagraph } from './handleTabOnParagraph';\nimport { setModelIndentation } from 'roosterjs-content-model-api';\nimport type {\n    FormatContentModelContext,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * 1. When the selection is collapsed and the cursor is at start of a list item, call setModelIndentation.\n * 2. Otherwise call handleTabOnParagraph.\n * @internal\n */\nexport function handleTabOnList(\n    model: ReadonlyContentModelDocument,\n    listItem: ReadonlyContentModelListItem,\n    rawEvent: KeyboardEvent,\n    context?: FormatContentModelContext\n) {\n    const selectedParagraph = findSelectedParagraph(listItem);\n    if (\n        !isMarkerAtStartOfBlock(listItem) &&\n        selectedParagraph.length == 1 &&\n        selectedParagraph[0].blockType === 'Paragraph'\n    ) {\n        return handleTabOnParagraph(model, selectedParagraph[0], rawEvent, context);\n    } else {\n        setModelIndentation(\n            model,\n            rawEvent.shiftKey ? 'outdent' : 'indent',\n            undefined /*length*/,\n            context\n        );\n        rawEvent.preventDefault();\n\n        return true;\n    }\n}\n\nfunction isMarkerAtStartOfBlock(listItem: ReadonlyContentModelListItem) {\n    return (\n        listItem.blocks[0].blockType == 'Paragraph' &&\n        listItem.blocks[0].segments[0].segmentType == 'SelectionMarker'\n    );\n}\n\nfunction findSelectedParagraph(listItem: ReadonlyContentModelListItem) {\n    return listItem.blocks.filter(\n        block =>\n            block.blockType == 'Paragraph' && block.segments.some(segment => segment.isSelected)\n    );\n}\n","import { setModelIndentation } from 'roosterjs-content-model-api';\nimport {\n    createSelectionMarker,\n    createText,\n    mutateBlock,\n    mutateSegment,\n} from 'roosterjs-content-model-dom';\nimport type {\n    FormatContentModelContext,\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\nconst tabSpaces = '';\nconst space = '';\n\n/**\n * @internal\n The handleTabOnParagraph function will handle the tab key in following scenarios:\n * 1. When the selection is collapsed and the cursor is at the end of a paragraph, add 4 spaces.\n * 2. When the selection is collapsed and the cursor is at the start of a paragraph, add 4 spaces.\n * 3. When the selection is collapsed and the cursor is at the middle of a paragraph, add 4 spaces.\n * 4. When the selection is not collapsed, replace the selected range with a single space.\n * 5. When the selection is not collapsed, but all segments are selected, call setModelIndention function to indent the whole paragraph\n The handleTabOnParagraph function will handle the shift + tab key in a indented paragraph in following scenarios:\n * 1. When the selection is collapsed and the cursor is at the end of a paragraph, remove 4 spaces.\n * 2. When the selection is collapsed and the cursor is at the start of a paragraph, call setModelIndention function to outdent the whole paragraph\n * 3. When the selection is collapsed and the cursor is at the middle of a paragraph, remove 4 spaces.\n * 4. When the selection is not collapsed, replace the selected range with a 4 space.\n * 5. When the selection is not collapsed, but all segments are selected, call setModelIndention function to outdent the whole paragraph\n */\nexport function handleTabOnParagraph(\n    model: ReadonlyContentModelDocument,\n    paragraph: ReadonlyContentModelParagraph,\n    rawEvent: KeyboardEvent,\n    context?: FormatContentModelContext\n) {\n    const selectedSegments = paragraph.segments.filter(segment => segment.isSelected);\n    const isCollapsed =\n        selectedSegments.length === 1 && selectedSegments[0].segmentType === 'SelectionMarker';\n    const isAllSelected = paragraph.segments.every(\n        segment =>\n            segment.isSelected || (segment.segmentType == 'Text' && segment.text.trim().length == 0)\n    );\n    if (isAllSelected) {\n        const { marginLeft, marginRight, direction } = paragraph.format;\n        const isRtl = direction === 'rtl';\n        if (\n            rawEvent.shiftKey &&\n            ((!isRtl && (!marginLeft || marginLeft == '0px')) ||\n                (isRtl && (!marginRight || marginRight == '0px')))\n        ) {\n            return false;\n        }\n        setModelIndentation(\n            model,\n            rawEvent.shiftKey ? 'outdent' : 'indent',\n            undefined /*length*/,\n            context\n        );\n    } else {\n        if (!isCollapsed) {\n            let firstSelectedSegmentIndex: number | undefined = undefined;\n            let lastSelectedSegmentIndex: number | undefined = undefined;\n\n            paragraph.segments.forEach((segment, index) => {\n                if (segment.isSelected) {\n                    if (!firstSelectedSegmentIndex) {\n                        firstSelectedSegmentIndex = index;\n                    }\n                    lastSelectedSegmentIndex = index;\n                }\n            });\n            if (firstSelectedSegmentIndex && lastSelectedSegmentIndex) {\n                const firstSelectedSegment = paragraph.segments[firstSelectedSegmentIndex];\n                const spaceText = createText(\n                    rawEvent.shiftKey ? tabSpaces : space,\n                    firstSelectedSegment.format\n                );\n                const marker = createSelectionMarker(firstSelectedSegment.format);\n\n                mutateBlock(paragraph).segments.splice(\n                    firstSelectedSegmentIndex,\n                    lastSelectedSegmentIndex - firstSelectedSegmentIndex + 1,\n                    spaceText,\n                    marker\n                );\n            } else {\n                return false;\n            }\n        } else {\n            const markerIndex = paragraph.segments.findIndex(\n                segment => segment.segmentType === 'SelectionMarker'\n            );\n\n            if (!rawEvent.shiftKey) {\n                const markerFormat = paragraph.segments[markerIndex].format;\n                const tabText = createText(tabSpaces, markerFormat);\n\n                mutateBlock(paragraph).segments.splice(markerIndex, 0, tabText);\n            } else {\n                if (markerIndex <= 0) {\n                    return false;\n                }\n                const tabText = paragraph.segments[markerIndex - 1];\n                const tabSpacesLength = tabSpaces.length;\n\n                if (tabText.segmentType == 'Text') {\n                    const tabSpaceTextLength = tabText.text.length - tabSpacesLength;\n\n                    if (tabText.text === tabSpaces) {\n                        mutateBlock(paragraph).segments.splice(markerIndex - 1, 1);\n                    } else if (tabText.text.substring(tabSpaceTextLength) === tabSpaces) {\n                        mutateSegment(paragraph, tabText, text => {\n                            text.text = text.text.substring(0, tabSpaceTextLength);\n                        });\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    rawEvent.preventDefault();\n    return true;\n}\n","import { getFirstSelectedTable } from 'roosterjs-content-model-dom';\nimport { setModelIndentation } from 'roosterjs-content-model-api';\nimport type {\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelTable,\n} from 'roosterjs-content-model-types';\n\n/**\n * When the whole table is selected, indent or outdent the whole table with setModelIndentation.\n * @internal\n */\nexport function handleTabOnTable(model: ReadonlyContentModelDocument, rawEvent: KeyboardEvent) {\n    const tableModel = getFirstSelectedTable(model)[0];\n    if (tableModel && isWholeTableSelected(tableModel)) {\n        setModelIndentation(model, rawEvent.shiftKey ? 'outdent' : 'indent');\n        rawEvent.preventDefault();\n        return true;\n    }\n    return false;\n}\n\nfunction isWholeTableSelected(tableModel: ReadonlyContentModelTable) {\n    const lastRow = tableModel.rows[tableModel.rows.length - 1];\n    const lastCell = lastRow?.cells[lastRow.cells.length - 1];\n\n    return tableModel.rows[0]?.cells[0]?.isSelected && lastCell?.isSelected;\n}\n","import { clearSelectedCells, insertTableRow } from 'roosterjs-content-model-api';\nimport {\n    createSelectionMarker,\n    getFirstSelectedTable,\n    mutateBlock,\n    normalizeTable,\n    setParagraphNotImplicit,\n    setSelection,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ReadonlyContentModelDocument,\n    ReadonlyContentModelTableCell,\n} from 'roosterjs-content-model-types';\n\n/**\n * When the cursor is on the last cell of a table, add new row and focus first new cell.\n * @internal\n */\nexport function handleTabOnTableCell(\n    model: ReadonlyContentModelDocument,\n    cell: ReadonlyContentModelTableCell,\n    rawEvent: KeyboardEvent\n) {\n    const readonlyTableModel = getFirstSelectedTable(model)[0];\n\n    if (readonlyTableModel) {\n        // Check if cursor is on last cell of the table\n        const lastRow = readonlyTableModel.rows[readonlyTableModel.rows.length - 1];\n        const lastColumn = lastRow ? lastRow.cells.length - 1 : -1;\n        const lastCell = lastRow?.cells[lastColumn];\n\n        if (!rawEvent.shiftKey && lastCell && lastCell === cell) {\n            const tableModel = mutateBlock(readonlyTableModel);\n            insertTableRow(tableModel, 'insertBelow');\n\n            // Clear Table selection\n            clearSelectedCells(tableModel, {\n                firstRow: tableModel.rows.length - 1,\n                firstColumn: 0,\n                lastRow: tableModel.rows.length - 1,\n                lastColumn: lastColumn,\n            });\n            normalizeTable(tableModel, model.format);\n\n            // Add selection marker to the first cell of the new row\n            const markerParagraph =\n                tableModel.rows[tableModel.rows.length - 1]?.cells[0]?.blocks[0];\n            if (markerParagraph.blockType == 'Paragraph') {\n                const marker = createSelectionMarker(model.format);\n\n                mutateBlock(markerParagraph).segments.unshift(marker);\n                setParagraphNotImplicit(markerParagraph);\n                setSelection(tableModel.rows[tableModel.rows.length - 1].cells[0], marker);\n            }\n\n            rawEvent.preventDefault();\n            return true;\n        }\n    }\n\n    return false;\n}\n","import { isGeneralSegment } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelParagraph,\n    ReadonlyContentModelBlock,\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport type BlockAndPath = {\n    /**\n     * The sibling block\n     */\n    block: ReadonlyContentModelBlock;\n\n    /**\n     * Path of this sibling block\n     */\n    path: ReadonlyContentModelBlockGroup[];\n\n    /**\n     * If the input block is under a general segment, it is possible there are sibling segments under the same paragraph.\n     * Use this property to return the sibling sibling under the same paragraph\n     */\n    siblingSegment?: ReadonlyContentModelSegment;\n};\n\n/**\n * @internal\n */\nexport type ReadonlyBlockAndPath = {\n    /**\n     * The sibling block\n     */\n    block: ReadonlyContentModelBlock;\n\n    /**\n     * Path of this sibling block\n     */\n    path: ReadonlyContentModelBlockGroup[];\n\n    /**\n     * If the input block is under a general segment, it is possible there are sibling segments under the same paragraph.\n     * Use this property to return the sibling sibling under the same paragraph\n     */\n    siblingSegment?: ReadonlyContentModelSegment;\n};\n\n/**\n * @internal\n */\nexport function getLeafSiblingBlock(\n    path: ReadonlyContentModelBlockGroup[],\n    block: ReadonlyContentModelBlock,\n    isNext: boolean\n): BlockAndPath | null;\n\n/**\n * @internal (Readonly)\n */\nexport function getLeafSiblingBlock(\n    path: ReadonlyContentModelBlockGroup[],\n    block: ReadonlyContentModelBlock,\n    isNext: boolean\n): ReadonlyBlockAndPath | null;\n\nexport function getLeafSiblingBlock(\n    path: ReadonlyContentModelBlockGroup[],\n    block: ReadonlyContentModelBlock,\n    isNext: boolean\n): ReadonlyBlockAndPath | null {\n    const newPath = [...path];\n\n    while (newPath.length > 0) {\n        const group = newPath[0];\n        const index = group.blocks.indexOf(block);\n\n        if (index < 0) {\n            break;\n        }\n\n        let nextBlock = group.blocks[index + (isNext ? 1 : -1)];\n\n        if (nextBlock) {\n            while (nextBlock.blockType == 'BlockGroup') {\n                const child = nextBlock.blocks[isNext ? 0 : nextBlock.blocks.length - 1];\n\n                if (!child) {\n                    return { block: nextBlock, path: newPath };\n                } else if (child.blockType != 'BlockGroup') {\n                    newPath.unshift(nextBlock);\n                    return { block: child, path: newPath };\n                } else {\n                    newPath.unshift(nextBlock);\n                    nextBlock = child;\n                }\n            }\n\n            return { block: nextBlock, path: newPath };\n        } else if (isGeneralSegment(group)) {\n            // For general segment, we need to check if there is sibling segment under the same paragraph\n            // First let's find the parent paragraph of this segment\n            newPath.shift();\n\n            let segmentIndex = -1;\n            const segment = group;\n            const para = newPath[0]?.blocks.find(\n                x => x.blockType == 'Paragraph' && (segmentIndex = x.segments.indexOf(segment)) >= 0\n            ) as ContentModelParagraph;\n\n            if (para) {\n                // Now we have found the parent paragraph, so let's check if it has a sibling segment\n                const siblingSegment = para.segments[segmentIndex + (isNext ? 1 : -1)];\n\n                if (siblingSegment) {\n                    // Return this block, path and segment since we have found it\n                    return { block: para, path: newPath, siblingSegment };\n                } else {\n                    // No sibling segment, let's keep go upper level\n                    block = para;\n                }\n            } else {\n                // Parent sibling is not found (in theory this should never happen), just return null\n                break;\n            }\n        } else if (group.blockGroupType != 'Document' && group.blockGroupType != 'TableCell') {\n            newPath.shift();\n            block = group;\n        } else {\n            break;\n        }\n    }\n\n    return null;\n}\n","import type { ShallowMutableContentModelParagraph } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Preserve specific paragraph format properties from source paragraph to target paragraph\n * @param formatsToPreserveOnMerge Array of format property names to preserve\n * @param paragraph Source paragraph to copy format from\n * @param newParagraph Target paragraph to copy format to\n */\nexport function preserveParagraphFormat(\n    formatsToPreserveOnMerge: string[] | undefined,\n    paragraph: ShallowMutableContentModelParagraph,\n    newParagraph: ShallowMutableContentModelParagraph\n) {\n    if (formatsToPreserveOnMerge && formatsToPreserveOnMerge.length) {\n        const format = paragraph.format as { [key: string]: string };\n        const newFormat = newParagraph.format as { [key: string]: string };\n        formatsToPreserveOnMerge.forEach(key => {\n            const formatValue = format[key];\n\n            if (formatValue !== undefined) {\n                newFormat[key] = formatValue;\n            }\n        });\n    }\n}\n","import { preserveParagraphFormat } from './preserveParagraphFormat';\nimport {\n    copyFormat,\n    createBr,\n    createParagraph,\n    normalizeParagraph,\n    ParagraphFormats,\n    setParagraphNotImplicit,\n} from 'roosterjs-content-model-dom';\nimport type {\n    InsertPoint,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Split the given paragraph from insert point into two paragraphs,\n * and move the selection marker to the beginning of the second paragraph\n * @param insertPoint The input insert point which includes the paragraph and selection marker\n * @param removeImplicitParagraph Whether to remove the implicit paragraph if it becomes empty after split\n * * If set to false, the implicit paragraph will be preserved even if it becomes empty\n * * If set to true, the implicit paragraph will be removed if it becomes empty\n * @returns The new paragraph it created\n */\nexport function splitParagraph(\n    insertPoint: InsertPoint,\n    removeImplicitParagraph: boolean = true,\n    formatsToPreserveOnMerge: string[] = []\n): ShallowMutableContentModelParagraph {\n    const { paragraph, marker } = insertPoint;\n    const newParagraph: ShallowMutableContentModelParagraph = createParagraph(\n        false /*isImplicit*/,\n        {},\n        paragraph.segmentFormat\n    );\n\n    copyFormat(newParagraph.format, paragraph.format, ParagraphFormats);\n    preserveParagraphFormat(formatsToPreserveOnMerge, paragraph, newParagraph);\n\n    const markerIndex = paragraph.segments.indexOf(marker);\n    const segments = paragraph.segments.splice(\n        markerIndex,\n        paragraph.segments.length - markerIndex\n    );\n\n    newParagraph.segments.push(...segments);\n\n    const isEmptyParagraph = paragraph.segments.length == 0;\n    const shouldPreserveImplicitParagraph = !paragraph.isImplicit || !removeImplicitParagraph;\n\n    if (isEmptyParagraph && shouldPreserveImplicitParagraph) {\n        paragraph.segments.push(createBr(marker.format));\n    } else if (!isEmptyParagraph) {\n        setParagraphNotImplicit(paragraph);\n    }\n\n    insertPoint.paragraph = newParagraph;\n\n    normalizeParagraph(paragraph);\n\n    return newParagraph;\n}\n","import { ChangeSource } from 'roosterjs-content-model-dom';\nimport { updateHighlight } from './utils/updateHighlight';\nimport type { FindReplaceHighlightOptions } from './types/FindReplaceHighlightOptions';\nimport {\n    FindHighlightRuleKey,\n    FindHighlightSelector,\n    ReplaceHighlightRuleKey,\n    ReplaceHighlightSelector,\n} from './utils/constants';\nimport type { EditorPlugin, IEditor, PluginEvent } from 'roosterjs-content-model-types';\nimport type { FindReplaceContext } from './types/FindReplaceContext';\n\nconst DefaultFindHighlightStyle = 'background-color: yellow;';\nconst DefaultReplaceHighlightStyle = 'background-color: orange;';\n\n/**\n * Plugin for finding and replacing text in the editor, maintain the highlights for found and replaced text\n */\nexport class FindReplacePlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private findHighlightStyle: string;\n    private replaceHighlightStyle: string;\n\n    /**\n     * Creates a FindReplacePlugin instance\n     * @param context FindReplaceContext to use. It will be disposed when plugin is being disposed.\n     * @param options Options for highlighting styles\n     */\n    constructor(private context: FindReplaceContext, options?: FindReplaceHighlightOptions) {\n        this.findHighlightStyle = options?.findHighlightStyle ?? DefaultFindHighlightStyle;\n        this.replaceHighlightStyle = options?.replaceHighlightStyle ?? DefaultReplaceHighlightStyle;\n    }\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'FindReplace';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        const win = editor.getDocument().defaultView;\n\n        if (win) {\n            this.context.findHighlight.initialize(win);\n            this.context.replaceHighlight.initialize(win);\n        }\n\n        this.editor.setEditorStyle(FindHighlightRuleKey, this.findHighlightStyle, [\n            FindHighlightSelector,\n        ]);\n        this.editor.setEditorStyle(ReplaceHighlightRuleKey, this.replaceHighlightStyle, [\n            ReplaceHighlightSelector,\n        ]);\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.context.findHighlight.dispose();\n        this.context.replaceHighlight.dispose();\n\n        if (this.editor) {\n            this.editor.setEditorStyle(FindHighlightRuleKey, null /*cssRule*/);\n            this.editor.setEditorStyle(ReplaceHighlightRuleKey, null /*cssRule*/);\n\n            this.editor = null;\n        }\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.context.text || !this.editor) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case 'input':\n                const selection = this.editor.getDOMSelection();\n\n                if (selection?.type == 'range') {\n                    const block = this.editor\n                        .getDOMHelper()\n                        .findClosestBlockElement(selection.range.startContainer);\n\n                    updateHighlight(this.editor, this.context, [block], [block]);\n                }\n\n                break;\n            case 'contentChanged':\n                if (!event.contentModel && event.source != ChangeSource.Replace) {\n                    updateHighlight(this.editor, this.context);\n                }\n\n                break;\n\n            case 'rewriteFromModel':\n                updateHighlight(\n                    this.editor,\n                    this.context,\n                    event.addedBlockElements,\n                    event.removedBlockElements\n                );\n\n                break;\n        }\n    }\n}\n","import { createHighlightHelper } from './utils/HighlightHelperImpl';\nimport { FindHighlightStyleKey, ReplaceHighlightStyleKey, ScrollMargin } from './utils/constants';\nimport type { FindReplaceContext } from './types/FindReplaceContext';\n\n/**\n * Creates a FindReplaceContext object with default values\n * @param win The window object\n * @param scrollMargin Margin size (in pixels) when scrolling to a highlighted item\n * @returns\n */\nexport function createFindReplaceContext(scrollMargin: number = ScrollMargin): FindReplaceContext {\n    return {\n        text: null,\n        matchCase: false,\n        wholeWord: false,\n        ranges: [],\n        markedIndex: -1,\n        scrollMargin,\n        findHighlight: createHighlightHelper(FindHighlightStyleKey),\n        replaceHighlight: createHighlightHelper(ReplaceHighlightStyleKey),\n    };\n}\n","import { updateHighlight } from './utils/updateHighlight';\nimport type { FindReplaceContext } from './types/FindReplaceContext';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * Start a find operation in the editor\n * @param editor The editor instance\n * @param context The FindReplaceContext to use\n * @param text The text to find\n * @param matchCase Whether to match case\n * @param wholeWord Whether to match whole words only\n */\nexport function find(\n    editor: IEditor,\n    context: FindReplaceContext,\n    text: string | null,\n    matchCase?: boolean,\n    wholeWord?: boolean\n): void {\n    context.text = text;\n    context.matchCase = !!matchCase;\n    context.wholeWord = !!wholeWord;\n\n    updateHighlight(editor, context);\n}\n","import { setMarkedIndex } from './utils/setMarkedIndex';\nimport type { IEditor } from 'roosterjs-content-model-types';\nimport type { FindReplaceContext } from './types/FindReplaceContext';\n\n/**\n * Move the highlight to next or previous match\n * @param editor The editor instance\n * @param context The FindReplaceContext to use\n * @param forward Whether to move forward or backward\n */\nexport function moveHighlight(editor: IEditor, context: FindReplaceContext, forward: boolean) {\n    if (context.ranges.length > 0) {\n        const newIndex =\n            !forward && context.markedIndex == -1\n                ? context.ranges.length - 1\n                : (context.markedIndex + (forward ? 1 : -1) + context.ranges.length) %\n                  context.ranges.length;\n\n        setMarkedIndex(editor, context, newIndex);\n    }\n}\n","import { ChangeSource } from 'roosterjs-content-model-dom';\nimport { replaceTextInRange } from './utils/replaceTextInRange';\nimport { setMarkedIndex } from './utils/setMarkedIndex';\nimport type { IEditor } from 'roosterjs-content-model-types';\nimport type { FindReplaceContext } from './types/FindReplaceContext';\n\n/**\n * Replace the currently found item or all found items in the editor\n * @param editor The editor instance\n * @param context The FindReplaceContext to use\n * @param replaceText The text to replace with\n * @param replaceAll Whether to replace all found items\n */\nexport function replace(\n    editor: IEditor,\n    context: FindReplaceContext,\n    replaceText: string,\n    replaceAll: boolean = false\n): void {\n    if (context.text) {\n        editor.takeSnapshot();\n        let isReplaced = false;\n\n        do {\n            const range = context.ranges[context.markedIndex];\n\n            if (!range || !editor.getDOMHelper().isNodeInEditor(range.startContainer)) {\n                setMarkedIndex(editor, context, 0);\n            } else {\n                const resultRange = replaceTextInRange(range, replaceText, context.ranges);\n\n                context.ranges.splice(context.markedIndex, 1);\n                setMarkedIndex(\n                    editor,\n                    context,\n                    context.markedIndex >= context.ranges.length ? 0 : context.markedIndex,\n                    resultRange\n                );\n\n                isReplaced = true;\n            }\n        } while (replaceAll && context.ranges[context.markedIndex]);\n\n        context.findHighlight.clear();\n\n        if (context.ranges.length > 0) {\n            context.findHighlight.addRanges(context.ranges);\n        }\n\n        if (isReplaced) {\n            editor.takeSnapshot();\n            editor.triggerEvent('contentChanged', {\n                data: replaceText,\n                source: ChangeSource.Replace,\n            });\n        }\n    } else {\n        setMarkedIndex(editor, context, -1);\n    }\n}\n","import type { HighlightHelper } from '../types/HighlightHelper';\n\ninterface HighlightRegistry {}\n\ninterface CSSShim {\n    highlights: HighlightRegistry;\n}\n\ndeclare class Highlight {\n    constructor(...textRange: Range[]);\n    clear: () => void;\n    add: (range: Range) => void;\n}\n\ninterface WindowWithHighlight extends Window {\n    Highlight: typeof Highlight;\n    CSS: CSSShim;\n}\n\ninterface HighlightRegistryWithMap extends HighlightRegistry {\n    set(name: string, highlight: Highlight): void;\n    delete(name: string): void;\n}\n\nfunction isWindowWithHighlight(win: Window): win is WindowWithHighlight {\n    return (\n        typeof (win as WindowWithHighlight).Highlight === 'function' &&\n        typeof (win as WindowWithHighlight).CSS === 'object'\n    );\n}\n\nfunction isHighlightRegistryWithMap(\n    highlight: HighlightRegistry\n): highlight is HighlightRegistryWithMap {\n    return typeof (highlight as HighlightRegistryWithMap).set === 'function';\n}\n\nclass HighlightHelperImpl implements HighlightHelper {\n    private highlight: Highlight | undefined;\n    private highlights: HighlightRegistryWithMap | undefined;\n\n    constructor(private styleKey: string) {}\n\n    initialize(win: Window) {\n        if (isWindowWithHighlight(win) && isHighlightRegistryWithMap(win.CSS.highlights)) {\n            this.highlights = win.CSS.highlights;\n            this.highlight = new win.Highlight();\n\n            this.highlights.set(this.styleKey, this.highlight);\n        }\n    }\n\n    dispose() {\n        this.highlights?.delete(this.styleKey);\n        this.highlight?.clear();\n        this.highlight = undefined;\n        this.highlights = undefined;\n    }\n\n    addRanges(ranges: Range[]) {\n        if (this.highlight) {\n            for (const range of ranges) {\n                this.highlight.add(range);\n            }\n        }\n    }\n\n    clear() {\n        this.highlight?.clear();\n    }\n}\n\n/**\n * @internal\n * Create a HighlightHelper instance. A highlight helper manages the highlights in the editor\n * @param win The window object\n * @param styleKey The style key for the highlight\n * @returns The created HighlightHelper instance or undefined if the window does not support highlights\n */\nexport function createHighlightHelper(styleKey: string): HighlightHelper {\n    return new HighlightHelperImpl(styleKey);\n}\n","/**\n * @internal\n */\nexport const FindHighlightRuleKey = '_RoosterjsFindHighlight';\n\n/**\n * @internal\n */\nexport const FindHighlightStyleKey = 'roostersFindHighlight';\n\n/**\n * @internal\n */\nexport const FindHighlightSelector = `::highlight(${FindHighlightStyleKey})`;\n\n/**\n * @internal\n */\nexport const ReplaceHighlightRuleKey = '_RoosterjsReplaceHighlight';\n\n/**\n * @internal\n */\nexport const ReplaceHighlightStyleKey = 'roostersReplaceHighlight';\n\n/**\n * @internal\n */\nexport const ReplaceHighlightSelector = `::highlight(${ReplaceHighlightStyleKey})`;\n\n/**\n * @internal\n */\nexport const ScrollMargin = 20;\n","import { getObjectKeys, isNodeOfType } from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n */\nexport function replaceTextInRange(\n    range: Range,\n    replaceText: string,\n    foundRanges: Range[]\n): Range | null {\n    if (\n        !isNodeOfType(range.startContainer, 'TEXT_NODE') ||\n        !isNodeOfType(range.endContainer, 'TEXT_NODE')\n    ) {\n        return null;\n    }\n\n    const textNode = range.startContainer;\n    const resultContainer = range.startContainer;\n    const resultOffset = range.startOffset + replaceText.length;\n\n    const originalText = textNode.textContent || '';\n    const newText =\n        originalText.substring(0, range.startOffset) +\n        replaceText +\n        (range.endContainer == range.startContainer\n            ? originalText.substring(range.endOffset, textNode.textContent?.length)\n            : '');\n    const pendingRanges: Record<\n        number,\n        {\n            startContainer: Node;\n            startOffset: number;\n            endContainer: Node;\n            endOffset: number;\n        }\n    > = {};\n\n    for (let i = 0; i < foundRanges.length; i++) {\n        const r = foundRanges[i];\n\n        if (r.startContainer == range.endContainer && r.startOffset >= range.endOffset) {\n            const startOffset =\n                range.startContainer == range.endContainer\n                    ? r.startOffset - range.endOffset + range.startOffset + replaceText.length\n                    : r.startOffset - range.endOffset;\n            const endOffset =\n                r.startContainer == r.endContainer\n                    ? startOffset + (r.endOffset - r.startOffset)\n                    : r.endOffset;\n\n            pendingRanges[i] = {\n                startContainer: r.startContainer,\n                endContainer: r.endContainer,\n                startOffset,\n                endOffset,\n            };\n        } else if (r.endContainer == range.startContainer && r.endOffset <= range.startOffset) {\n            pendingRanges[i] = {\n                startContainer: r.startContainer,\n                endContainer: r.endContainer,\n                startOffset: r.startOffset,\n                endOffset: r.endOffset,\n            };\n        }\n    }\n\n    range.deleteContents();\n    textNode.nodeValue = newText;\n\n    getObjectKeys(pendingRanges).forEach(i => {\n        const { startOffset, endOffset, startContainer, endContainer } = pendingRanges[i];\n\n        safeSetRange(foundRanges[i], startContainer, startOffset, endContainer, endOffset);\n    });\n\n    safeSetRange(range, resultContainer, resultOffset, resultContainer, resultOffset);\n\n    return range;\n}\n\nfunction safeSetRange(\n    range: Range,\n    startContainer: Node,\n    startOffset: number,\n    endContainer: Node,\n    endOffset: number\n) {\n    if (\n        isNodeOfType(startContainer, 'TEXT_NODE') &&\n        isNodeOfType(endContainer, 'TEXT_NODE') &&\n        startOffset >= 0 &&\n        startOffset <= (startContainer.nodeValue?.length ?? 0) &&\n        endOffset >= 0 &&\n        endOffset <= (endContainer.nodeValue?.length ?? 0)\n    ) {\n        range.setStart(startContainer, startOffset);\n        range.setEnd(endContainer, endOffset);\n    }\n}\n","import { scrollRectIntoView } from 'roosterjs-content-model-dom';\nimport type { IEditor, Rect } from 'roosterjs-content-model-types';\nimport type { FindReplaceContext } from '../types/FindReplaceContext';\n\n/**\n * @internal\n */\nexport function setMarkedIndex(\n    editor: IEditor,\n    context: FindReplaceContext,\n    index: number,\n    alternativeRange?: Range | null\n): void {\n    context.replaceHighlight.clear();\n    context.markedIndex = index;\n\n    const range = context.ranges[context.markedIndex];\n\n    if (range) {\n        context.replaceHighlight.addRanges([range]);\n        let rect: Rect | null;\n\n        if (context.scrollMargin >= 0 && (rect = editor.getVisibleViewport())) {\n            scrollRectIntoView(\n                editor.getScrollContainer(),\n                rect,\n                editor.getDOMHelper(),\n                range.getBoundingClientRect(),\n                context.scrollMargin,\n                true /*preferTop*/\n            );\n        }\n    } else {\n        context.markedIndex = -1;\n    }\n\n    editor.triggerEvent('findResultChanged', {\n        markedIndex: context.markedIndex,\n        ranges: context.ranges,\n        alternativeRange,\n    });\n}\n","/**\n * @internal\n * Sort ranges in the order of their position in the document\n */\nexport function sortRanges(ranges: Range[]) {\n    return ranges.sort(compareRange);\n}\n\nfunction compareRange(r1: Range, r2: Range): number {\n    if (r1.startContainer == r2.startContainer) {\n        return r1.startOffset - r2.startOffset;\n    } else {\n        return r1.startContainer.compareDocumentPosition(r2.startContainer) &\n            Node.DOCUMENT_POSITION_FOLLOWING\n            ? -1\n            : 1;\n    }\n}\n","import { getRangesByText } from 'roosterjs-content-model-dom';\nimport { setMarkedIndex } from './setMarkedIndex';\nimport { sortRanges } from './sortRanges';\nimport type { IEditor } from 'roosterjs-content-model-types';\nimport type { FindReplaceContext } from '../types/FindReplaceContext';\n\n/**\n * @internal\n */\nexport function updateHighlight(\n    editor: IEditor,\n    context: FindReplaceContext,\n    addedBlockElements: HTMLElement[] | null = null,\n    removedBlockElements: HTMLElement[] | null = null\n) {\n    context.findHighlight.clear();\n\n    if (context.text) {\n        const { text, matchCase, wholeWord } = context;\n        const domHelper = editor.getDOMHelper();\n\n        if (removedBlockElements) {\n            context.ranges = context.ranges.filter(\n                r =>\n                    !removedBlockElements.some(x => x.contains(r.startContainer)) &&\n                    domHelper.isNodeInEditor(r.startContainer, true /*excludeRoot*/)\n            );\n        } else {\n            context.ranges = [];\n        }\n\n        if (addedBlockElements) {\n            const newRanges = addedBlockElements.map(b =>\n                getRangesByText(b, text, matchCase, wholeWord, true /*editableOnly*/)\n            );\n            context.ranges = context.ranges.concat(...newRanges);\n        } else {\n            context.ranges = domHelper.getRangesByText(text, matchCase, wholeWord);\n        }\n\n        sortRanges(context.ranges);\n    } else {\n        context.ranges = [];\n    }\n\n    if (context.ranges.length > 0) {\n        context.findHighlight.addRanges(context.ranges);\n    }\n\n    setMarkedIndex(editor, context, -1);\n}\n","import { ChangeSource } from 'roosterjs-content-model-dom';\nimport { fixupHiddenProperties } from './fixupHiddenProperties';\nimport type { IEditor, PluginEvent, EditorPlugin } from 'roosterjs-content-model-types';\nimport type { HiddenPropertyOptions } from './HiddenPropertyOptions';\n\n/**\n * HiddenPropertyPlugin helps editor to maintain hidden properties in DOM after editor content is reset using HTML\n */\nexport class HiddenPropertyPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n\n    /**\n     * Construct a new instance of FormatPlugin class\n     * @param option The editor option\n     */\n    constructor(private option: HiddenPropertyOptions) {}\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'HiddenProperty';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n\n        if (event.eventType == 'contentChanged' && event.source == ChangeSource.SetContent) {\n            fixupHiddenProperties(this.editor, this.option);\n        }\n    }\n}\n","import { setLinkUndeletable } from 'roosterjs-content-model-dom';\nimport type { HiddenPropertyOptions } from './HiddenPropertyOptions';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Maintain hidden properties in DOM after editor content is reset using HTML\n * This includes:\n * 1. Undeletable property\n */\nexport function fixupHiddenProperties(editor: IEditor, options: HiddenPropertyOptions) {\n    if (options.undeletableLinkChecker) {\n        checkUndeletable(editor, options.undeletableLinkChecker);\n    }\n\n    // Add more hidden properties checkers here\n}\n\nfunction checkUndeletable(editor: IEditor, checker: (link: HTMLAnchorElement) => boolean) {\n    const anchors = editor.getDOMHelper().queryElements('a');\n\n    for (const a of anchors) {\n        if (checker(a)) {\n            setLinkUndeletable(a, true);\n        }\n    }\n}\n","import { matchLink } from 'roosterjs-content-model-api';\nimport type { HyperlinkToolTip } from './HyperlinkToolTip';\nimport type {\n    DOMHelper,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    LinkData,\n} from 'roosterjs-content-model-types';\n\nconst defaultToolTipCallback: HyperlinkToolTip = (url: string) => url;\n\n/**\n * Hyperlink plugin does the following jobs for a hyperlink in editor:\n * 1. When hover on a link, show a tool tip\n * 2. When Ctrl+Click on a link, open a new window with the link\n * 3. When type directly on a link whose text matches its link url, update the link url with the link text\n */\nexport class HyperlinkPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private domHelper: DOMHelper | null = null;\n    private isMac: boolean = false;\n    private disposer: (() => void) | null = null;\n\n    private currentNode: Node | null = null;\n    private currentLink: HTMLAnchorElement | null = null;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param tooltip Tooltip to show when mouse hover over a link\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private tooltip: HyperlinkToolTip = defaultToolTipCallback,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n        this.domHelper = editor.getDOMHelper();\n        this.isMac = !!editor.getEnvironment().isMac;\n        this.disposer = editor.attachDomEvent({\n            mouseover: { beforeDispatch: this.onMouse },\n            mouseout: { beforeDispatch: this.onMouse },\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n\n        this.currentNode = null;\n        this.currentLink = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        let matchedLink: LinkData | null;\n\n        if (event.eventType == 'keyDown') {\n            const selection = this.editor?.getDOMSelection();\n            const node =\n                selection?.type == 'range' ? selection.range.commonAncestorContainer : null;\n\n            if (node && node != this.currentNode) {\n                this.currentNode = node;\n                this.currentLink = null;\n\n                this.runWithHyperlink(node, (href, a) => {\n                    if (\n                        node.textContent &&\n                        (matchedLink = matchLink(node.textContent)) &&\n                        matchedLink.normalizedUrl == href\n                    ) {\n                        this.currentLink = a;\n                    }\n                });\n            }\n        } else if (event.eventType == 'keyUp') {\n            const selection = this.editor?.getDOMSelection();\n            const node =\n                selection?.type == 'range' ? selection.range.commonAncestorContainer : null;\n\n            if (\n                node &&\n                node == this.currentNode &&\n                this.currentLink &&\n                this.currentLink.contains(node) &&\n                node.textContent &&\n                (matchedLink = matchLink(node.textContent))\n            ) {\n                this.currentLink.setAttribute('href', matchedLink.normalizedUrl);\n            }\n        } else if (event.eventType == 'mouseUp' && event.isClicking) {\n            this.runWithHyperlink(event.rawEvent.target as Node, (href, anchor) => {\n                if (\n                    !this.onLinkClick?.(anchor, event.rawEvent) &&\n                    this.isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    event.rawEvent.preventDefault();\n\n                    const target = this.target || '_blank';\n                    const window = this.editor?.getDocument().defaultView;\n\n                    try {\n                        window?.open(href, target);\n                    } catch {}\n                }\n            });\n        } else if (event.eventType == 'contentChanged') {\n            this.domHelper?.setDomAttribute('title', null /*value*/);\n        }\n    }\n\n    protected onMouse = (e: Event) => {\n        this.runWithHyperlink(e.target as Node, (href, a) => {\n            const tooltip =\n                e.type == 'mouseover'\n                    ? typeof this.tooltip == 'function'\n                        ? this.tooltip(href, a)\n                        : this.tooltip\n                    : null;\n            this.domHelper?.setDomAttribute('title', tooltip);\n        });\n    };\n\n    private runWithHyperlink(node: Node, callback: (href: string, a: HTMLAnchorElement) => void) {\n        const a = this.domHelper?.findClosestElementAncestor(\n            node,\n            'a[href]'\n        ) as HTMLAnchorElement | null;\n        const href = a?.getAttribute('href');\n\n        if (href && a) {\n            callback(href, a);\n        }\n    }\n\n    private isCtrlOrMetaPressed(event: KeyboardEvent | MouseEvent): boolean {\n        return this.isMac ? event.metaKey : event.ctrlKey;\n    }\n}\n","import { createElement } from '../../pluginUtils/CreateElement/createElement';\nimport { ImageEditElementClass } from '../types/ImageEditElementClass';\nimport { isElementOfType, isNodeOfType } from 'roosterjs-content-model-dom';\nimport type { CreateElementData } from '../../pluginUtils/CreateElement/CreateElementData';\nimport type { DNDDirectionX, DnDDirectionY } from '../types/DragAndDropContext';\nimport {\n    CROP_HANDLE_SIZE,\n    CROP_HANDLE_WIDTH,\n    ROTATION,\n    XS_CROP,\n    YS_CROP,\n} from '../constants/constants';\n\n/**\n * @internal\n */\nexport function createImageCropper(doc: Document) {\n    const cropper = getCropHTML()\n        .map(data => {\n            const cropper = createElement(data, doc);\n            if (\n                cropper &&\n                isNodeOfType(cropper, 'ELEMENT_NODE') &&\n                isElementOfType(cropper, 'div')\n            ) {\n                return cropper;\n            }\n        })\n        .filter(cropper => !!cropper) as HTMLDivElement[];\n    return cropper;\n}\n\n/**\n * @internal\n * Get HTML for crop elements, including 4 overlays (to show dark shadow), 1 container and 4 crop handles\n */\nexport function getCropHTML(): CreateElementData[] {\n    const overlayHTML: CreateElementData = {\n        tag: 'div',\n        style: 'position:absolute;background-color:rgb(0,0,0,0.5);pointer-events:none',\n        className: ImageEditElementClass.CropOverlay,\n    };\n    const containerHTML: CreateElementData = {\n        tag: 'div',\n        style: 'position:absolute;overflow:hidden;inset:0px;',\n        className: ImageEditElementClass.CropContainer,\n        children: [],\n    };\n\n    if (containerHTML) {\n        XS_CROP.forEach(x =>\n            YS_CROP.forEach(y => containerHTML.children?.push(getCropHTMLInternal(x, y)))\n        );\n    }\n    return [containerHTML, overlayHTML, overlayHTML, overlayHTML, overlayHTML];\n}\n\nfunction getCropHTMLInternal(x: DNDDirectionX, y: DnDDirectionY): CreateElementData {\n    const leftOrRight = x == 'w' ? 'left' : 'right';\n    const topOrBottom = y == 'n' ? 'top' : 'bottom';\n    const rotation = ROTATION[y + x];\n\n    return {\n        tag: 'div',\n        className: ImageEditElementClass.CropHandle,\n        style: `position:absolute;pointer-events:auto;cursor:${y}${x}-resize;${leftOrRight}:0;${topOrBottom}:0;width:${CROP_HANDLE_SIZE}px;height:${CROP_HANDLE_SIZE}px;transform:rotate(${rotation}deg)`,\n        dataset: { x, y },\n        children: getCropHandleHTML(),\n    };\n}\n\nfunction getCropHandleHTML(): CreateElementData[] {\n    const result: CreateElementData[] = [];\n    [0, 1].forEach(layer =>\n        [0, 1].forEach(dir => {\n            result.push(getCropHandleHTMLInternal(layer, dir));\n        })\n    );\n    return result;\n}\n\nfunction getCropHandleHTMLInternal(layer: number, dir: number): CreateElementData {\n    const position =\n        dir == 0\n            ? `right:${layer}px;height:${CROP_HANDLE_WIDTH - layer * 2}px;`\n            : `top:${layer}px;width:${CROP_HANDLE_WIDTH - layer * 2}px;`;\n    const bgColor = layer == 0 ? 'white' : 'black';\n\n    return {\n        tag: 'div',\n        style: `position:absolute;left:${layer}px;bottom:${layer}px;${position};background-color:${bgColor}`,\n    };\n}\n","import { rotateCoordinate } from '../utils/imageEditUtils';\nimport type { DragAndDropContext } from '../types/DragAndDropContext';\nimport type { DragAndDropHandler } from '../../pluginUtils/DragAndDrop/DragAndDropHandler';\nimport type { ImageCropMetadataFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Crop handle for DragAndDropHelper\n */\nexport const Cropper: DragAndDropHandler<DragAndDropContext, ImageCropMetadataFormat> = {\n    onDragStart: ({ editInfo }) => ({ ...editInfo }),\n    onDragging: ({ editInfo, x, y, options }, e, base, dx, dy) => {\n        [dx, dy] = rotateCoordinate(dx, dy, editInfo.angleRad ?? 0);\n\n        const {\n            widthPx,\n            heightPx,\n            leftPercent,\n            rightPercent,\n            topPercent,\n            bottomPercent,\n        } = editInfo;\n\n        if (\n            leftPercent === undefined ||\n            rightPercent === undefined ||\n            topPercent === undefined ||\n            bottomPercent === undefined ||\n            base.leftPercent === undefined ||\n            base.rightPercent === undefined ||\n            base.topPercent === undefined ||\n            base.bottomPercent === undefined ||\n            widthPx === undefined ||\n            heightPx === undefined\n        ) {\n            return false;\n        }\n\n        const { minWidth, minHeight } = options;\n        const widthPercent = 1 - leftPercent - rightPercent;\n        const heightPercent = 1 - topPercent - bottomPercent;\n\n        if (\n            widthPercent > 0 &&\n            heightPercent > 0 &&\n            minWidth !== undefined &&\n            minHeight !== undefined\n        ) {\n            const fullWidth = widthPx / widthPercent;\n            const fullHeight = heightPx / heightPercent;\n            const newLeft =\n                x != 'e'\n                    ? crop(base.leftPercent, dx, fullWidth, rightPercent, minWidth)\n                    : leftPercent;\n            const newRight =\n                x != 'w'\n                    ? crop(base.rightPercent, -dx, fullWidth, leftPercent, minWidth)\n                    : rightPercent;\n            const newTop =\n                y != 's'\n                    ? crop(base.topPercent, dy, fullHeight, bottomPercent, minHeight)\n                    : topPercent;\n            const newBottom =\n                y != 'n'\n                    ? crop(base.bottomPercent, -dy, fullHeight, topPercent, minHeight)\n                    : bottomPercent;\n\n            editInfo.leftPercent = newLeft;\n            editInfo.rightPercent = newRight;\n            editInfo.topPercent = newTop;\n            editInfo.bottomPercent = newBottom;\n            editInfo.widthPx = fullWidth * (1 - newLeft - newRight);\n            editInfo.heightPx = fullHeight * (1 - newTop - newBottom);\n\n            return true;\n        } else {\n            return false;\n        }\n    },\n};\n\nfunction crop(\n    basePercentage: number,\n    deltaValue: number,\n    fullValue: number,\n    currentPercentage: number,\n    minValue: number\n): number {\n    const maxValue = fullValue * (1 - currentPercentage) - minValue;\n    const newValue = fullValue * basePercentage + deltaValue;\n    const validValue = Math.max(Math.min(newValue, maxValue), 0);\n    return validValue / fullValue;\n}\n","import { applyChange } from './utils/applyChange';\nimport { canRegenerateImage } from './utils/canRegenerateImage';\nimport { checkIfImageWasResized, isASmallImage } from './utils/imageEditUtils';\nimport { createImageWrapper } from './utils/createImageWrapper';\nimport { Cropper } from './Cropper/cropperContext';\nimport { EDITING_MARKER, findEditingImage } from './utils/findEditingImage';\nimport { filterInnerResizerHandles } from './utils/filterInnerResizerHandles';\nimport { getDropAndDragHelpers } from './utils/getDropAndDragHelpers';\nimport { getHTMLImageOptions } from './utils/getHTMLImageOptions';\nimport { getSelectedImage } from './utils/getSelectedImage';\nimport { getSelectedImageMetadata, updateImageEditInfo } from './utils/updateImageEditInfo';\nimport { ImageEditElementClass } from './types/ImageEditElementClass';\nimport { normalizeImageSelection } from './utils/normalizeImageSelection';\nimport { Resizer } from './Resizer/resizerContext';\nimport { Rotator } from './Rotator/rotatorContext';\nimport { updateHandleCursor } from './utils/updateHandleCursor';\nimport { updateRotateHandle } from './Rotator/updateRotateHandle';\nimport { updateWrapper } from './utils/updateWrapper';\nimport {\n    ChangeSource,\n    getSafeIdSelector,\n    getSelectedParagraphs,\n    isElementOfType,\n    isNodeOfType,\n    mutateBlock,\n    mutateSegment,\n    setImageState,\n    unwrap,\n} from 'roosterjs-content-model-dom';\nimport type { DragAndDropHelper } from '../pluginUtils/DragAndDrop/DragAndDropHelper';\nimport type { DragAndDropContext } from './types/DragAndDropContext';\nimport type { ImageHtmlOptions } from './types/ImageHtmlOptions';\nimport type { ImageEditOptions } from './types/ImageEditOptions';\nimport type {\n    ContentChangedEvent,\n    ContentModelImage,\n    EditorPlugin,\n    IEditor,\n    ImageEditOperation,\n    ImageEditor,\n    ImageMetadataFormat,\n    KeyDownEvent,\n    MouseDownEvent,\n    MouseUpEvent,\n    PluginEvent,\n} from 'roosterjs-content-model-types';\n\nconst DefaultOptions: Partial<ImageEditOptions> = {\n    borderColor: '#DB626C',\n    minWidth: 10,\n    minHeight: 10,\n    preserveRatio: true,\n    disableRotate: false,\n    disableSideResize: false,\n    onSelectState: ['resize', 'rotate'],\n};\n\nconst MouseRightButton = 2;\nconst DRAG_ID = '_dragging';\nconst IMAGE_EDIT_CLASS = 'imageEdit';\nconst IMAGE_EDIT_CLASS_CARET = 'imageEditCaretColor';\nconst IMAGE_EDIT_FORMAT_EVENT = 'ImageEditEvent';\n\n/**\n * ImageEdit plugin handles the following image editing features:\n * - Resize image\n * - Crop image\n * - Rotate image\n * - Flip image\n */\nexport class ImageEditPlugin implements ImageEditor, EditorPlugin {\n    protected editor: IEditor | null = null;\n    private shadowSpan: HTMLSpanElement | null = null;\n    private selectedImage: HTMLImageElement | null = null;\n    protected wrapper: HTMLSpanElement | null = null;\n    protected imageEditInfo: ImageMetadataFormat | null = null;\n    private imageHTMLOptions: ImageHtmlOptions | null = null;\n    private dndHelpers: DragAndDropHelper<DragAndDropContext, any>[] = [];\n    private clonedImage: HTMLImageElement | null = null;\n    private lastSrc: string | null = null;\n    private wasImageResized: boolean = false;\n    private isCropMode: boolean = false;\n    private resizers: HTMLDivElement[] = [];\n    private rotators: HTMLDivElement[] = [];\n    private croppers: HTMLDivElement[] = [];\n    private zoomScale: number = 1;\n    private disposer: (() => void) | null = null;\n    protected isEditing = false;\n    protected options: ImageEditOptions;\n\n    constructor(options?: ImageEditOptions) {\n        this.options = { ...DefaultOptions, ...options };\n    }\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'ImageEdit';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = editor.attachDomEvent({\n            blur: {\n                beforeDispatch: () => {\n                    if (this.isEditing && this.editor && !this.editor.isDisposed()) {\n                        this.applyFormatWithContentModel(\n                            this.editor,\n                            this.isCropMode,\n                            true /* shouldSelectImage */\n                        );\n                    }\n                },\n            },\n            dragstart: {\n                beforeDispatch: ev => {\n                    if (this.editor) {\n                        const target = ev.target as Node;\n                        if (this.isImageSelection(target)) {\n                            target.id = target.id + DRAG_ID;\n                        }\n                    }\n                },\n            },\n            dragend: {\n                beforeDispatch: ev => {\n                    if (this.editor) {\n                        const target = ev.target as Node;\n                        if (this.isImageSelection(target) && target.id.includes(DRAG_ID)) {\n                            target.id = target.id.replace(DRAG_ID, '').trim();\n                        }\n                    }\n                },\n            },\n        });\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.isEditing = false;\n        this.cleanInfo();\n        this.editor = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n        switch (event.eventType) {\n            case 'mouseDown':\n                this.mouseDownHandler(this.editor, event);\n                break;\n            case 'mouseUp':\n                this.mouseUpHandler(this.editor, event);\n                break;\n            case 'keyDown':\n                this.keyDownHandler(this.editor, event);\n                break;\n            case 'contentChanged':\n                this.contentChangedHandler(this.editor, event);\n                break;\n            case 'extractContentWithDom':\n                this.removeImageEditing(event.clonedRoot);\n                break;\n            case 'beforeLogicalRootChange':\n                this.handleBeforeLogicalRootChange();\n                break;\n        }\n    }\n\n    private handleBeforeLogicalRootChange() {\n        if (this.isEditing && this.editor && !this.editor.isDisposed()) {\n            this.applyFormatWithContentModel(\n                this.editor,\n                this.isCropMode,\n                false /* shouldSelectImage */\n            );\n            this.removeImageWrapper();\n            this.cleanInfo();\n        }\n    }\n\n    private removeImageEditing(clonedRoot: HTMLElement) {\n        const images = clonedRoot.querySelectorAll('img');\n        images.forEach(image => {\n            if (image.dataset.editingInfo) {\n                delete image.dataset.editingInfo;\n            }\n        });\n    }\n\n    private isImageSelection(target: Node): target is HTMLElement {\n        return (\n            isNodeOfType(target, 'ELEMENT_NODE') &&\n            (isElementOfType(target, 'img') ||\n                !!(\n                    isElementOfType(target, 'span') &&\n                    target.firstElementChild &&\n                    isNodeOfType(target.firstElementChild, 'ELEMENT_NODE') &&\n                    isElementOfType(target.firstElementChild, 'img')\n                ))\n        );\n    }\n\n    private mouseUpHandler(editor: IEditor, event: MouseUpEvent) {\n        const selection = editor.getDOMSelection();\n        if ((selection && selection.type == 'image') || this.isEditing) {\n            const shouldSelectImage =\n                this.isImageSelection(event.rawEvent.target as Node) &&\n                event.rawEvent.button === MouseRightButton;\n            this.applyFormatWithContentModel(editor, this.isCropMode, shouldSelectImage);\n        }\n    }\n\n    private mouseDownHandler(editor: IEditor, event: MouseDownEvent) {\n        if (\n            this.isEditing &&\n            this.isImageSelection(event.rawEvent.target as Node) &&\n            event.rawEvent.button !== MouseRightButton &&\n            !this.isCropMode\n        ) {\n            this.applyFormatWithContentModel(editor, this.isCropMode);\n        }\n    }\n\n    private onDropHandler(editor: IEditor) {\n        const selection = editor.getDOMSelection();\n        if (selection?.type == 'image') {\n            editor.formatContentModel(model => {\n                const imageDragged = findEditingImage(model, selection.image.id);\n                const imageDropped = findEditingImage(\n                    model,\n                    selection.image.id.replace(DRAG_ID, '').trim()\n                );\n                if (imageDragged && imageDropped) {\n                    const draggedIndex = imageDragged.paragraph.segments.indexOf(\n                        imageDragged.image\n                    );\n                    mutateBlock(imageDragged.paragraph).segments.splice(draggedIndex, 1);\n                    const segment = imageDropped.image;\n                    const paragraph = imageDropped.paragraph;\n                    mutateSegment(paragraph, segment, image => {\n                        image.isSelected = true;\n                        image.isSelectedAsImageSelection = true;\n                    });\n\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n\n    private keyDownHandler(editor: IEditor, event: KeyDownEvent) {\n        if (this.isEditing) {\n            if (\n                event.rawEvent.key === 'Escape' ||\n                event.rawEvent.key === 'Delete' ||\n                event.rawEvent.key === 'Backspace'\n            ) {\n                if (event.rawEvent.key === 'Escape') {\n                    this.removeImageWrapper();\n                }\n                this.cleanInfo();\n            } else {\n                if (event.rawEvent.key == 'Enter' && this.isCropMode) {\n                    event.rawEvent.preventDefault();\n                }\n                this.applyFormatWithContentModel(\n                    editor,\n                    this.isCropMode,\n                    true /** should selectImage */,\n                    false /* isApiOperation */\n                );\n            }\n        }\n    }\n\n    private setContentHandler() {\n        if (this.selectedImage) {\n            this.cleanInfo();\n            setImageState(this.selectedImage, '');\n            this.isEditing = false;\n            this.isCropMode = false;\n        }\n    }\n\n    private formatEventHandler(event: ContentChangedEvent) {\n        if (this.isEditing && event.formatApiName !== IMAGE_EDIT_FORMAT_EVENT) {\n            this.cleanInfo();\n            this.isEditing = false;\n            this.isCropMode = false;\n        }\n    }\n\n    private contentChangedHandler(editor: IEditor, event: ContentChangedEvent) {\n        switch (event.source) {\n            case ChangeSource.SetContent:\n                this.setContentHandler();\n                break;\n            case ChangeSource.Format:\n                this.formatEventHandler(event);\n                break;\n            case ChangeSource.Drop:\n                this.onDropHandler(editor);\n                break;\n        }\n    }\n\n    /**\n     * EXPOSED FOR TESTING PURPOSE ONLY\n     */\n    protected applyFormatWithContentModel(\n        editor: IEditor,\n        isCropMode: boolean,\n        shouldSelectImage?: boolean,\n        isApiOperation?: boolean\n    ) {\n        let editingImageModel: ContentModelImage | undefined;\n        const selection = editor.getDOMSelection();\n        let isRTL: boolean = false;\n\n        editor.formatContentModel(\n            (model, context) => {\n                const editingImage = getSelectedImage(model);\n                const previousSelectedImage = isApiOperation\n                    ? editingImage\n                    : findEditingImage(model);\n                let result = false;\n\n                // Skip adding undo snapshot for now. If we detect any changes later, we will reset it\n                context.skipUndoSnapshot = 'SkipAll';\n\n                if (\n                    shouldSelectImage ||\n                    previousSelectedImage?.image != editingImage?.image ||\n                    previousSelectedImage?.image.format.imageState == EDITING_MARKER ||\n                    isApiOperation\n                ) {\n                    const { lastSrc, selectedImage, imageEditInfo, clonedImage } = this;\n                    if (\n                        (this.isEditing || isApiOperation) &&\n                        previousSelectedImage &&\n                        lastSrc &&\n                        selectedImage &&\n                        imageEditInfo &&\n                        clonedImage\n                    ) {\n                        mutateSegment(\n                            previousSelectedImage.paragraph,\n                            previousSelectedImage.image,\n                            image => {\n                                const changeState = applyChange(\n                                    editor,\n                                    selectedImage,\n                                    image,\n                                    imageEditInfo,\n                                    lastSrc,\n                                    this.wasImageResized || this.isCropMode,\n                                    clonedImage\n                                );\n\n                                if (this.wasImageResized || changeState == 'FullyChanged') {\n                                    context.skipUndoSnapshot = false;\n                                }\n                                const isSameImage =\n                                    previousSelectedImage?.image === editingImage?.image;\n                                image.isSelected = isSameImage || shouldSelectImage;\n                                image.isSelectedAsImageSelection = isSameImage || shouldSelectImage;\n                                image.format.imageState = undefined;\n\n                                if (selection?.type == 'range' && !selection.range.collapsed) {\n                                    const selectedParagraphs = getSelectedParagraphs(model, true);\n                                    const isImageInRange = selectedParagraphs.some(paragraph =>\n                                        paragraph.segments.includes(image)\n                                    );\n                                    if (isImageInRange) {\n                                        image.isSelected = true;\n                                    }\n                                }\n                            }\n                        );\n\n                        if (shouldSelectImage) {\n                            normalizeImageSelection(previousSelectedImage);\n                        }\n\n                        this.cleanInfo();\n                        result = true;\n                    }\n\n                    this.isEditing = false;\n                    this.isCropMode = false;\n\n                    if (\n                        editingImage &&\n                        selection?.type == 'image' &&\n                        !shouldSelectImage &&\n                        !isApiOperation\n                    ) {\n                        this.isEditing = true;\n                        this.isCropMode = isCropMode;\n                        mutateSegment(editingImage.paragraph, editingImage.image, image => {\n                            editingImageModel = image;\n                            isRTL = editingImage.paragraph.format.direction == 'rtl';\n                            this.imageEditInfo = updateImageEditInfo(image, selection.image);\n                            image.format.imageState = 'isEditing';\n                        });\n\n                        result = true;\n                    }\n                }\n\n                return result;\n            },\n            {\n                onNodeCreated: (model, node) => {\n                    if (\n                        !isApiOperation &&\n                        editingImageModel &&\n                        editingImageModel == model &&\n                        editingImageModel.format.imageState == EDITING_MARKER &&\n                        isNodeOfType(node, 'ELEMENT_NODE') &&\n                        isElementOfType(node, 'img')\n                    ) {\n                        if (isCropMode) {\n                            this.startCropMode(editor, node, isRTL);\n                        } else {\n                            this.startRotateAndResize(editor, node, isRTL);\n                        }\n                    }\n                },\n                apiName: IMAGE_EDIT_FORMAT_EVENT,\n            },\n            {\n                tryGetFromCache: true,\n            }\n        );\n    }\n\n    private startEditing(\n        editor: IEditor,\n        image: HTMLImageElement,\n        apiOperation: ImageEditOperation[]\n    ) {\n        if (!this.imageEditInfo) {\n            this.imageEditInfo = getSelectedImageMetadata(editor, image);\n        }\n\n        if (\n            (this.imageEditInfo.widthPx == 0 || this.imageEditInfo.heightPx == 0) &&\n            !image.complete\n        ) {\n            // Image dimensions are zero and loading is incomplete, wait for image to load.\n            image.onload = () => {\n                this.updateImageDimensionsIfZero(image);\n                this.startEditingInternal(editor, image, apiOperation);\n                image.onload = null;\n                image.onerror = null;\n            };\n            image.onerror = () => {\n                image.onload = null;\n                image.onerror = null;\n            };\n        } else {\n            this.updateImageDimensionsIfZero(image);\n            this.startEditingInternal(editor, image, apiOperation);\n        }\n    }\n\n    private updateImageDimensionsIfZero(image: HTMLImageElement) {\n        if (this.imageEditInfo?.widthPx === 0 || this.imageEditInfo?.heightPx === 0) {\n            this.imageEditInfo.widthPx = image.clientWidth;\n            this.imageEditInfo.heightPx = image.clientHeight;\n        }\n    }\n\n    private startEditingInternal(\n        editor: IEditor,\n        image: HTMLImageElement,\n        apiOperation: ImageEditOperation[]\n    ) {\n        if (!this.imageEditInfo) {\n            this.imageEditInfo = getSelectedImageMetadata(editor, image);\n        }\n\n        this.imageHTMLOptions = getHTMLImageOptions(editor, this.options, this.imageEditInfo);\n        this.lastSrc = image.getAttribute('src');\n\n        const {\n            resizers,\n            rotators,\n            wrapper,\n            shadowSpan,\n            imageClone,\n            croppers,\n        } = createImageWrapper(\n            editor,\n            image,\n            this.options,\n            this.imageEditInfo,\n            this.imageHTMLOptions,\n            apiOperation\n        );\n        this.shadowSpan = shadowSpan;\n        this.selectedImage = image;\n        this.wrapper = wrapper;\n        this.clonedImage = imageClone;\n        this.wasImageResized = checkIfImageWasResized(image);\n        this.resizers = resizers;\n        this.rotators = rotators;\n        this.croppers = croppers;\n        this.zoomScale = editor.getDOMHelper().calculateZoomScale();\n\n        editor.setEditorStyle(IMAGE_EDIT_CLASS, `outline-style:none!important;`, [\n            `span:has(>img${getSafeIdSelector(this.selectedImage.id)})`,\n        ]);\n\n        editor.setEditorStyle(IMAGE_EDIT_CLASS_CARET, `caret-color: transparent;`);\n    }\n\n    public startRotateAndResize(editor: IEditor, image: HTMLImageElement, isRTL: boolean) {\n        if (this.imageEditInfo) {\n            this.startEditing(editor, image, ['resize', 'rotate']);\n            if (this.selectedImage && this.imageEditInfo && this.wrapper && this.clonedImage) {\n                const isMobileOrTable = !!editor.getEnvironment().isMobileOrTablet;\n                this.dndHelpers = [\n                    ...getDropAndDragHelpers(\n                        this.wrapper,\n                        this.imageEditInfo,\n                        this.options,\n                        ImageEditElementClass.ResizeHandle,\n                        Resizer,\n                        () => {\n                            if (\n                                this.imageEditInfo &&\n                                this.selectedImage &&\n                                this.wrapper &&\n                                this.clonedImage\n                            ) {\n                                updateWrapper(\n                                    this.imageEditInfo,\n                                    this.options,\n                                    this.selectedImage,\n                                    this.clonedImage,\n                                    this.wrapper,\n                                    this.resizers,\n                                    undefined /* croppers */,\n                                    isRTL\n                                );\n                                this.wasImageResized = true;\n                            }\n                        },\n                        this.zoomScale,\n                        isMobileOrTable\n                    ),\n                    ...getDropAndDragHelpers(\n                        this.wrapper,\n                        this.imageEditInfo,\n                        this.options,\n                        ImageEditElementClass.RotateHandle,\n                        Rotator,\n                        () => {\n                            if (\n                                this.imageEditInfo &&\n                                this.selectedImage &&\n                                this.wrapper &&\n                                this.clonedImage\n                            ) {\n                                updateWrapper(\n                                    this.imageEditInfo,\n                                    this.options,\n                                    this.selectedImage,\n                                    this.clonedImage,\n                                    this.wrapper,\n                                    undefined /* resizers */,\n                                    undefined /* croppers */,\n                                    isRTL,\n                                    true /* isRotating */\n                                );\n                                this.updateRotateHandleState(\n                                    editor,\n                                    this.selectedImage,\n                                    this.wrapper,\n                                    this.rotators,\n                                    this.imageEditInfo?.angleRad,\n                                    !!this.options?.disableSideResize\n                                );\n                                this.updateResizeHandleDirection(\n                                    this.resizers,\n                                    this.imageEditInfo.angleRad\n                                );\n                            }\n                        },\n                        this.zoomScale,\n                        isMobileOrTable\n                    ),\n                ];\n\n                updateWrapper(\n                    this.imageEditInfo,\n                    this.options,\n                    this.selectedImage,\n                    this.clonedImage,\n                    this.wrapper,\n                    this.resizers,\n                    undefined /* croppers */,\n                    isRTL\n                );\n\n                this.updateRotateHandleState(\n                    editor,\n                    this.selectedImage,\n                    this.wrapper,\n                    this.rotators,\n                    this.imageEditInfo?.angleRad,\n                    !!this.options?.disableSideResize\n                );\n            }\n        }\n    }\n\n    private updateResizeHandleDirection(resizers: HTMLDivElement[], angleRad: number | undefined) {\n        const resizeHandles = filterInnerResizerHandles(resizers);\n        if (angleRad !== undefined) {\n            updateHandleCursor(resizeHandles, angleRad);\n        }\n    }\n\n    private updateRotateHandleState(\n        editor: IEditor,\n        image: HTMLImageElement,\n        wrapper: HTMLSpanElement,\n        rotators: HTMLDivElement[],\n        angleRad: number | undefined,\n        disableSideResize: boolean\n    ) {\n        const viewport = editor.getVisibleViewport();\n        const smallImage = isASmallImage(image.width, image.height);\n        if (viewport && rotators && rotators.length > 0) {\n            const rotator = rotators[0];\n            const rotatorHandle = rotator.firstElementChild;\n            if (\n                isNodeOfType(rotatorHandle, 'ELEMENT_NODE') &&\n                isElementOfType(rotatorHandle, 'div')\n            ) {\n                updateRotateHandle(\n                    viewport,\n                    angleRad ?? 0,\n                    wrapper,\n                    rotator,\n                    rotatorHandle,\n                    smallImage,\n                    disableSideResize\n                );\n            }\n        }\n    }\n\n    public isOperationAllowed(operation: ImageEditOperation): boolean {\n        return (\n            operation === 'resize' ||\n            operation === 'rotate' ||\n            operation === 'flip' ||\n            operation === 'crop'\n        );\n    }\n\n    public canRegenerateImage(image: HTMLImageElement): boolean {\n        return canRegenerateImage(image);\n    }\n\n    private startCropMode(editor: IEditor, image: HTMLImageElement, isRTL: boolean) {\n        if (this.imageEditInfo) {\n            this.startEditing(editor, image, ['crop']);\n            if (this.imageEditInfo && this.selectedImage && this.wrapper && this.clonedImage) {\n                this.dndHelpers = [\n                    ...getDropAndDragHelpers(\n                        this.wrapper,\n                        this.imageEditInfo,\n                        this.options,\n                        ImageEditElementClass.CropHandle,\n                        Cropper,\n                        () => {\n                            if (\n                                this.imageEditInfo &&\n                                this.selectedImage &&\n                                this.wrapper &&\n                                this.clonedImage\n                            ) {\n                                updateWrapper(\n                                    this.imageEditInfo,\n                                    this.options,\n                                    this.selectedImage,\n                                    this.clonedImage,\n                                    this.wrapper,\n                                    undefined /* resizers */,\n                                    this.croppers,\n                                    isRTL\n                                );\n                                this.isCropMode = true;\n                            }\n                        },\n                        this.zoomScale,\n                        !!editor.getEnvironment().isMobileOrTablet\n                    ),\n                ];\n                updateWrapper(\n                    this.imageEditInfo,\n                    this.options,\n                    this.selectedImage,\n                    this.clonedImage,\n                    this.wrapper,\n                    undefined /* resizers */,\n                    this.croppers,\n                    isRTL\n                );\n            }\n        }\n    }\n\n    public cropImage() {\n        if (!this.editor) {\n            return;\n        }\n        if (!this.editor.getEnvironment().isSafari) {\n            this.editor.focus(); // Safari will keep the selection when click crop, then the focus() call should not be called\n        }\n        const selection = this.editor.getDOMSelection();\n        if (selection?.type == 'image') {\n            this.applyFormatWithContentModel(\n                this.editor,\n                true /* isCropMode */,\n                false /* shouldSelectImage */\n            );\n        }\n    }\n\n    private editImage(\n        editor: IEditor,\n        image: HTMLImageElement,\n        apiOperation: ImageEditOperation[],\n        operation: (imageEditInfo: ImageMetadataFormat) => void\n    ) {\n        this.startEditing(editor, image, apiOperation);\n        if (!this.selectedImage || !this.imageEditInfo || !this.wrapper || !this.clonedImage) {\n            return;\n        }\n\n        operation(this.imageEditInfo);\n\n        updateWrapper(\n            this.imageEditInfo,\n            this.options,\n            this.selectedImage,\n            this.clonedImage,\n            this.wrapper\n        );\n\n        this.applyFormatWithContentModel(\n            editor,\n            false /* isCrop */,\n            true /* shouldSelect*/,\n            true /* isApiOperation */\n        );\n    }\n\n    /**\n     * Exported for testing purpose only\n     */\n    public cleanInfo() {\n        this.editor?.setEditorStyle(IMAGE_EDIT_CLASS, null);\n        this.editor?.setEditorStyle(IMAGE_EDIT_CLASS_CARET, null);\n        this.selectedImage = null;\n        this.shadowSpan = null;\n        this.wrapper = null;\n        this.imageEditInfo = null;\n        this.imageHTMLOptions = null;\n        this.dndHelpers.forEach(helper => helper.dispose());\n        this.dndHelpers = [];\n        this.clonedImage = null;\n        this.lastSrc = null;\n        this.wasImageResized = false;\n        this.isCropMode = false;\n        this.resizers = [];\n        this.rotators = [];\n        this.croppers = [];\n    }\n\n    private removeImageWrapper() {\n        let image: HTMLImageElement | null = null;\n        if (this.shadowSpan && this.shadowSpan.parentElement) {\n            if (\n                this.shadowSpan.firstElementChild &&\n                isNodeOfType(this.shadowSpan.firstElementChild, 'ELEMENT_NODE') &&\n                isElementOfType(this.shadowSpan.firstElementChild, 'img')\n            ) {\n                image = this.shadowSpan.firstElementChild;\n            }\n            unwrap(this.shadowSpan);\n            this.shadowSpan = null;\n            this.wrapper = null;\n        }\n\n        return image;\n    }\n\n    public flipImage(direction: 'horizontal' | 'vertical') {\n        const selection = this.editor?.getDOMSelection();\n        if (!this.editor || !selection || selection.type !== 'image') {\n            return;\n        }\n        const image = selection.image;\n        if (this.editor) {\n            this.editImage(this.editor, image, ['flip'], imageEditInfo => {\n                const angleRad = imageEditInfo.angleRad || 0;\n                const isInVerticalPostion =\n                    (angleRad >= Math.PI / 2 && angleRad < (3 * Math.PI) / 4) ||\n                    (angleRad <= -Math.PI / 2 && angleRad > (-3 * Math.PI) / 4);\n                if (isInVerticalPostion) {\n                    if (direction === 'horizontal') {\n                        imageEditInfo.flippedVertical = !imageEditInfo.flippedVertical;\n                    } else {\n                        imageEditInfo.flippedHorizontal = !imageEditInfo.flippedHorizontal;\n                    }\n                } else {\n                    if (direction === 'vertical') {\n                        imageEditInfo.flippedVertical = !imageEditInfo.flippedVertical;\n                    } else {\n                        imageEditInfo.flippedHorizontal = !imageEditInfo.flippedHorizontal;\n                    }\n                }\n            });\n        }\n    }\n\n    public rotateImage(angleRad: number) {\n        const selection = this.editor?.getDOMSelection();\n        if (!this.editor || !selection || selection.type !== 'image') {\n            return;\n        }\n        const image = selection.image;\n        if (this.editor) {\n            this.editImage(this.editor, image, [], imageEditInfo => {\n                imageEditInfo.angleRad = (imageEditInfo.angleRad || 0) + angleRad;\n            });\n        }\n    }\n}\n","import { createElement } from '../../pluginUtils/CreateElement/createElement';\nimport { ImageEditElementClass } from '../types/ImageEditElementClass';\nimport { isElementOfType, isNodeOfType } from 'roosterjs-content-model-dom';\nimport { Xs, Ys } from '../constants/constants';\nimport type { CreateElementData } from '../../pluginUtils/CreateElement/CreateElementData';\nimport type { DNDDirectionX, DnDDirectionY } from '../types/DragAndDropContext';\n/**\n * @internal\n */\nexport interface OnShowResizeHandle {\n    (elementData: CreateElementData, x: DNDDirectionX, y: DnDDirectionY): void;\n}\n\nconst RESIZE_HANDLE_MARGIN = 6;\nconst RESIZE_HANDLE_SIZE = 10;\n\n/**\n * @internal\n */\nexport function createImageResizer(\n    doc: Document,\n    disableSideResize: boolean,\n    onShowResizeHandle?: OnShowResizeHandle\n): HTMLDivElement[] {\n    const cornerElements = getCornerResizeHTML(onShowResizeHandle);\n    const sideElements = getSideResizeHTML(onShowResizeHandle);\n    const handles = disableSideResize ? cornerElements : cornerElements.concat(sideElements);\n\n    return handles\n        .map(element => {\n            const handle = createElement(element, doc);\n            if (isNodeOfType(handle, 'ELEMENT_NODE') && isElementOfType(handle, 'div')) {\n                return handle;\n            }\n        })\n        .filter(element => !!element) as HTMLDivElement[];\n}\n\n/**\n * @internal\n * Get HTML for resize handles at the corners\n */\nfunction getCornerResizeHTML(onShowResizeHandle?: OnShowResizeHandle): CreateElementData[] {\n    const result: CreateElementData[] = [];\n\n    Xs.forEach(x =>\n        Ys.forEach(y => {\n            const elementData = (x == '') == (y == '') ? getResizeHandleHTML(x, y) : null;\n            if (onShowResizeHandle && elementData) {\n                onShowResizeHandle(elementData, x, y);\n            }\n            if (elementData) {\n                result.push(elementData);\n            }\n        })\n    );\n    return result;\n}\n\n/**\n * @internal\n * Get HTML for resize handles on the sides\n */\nfunction getSideResizeHTML(onShowResizeHandle?: OnShowResizeHandle): CreateElementData[] {\n    const result: CreateElementData[] = [];\n    Xs.forEach(x =>\n        Ys.forEach(y => {\n            const elementData = (x == '') != (y == '') ? getResizeHandleHTML(x, y) : null;\n            if (onShowResizeHandle && elementData) {\n                onShowResizeHandle(elementData, x, y);\n            }\n            if (elementData) {\n                result.push(elementData);\n            }\n        })\n    );\n    return result;\n}\n\nconst createHandleStyle = (direction: string, topOrBottom: string, leftOrRight: string) => {\n    return `position:relative;width:${RESIZE_HANDLE_SIZE}px;height:${RESIZE_HANDLE_SIZE}px;background-color: #FFFFFF;cursor:${direction}-resize;${topOrBottom}:-${RESIZE_HANDLE_MARGIN}px;${leftOrRight}:-${RESIZE_HANDLE_MARGIN}px;border-radius:100%;border: 2px solid #bfbfbf;box-shadow: 0px 0.36316px 1.36185px rgba(100, 100, 100, 0.25);`;\n};\n\nfunction getResizeHandleHTML(x: DNDDirectionX, y: DnDDirectionY): CreateElementData | null {\n    const leftOrRight = x == 'w' ? 'left' : 'right';\n    const topOrBottom = y == 'n' ? 'top' : 'bottom';\n    const leftOrRightValue = x == '' ? '50%' : '0px';\n    const topOrBottomValue = y == '' ? '50%' : '0px';\n    const direction = y + x;\n    return x == '' && y == ''\n        ? null\n        : {\n              tag: 'div',\n              style: `position:absolute;${leftOrRight}:${leftOrRightValue};${topOrBottom}:${topOrBottomValue}`,\n              children: [\n                  {\n                      tag: 'div',\n                      style: createHandleStyle(direction, topOrBottom, leftOrRight),\n                      className: ImageEditElementClass.ResizeHandle,\n                      dataset: { x, y },\n                  },\n              ],\n          };\n}\n","import { rotateCoordinate } from '../utils/imageEditUtils';\nimport type { DragAndDropHandler } from '../../pluginUtils/DragAndDrop/DragAndDropHandler';\nimport type { ImageResizeMetadataFormat } from 'roosterjs-content-model-types';\nimport type { DragAndDropContext } from '../types/DragAndDropContext';\n\n/**\n * @internal\n * The resize drag and drop handler\n */\nexport const Resizer: DragAndDropHandler<DragAndDropContext, ImageResizeMetadataFormat> = {\n    onDragStart: ({ editInfo }) => ({ ...editInfo }),\n    onDragging: ({ x, y, editInfo, options }, e, base, deltaX, deltaY) => {\n        if (\n            base.heightPx &&\n            base.widthPx &&\n            options.minWidth !== undefined &&\n            options.minHeight !== undefined\n        ) {\n            const ratio =\n                base.widthPx > 0 && base.heightPx > 0 ? (base.widthPx * 1.0) / base.heightPx : 0;\n            [deltaX, deltaY] = rotateCoordinate(deltaX, deltaY, editInfo.angleRad ?? 0);\n            const horizontalOnly = x == '';\n            const verticalOnly = y == '';\n            const shouldPreserveRatio =\n                !(horizontalOnly || verticalOnly) && (options.preserveRatio || e.shiftKey);\n            let newWidth = horizontalOnly\n                ? base.widthPx\n                : Math.max(base.widthPx + deltaX * (x == 'w' ? -1 : 1), options.minWidth);\n            let newHeight = verticalOnly\n                ? base.heightPx\n                : Math.max(base.heightPx + deltaY * (y == 'n' ? -1 : 1), options.minHeight);\n\n            if (shouldPreserveRatio && ratio > 0) {\n                if (ratio > 1) {\n                    // first sure newHeight is rightcalculate newWidth\n                    newWidth = newHeight * ratio;\n                    if (newWidth < options.minWidth) {\n                        newWidth = options.minWidth;\n                        newHeight = newWidth / ratio;\n                    }\n                } else {\n                    // first sure newWidth is rightcalculate newHeight\n                    newHeight = newWidth / ratio;\n                    if (newHeight < options.minHeight) {\n                        newHeight = options.minHeight;\n                        newWidth = newHeight * ratio;\n                    }\n                }\n            }\n\n            editInfo.widthPx = newWidth;\n            editInfo.heightPx = newHeight;\n            return true;\n        } else {\n            return false;\n        }\n    },\n};\n","/**\n * @internal\n */\nexport function updateSideHandlesVisibility(handles: HTMLDivElement[], isSmall: boolean) {\n    handles.forEach(handle => {\n        const { y, x } = handle.dataset;\n        const coordinate = (y ?? '') + (x ?? '');\n        const directions = ['n', 's', 'e', 'w'];\n        const isSideHandle = directions.indexOf(coordinate) > -1;\n        handle.style.display = isSideHandle && isSmall ? 'none' : '';\n    });\n}\n","import { createElement } from '../../pluginUtils/CreateElement/createElement';\nimport { ImageEditElementClass } from '../types/ImageEditElementClass';\nimport { isElementOfType, isNodeOfType } from 'roosterjs-content-model-dom';\nimport type { CreateElementData } from '../../pluginUtils/CreateElement/CreateElementData';\nimport type { ImageHtmlOptions } from '../types/ImageHtmlOptions';\nimport {\n    ROTATE_GAP,\n    ROTATE_HANDLE_TOP,\n    ROTATE_HANDLE_TOP_NO_SIDE_RESIZE,\n    ROTATE_ICON_MARGIN,\n    ROTATE_SIZE,\n    ROTATE_WIDTH,\n} from '../constants/constants';\n\n/**\n * @internal\n * Get HTML for rotate elements, including the rotate handle with icon, and a line between the handle and the image\n */\nexport function createImageRotator(doc: Document, htmlOptions: ImageHtmlOptions) {\n    return getRotateHTML(htmlOptions)\n        .map(element => {\n            const rotator = createElement(element, doc);\n            if (isNodeOfType(rotator, 'ELEMENT_NODE') && isElementOfType(rotator, 'div')) {\n                return rotator;\n            }\n        })\n        .filter(rotator => !!rotator) as HTMLDivElement[];\n}\n\n/**\n * @internal\n * Get HTML for rotate elements, including the rotate handle with icon, and a line between the handle and the image\n *\n */\nfunction getRotateHTML({\n    borderColor,\n    rotateHandleBackColor,\n    disableSideResize,\n}: ImageHtmlOptions): CreateElementData[] {\n    const handleLeft = ROTATE_SIZE / 2;\n    return [\n        {\n            tag: 'div',\n            className: ImageEditElementClass.RotateCenter,\n            style: `position:absolute;left:50%;width:1px;background-color:${borderColor};top:${\n                disableSideResize ? -ROTATE_HANDLE_TOP_NO_SIDE_RESIZE : -ROTATE_HANDLE_TOP\n            }px;height:${ROTATE_GAP}px;margin-left:${-ROTATE_WIDTH}px;`,\n            children: [\n                {\n                    tag: 'div',\n                    className: ImageEditElementClass.RotateHandle,\n                    style: `position:absolute;background-color:${rotateHandleBackColor};border:solid 1px ${borderColor};border-radius:50%;width:${ROTATE_SIZE}px;height:${ROTATE_SIZE}px;left:-${\n                        handleLeft + ROTATE_WIDTH\n                    }px;cursor:move;top:${-ROTATE_SIZE}px;line-height: 0px;`,\n                    children: [getRotateIconHTML(borderColor)],\n                },\n            ],\n        },\n    ];\n}\n\nfunction getRotateIconHTML(borderColor: string): CreateElementData {\n    return {\n        tag: 'svg',\n        namespace: 'http://www.w3.org/2000/svg',\n        style: `width:16px;height:16px;margin: ${ROTATE_ICON_MARGIN}px ${ROTATE_ICON_MARGIN}px`,\n        children: [\n            {\n                tag: 'path',\n                namespace: 'http://www.w3.org/2000/svg',\n                attributes: {\n                    d: 'M 10.5,10.0 A 3.8,3.8 0 1 1 6.7,6.3',\n                    transform: 'matrix(1.1 1.1 -1.1 1.1 11.6 -10.8)',\n                    ['fill-opacity']: '0',\n                    stroke: borderColor,\n                },\n            },\n            {\n                tag: 'path',\n                namespace: 'http://www.w3.org/2000/svg',\n                attributes: {\n                    d: 'M12.0 3.648l.884-.884.53 2.298-2.298-.53z',\n                    stroke: borderColor,\n                },\n            },\n        ],\n    };\n}\n","import { DEFAULT_ROTATE_HANDLE_HEIGHT, DEG_PER_RAD } from '../constants/constants';\nimport type { ImageRotateMetadataFormat } from 'roosterjs-content-model-types';\nimport type { DragAndDropHandler } from '../../pluginUtils/DragAndDrop/DragAndDropHandler';\nimport type { DragAndDropContext } from '../types/DragAndDropContext';\n\n/**\n * @internal\n * The rotate drag and drop handler\n */\nexport const Rotator: DragAndDropHandler<DragAndDropContext, ImageRotateMetadataFormat> = {\n    onDragStart: ({ editInfo }) => ({ ...editInfo }),\n    onDragging: ({ editInfo, options }, e, base, deltaX, deltaY) => {\n        if (editInfo.heightPx) {\n            const distance = editInfo.heightPx / 2 + DEFAULT_ROTATE_HANDLE_HEIGHT;\n            const newX = distance * Math.sin(base.angleRad ?? 0) + deltaX;\n            const newY = distance * Math.cos(base.angleRad ?? 0) - deltaY;\n            let angleInRad = Math.atan2(newX, newY);\n\n            if (!e.altKey && options && options.minRotateDeg !== undefined) {\n                const angleInDeg = angleInRad * DEG_PER_RAD;\n                const adjustedAngleInDeg =\n                    Math.round(angleInDeg / options.minRotateDeg) * options.minRotateDeg;\n                angleInRad = adjustedAngleInDeg / DEG_PER_RAD;\n            }\n\n            if (editInfo.angleRad != angleInRad) {\n                editInfo.angleRad = angleInRad;\n                return true;\n            }\n        }\n        return false;\n    },\n};\n","import { DEG_PER_RAD, RESIZE_HANDLE_MARGIN, ROTATE_GAP, ROTATE_SIZE } from '../constants/constants';\nimport type { Rect } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Move rotate handle. When image is very close to the border of editor, rotate handle may not be visible.\n * Fix it by reduce the distance from image to rotate handle\n */\nexport function updateRotateHandle(\n    editorRect: Rect,\n    angleRad: number,\n    wrapper: HTMLElement,\n    rotateCenter: HTMLElement,\n    rotateHandle: HTMLElement,\n    isSmallImage: boolean,\n    disableSideResize: boolean\n) {\n    if (isSmallImage) {\n        rotateCenter.style.display = 'none';\n        rotateHandle.style.display = 'none';\n        return;\n    } else {\n        rotateCenter.style.display = '';\n        rotateHandle.style.display = '';\n        const rotateCenterRect = rotateCenter.getBoundingClientRect();\n        const wrapperRect = wrapper.getBoundingClientRect();\n        const ROTATOR_HEIGHT = ROTATE_SIZE + ROTATE_GAP + RESIZE_HANDLE_MARGIN;\n        if (rotateCenterRect && wrapperRect) {\n            let adjustedDistance = Number.MAX_SAFE_INTEGER;\n            const angle = angleRad * DEG_PER_RAD;\n\n            if (angle < 45 && angle > -45 && wrapperRect.top - editorRect.top < ROTATOR_HEIGHT) {\n                const top = rotateCenterRect.top - editorRect.top;\n                adjustedDistance = top;\n            } else if (\n                angle <= -80 &&\n                angle >= -100 &&\n                wrapperRect.left - editorRect.left < ROTATOR_HEIGHT\n            ) {\n                const left = rotateCenterRect.left - editorRect.left;\n                adjustedDistance = left;\n            } else if (\n                angle >= 80 &&\n                angle <= 100 &&\n                editorRect.right - wrapperRect.right < ROTATOR_HEIGHT\n            ) {\n                const right = rotateCenterRect.right - editorRect.right;\n                adjustedDistance = Math.min(editorRect.right - wrapperRect.right, right);\n            } else if (\n                (angle <= -160 || angle >= 160) &&\n                editorRect.bottom - wrapperRect.bottom < ROTATOR_HEIGHT\n            ) {\n                const bottom = rotateCenterRect.bottom - editorRect.bottom;\n                adjustedDistance = Math.min(editorRect.bottom - wrapperRect.bottom, bottom);\n            }\n\n            const rotateGap = Math.max(Math.min(ROTATE_GAP, adjustedDistance), 0);\n            const rotateTop = Math.max(Math.min(ROTATE_SIZE, adjustedDistance - rotateGap), 0);\n            rotateCenter.style.top =\n                -rotateGap - (disableSideResize ? 0 : RESIZE_HANDLE_MARGIN) + 'px';\n            rotateCenter.style.height = rotateGap + 'px';\n            rotateHandle.style.top = -rotateTop + 'px';\n        }\n    }\n}\n","import type { DNDDirectionX, DnDDirectionY } from '../types/DragAndDropContext';\n\n/**\n * @internal\n */\nexport const RESIZE_HANDLE_SIZE = 10;\n\n/**\n * @internal\n */\nexport const RESIZE_HANDLE_MARGIN = 6;\n\n/**\n * @internal\n */\nexport const ROTATE_SIZE = 32;\n\n/**\n * @internal\n */\nexport const ROTATE_GAP = 15;\n\n/**\n * @internal\n */\nexport const DEG_PER_RAD = 180 / Math.PI;\n\n/**\n * @internal\n */\nexport const DEFAULT_ROTATE_HANDLE_HEIGHT = ROTATE_SIZE / 2 + ROTATE_GAP;\n\n/**\n * @internal\n */\nexport const ROTATE_ICON_MARGIN = 8;\n\n/**\n * @internal\n */\nexport const ROTATION: Record<string, number> = {\n    sw: 0,\n    nw: 90,\n    ne: 180,\n    se: 270,\n};\n\n/**\n * @internal\n */\nexport const Xs: DNDDirectionX[] = ['w', '', 'e'];\n\n/**\n * @internal\n */\nexport const Ys: DnDDirectionY[] = ['s', '', 'n'];\n\n/**\n * @internal\n */\nexport const ROTATE_WIDTH = 1;\n\n/**\n * @internal\n */\nexport const ROTATE_HANDLE_TOP = ROTATE_GAP + RESIZE_HANDLE_MARGIN;\n\n/**\n * @internal\n */\nexport const ROTATE_HANDLE_TOP_NO_SIDE_RESIZE = ROTATE_GAP;\n\n/**\n * @internal\n */\nexport const CROP_HANDLE_SIZE = 22;\n\n/**\n * @internal\n */\nexport const CROP_HANDLE_WIDTH = 7;\n\n/**\n * @internal\n */\nexport const XS_CROP: DNDDirectionX[] = ['w', 'e'];\n\n/**\n * @internal\n */\nexport const YS_CROP: DnDDirectionY[] = ['s', 'n'];\n\n/**\n * @internal\n */\nexport const MIN_HEIGHT_WIDTH = 3 * RESIZE_HANDLE_SIZE + 2 * RESIZE_HANDLE_MARGIN;\n\n/**\n * @internal\n */\nexport const RESIZE_IMAGE = 'resizeImage';\n","/**\n * @internal\n * CSS class names for image editing elements\n */\nexport enum ImageEditElementClass {\n    /**\n     * CSS class name for resize handle\n     */\n    ResizeHandle = 'r_resizeH',\n\n    /**\n     * CSS class name for rotate handle\n     */\n    RotateHandle = 'r_rotateH',\n\n    /**\n     * CSS class name for the container of rotate handle\n     */\n    RotateCenter = 'r_rotateC',\n\n    /**\n     * CSS class name for crop overlay\n     */\n    CropOverlay = 'r_cropO',\n\n    /**\n     * CSS class name for container of crop handle\n     */\n    CropContainer = 'r_cropC',\n\n    /**\n     * CSS class name for crop handle\n     */\n    CropHandle = 'r_cropH',\n}\n","import { checkEditInfoState } from './checkEditInfoState';\nimport { generateDataURL } from './generateDataURL';\nimport { getGeneratedImageSize } from './generateImageSize';\nimport { updateImageEditInfo } from './updateImageEditInfo';\nimport type { ImageEditInfoState } from './checkEditInfoState';\nimport type {\n    ContentModelImage,\n    IEditor,\n    ImageMetadataFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Apply changes from the edit info of an image, write result to the image\n * @param editor The editor object that contains the image\n * @param image The image to apply the change\n * @param editInfo Edit info that contains the changed information of the image\n * @param previousSrc Last src value of the image before the change was made\n * @param wasResizedOrCropped if the image was resized or cropped apply the new image dimensions\n * @param editingImage (optional) Image in editing state\n */\nexport function applyChange(\n    editor: IEditor,\n    image: HTMLImageElement,\n    contentModelImage: ContentModelImage,\n    editInfo: ImageMetadataFormat,\n    previousSrc: string,\n    wasResizedOrCropped: boolean,\n    editingImage?: HTMLImageElement\n): ImageEditInfoState {\n    let newSrc = '';\n    const imageEditing = editingImage ?? image;\n    const initEditInfo = updateImageEditInfo(contentModelImage, imageEditing) ?? undefined;\n    const state = checkEditInfoState(editInfo, initEditInfo);\n\n    switch (state) {\n        case 'ResizeOnly':\n            // For resize only case, no need to generate a new image, just reuse the original one\n            newSrc = editInfo.src || '';\n            break;\n        case 'SameWithLast':\n            // For SameWithLast case, image may be resized but the content is still the same with last one,\n            // so no need to create a new image, but just reuse last one\n            newSrc = previousSrc;\n            break;\n        case 'FullyChanged':\n            // For other cases (cropped, rotated, ...) we need to create a new image to reflect the change\n            newSrc = generateDataURL(editingImage ?? image, editInfo);\n            break;\n    }\n\n    const srcChanged = newSrc != previousSrc;\n\n    if (srcChanged) {\n        // If the src is changed, fire an EditImage event so that plugins knows that a new image is used, and can\n        // replace the new src with some other string and it will be used and set to the image\n        const event = editor.triggerEvent('editImage', {\n            image: image,\n            originalSrc: editInfo.src || image.src,\n            previousSrc,\n            newSrc,\n        });\n        newSrc = event.newSrc;\n    }\n\n    if (newSrc == editInfo.src) {\n        // If newSrc is the same with original one, it means there is only size change, but no rotation, no cropping,\n        // so we don't need to keep edit info, we can delete it\n        updateImageEditInfo(contentModelImage, imageEditing, null);\n    } else {\n        // Otherwise, save the new edit info to the image so that next time when we edit the same image, we know\n        // the edit info\n        updateImageEditInfo(contentModelImage, imageEditing, editInfo);\n    }\n\n    // Write back the change to image, and set its new size\n    const generatedImageSize = getGeneratedImageSize(editInfo);\n\n    if (generatedImageSize) {\n        contentModelImage.src = newSrc;\n\n        if (wasResizedOrCropped || state == 'FullyChanged') {\n            contentModelImage.format.width = generatedImageSize.targetWidth + 'px';\n            contentModelImage.format.height = generatedImageSize.targetHeight + 'px';\n        }\n    }\n\n    return state;\n}\n","/**\n * @internal\n * Check if we can regenerate edited image from the source image.\n * An image can't regenerate result when there is CORS issue of the source content.\n * @param img The image element to test\n * @returns True when we can regenerate the edited image, otherwise false\n */\nexport function canRegenerateImage(img: HTMLImageElement | null): boolean {\n    if (!img) {\n        return false;\n    }\n\n    try {\n        const canvas = img.ownerDocument.createElement('canvas');\n        canvas.width = 10;\n        canvas.height = 10;\n        const context = canvas.getContext('2d');\n        if (context) {\n            context.drawImage(img, 0, 0);\n            context.getImageData(0, 0, 1, 1);\n            return true;\n        }\n\n        return false;\n    } catch {\n        return false;\n    }\n}\n","import type {\n    ImageCropMetadataFormat,\n    ImageMetadataFormat,\n    ImageResizeMetadataFormat,\n    ImageRotateMetadataFormat,\n} from 'roosterjs-content-model-types';\n\nconst RESIZE_KEYS: (keyof ImageResizeMetadataFormat)[] = ['widthPx', 'heightPx'];\nconst ROTATE_KEYS: (keyof ImageRotateMetadataFormat)[] = ['angleRad'];\nconst CROP_KEYS: (keyof ImageCropMetadataFormat)[] = [\n    'leftPercent',\n    'rightPercent',\n    'topPercent',\n    'bottomPercent',\n];\nconst ROTATE_CROP_KEYS: (keyof ImageRotateMetadataFormat | keyof ImageCropMetadataFormat)[] = [\n    ...ROTATE_KEYS,\n    ...CROP_KEYS,\n];\nconst ALL_KEYS = [...ROTATE_CROP_KEYS, ...RESIZE_KEYS];\n\n/**\n * @internal\n * State of an edit info object for image editing.\n * It is returned by checkEditInfoState() function\n */\nexport type ImageEditInfoState =\n    /**\n     * Invalid edit info. It means the given edit info object is either null,\n     * or not all its member are of correct type\n     */\n    | 'Invalid'\n\n    /**\n     * The edit info shows that it is only potentially edited by resizing action.\n     * Image is not rotated or cropped, or event not changed at all.\n     */\n    | 'ResizeOnly'\n\n    /**\n     * When compare with another edit info, this value can be returned when both current\n     * edit info and the other one are not been rotated, and they have same cropping\n     * percentages. So that they can share the same image src, only width and height\n     * need to be adjusted.\n     */\n    | 'SameWithLast'\n\n    /**\n     * When this value is returned, it means the image is edited by either cropping or\n     * rotation, or both. Image source can't be reused, need to generate a new image src\n     * data uri.\n     */\n    | 'FullyChanged';\n\n/**\n * @internal\n * Check the state of an edit info\n * @param editInfo The edit info to check\n * @param compareTo An optional edit info to compare to\n * @returns If the source edit info is not valid (wrong type, missing field, ...), returns Invalid.\n * If the source edit info doesn't contain any rotation or cropping, returns ResizeOnly\n * If the compare edit info exists, and both of them don't contain rotation, and the have same cropping values,\n * returns SameWithLast. Otherwise, returns FullyChanged\n */\nexport function checkEditInfoState(\n    editInfo: ImageMetadataFormat,\n    compareTo?: ImageMetadataFormat\n): ImageEditInfoState {\n    if (!editInfo || !editInfo.src || ALL_KEYS.some(key => !isNumber(editInfo[key]))) {\n        return 'Invalid';\n    } else if (\n        ROTATE_CROP_KEYS.every(key => areSameNumber(editInfo[key], 0)) &&\n        !editInfo.flippedHorizontal &&\n        !editInfo.flippedVertical &&\n        (!compareTo || (compareTo && editInfo.angleRad === compareTo.angleRad))\n    ) {\n        return 'ResizeOnly';\n    } else if (\n        compareTo &&\n        ROTATE_KEYS.every(key => areSameNumber(editInfo[key], compareTo[key])) &&\n        CROP_KEYS.every(key => areSameNumber(editInfo[key], compareTo[key])) &&\n        compareTo.flippedHorizontal === editInfo.flippedHorizontal &&\n        compareTo.flippedVertical === editInfo.flippedVertical\n    ) {\n        return 'SameWithLast';\n    } else {\n        return 'FullyChanged';\n    }\n}\n\nfunction isNumber(o: any): o is number {\n    return typeof o === 'number';\n}\n\nfunction areSameNumber(n1?: number, n2?: number) {\n    return n1 != undefined && n2 != undefined && Math.abs(n1 - n2) < 1e-3;\n}\n","import { createImageCropper } from '../Cropper/createImageCropper';\nimport { createImageResizer } from '../Resizer/createImageResizer';\nimport { createImageRotator } from '../Rotator/createImageRotator';\nimport { wrap } from 'roosterjs-content-model-dom';\n\nimport type {\n    IEditor,\n    ImageEditOperation,\n    ImageMetadataFormat,\n} from 'roosterjs-content-model-types';\nimport type { ImageEditOptions } from '../types/ImageEditOptions';\nimport type { ImageHtmlOptions } from '../types/ImageHtmlOptions';\n\nconst IMAGE_EDIT_SHADOW_ROOT = 'ImageEditShadowRoot';\n\n/**\n * @internal\n */\nexport interface WrapperElements {\n    wrapper: HTMLSpanElement;\n    shadowSpan: HTMLElement;\n    imageClone: HTMLImageElement;\n    resizers: HTMLDivElement[];\n    rotators: HTMLDivElement[];\n    croppers: HTMLDivElement[];\n}\n\n/**\n * @internal\n */\nexport function createImageWrapper(\n    editor: IEditor,\n    image: HTMLImageElement,\n    options: ImageEditOptions,\n    editInfo: ImageMetadataFormat,\n    htmlOptions: ImageHtmlOptions,\n    operation: ImageEditOperation[]\n): WrapperElements {\n    const imageClone = cloneImage(image, editInfo);\n    const doc = editor.getDocument();\n\n    let rotators: HTMLDivElement[] = [];\n    if (!options.disableRotate && operation.indexOf('rotate') > -1) {\n        rotators = createImageRotator(doc, htmlOptions);\n    }\n    let resizers: HTMLDivElement[] = [];\n    if (operation.indexOf('resize') > -1) {\n        resizers = createImageResizer(doc, !!options.disableSideResize);\n    }\n\n    let croppers: HTMLDivElement[] = [];\n    if (operation.indexOf('crop') > -1) {\n        croppers = createImageCropper(doc);\n    }\n\n    const wrapper = createWrapper(\n        editor,\n        imageClone,\n        options,\n        editInfo,\n        resizers,\n        rotators,\n        croppers\n    );\n    const imageSpan = wrap(doc, image, 'span');\n    const shadowSpan = createShadowSpan(wrapper, imageSpan);\n    return { wrapper, shadowSpan, imageClone, resizers, rotators, croppers };\n}\n\nconst createShadowSpan = (wrapper: HTMLElement, imageSpan: HTMLSpanElement) => {\n    const shadowRoot = imageSpan.attachShadow({\n        mode: 'open',\n    });\n    imageSpan.id = IMAGE_EDIT_SHADOW_ROOT;\n    shadowRoot.appendChild(wrapper);\n    return imageSpan;\n};\n\nconst createWrapper = (\n    editor: IEditor,\n    image: HTMLImageElement,\n    options: ImageEditOptions,\n    editInfo: ImageMetadataFormat,\n    resizers?: HTMLDivElement[],\n    rotators?: HTMLDivElement[],\n    cropper?: HTMLDivElement[]\n) => {\n    const doc = editor.getDocument();\n    const wrapper = doc.createElement('span');\n    const imageBox = doc.createElement('div');\n\n    imageBox.setAttribute(\n        `style`,\n        `position:relative;width:100%;height:100%;overflow:hidden;transform:scale(1);`\n    );\n    imageBox.appendChild(image);\n    wrapper.setAttribute(\n        'style',\n        `font-size: 24px; margin: 0px; transform: rotate(${editInfo.angleRad ?? 0}rad);`\n    );\n    wrapper.style.display = editor.getEnvironment().isSafari\n        ? '-webkit-inline-flex'\n        : 'inline-flex';\n\n    const border = createBorder(editor, options.borderColor);\n    wrapper.appendChild(imageBox);\n    wrapper.appendChild(border);\n    wrapper.style.userSelect = 'none';\n\n    if (resizers && resizers?.length > 0) {\n        resizers.forEach(resizer => {\n            wrapper.appendChild(resizer);\n        });\n    }\n    if (rotators && rotators.length > 0) {\n        rotators.forEach(r => {\n            wrapper.appendChild(r);\n        });\n    }\n    if (cropper && cropper.length > 0) {\n        cropper.forEach(c => {\n            wrapper.appendChild(c);\n        });\n    }\n\n    return wrapper;\n};\n\nconst createBorder = (editor: IEditor, borderColor?: string) => {\n    const doc = editor.getDocument();\n    const resizeBorder = doc.createElement('div');\n    resizeBorder.setAttribute(\n        `style`,\n        `position:absolute;left:0;right:0;top:0;bottom:0;border:solid 2px ${borderColor};pointer-events:none;`\n    );\n    return resizeBorder;\n};\n\nconst cloneImage = (image: HTMLImageElement, editInfo: ImageMetadataFormat) => {\n    const imageClone = image.cloneNode(true) as HTMLImageElement;\n    imageClone.style.removeProperty('transform');\n    if (editInfo.src) {\n        imageClone.src = editInfo.src;\n        imageClone.removeAttribute('id');\n        imageClone.style.removeProperty('max-width');\n        imageClone.style.removeProperty('max-height');\n        imageClone.style.width = editInfo.widthPx + 'px';\n        imageClone.style.height = editInfo.heightPx + 'px';\n    }\n    return imageClone;\n};\n","import type { ImageMetadataFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Double check if the changed size can satisfy current width of container.\n * When resize an image and preserve ratio, its size can be limited by the size of container.\n * So we need to check the actual size and calculate the size again\n * @param editInfo Edit info of the image\n * @param preserveRatio Whether w/h ratio need to be preserved\n * @param actualWidth Actual width of the image after resize\n * @param actualHeight Actual height of the image after resize\n */\nexport function doubleCheckResize(\n    editInfo: ImageMetadataFormat,\n    preserveRatio: boolean,\n    actualWidth: number,\n    actualHeight: number\n) {\n    let { widthPx, heightPx } = editInfo;\n    if (widthPx == undefined || heightPx == undefined) {\n        return;\n    }\n    const ratio = heightPx > 0 ? widthPx / heightPx : 0;\n\n    actualWidth = Math.floor(actualWidth);\n    actualHeight = Math.floor(actualHeight);\n    widthPx = Math.floor(widthPx);\n    heightPx = Math.floor(heightPx);\n\n    editInfo.widthPx = actualWidth;\n    editInfo.heightPx = actualHeight;\n\n    if (preserveRatio && ratio > 0 && (widthPx !== actualWidth || heightPx !== actualHeight)) {\n        if (actualWidth < widthPx) {\n            editInfo.heightPx = actualWidth / ratio;\n        } else {\n            editInfo.widthPx = actualHeight * ratio;\n        }\n    }\n}\n","import { isElementOfType, isNodeOfType } from 'roosterjs-content-model-dom';\n\n/**\n * @internal\n */\nexport function filterInnerResizerHandles(resizeHandles: HTMLDivElement[]) {\n    return resizeHandles\n        .map(resizer => {\n            const resizeHandle = resizer.firstElementChild;\n            if (\n                isNodeOfType(resizeHandle, 'ELEMENT_NODE') &&\n                isElementOfType(resizeHandle, 'div')\n            ) {\n                return resizeHandle;\n            }\n        })\n        .filter(handle => !!handle) as HTMLDivElement[];\n}\n","import { queryContentModelBlocks } from 'roosterjs-content-model-api';\nimport type {\n    ReadonlyContentModelBlockGroup,\n    ReadonlyContentModelParagraph,\n} from 'roosterjs-content-model-types';\nimport type { ImageAndParagraph } from '../types/ImageAndParagraph';\n\n/**\n * @internal\n */\nexport const EDITING_MARKER = 'isEditing';\n\n/**\n * @internal\n */\nexport function findEditingImage(\n    group: ReadonlyContentModelBlockGroup,\n    imageId?: string\n): ImageAndParagraph | null {\n    let imageAndParagraph: ImageAndParagraph | null = null;\n    queryContentModelBlocks<ReadonlyContentModelParagraph>(\n        group,\n        'Paragraph',\n        (paragraph: ReadonlyContentModelParagraph): paragraph is ReadonlyContentModelParagraph => {\n            for (const segment of paragraph.segments) {\n                if (\n                    segment.segmentType == 'Image' &&\n                    ((imageId && segment.format.id == imageId) ||\n                        segment.format.imageState == EDITING_MARKER)\n                ) {\n                    imageAndParagraph = { image: segment, paragraph };\n                    return true;\n                }\n            }\n            return false;\n        },\n        true /*findFirstOnly*/\n    );\n\n    return imageAndParagraph;\n}\n","import { getGeneratedImageSize } from './generateImageSize';\nimport type { ImageMetadataFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Generate new dataURL from an image and edit info\n * @param image The image to generate data URL from. It is supposed to have original src loaded\n * @param editInfo Edit info of the image\n * @returns A BASE64 encoded string with image prefix that represents the content of the generated image.\n * If there are rotate/crop/resize info in the edit info, the generated image will also reflect the result.\n * It is possible to throw exception since the original image may not be able to read its content from\n * the code, so better check canRegenerateImage() of the image first.\n * @throws Exception when fail to generate dataURL from canvas\n */\nexport function generateDataURL(image: HTMLImageElement, editInfo: ImageMetadataFormat): string {\n    const generatedImageSize = getGeneratedImageSize(editInfo);\n    if (!generatedImageSize) {\n        return '';\n    }\n\n    const {\n        angleRad,\n        widthPx,\n        heightPx,\n        bottomPercent,\n        leftPercent,\n        rightPercent,\n        topPercent,\n        naturalWidth,\n        naturalHeight,\n    } = editInfo;\n    const angle = angleRad || 0;\n    const left = leftPercent || 0;\n    const right = rightPercent || 0;\n    const top = topPercent || 0;\n    const bottom = bottomPercent || 0;\n    const nHeight = naturalHeight || image.naturalHeight;\n    const nWidth = naturalWidth || image.naturalHeight;\n    const width = widthPx || image.clientWidth;\n    const height = heightPx || image.clientHeight;\n\n    const imageWidth = nWidth * (1 - left - right);\n    const imageHeight = nHeight * (1 - top - bottom);\n    const doc = image.ownerDocument;\n    const win = doc.defaultView;\n\n    // Adjust the canvas size and scaling for high display resolution\n    const devicePixelRatio = win?.devicePixelRatio || 1;\n    const canvas = doc.createElement('canvas');\n    const { targetWidth, targetHeight } = generatedImageSize;\n    canvas.width = targetWidth * devicePixelRatio;\n    canvas.height = targetHeight * devicePixelRatio;\n\n    const context = canvas.getContext('2d');\n\n    try {\n        if (context) {\n            context.scale(devicePixelRatio, devicePixelRatio);\n            context.translate(targetWidth / 2, targetHeight / 2);\n            context.rotate(angle);\n            context.scale(editInfo.flippedHorizontal ? -1 : 1, editInfo.flippedVertical ? -1 : 1);\n            context.drawImage(\n                image,\n                nWidth * left,\n                nHeight * top,\n                imageWidth,\n                imageHeight,\n                -width / 2,\n                -height / 2,\n                width,\n                height\n            );\n        }\n        return canvas.toDataURL('image/png', 1.0);\n    } catch {\n        return image.src;\n    }\n}\n","import type { ImageMetadataFormat } from 'roosterjs-content-model-types';\nimport type { GeneratedImageSize } from '../types/GeneratedImageSize';\n\n/**\n * @internal\n * Calculate the target size of an image.\n * For image that is not rotated, target size is the same with resizing/cropping size.\n * For image that is rotated, target size is calculated from resizing/cropping size and its rotate angle\n * Say an image is resized to 100w*100h, cropped 25% on each side, then rotated 45deg, so that cropped size\n * will be (both height and width) 100*(1-0.25-0,25) = 50px, then final image size will be 50*sqrt(2) = 71px\n * @param editInfo The edit info to calculate size from\n * @param beforeCrop True to calculate the full size of original image before crop, false to calculate the size\n * after crop\n * @returns A GeneratedImageSize object which contains original, visible and target target width and height of the image\n */\nexport function getGeneratedImageSize(\n    editInfo: ImageMetadataFormat,\n    beforeCrop?: boolean\n): GeneratedImageSize | undefined {\n    const {\n        widthPx: width,\n        heightPx: height,\n        angleRad,\n        leftPercent: left,\n        rightPercent: right,\n        topPercent: top,\n        bottomPercent: bottom,\n    } = editInfo;\n\n    if (\n        height == undefined ||\n        width == undefined ||\n        left == undefined ||\n        right == undefined ||\n        top == undefined ||\n        bottom == undefined\n    ) {\n        return;\n    }\n\n    const angle = angleRad ?? 0;\n\n    // Original image size before crop and rotate\n    const originalWidth = width / (1 - left - right);\n    const originalHeight = height / (1 - top - bottom);\n\n    // Visible size\n    const visibleWidth = beforeCrop ? originalWidth : width;\n    const visibleHeight = beforeCrop ? originalHeight : height;\n\n    // Target size after crop and rotate\n    const targetWidth =\n        Math.abs(visibleWidth * Math.cos(angle)) + Math.abs(visibleHeight * Math.sin(angle));\n    const targetHeight =\n        Math.abs(visibleWidth * Math.sin(angle)) + Math.abs(visibleHeight * Math.cos(angle));\n\n    return {\n        targetWidth,\n        targetHeight,\n        originalWidth,\n        originalHeight,\n        visibleWidth,\n        visibleHeight,\n    };\n}\n","import { DragAndDropHelper } from '../../pluginUtils/DragAndDrop/DragAndDropHelper';\nimport { toArray } from 'roosterjs-content-model-dom';\nimport type { ImageEditElementClass } from '../types/ImageEditElementClass';\nimport type { ImageMetadataFormat } from 'roosterjs-content-model-types';\nimport type { ImageEditOptions } from '../types/ImageEditOptions';\nimport type { DragAndDropHandler } from '../../pluginUtils/DragAndDrop/DragAndDropHandler';\nimport type { DragAndDropContext, DNDDirectionX, DnDDirectionY } from '../types/DragAndDropContext';\n\n/**\n * @internal\n */\nexport function getDropAndDragHelpers(\n    wrapper: HTMLElement,\n    editInfo: ImageMetadataFormat,\n    options: ImageEditOptions,\n    elementClass: ImageEditElementClass,\n    helper: DragAndDropHandler<DragAndDropContext, any>,\n    updateWrapper: (context: DragAndDropContext, _handle: HTMLElement) => void,\n    zoomScale: number,\n    useTouch: boolean\n): DragAndDropHelper<DragAndDropContext, any>[] {\n    return getEditElements(wrapper, elementClass).map(\n        element =>\n            new DragAndDropHelper<DragAndDropContext, any>(\n                element,\n                {\n                    editInfo: editInfo,\n                    options: options,\n                    elementClass,\n                    x: element.dataset.x as DNDDirectionX,\n                    y: element.dataset.y as DnDDirectionY,\n                },\n                updateWrapper,\n                helper,\n                zoomScale,\n                useTouch\n            )\n    );\n}\n\nfunction getEditElements(wrapper: HTMLElement, elementClass: ImageEditElementClass): HTMLElement[] {\n    return toArray(wrapper.querySelectorAll('.' + elementClass)) as HTMLElement[];\n}\n","import { isASmallImage } from './imageEditUtils';\nimport type { IEditor, ImageMetadataFormat } from 'roosterjs-content-model-types';\nimport type { ImageEditOptions } from '../types/ImageEditOptions';\nimport type { ImageHtmlOptions } from '../types/ImageHtmlOptions';\n\n/**\n * Default background colors for rotate handle\n */\nconst LIGHT_MODE_BGCOLOR = 'white';\nconst DARK_MODE_BGCOLOR = '#333';\n\n/**\n * @internal\n */\nexport const getHTMLImageOptions = (\n    editor: IEditor,\n    options: ImageEditOptions,\n    editInfo: ImageMetadataFormat\n): ImageHtmlOptions => {\n    return {\n        borderColor:\n            options.borderColor || (editor.isDarkMode() ? DARK_MODE_BGCOLOR : LIGHT_MODE_BGCOLOR),\n        rotateHandleBackColor: editor.isDarkMode() ? DARK_MODE_BGCOLOR : LIGHT_MODE_BGCOLOR,\n        isSmallImage: isASmallImage(editInfo.widthPx ?? 0, editInfo.heightPx ?? 0),\n        disableSideResize: !!options.disableSideResize,\n    };\n};\n","import { getSelectedSegmentsAndParagraphs } from 'roosterjs-content-model-dom';\nimport type { ReadonlyContentModelDocument } from 'roosterjs-content-model-types';\nimport type { ImageAndParagraph } from '../types/ImageAndParagraph';\n\n/**\n * @internal\n */\nexport function getSelectedImage(model: ReadonlyContentModelDocument): ImageAndParagraph | null {\n    const selections = getSelectedSegmentsAndParagraphs(model, false);\n\n    if (selections.length == 1 && selections[0][0].segmentType == 'Image' && selections[0][1]) {\n        return {\n            image: selections[0][0],\n            paragraph: selections[0][1],\n        };\n    } else {\n        return null;\n    }\n}\n","import { MIN_HEIGHT_WIDTH } from '../constants/constants';\n\n/**\n * @internal\n */\ninterface WrapperDimensions {\n    height: number;\n    width: number;\n}\n\n/**\n * @internal\n */\nexport function getPx(value: number): string {\n    return value + 'px';\n}\n\n/**\n * @internal\n */\nexport function isASmallImage(widthPx: number, heightPx: number): boolean {\n    return widthPx && heightPx && (widthPx < MIN_HEIGHT_WIDTH || heightPx < MIN_HEIGHT_WIDTH)\n        ? true\n        : false;\n}\n\n/**\n * @internal Calculate the rotated x and y distance for mouse moving\n * @param x Original x distance\n * @param y Original y distance\n * @param angle Rotated angle, in radian\n * @returns rotated x and y distances\n */\nexport function rotateCoordinate(x: number, y: number, angle: number): [number, number] {\n    if (x == 0 && y == 0) {\n        return [0, 0];\n    }\n    const hypotenuse = Math.sqrt(x * x + y * y);\n    angle = Math.atan2(y, x) - angle;\n    return [hypotenuse * Math.cos(angle), hypotenuse * Math.sin(angle)];\n}\n\n/**\n * @internal\n */\nexport function setFlipped(\n    element: HTMLElement | null,\n    flippedHorizontally?: boolean,\n    flippedVertically?: boolean\n) {\n    if (element) {\n        element.style.transform = `scale(${flippedHorizontally ? -1 : 1}, ${\n            flippedVertically ? -1 : 1\n        })`;\n    }\n}\n\n/**\n * @internal\n */\nexport function setWrapperSizeDimensions(\n    wrapper: HTMLElement,\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    isRotating: boolean\n) {\n    const hasBorder = image.style.borderStyle;\n    if (hasBorder) {\n        const borderWidth = image.style.borderWidth ? 2 * parseInt(image.style.borderWidth) : 2;\n        if (isRotating) {\n            wrapper.style.width = getPx(parseInt(image.style.width) + borderWidth);\n            wrapper.style.height = getPx(parseInt(image.style.height) + borderWidth);\n            return;\n        }\n        wrapper.style.width = getPx(width + borderWidth);\n        wrapper.style.height = getPx(height + borderWidth);\n        return;\n    }\n    wrapper.style.width = getPx(width);\n    wrapper.style.height = getPx(height);\n}\n\n/**\n * @internal\n */\nexport function setSize(\n    element: HTMLElement,\n    left: number | undefined,\n    top: number | undefined,\n    right: number | undefined,\n    bottom: number | undefined,\n    width: number | undefined,\n    height: number | undefined\n) {\n    element.style.left = left !== undefined ? getPx(left) : element.style.left;\n    element.style.top = top !== undefined ? getPx(top) : element.style.top;\n    element.style.right = right !== undefined ? getPx(right) : element.style.right;\n    element.style.bottom = bottom !== undefined ? getPx(bottom) : element.style.bottom;\n    element.style.width = width !== undefined ? getPx(width) : element.style.width;\n    element.style.height = height !== undefined ? getPx(height) : element.style.height;\n}\n\n/**\n * @internal\n * Check if the current image was resized by the user\n * @param image the current image\n * @returns if the user resized the image, returns true, otherwise, returns false\n */\nexport function checkIfImageWasResized(image: HTMLImageElement): boolean {\n    const { style } = image;\n    const isMaxWidthInitial =\n        style.maxWidth === '' || style.maxWidth === 'initial' || style.maxWidth === 'auto';\n    if (\n        isMaxWidthInitial &&\n        (isFixedNumberValue(style.height) || isFixedNumberValue(style.width))\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isFixedNumberValue(value: string | number) {\n    const numberValue = typeof value === 'string' ? parseInt(value) : value;\n    return !isNaN(numberValue);\n}\n\n/**\n * @internal\n */\nexport function getActualWrapperDimensions(\n    image: HTMLImageElement,\n    wrapperWidth: number,\n    wrapperHeight: number\n): WrapperDimensions {\n    const hasBorder = image.style.borderStyle;\n    const borderWidth =\n        hasBorder && image.style.borderWidth\n            ? 2 * parseInt(image.style.borderWidth)\n            : hasBorder\n            ? 2\n            : 0;\n\n    return {\n        width: wrapperWidth - borderWidth,\n        height: wrapperHeight - borderWidth,\n    };\n}\n","import { mutateBlock } from 'roosterjs-content-model-dom';\nimport type { ImageAndParagraph } from '../types/ImageAndParagraph';\n\n/**\n * Selecting directly on the image will only capture the image segment.\n * However, if the selection is made while the image is within a wrapper, it will capture the span that encloses the image.\n * In the last case, the selection will be marked as <---SelectionMarker---><---Image---><---SelectionMarker--->.\n * To fix this behavior the extra selection markers are removed.\n * @internal\n */\nexport function normalizeImageSelection(imageAndParagraph: ImageAndParagraph) {\n    const paragraph = imageAndParagraph.paragraph;\n    const index = paragraph.segments.indexOf(imageAndParagraph.image);\n    if (index > 0) {\n        const markerBefore = paragraph.segments[index - 1];\n        const markerAfter = paragraph.segments[index + 1];\n        if (\n            markerBefore &&\n            markerAfter &&\n            markerAfter.segmentType == 'SelectionMarker' &&\n            markerBefore.segmentType == 'SelectionMarker' &&\n            markerAfter.isSelected &&\n            markerBefore.isSelected\n        ) {\n            const mutatedParagraph = mutateBlock(paragraph);\n            mutatedParagraph.segments.splice(index - 1, 1);\n            mutatedParagraph.segments.splice(index, 1);\n        }\n        return imageAndParagraph;\n    }\n}\n","const PI = Math.PI;\nconst DIRECTIONS = 8;\nconst DirectionRad = (PI * 2) / DIRECTIONS;\nconst DirectionOrder = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];\n\nfunction handleRadIndexCalculator(angleRad: number): number {\n    const idx = Math.round(angleRad / DirectionRad) % DIRECTIONS;\n    return idx < 0 ? idx + DIRECTIONS : idx;\n}\n\nfunction rotateHandles(angleRad: number, y: string = '', x: string = ''): string {\n    const radIndex = handleRadIndexCalculator(angleRad);\n    const originalDirection = y + x;\n    const originalIndex = DirectionOrder.indexOf(originalDirection);\n    const rotatedIndex = originalIndex >= 0 && originalIndex + radIndex;\n    return rotatedIndex ? DirectionOrder[rotatedIndex % DIRECTIONS] : '';\n}\n/**\n * @internal\n * Rotate the resizer and cropper handles according to the image position.\n * @param handles The resizer handles.\n * @param angleRad The angle that the image was rotated.\n */\nexport function updateHandleCursor(handles: HTMLElement[], angleRad: number) {\n    handles.forEach(handle => {\n        const { y, x } = handle.dataset;\n        handle.style.cursor = `${rotateHandles(angleRad, y, x)}-resize`;\n    });\n}\n","import { getSelectedImage } from './getSelectedImage';\nimport { mutateSegment, updateImageMetadata } from 'roosterjs-content-model-dom';\n\nimport type {\n    ContentModelImage,\n    IEditor,\n    ImageMetadataFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function updateImageEditInfo(\n    contentModelImage: ContentModelImage,\n    image: HTMLImageElement,\n    newImageMetadata?: ImageMetadataFormat | null | undefined\n): ImageMetadataFormat {\n    const contentModelMetadata = updateImageMetadata(\n        contentModelImage,\n        newImageMetadata !== undefined\n            ? format => {\n                  format = newImageMetadata;\n                  return format;\n              }\n            : undefined\n    );\n    return { ...getInitialEditInfo(image), ...contentModelMetadata };\n}\n\nfunction getInitialEditInfo(image: HTMLImageElement): ImageMetadataFormat {\n    return {\n        src: image.getAttribute('src') || '',\n        widthPx: image.clientWidth,\n        heightPx: image.clientHeight,\n        naturalWidth: image.naturalWidth,\n        naturalHeight: image.naturalHeight,\n        leftPercent: 0,\n        rightPercent: 0,\n        topPercent: 0,\n        bottomPercent: 0,\n        angleRad: 0,\n    };\n}\n\n/**\n * @internal\n * @returns\n */\nexport function getSelectedImageMetadata(\n    editor: IEditor,\n    image: HTMLImageElement\n): ImageMetadataFormat {\n    let imageMetadata: ImageMetadataFormat = getInitialEditInfo(image);\n    editor.formatContentModel(model => {\n        const selectedImage = getSelectedImage(model);\n        if (selectedImage?.image) {\n            mutateSegment(selectedImage.paragraph, selectedImage?.image, modelImage => {\n                imageMetadata = updateImageEditInfo(modelImage, image);\n            });\n\n            return true;\n        }\n        return false;\n    });\n\n    return imageMetadata;\n}\n","import { doubleCheckResize } from './doubleCheckResize';\nimport { filterInnerResizerHandles } from './filterInnerResizerHandles';\nimport { getGeneratedImageSize } from './generateImageSize';\nimport { ImageEditElementClass } from '../types/ImageEditElementClass';\nimport { toArray } from 'roosterjs-content-model-dom';\nimport { updateHandleCursor } from './updateHandleCursor';\nimport { updateSideHandlesVisibility } from '../Resizer/updateSideHandlesVisibility';\nimport type { ImageEditOptions } from '../types/ImageEditOptions';\nimport type { ImageMetadataFormat } from 'roosterjs-content-model-types';\nimport {\n    getActualWrapperDimensions,\n    getPx,\n    isASmallImage,\n    setFlipped,\n    setSize,\n    setWrapperSizeDimensions,\n} from './imageEditUtils';\n\n/**\n * @internal\n */\nexport function updateWrapper(\n    editInfo: ImageMetadataFormat,\n    options: ImageEditOptions,\n    image: HTMLImageElement,\n    clonedImage: HTMLImageElement,\n    wrapper: HTMLSpanElement,\n    resizers?: HTMLDivElement[],\n    croppers?: HTMLDivElement[],\n    isRTL?: boolean,\n    isRotating?: boolean\n) {\n    const {\n        angleRad,\n        bottomPercent,\n        leftPercent,\n        rightPercent,\n        topPercent,\n        flippedHorizontal,\n        flippedVertical,\n    } = editInfo;\n\n    const generateImageSize = getGeneratedImageSize(editInfo, croppers && croppers?.length > 0);\n    if (!generateImageSize) {\n        return;\n    }\n    const {\n        targetWidth,\n        targetHeight,\n        originalWidth,\n        originalHeight,\n        visibleWidth,\n        visibleHeight,\n    } = generateImageSize;\n\n    const marginHorizontal = (targetWidth - visibleWidth) / 2;\n    const marginVertical = (targetHeight - visibleHeight) / 2;\n    const cropLeftPx = originalWidth * (leftPercent || 0);\n    const cropRightPx = originalWidth * (rightPercent || 0);\n    const cropTopPx = originalHeight * (topPercent || 0);\n    const cropBottomPx = originalHeight * (bottomPercent || 0);\n\n    // Update size and margin of the wrapper\n    wrapper.style.marginTop = `${marginVertical}px`;\n    wrapper.style.marginBottom = `${marginVertical + 5}px `; // 5px to adjust the image on top of the handles\n    wrapper.style.marginLeft = `${marginHorizontal}px`;\n    wrapper.style.marginRight = `${marginHorizontal}px`;\n\n    wrapper.style.transform = `rotate(${angleRad}rad)`;\n    setWrapperSizeDimensions(wrapper, image, visibleWidth, visibleHeight, !!isRotating);\n    wrapper.style.verticalAlign = 'text-bottom';\n\n    // Update the text-alignment to avoid the image to overflow if the parent element have align center or right\n    // or if the direction is Right To Left\n    if (isRTL) {\n        wrapper.style.textAlign = 'right';\n        if (!croppers) {\n            clonedImage.style.left = getPx(cropLeftPx);\n            clonedImage.style.right = getPx(-cropRightPx);\n        }\n    } else {\n        wrapper.style.textAlign = 'left';\n    }\n\n    if (!isRotating) {\n        // Update size of the image\n        clonedImage.style.width = getPx(originalWidth);\n        clonedImage.style.height = getPx(originalHeight);\n    }\n\n    clonedImage.style.position = 'absolute';\n\n    //Update flip direction\n    setFlipped(clonedImage.parentElement, flippedHorizontal, flippedVertical);\n    const smallImage = isASmallImage(visibleWidth, visibleWidth);\n\n    if (!croppers) {\n        // For rotate/resize, set the margin of the image so that cropped part won't be visible\n        clonedImage.style.margin = `${-cropTopPx}px 0 0 ${-cropLeftPx}px`;\n    }\n\n    if (croppers && croppers.length > 0) {\n        const cropContainer = croppers[0];\n        const cropOverlays = croppers.filter(\n            cropper => cropper.className === ImageEditElementClass.CropOverlay\n        );\n        const cropHandles = toArray<HTMLElement>(\n            cropContainer.querySelectorAll(`.${ImageEditElementClass.CropHandle}`)\n        );\n\n        setSize(\n            cropContainer,\n            cropLeftPx,\n            cropTopPx,\n            cropRightPx,\n            cropBottomPx,\n            undefined,\n            undefined\n        );\n        setSize(cropOverlays[0], 0, 0, cropRightPx, undefined, undefined, cropTopPx);\n        setSize(cropOverlays[1], undefined, 0, 0, cropBottomPx, cropRightPx, undefined);\n        setSize(cropOverlays[2], cropLeftPx, undefined, 0, 0, undefined, cropBottomPx);\n        setSize(cropOverlays[3], 0, cropTopPx, undefined, 0, cropLeftPx, undefined);\n\n        if (angleRad !== undefined) {\n            updateHandleCursor(cropHandles, angleRad);\n        }\n    }\n\n    if (resizers && !isRotating) {\n        const clientWidth = wrapper.clientWidth;\n        const clientHeight = wrapper.clientHeight;\n\n        const actualDimensions = getActualWrapperDimensions(image, clientWidth, clientHeight);\n\n        doubleCheckResize(\n            editInfo,\n            options.preserveRatio || false,\n            actualDimensions.width,\n            actualDimensions.height\n        );\n\n        const resizeHandles = filterInnerResizerHandles(resizers);\n\n        if (angleRad !== undefined) {\n            updateHandleCursor(resizeHandles, angleRad);\n        }\n\n        updateSideHandlesVisibility(resizeHandles, smallImage);\n    }\n}\n","export { TableEditPlugin } from './tableEdit/TableEditPlugin';\nexport { OnTableEditorCreatedCallback } from './tableEdit/OnTableEditorCreatedCallback';\nexport { TableEditFeatureName } from './tableEdit/editors/features/TableEditFeatureName';\nexport { TableWithRoot } from './tableEdit/TableWithRoot';\nexport { PastePlugin } from './paste/PastePlugin';\nexport { DefaultSanitizers } from './paste/DefaultSanitizers';\nexport { EditPlugin } from './edit/EditPlugin';\nexport { EditOptions, HandleTabOptions } from './edit/EditOptions';\nexport { AutoFormatPlugin } from './autoFormat/AutoFormatPlugin';\nexport { AutoFormatOptions } from './autoFormat/interface/AutoFormatOptions';\n\nexport {\n    ShortcutBold,\n    ShortcutItalic,\n    ShortcutUnderline,\n    ShortcutClearFormat,\n    ShortcutUndo,\n    ShortcutUndo2,\n    ShortcutRedo,\n    ShortcutRedoAlt,\n    ShortcutRedoMacOS,\n    ShortcutBullet,\n    ShortcutNumbering,\n    ShortcutIncreaseFont,\n    ShortcutDecreaseFont,\n    ShortcutIndentList,\n    ShortcutOutdentList,\n} from './shortcut/shortcuts';\nexport { ShortcutPlugin } from './shortcut/ShortcutPlugin';\nexport { ShortcutKeyDefinition, ShortcutCommand } from './shortcut/ShortcutCommand';\nexport { ContextMenuPluginBase, ContextMenuOptions } from './contextMenuBase/ContextMenuPluginBase';\nexport { WatermarkPlugin } from './watermark/WatermarkPlugin';\nexport { WatermarkFormat } from './watermark/WatermarkFormat';\nexport { isModelEmptyFast } from './watermark/isModelEmptyFast';\nexport { MarkdownPlugin, MarkdownOptions } from './markdown/MarkdownPlugin';\nexport { HyperlinkPlugin } from './hyperlink/HyperlinkPlugin';\nexport { HyperlinkToolTip } from './hyperlink/HyperlinkToolTip';\nexport { PickerPlugin } from './picker/PickerPlugin';\nexport { PickerHelper } from './picker/PickerHelper';\nexport { PickerSelectionChangMode, PickerDirection, PickerHandler } from './picker/PickerHandler';\nexport { CustomReplacePlugin, CustomReplace } from './customReplace/CustomReplacePlugin';\nexport { ImageEditPlugin } from './imageEdit/ImageEditPlugin';\nexport { ImageEditOptions } from './imageEdit/types/ImageEditOptions';\nexport { HiddenPropertyPlugin } from './hiddenProperty/HiddenPropertyPlugin';\nexport { HiddenPropertyOptions } from './hiddenProperty/HiddenPropertyOptions';\nexport { TouchPlugin } from './touch/TouchPlugin';\nexport { FindReplacePlugin } from './findReplace/FindReplacePlugin';\nexport { createFindReplaceContext } from './findReplace/createFindReplaceContext';\nexport { find } from './findReplace/find';\nexport { replace } from './findReplace/replace';\nexport { moveHighlight } from './findReplace/moveHighlight';\nexport { FindReplaceContext } from './findReplace/types/FindReplaceContext';\nexport { HighlightHelper } from './findReplace/types/HighlightHelper';\nexport { FindReplaceHighlightOptions } from './findReplace/types/FindReplaceHighlightOptions';\nexport { AnnouncePlugin } from './announce/AnnouncePlugin';\n","import { setFormat } from './utils/setFormat';\nimport type {\n    ContentChangedEvent,\n    ContentModelCodeFormat,\n    EditorInputEvent,\n    EditorPlugin,\n    IEditor,\n    KeyDownEvent,\n    PluginEvent,\n} from 'roosterjs-content-model-types';\n\n/**\n *\n * Options for Markdown plugin\n *  - strikethrough: If true text between ~ will receive strikethrough format.\n *  - bold: If true text between * will receive bold format.\n *  - italic: If true text between _ will receive italic format.\n *  - codeFormat: If provided, text between ` will receive code format. If equal to {}, it will set the default code format.\n */\nexport interface MarkdownOptions {\n    strikethrough?: boolean;\n    bold?: boolean;\n    italic?: boolean;\n    codeFormat?: ContentModelCodeFormat;\n}\n\n/**\n * @internal\n */\nconst DefaultOptions: Partial<MarkdownOptions> = {\n    strikethrough: false,\n    bold: false,\n    italic: false,\n};\n\n/**\n * Markdown plugin handles markdown formatting, such as transforming * characters into bold text.\n */\nexport class MarkdownPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private shouldBold = false;\n    private shouldItalic = false;\n    private shouldStrikethrough = false;\n    private shouldCode = false;\n    private lastKeyTyped: string | null = null;\n\n    /**\n     * @param options An optional parameter that takes in an object of type MarkdownOptions, which includes the following properties:\n     *  - strikethrough: If true text between ~ will receive strikethrough format. Defaults to false.\n     *  - bold: If true text between * will receive bold format. Defaults to false.\n     *  - italic: If true text between _ will receive italic format. Defaults to false.\n     *  - codeFormat: If provided, text between ` will receive code format. Defaults to undefined.\n     */\n    constructor(private options: MarkdownOptions = DefaultOptions) {}\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'Markdown';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n        this.disableAllFeatures();\n        this.lastKeyTyped = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case 'input':\n                    this.handleEditorInputEvent(this.editor, event);\n                    break;\n                case 'keyDown':\n                    this.handleBackspaceEvent(event);\n                    this.handleKeyDownEvent(event);\n                    break;\n                case 'contentChanged':\n                    this.handleContentChangedEvent(event);\n                    break;\n            }\n        }\n    }\n\n    private handleEditorInputEvent(editor: IEditor, event: EditorInputEvent) {\n        const rawEvent = event.rawEvent;\n        const selection = editor.getDOMSelection();\n        if (\n            selection &&\n            selection.type == 'range' &&\n            selection.range.collapsed &&\n            rawEvent.inputType == 'insertText'\n        ) {\n            switch (rawEvent.data) {\n                case '*':\n                    if (this.options.bold) {\n                        if (this.shouldBold) {\n                            setFormat(editor, '*', { fontWeight: 'bold' });\n                            this.shouldBold = false;\n                        } else {\n                            this.shouldBold = true;\n                        }\n                    }\n\n                    break;\n                case '~':\n                    if (this.options.strikethrough) {\n                        if (this.shouldStrikethrough) {\n                            setFormat(editor, '~', { strikethrough: true });\n                            this.shouldStrikethrough = false;\n                        } else {\n                            this.shouldStrikethrough = true;\n                        }\n                    }\n                    break;\n                case '_':\n                    if (this.options.italic) {\n                        if (this.shouldItalic) {\n                            setFormat(editor, '_', { italic: true });\n                            this.shouldItalic = false;\n                        } else {\n                            this.shouldItalic = true;\n                        }\n                    }\n                    break;\n                case '`':\n                    if (this.options.codeFormat) {\n                        if (this.shouldCode) {\n                            setFormat(editor, '`', {} /* format */, this.options.codeFormat);\n                            this.shouldCode = false;\n                        } else {\n                            this.shouldCode = true;\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    private handleKeyDownEvent(event: KeyDownEvent) {\n        const rawEvent = event.rawEvent;\n        if (!event.handledByEditFeature && !rawEvent.defaultPrevented) {\n            switch (rawEvent.key) {\n                case 'Enter':\n                    this.disableAllFeatures();\n                    this.lastKeyTyped = null;\n                    break;\n                case ' ':\n                    if (this.lastKeyTyped === '*' && this.shouldBold) {\n                        this.shouldBold = false;\n                    } else if (this.lastKeyTyped === '~' && this.shouldStrikethrough) {\n                        this.shouldStrikethrough = false;\n                    } else if (this.lastKeyTyped === '_' && this.shouldItalic) {\n                        this.shouldItalic = false;\n                    } else if (this.lastKeyTyped === '`' && this.shouldCode) {\n                        this.shouldCode = false;\n                    }\n                    this.lastKeyTyped = null;\n                    break;\n                default:\n                    this.lastKeyTyped = rawEvent.key;\n                    break;\n            }\n        }\n    }\n\n    private handleBackspaceEvent(event: KeyDownEvent) {\n        if (!event.handledByEditFeature && event.rawEvent.key === 'Backspace') {\n            if (this.lastKeyTyped === '*' && this.shouldBold) {\n                this.shouldBold = false;\n            } else if (this.lastKeyTyped === '~' && this.shouldStrikethrough) {\n                this.shouldStrikethrough = false;\n            } else if (this.lastKeyTyped === '_' && this.shouldItalic) {\n                this.shouldItalic = false;\n            } else if (this.lastKeyTyped === '`' && this.shouldCode) {\n                this.shouldCode = false;\n            }\n            this.lastKeyTyped = null;\n        }\n    }\n\n    private handleContentChangedEvent(event: ContentChangedEvent) {\n        if (event.source == 'Format') {\n            this.disableAllFeatures();\n        }\n    }\n\n    private disableAllFeatures() {\n        this.shouldBold = false;\n        this.shouldItalic = false;\n        this.shouldStrikethrough = false;\n        this.shouldCode = false;\n    }\n}\n","import {\n    formatTextSegmentBeforeSelectionMarker,\n    splitTextSegment,\n} from 'roosterjs-content-model-api';\nimport type {\n    ContentModelCodeFormat,\n    ContentModelSegmentFormat,\n    IEditor,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function setFormat(\n    editor: IEditor,\n    character: string,\n    format: ContentModelSegmentFormat,\n    codeFormat?: ContentModelCodeFormat\n) {\n    formatTextSegmentBeforeSelectionMarker(\n        editor,\n        (_model, previousSegment, paragraph, markerFormat, context) => {\n            if (previousSegment.text[previousSegment.text.length - 1] == character) {\n                const textSegment = previousSegment.text;\n                const textBeforeMarker = textSegment.slice(0, -1);\n                context.newPendingFormat = {\n                    ...markerFormat,\n                    strikethrough: !!markerFormat.strikethrough,\n                    italic: !!markerFormat.italic,\n                    fontWeight: markerFormat?.fontWeight ? 'bold' : undefined,\n                };\n                if (textBeforeMarker.indexOf(character) > -1) {\n                    const lastCharIndex = textSegment.length;\n                    const firstCharIndex = textSegment\n                        .substring(0, lastCharIndex - 1)\n                        .lastIndexOf(character);\n\n                    if (\n                        hasSpaceBeforeFirstCharacter(textSegment, firstCharIndex) &&\n                        lastCharIndex - firstCharIndex > 2\n                    ) {\n                        const formattedText = splitTextSegment(\n                            previousSegment,\n                            paragraph,\n                            firstCharIndex,\n                            lastCharIndex\n                        );\n\n                        formattedText.text = formattedText.text.replace(character, '').slice(0, -1);\n                        formattedText.format = {\n                            ...formattedText.format,\n                            ...format,\n                        };\n                        if (codeFormat) {\n                            formattedText.code = {\n                                format: codeFormat,\n                            };\n                        }\n\n                        context.canUndoByBackspace = true;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    );\n}\n\n/**\n * The markdown should not be trigger inside a word, then check if exist a space before the trigger character\n * Should trigger markdown example: _one two_\n * Should not trigger markdown example: one_two_\n */\nfunction hasSpaceBeforeFirstCharacter(text: string, index: number) {\n    return !text[index - 1] || text[index - 1].trim().length == 0;\n}\n","import type { ValueSanitizer } from 'roosterjs-content-model-types';\n\n/**\n * Default style sanitizers for PastePlugin.\n */\nexport const DefaultSanitizers: Record<string, ValueSanitizer> = {\n    width: divParagraphSanitizer,\n    height: divParagraphSanitizer,\n    'inline-size': divParagraphSanitizer,\n    'block-size': divParagraphSanitizer,\n};\n\n/**\n * @internal\n * exported only for unit test\n */\nexport function divParagraphSanitizer(value: string, tagName: string): string | null {\n    const tag = tagName.toLowerCase();\n    if (tag == 'div' || tag == 'p') {\n        return null;\n    }\n    return value;\n}\n","import { addParser } from '../utils/addParser';\nimport { isNodeOfType, moveChildNodes } from 'roosterjs-content-model-dom';\nimport { setProcessor } from '../utils/setProcessor';\nimport type {\n    BeforePasteEvent,\n    ClipboardData,\n    DOMCreator,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\nconst TABLE_SELECTOR = 'table';\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\n\n/**\n * @internal\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\n * @param event The BeforePaste event\n * @param domCreator The DOM creator\n * @param allowExcelNoBorderTable Allow table copied from Excel without border\n * @param isNativeEvent Whether the event is native event\n */\nexport function processPastedContentFromExcel(\n    event: BeforePasteEvent,\n    domCreator: DOMCreator,\n    allowExcelNoBorderTable: boolean,\n    isNativeEvent: boolean\n) {\n    const { fragment, htmlBefore, htmlAfter, clipboardData } = event;\n\n    // For non native event we already validated that the content contains a table\n    if (isNativeEvent) {\n        validateExcelFragment(fragment, domCreator, htmlBefore, clipboardData, htmlAfter);\n    }\n\n    // For Excel Online\n    const firstChild = fragment.firstChild;\n    if (\n        isNodeOfType(firstChild, 'ELEMENT_NODE') &&\n        firstChild.tagName == 'div' &&\n        firstChild.firstChild\n    ) {\n        const tableFound = Array.from(firstChild.childNodes).every((child: Node) => {\n            // Tables pasted from Excel Online should be of the format: 0 to N META tags and 1 TABLE tag\n            const tagName = isNodeOfType(child, 'ELEMENT_NODE') && child.tagName;\n\n            return tagName == 'META'\n                ? true\n                : tagName == 'TABLE'\n                ? child == firstChild.lastChild\n                : false;\n        });\n\n        // Extract Table from Div\n        if (tableFound && firstChild.lastChild) {\n            event.fragment.replaceChildren(firstChild.lastChild);\n        }\n    }\n\n    setupExcelTableHandlers(\n        event,\n        allowExcelNoBorderTable,\n        isNativeEvent /* handleForNativeEvent */\n    );\n}\n\n/**\n * @internal\n * Exported only for unit test\n */\nexport function validateExcelFragment(\n    fragment: DocumentFragment,\n    domCreator: DOMCreator,\n    htmlBefore: string,\n    clipboardData: ClipboardData,\n    htmlAfter: string\n) {\n    // Clipboard content of Excel may contain the <StartFragment> and EndFragment comment tags inside the table\n    //\n    // @example\n    // <table>\n    // <!--StartFragment-->\n    // <tr>...</tr>\n    // <!--EndFragment-->\n    // </table>\n    //\n    // This causes that the fragment is not properly created and the table is not extracted.\n    // The content that is before the StartFragment is htmlBefore and the content that is after the EndFragment is htmlAfter.\n    // So attempt to create a new document fragment with the content of htmlBefore + clipboardData.html + htmlAfter\n    // If a table is found, replace the fragment with the new fragment\n    const result =\n        !fragment.querySelector(TABLE_SELECTOR) &&\n        domCreator.htmlToDOM(htmlBefore + clipboardData.html + htmlAfter);\n    if (result && result.querySelector(TABLE_SELECTOR)) {\n        moveChildNodes(fragment, result?.body);\n    } else {\n        // If the table is still not found, try to extract the table from the clipboard data using Regex\n        const html = clipboardData.html ? excelHandler(clipboardData.html, htmlBefore) : undefined;\n\n        if (html && clipboardData.html != html) {\n            const doc = domCreator.htmlToDOM(html);\n            moveChildNodes(fragment, doc?.body);\n        }\n    }\n}\n\n/**\n * @internal Export for test only\n * @param html Source html\n */\nexport function excelHandler(html: string, htmlBefore: string): string {\n    try {\n        if (html.match(LAST_TD_END_REGEX)) {\n            const trMatch = htmlBefore.match(LAST_TR_REGEX);\n            const tr = trMatch ? trMatch[0] : '<TR>';\n            html = tr + html + '</TR>';\n        }\n        if (html.match(LAST_TR_END_REGEX)) {\n            const tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\n            const table = tableMatch ? tableMatch[0] : '<TABLE>';\n            html = table + html + '</TABLE>';\n        }\n    } finally {\n        return html;\n    }\n}\n\n/**\n * @internal\n * Exported only for unit test\n */\nexport function setupExcelTableHandlers(\n    event: BeforePasteEvent,\n    allowExcelNoBorderTable: boolean | undefined,\n    isNativeEvent: boolean\n) {\n    addParser(event.domToModelOption, 'tableCell', (format, element) => {\n        if (\n            !allowExcelNoBorderTable &&\n            (element.style.borderStyle === 'none' ||\n                (!isNativeEvent && element.style.borderStyle == ''))\n        ) {\n            format.borderBottom = DEFAULT_BORDER_STYLE;\n            format.borderLeft = DEFAULT_BORDER_STYLE;\n            format.borderRight = DEFAULT_BORDER_STYLE;\n            format.borderTop = DEFAULT_BORDER_STYLE;\n        }\n    });\n\n    setProcessor(event.domToModelOption, 'child', childProcessor);\n}\n\n/**\n * @internal\n * Exported only for unit test\n */\nexport const childProcessor: ElementProcessor<ParentNode> = (group, element, context) => {\n    const segmentFormat = { ...context.segmentFormat };\n    if (\n        group.blockGroupType === 'TableCell' &&\n        group.format.textColor &&\n        !context.segmentFormat.textColor\n    ) {\n        context.segmentFormat.textColor = group.format.textColor;\n    }\n\n    context.defaultElementProcessors.child(group, element, context);\n\n    if (group.blockGroupType === 'TableCell' && group.format.textColor) {\n        context.segmentFormat = segmentFormat;\n        delete group.format.textColor;\n    }\n};\n","import { addParser } from './utils/addParser';\nimport { blockElementParser } from './parsers/blockElementParser';\nimport { chainSanitizerCallback } from './utils/chainSanitizerCallback';\nimport { DefaultSanitizers } from './DefaultSanitizers';\nimport { deprecatedBorderColorParser } from './parsers/deprecatedColorParser';\nimport { getDocumentSource } from './pasteSourceValidations/getDocumentSource';\nimport { getObjectKeys } from 'roosterjs-content-model-dom';\nimport { imageSizeParser } from './parsers/imageSizeParser';\nimport { parseLink } from './parsers/linkParser';\nimport { pasteButtonProcessor } from './processors/pasteButtonProcessor';\nimport { PastePropertyNames } from './pasteSourceValidations/constants';\nimport { processPastedContentFromExcel } from './Excel/processPastedContentFromExcel';\nimport { processPastedContentFromOneNote } from './oneNote/processPastedContentFromOneNote';\nimport { processPastedContentFromPowerPoint } from './PowerPoint/processPastedContentFromPowerPoint';\nimport { processPastedContentFromWordDesktop } from './WordDesktop/processPastedContentFromWordDesktop';\nimport { processPastedContentWacComponents } from './WacComponents/processPastedContentWacComponents';\nimport { setProcessor } from './utils/setProcessor';\nimport { tableBorderParser } from './parsers/tableBorderParser';\nimport type {\n    BeforePasteEvent,\n    DomToModelOptionForSanitizing,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n} from 'roosterjs-content-model-types';\n\n/**\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\n * 1. Content copied from Word\n * 2. Content copied from Excel\n * 3. Content copied from Word Online or OneNote Online\n * 4. Content copied from Power Point\n */\nexport class PastePlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n\n    /**\n     * Construct a new instance of Paste class\n     * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN\n     * @param allowExcelNoBorderTable Allow table copied from Excel without border\n     */\n    constructor(\n        private allowExcelNoBorderTable?: boolean,\n        private domToModelForSanitizing: Pick<\n            DomToModelOptionForSanitizing,\n            | 'additionalAllowedTags'\n            | 'additionalDisallowedTags'\n            | 'styleSanitizers'\n            | 'attributeSanitizers'\n        > = {\n            styleSanitizers: DefaultSanitizers,\n            additionalAllowedTags: [],\n            additionalDisallowedTags: [],\n            attributeSanitizers: {},\n        }\n    ) {}\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'Paste';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor || event.eventType != 'beforePaste') {\n            return;\n        }\n\n        if (!event.domToModelOption) {\n            return;\n        }\n\n        const { htmlAttributes, clipboardData, fragment } = event;\n\n        const pasteSource = getDocumentSource({\n            htmlAttributes,\n            fragment,\n            clipboardItemTypes: clipboardData.types,\n            htmlFirstLevelChildTags: clipboardData.htmlFirstLevelChildTags,\n            environment: this.editor.getEnvironment(),\n            rawHtml: clipboardData.rawHtml,\n        });\n        const pasteType = event.pasteType;\n\n        switch (pasteSource) {\n            case 'wordDesktop':\n                processPastedContentFromWordDesktop(\n                    event.domToModelOption,\n                    event.htmlBefore || event.clipboardData.rawHtml || ''\n                );\n                break;\n            case 'wacComponents':\n                processPastedContentWacComponents(event);\n                break;\n            case 'excelOnline':\n            case 'excelDesktop':\n            case 'excelNonNativeEvent':\n                if (pasteType === 'normal' || pasteType === 'mergeFormat') {\n                    // Handle HTML copied from Excel\n                    processPastedContentFromExcel(\n                        event,\n                        this.editor.getDOMCreator(),\n                        !!this.allowExcelNoBorderTable,\n                        pasteSource != 'excelNonNativeEvent' /* isNativeEvent */\n                    );\n                }\n                break;\n            case 'googleSheets':\n                event.domToModelOption.additionalAllowedTags.push(\n                    PastePropertyNames.GOOGLE_SHEET_NODE_NAME as Lowercase<string>\n                );\n                break;\n            case 'powerPointDesktop':\n                processPastedContentFromPowerPoint(event, this.editor.getDOMCreator());\n                break;\n\n            case 'oneNoteDesktop':\n                processPastedContentFromOneNote(event);\n                break;\n        }\n\n        addParser(event.domToModelOption, 'link', parseLink);\n        addParser(event.domToModelOption, 'tableCell', deprecatedBorderColorParser);\n        addParser(event.domToModelOption, 'tableCell', tableBorderParser);\n        addParser(event.domToModelOption, 'table', deprecatedBorderColorParser);\n        addParser(event.domToModelOption, 'image', imageSizeParser);\n        setProcessor(event.domToModelOption, 'button', pasteButtonProcessor);\n\n        if (pasteType === 'mergeFormat') {\n            addParser(event.domToModelOption, 'block', blockElementParser);\n            addParser(event.domToModelOption, 'listLevel', blockElementParser);\n        }\n\n        this.setEventSanitizers(event);\n    }\n\n    private setEventSanitizers(event: BeforePasteEvent) {\n        if (this.domToModelForSanitizing) {\n            const {\n                styleSanitizers,\n                attributeSanitizers,\n                additionalAllowedTags,\n                additionalDisallowedTags,\n            } = this.domToModelForSanitizing;\n            getObjectKeys(styleSanitizers).forEach(key =>\n                chainSanitizerCallback(\n                    event.domToModelOption.styleSanitizers,\n                    key,\n                    styleSanitizers[key]\n                )\n            );\n            getObjectKeys(attributeSanitizers).forEach(key =>\n                chainSanitizerCallback(\n                    event.domToModelOption.attributeSanitizers,\n                    key,\n                    attributeSanitizers[key]\n                )\n            );\n            event.domToModelOption.additionalAllowedTags.push(...additionalAllowedTags);\n            event.domToModelOption.additionalDisallowedTags.push(...additionalDisallowedTags);\n        }\n    }\n}\n","import { addParser } from '../utils/addParser';\nimport { processAsListItem, setupListFormat } from '../utils/customListUtils';\nimport { removeNegativeTextIndentParser } from '../parsers/removeNegativeTextIndentParser';\nimport { setProcessor } from '../utils/setProcessor';\nimport {\n    BulletListType,\n    getOrderedListNumberStr,\n    moveChildNodes,\n    NumberingListType,\n} from 'roosterjs-content-model-dom';\nimport type {\n    BeforePasteEvent,\n    ContentModelListItemLevelFormat,\n    DOMCreator,\n} from 'roosterjs-content-model-types';\n\nconst BulletSelector = '* > span > span[style*=mso-special-format]';\nconst MsOfficeSpecialFormat = 'mso-special-format';\nconst CssStyleKey = 'style';\nconst MsoSpecialFormatRegex = /mso-special-format:\\s*([^;]*)/;\n\nconst clearListItemStyles = (format: ContentModelListItemLevelFormat): void => {\n    delete format.textAlign;\n    delete format.marginLeft;\n    delete format.paddingLeft;\n};\n/**\n * @internal\n * Convert pasted content from PowerPoint\n * @param event The BeforePaste event\n */\n\nexport function processPastedContentFromPowerPoint(\n    event: BeforePasteEvent,\n    domCreator: DOMCreator\n) {\n    const { fragment, clipboardData, domToModelOption } = event;\n\n    if (clipboardData.html && !clipboardData.text && clipboardData.image) {\n        // It is possible that PowerPoint copied both image and HTML but not plain text.\n        // We always prefer HTML if any.\n        const doc = domCreator.htmlToDOM(clipboardData.html);\n\n        moveChildNodes(fragment, doc?.body);\n    }\n\n    addParser(domToModelOption, 'block', removeNegativeTextIndentParser);\n\n    setProcessor(domToModelOption, 'element', (group, element, context) => {\n        const style = element.getAttribute(CssStyleKey) || '';\n        // If the element is the bullet element, just ignore it, otherwise we will see an extra bullet in the list\n        if (style.includes(MsOfficeSpecialFormat) && context.listFormat.levels.length > 0) {\n            return;\n        }\n        const bulletElement = element.querySelector(BulletSelector) as HTMLElement;\n        if (bulletElement) {\n            const {\n                depth,\n                unorderedBulletType,\n                orderedBulletType,\n                startNumberOverrideOrBullet,\n                isOrderedList,\n                isNewList,\n            } = extractPowerPointListInfo(element, bulletElement);\n\n            // Setup the listformat with the metadata extracted from the bullet element\n            setupListFormat(\n                isOrderedList ? 'OL' : 'UL',\n                element,\n                context,\n                depth,\n                context.listFormat,\n                group,\n                [clearListItemStyles]\n            );\n\n            // Set the metadata for the list item, which will be used to set the correct bullet style type\n            const listMetadata = {\n                unorderedStyleType:\n                    !isOrderedList && unorderedBulletType\n                        ? BulletListType[unorderedBulletType]\n                        : undefined,\n                orderedStyleType:\n                    isOrderedList && orderedBulletType\n                        ? NumberingListType[orderedBulletType]\n                        : undefined,\n            };\n\n            // Process the Div element as a list item.\n            processAsListItem(context, element, group, listMetadata, bulletElement, listItem => {\n                if (isNewList) {\n                    listItem.levels[\n                        listItem.levels.length - 1\n                    ].format.startNumberOverride = parseInt(startNumberOverrideOrBullet);\n                }\n                clearListItemStyles(listItem.levels[listItem.levels.length - 1].format);\n                clearListItemStyles(listItem.format);\n            });\n        } else {\n            context.defaultElementProcessors.element?.(group, element, context);\n        }\n    });\n}\n\n/**\n * Extract list information from PowerPoint pasted content\n *\n * The lists from PowerPoint are represent as:\n *\n * - The class 0# represents the depth of the list, if the list is in the first level, the class attribute wont be present.\n * - The mso-special-format style represents the type of bullet and the start of the list.\n *      The first part of the mso-special-format is the type of bullet, and the second part is the start of the list.\n *  - All the items that are in the same list have the same mso-special-format style. Which we are leveraging to identify when a list is new or part of the existing list thread.\n *\n * @example\n *  `   <div class=\"O1\" style=\"...\">\n            <span style=\"font-size: 5pt\"\n                ><span style=\"mso-special-format: 'numbullet6\\,1'; font-family: +mj-lt\"\n                    >i.</span\n                ></span\n            ><span style=\"...;\">123</span>\n        </div> `\n *\n * @param element The element to extract list information from\n * @param bulletElement The bullet element to extract list information from\n * @returns The extracted list information\n */\nfunction extractPowerPointListInfo(element: HTMLElement, bulletElement: HTMLElement) {\n    const className = element.className.substring(1) || '0';\n    const depth = parseInt(className) + 1;\n    const style = bulletElement.getAttribute(CssStyleKey) || '';\n    const msoSpecialFormat = style.match(MsoSpecialFormatRegex);\n    const [bulletTypeHtml, startNumberOverrideOrBullet] =\n        msoSpecialFormat?.[1].replace('\"', '').split('\\\\,') || [];\n    const isOrderedList = OrderedListStyleMap.has(bulletTypeHtml);\n\n    const unorderedBulletType = UnorderedBullets.get(bulletElement.innerText);\n    const orderedBulletType = OrderedListStyleMap.get(bulletTypeHtml);\n\n    return {\n        depth,\n        unorderedBulletType,\n        orderedBulletType,\n        startNumberOverrideOrBullet,\n        isOrderedList,\n        isNewList:\n            isOrderedList &&\n            !!orderedBulletType &&\n            bulletElement.innerText ===\n                getPptListStart(orderedBulletType, startNumberOverrideOrBullet),\n    };\n}\n\nconst UnorderedBullets: Map<string, keyof typeof BulletListType> = new Map([\n    ['', 'Disc'],\n    ['o', 'Circle'],\n    ['', 'Square'],\n    ['q', 'BoxShadow'],\n    ['v', 'Xrhombus'],\n    ['', 'ShortArrow'],\n    ['', 'CheckMark'],\n]);\n\nconst OrderedListStyleMap: Map<string, keyof typeof NumberingListType> = new Map([\n    ['numbullet1', 'UpperAlpha'],\n    ['numbullet2', 'DecimalParenthesis'],\n    ['numbullet3', 'Decimal'],\n    ['numbullet7', 'UpperRoman'],\n    ['numbullet9', 'LowerAlphaParenthesis'],\n    ['numbullet0', 'LowerAlpha'],\n    ['numbullet6', 'LowerRoman'],\n]);\n\nfunction getPptListStart(\n    orderedBulletType: keyof typeof NumberingListType,\n    startNumberOverride: string\n) {\n    const bullet = getOrderedListNumberStr(\n        NumberingListType[orderedBulletType],\n        parseInt(startNumberOverride)\n    );\n    switch (orderedBulletType) {\n        case 'Decimal':\n        case 'UpperAlpha':\n        case 'LowerAlpha':\n        case 'UpperRoman':\n        case 'LowerRoman':\n            return bullet + '.';\n        case 'DecimalParenthesis':\n        case 'LowerAlphaParenthesis':\n            return bullet + ')';\n\n        default:\n            return undefined;\n    }\n}\n","/**\n * @internal\n **/\nexport const WORD_ONLINE_TABLE_TEMP_ELEMENT_CLASSES: string[] = [\n    'TableInsertRowGapBlank',\n    'TableColumnResizeHandle',\n    'TableCellTopBorderHandle',\n    'TableCellLeftBorderHandle',\n    'TableHoverColumnHandle',\n    'TableHoverRowHandle',\n];\n/**\n * @internal\n **/\nexport const BULLET_LIST_STYLE: string = 'BulletListStyle';\n/**\n * @internal\n **/\nexport const NUMBER_LIST_STYLE: string = 'NumberListStyle';\n/**\n * @internal\n **/\nexport const IMAGE_BORDER: string = 'WACImageBorder';\n/**\n * @internal\n **/\nexport const IMAGE_CONTAINER: string = 'WACImageContainer';\n/**\n * @internal\n **/\nexport const OUTLINE_ELEMENT: string = 'OutlineElement';\n/**\n * @internal\n **/\nexport const PARAGRAPH: string = 'Paragraph';\n/**\n * @internal\n **/\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME: string = 'ListContainerWrapper';\n/**\n * @internal\n **/\nexport const COMMENT_HIGHLIGHT_CLASS: string = 'CommentHighlightRest';\n/**\n * @internal\n **/\nexport const COMMENT_HIGHLIGHT_CLICKED_CLASS: string = 'CommentHighlightClicked';\n/**\n * @internal\n **/\nexport const TEMP_ELEMENTS_CLASSES: string[] = [\n    ...WORD_ONLINE_TABLE_TEMP_ELEMENT_CLASSES,\n    'ListMarkerWrappingSpan',\n];\n\n/**\n * @internal\n */\nexport const REMOVE_MARGIN_ELEMENTS: string =\n    `span.${IMAGE_CONTAINER},span.${IMAGE_BORDER},.${COMMENT_HIGHLIGHT_CLASS},.${COMMENT_HIGHLIGHT_CLICKED_CLASS},` +\n    WORD_ONLINE_TABLE_TEMP_ELEMENT_CLASSES.map(c => `table div[class^=\"${c}\"]`).join(',');\n\n/**\n * @internal\n **/\nexport const WAC_IDENTIFY_SELECTOR: string = `ul[class^=\"${BULLET_LIST_STYLE}\"]>.${OUTLINE_ELEMENT},ol[class^=\"${NUMBER_LIST_STYLE}\"]>.${OUTLINE_ELEMENT},${REMOVE_MARGIN_ELEMENTS}`;\n","import { addParser } from '../utils/addParser';\nimport { createListLevel, parseFormat } from 'roosterjs-content-model-dom';\nimport { setProcessor } from '../utils/setProcessor';\nimport {\n    COMMENT_HIGHLIGHT_CLASS,\n    COMMENT_HIGHLIGHT_CLICKED_CLASS,\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\n    REMOVE_MARGIN_ELEMENTS,\n    TEMP_ELEMENTS_CLASSES,\n} from './constants';\nimport type {\n    BeforePasteEvent,\n    ContentModelBlockFormat,\n    ContentModelBlockGroup,\n    ContentModelListItemLevelFormat,\n    ContentModelListLevel,\n    ContentModelSegmentFormat,\n    DomToModelContext,\n    DomToModelListFormat,\n    ElementProcessor,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\nconst LIST_ELEMENT_TAGS = ['UL', 'OL', 'LI'];\nconst LIST_ELEMENT_SELECTOR = LIST_ELEMENT_TAGS.join(',');\n\ninterface WacContext extends DomToModelListFormat {\n    /**\n     * Current list levels\n     */\n    currentListLevels?: ContentModelListLevel[];\n    /**\n     * Array to keep the start of the lists and determine if the start override should be set.\n     */\n    listItemThread?: number[];\n}\n\n/**\n * Wac components do not use sub and super tags, instead only add vertical align to a span.\n * This parser normalize the content for content model\n */\nconst wacSubSuperParser: FormatParser<ContentModelSegmentFormat> = (\n    format: ContentModelSegmentFormat,\n    element: HTMLElement\n): void => {\n    const verticalAlign = element.style.verticalAlign;\n    if (verticalAlign === 'super') {\n        format.superOrSubScriptSequence = 'super';\n    }\n    if (verticalAlign === 'sub') {\n        format.superOrSubScriptSequence = 'sub';\n    }\n};\n\n/**\n * This processor does:\n * 1) Remove the display and margin of the element.\n * 2) When an element should be ignored but should handle the child elements call the default child processor.\n * 3) Removes the End of Paragraph element to avoid empty lines, we should only remove this if the previous element of the EOP is an EmptyTextRun\n * 4) Finally call the default processor.\n * @returns\n */\nconst wacElementProcessor: ElementProcessor<HTMLElement> = (\n    group: ContentModelBlockGroup,\n    element: HTMLElement,\n    context: DomToModelContext\n): void => {\n    const elementTag = element.tagName;\n\n    if (element.matches(REMOVE_MARGIN_ELEMENTS)) {\n        element.style.removeProperty('display');\n        element.style.removeProperty('margin');\n    }\n\n    if (element.classList.contains(LIST_CONTAINER_ELEMENT_CLASS_NAME)) {\n        context.elementProcessors.child(group, element, context);\n        return;\n    }\n\n    if (TEMP_ELEMENTS_CLASSES.some(className => element.classList.contains(className))) {\n        return;\n    } else if (shouldClearListContext(elementTag, element, context)) {\n        const { listFormat } = context;\n        listFormat.levels = [];\n        listFormat.listParent = undefined;\n    }\n\n    context.defaultElementProcessors.element(group, element, context);\n};\n\n/**\n * This processor calls the default list processor and then sets the correct list level and list bullet.\n */\nconst wacLiElementProcessor: ElementProcessor<HTMLLIElement> = (\n    group: ContentModelBlockGroup,\n    element: HTMLLIElement,\n    context: DomToModelContext\n): void => {\n    const level = parseInt(element.getAttribute('data-aria-level') ?? '');\n    const listFormat = context.listFormat as WacContext;\n    const listType =\n        listFormat.levels[context.listFormat.levels.length - 1]?.listType ||\n        (element.closest('ol,ul')?.tagName.toUpperCase() as 'UL' | 'OL');\n    const newLevel: ContentModelListLevel = createListLevel(listType, context.blockFormat);\n    parseFormat(element, context.formatParsers.listLevelThread, newLevel.format, context);\n    parseFormat(element, context.formatParsers.listLevel, newLevel.format, context);\n    context.listFormat.levels = listFormat.currentListLevels || context.listFormat.levels;\n\n    if (level > 0) {\n        if (level > context.listFormat.levels.length) {\n            while (level != context.listFormat.levels.length) {\n                context.listFormat.levels.push(newLevel);\n            }\n        } else {\n            context.listFormat.levels.splice(level, context.listFormat.levels.length - 1);\n            context.listFormat.levels[level - 1] = newLevel;\n        }\n    }\n\n    context.defaultElementProcessors.li?.(group, element, context);\n\n    const listParent = listFormat.listParent;\n    if (listParent) {\n        const lastblock = listParent.blocks[listParent.blocks.length - 1];\n        if (lastblock.blockType == 'BlockGroup' && lastblock.blockGroupType == 'ListItem') {\n            const currentLevel = lastblock.levels[lastblock.levels.length - 1];\n            updateStartOverride(currentLevel, element, context);\n        }\n    }\n\n    const newLevels: ContentModelListLevel[] = [];\n    listFormat.levels.forEach(v => {\n        const newValue: ContentModelListLevel = {\n            dataset: { ...v.dataset },\n            format: { ...v.format },\n            listType: v.listType,\n        };\n        newLevels.push(newValue);\n    });\n    listFormat.currentListLevels = newLevels;\n    listFormat.levels = [];\n};\n\n/**\n * This parsers does:\n * 1) Sets the display for dummy item to undefined when the current style is block.\n * 2) Removes the Margin Left\n */\nconst wacListItemParser: FormatParser<ContentModelListItemLevelFormat> = (\n    format: ContentModelListItemLevelFormat,\n    element: HTMLElement\n): void => {\n    if (element.style.display === 'block') {\n        format.displayForDummyItem = undefined;\n    }\n\n    format.marginLeft = undefined;\n    format.marginRight = undefined;\n};\n\n/**\n * Wac usually adds padding to lists which is unwanted so remove it.\n */\nconst wacListLevelParser: FormatParser<ContentModelListItemLevelFormat> = (\n    format: ContentModelListItemLevelFormat\n): void => {\n    format.marginLeft = undefined;\n    format.paddingLeft = undefined;\n};\n\n/**\n * This function returns whether we need to clear the list format.\n * Word Online wraps lists inside divs to have this structure:\n *\n *  <div class='ListContainerWrapper'>\n *      <ol>...</ol>\n *  </div>\n *  <div>\n *      <p>...</p>\n *  <div>\n *  <div class='ListContainerWrapper'>\n *      <ol>...</ol>\n *  </div>\n *\n *  So if a elements is not contained inside of a list we should clear the list context to prevent normal text to be\n *  transformed into list\n *  For the above scenario, if we do not clear the format, the content inside of the second div would be transformed to a list too.\n */\nfunction shouldClearListContext(\n    elementTag: string,\n    element: HTMLElement,\n    context: DomToModelContext\n) {\n    return (\n        context.listFormat.levels.length > 0 &&\n        LIST_ELEMENT_TAGS.every(tag => tag != elementTag) &&\n        !element.closest(LIST_ELEMENT_SELECTOR)\n    );\n}\n\nconst wacCommentParser: FormatParser<ContentModelSegmentFormat> = (\n    format: ContentModelSegmentFormat,\n    element: HTMLElement\n): void => {\n    if (\n        element.className.includes(COMMENT_HIGHLIGHT_CLASS) ||\n        element.className.includes(COMMENT_HIGHLIGHT_CLICKED_CLASS)\n    ) {\n        delete format.backgroundColor;\n    }\n};\n/**\n * @internal\n * Convert pasted content from Office Online\n * Once it is known that the document is from WAC\n * We need to remove the display property and margin from all the list item\n * @param ev BeforePasteEvent\n */\nexport function processPastedContentWacComponents(ev: BeforePasteEvent) {\n    addParser(ev.domToModelOption, 'segment', wacSubSuperParser);\n    addParser(ev.domToModelOption, 'listItemThread', wacListItemParser);\n    addParser(ev.domToModelOption, 'listItemElement', wacListItemParser);\n    addParser(ev.domToModelOption, 'listLevel', wacListLevelParser);\n    addParser(ev.domToModelOption, 'container', wacContainerParser);\n    addParser(ev.domToModelOption, 'table', wacContainerParser);\n    addParser(ev.domToModelOption, 'segment', wacCommentParser);\n\n    setProcessor(ev.domToModelOption, 'element', wacElementProcessor);\n    setProcessor(ev.domToModelOption, 'li', wacLiElementProcessor);\n}\n\nconst wacContainerParser: FormatParser<ContentModelBlockFormat> = (\n    format: ContentModelBlockFormat,\n    element: HTMLElement\n) => {\n    if (element.style.marginLeft.startsWith('-')) {\n        delete format.marginLeft;\n    }\n};\n\nfunction updateStartOverride(\n    currentLevel: ContentModelListLevel | undefined,\n    element: HTMLLIElement,\n    ctx: DomToModelContext\n) {\n    if (!currentLevel || currentLevel.listType == 'UL') {\n        return;\n    }\n\n    const list = element.closest('ol');\n    const listFormat = ctx.listFormat as WacContext;\n    const [start, listLevel] = extractWordListMetadata(list, element);\n\n    if (!listFormat.listItemThread) {\n        listFormat.listItemThread = [];\n    }\n\n    const thread: number | undefined = listFormat.listItemThread[listLevel];\n    if (thread && start - thread != 1) {\n        currentLevel.format.startNumberOverride = start;\n    }\n    listFormat.listItemThread[listLevel] = start;\n}\nfunction extractWordListMetadata(\n    list: HTMLElement | null | undefined,\n    item: HTMLElement | null | undefined\n) {\n    const itemIndex =\n        item && Array.from(list?.querySelectorAll('li') || []).indexOf(item as HTMLLIElement);\n    const start =\n        parseInt(list?.getAttribute('start') || '1') + (itemIndex && itemIndex > 0 ? itemIndex : 0);\n    const listLevel = parseInt(item?.getAttribute('data-aria-level') || '');\n\n    return [start, listLevel];\n}\n","import { getObjectKeys } from 'roosterjs-content-model-dom';\nimport type { WordMetadata } from './WordMetadata';\n\nconst FORMATING_REGEX = /[\\n\\t'{}\"]+/g;\nconst STYLE_TAG = '<style';\nconst STYLE_TAG_END = '</style>';\nconst nonWordCharacterRegex = /\\W/;\n\nfunction extractStyleTagsFromHtml(htmlContent: string): string[] {\n    const styles: string[] = [];\n\n    let { styleIndex, styleEndIndex } = extractHtmlIndexes(htmlContent);\n    while (styleIndex >= 0 && styleEndIndex >= 0) {\n        const styleContent = htmlContent\n            .substring(styleIndex + STYLE_TAG.length, styleEndIndex)\n            .trim();\n        styles.push(styleContent);\n        ({ styleIndex, styleEndIndex } = extractHtmlIndexes(htmlContent, styleEndIndex + 1));\n    }\n    return styles;\n}\n\nfunction extractHtmlIndexes(html: string, startIndex: number = 0) {\n    const htmlLowercase = html.toLowerCase();\n    let styleIndex = htmlLowercase.indexOf(STYLE_TAG, startIndex);\n    let currentIndex = styleIndex + STYLE_TAG.length;\n    let nextChar = html.substring(currentIndex, currentIndex + 1);\n\n    while (!nonWordCharacterRegex.test(nextChar) && styleIndex > -1) {\n        styleIndex = htmlLowercase.indexOf(STYLE_TAG, styleIndex + 1);\n        currentIndex = styleIndex + STYLE_TAG.length;\n        nextChar = html.substring(currentIndex, currentIndex + 1);\n    }\n\n    const styleEndIndex = htmlLowercase.indexOf(STYLE_TAG_END, startIndex);\n    return { styleIndex, styleEndIndex };\n}\n\n/**\n * @internal\n * Word Desktop content has a style tag that contains data for the lists.\n * So this function query that style tag and extract the data from the innerHTML, since it is not available from the HTMLStyleElement.sheet.\n *\n * The format is like:\n * example of style element content\n * @list l0:level1 {\n * styleTag: styleValue;\n * ...\n * }\n *\n * To extract the data:\n * 1. Substring the value of the style selector, using @ index and { index\n * 2. Substring the value of the style rules by Substring the content between { and }\n * 3. Split the value of the rules using ; as separator { styleTag: styleValue; styleTag1: StyleValue1 } = ['styleTag: styleValue',  'styleTag1: StyleValue1']\n * 4. Split the value of the rule  using : as separator: styleTag: styleValue = [styleTag, styleValue]\n * 5. Save data in record and only use the required information.\n *\n */\nexport function getStyleMetadata(htmlString: string) {\n    const metadataMap: Map<string, WordMetadata> = new Map();\n    if (!htmlString) {\n        return metadataMap;\n    }\n    const headStyles = extractStyleTagsFromHtml(htmlString);\n\n    headStyles.forEach(text => {\n        let index = 0;\n        while (index >= 0) {\n            const indexAt = text.indexOf('@', index + 1);\n            const indexCurlyEnd = text.indexOf('}', indexAt);\n            const indexCurlyStart = text.indexOf('{', indexAt);\n            index = indexAt;\n\n            // 1.\n            const metadataName = text\n                .substring(indexAt + 1, indexCurlyStart)\n                .replace(FORMATING_REGEX, '')\n                .replace('list', '')\n                .trimRight()\n                .trimLeft();\n\n            // 2.\n            const dataName = text\n                .substring(indexCurlyStart, indexCurlyEnd + 1)\n                .trimLeft()\n                .trimRight();\n            const record: Record<string, string> = {};\n\n            // 3.\n            const entries = dataName.split(';');\n            entries.forEach(entry => {\n                // 4.\n                const [key, value] = entry.split(':');\n                if (key && value) {\n                    const formatedKey = key.replace(FORMATING_REGEX, '').trimRight().trimLeft();\n                    const formatedValue = value.replace(FORMATING_REGEX, '').trimRight().trimLeft();\n                    // 5.\n                    record[formatedKey] = formatedValue;\n                }\n            });\n\n            const data: WordMetadata = {\n                'mso-level-number-format': record['mso-level-number-format'],\n                'mso-level-start-at': record['mso-level-start-at'] || '1',\n                'mso-level-text': record['mso-level-text'],\n            };\n            if (getObjectKeys(data).some(key => !!data[key])) {\n                metadataMap.set(metadataName, data);\n            }\n        }\n    });\n\n    return metadataMap;\n}\n","import { addParser } from '../utils/addParser';\nimport { adjustPercentileLineHeight } from '../parsers/adjustPercentileLineHeightParser';\nimport { getStyleMetadata } from './getStyleMetadata';\nimport { getStyles } from '../utils/getStyles';\nimport { listLevelParser } from '../parsers/listLevelParser';\nimport { processWordComments } from './processWordComments';\nimport { processWordList } from './processWordLists';\nimport { removeNegativeTextIndentParser } from '../parsers/removeNegativeTextIndentParser';\nimport { setProcessor } from '../utils/setProcessor';\nimport { wordContainerParser } from '../parsers/wordContainerParser';\nimport { wordTableParser } from '../parsers/wordTableParser';\nimport type { WordMetadata } from './WordMetadata';\nimport type { DomToModelOption, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Handles pasted content when the source is Word Desktop.\n * @param domToModelOption Options for DOM to Content Model conversion\n * @param htmlString The HTML string to process\n */\nexport function processPastedContentFromWordDesktop(\n    domToModelOption: DomToModelOption,\n    htmlString: string\n) {\n    const metadataMap: Map<string, WordMetadata> = getStyleMetadata(htmlString);\n\n    setProcessor(domToModelOption, 'element', wordDesktopElementProcessor(metadataMap));\n    addParser(domToModelOption, 'block', adjustPercentileLineHeight);\n    addParser(domToModelOption, 'block', removeNegativeTextIndentParser);\n    addParser(domToModelOption, 'listItemElement', removeNegativeTextIndentParser);\n    addParser(domToModelOption, 'listLevel', listLevelParser);\n    addParser(domToModelOption, 'container', wordContainerParser);\n    addParser(domToModelOption, 'table', wordTableParser);\n}\n\nconst wordDesktopElementProcessor = (\n    metadataKey: Map<string, WordMetadata>\n): ElementProcessor<HTMLElement> => {\n    return (group, element, context) => {\n        const styles = getStyles(element);\n        // Process Word Lists or Word Commands, otherwise use the default processor on this element.\n        if (\n            !(\n                processWordList(styles, group, element, context, metadataKey) ||\n                processWordComments(styles, element)\n            )\n        ) {\n            context.defaultElementProcessors.element(group, element, context);\n        }\n    };\n};\n","import { isElementOfType } from 'roosterjs-content-model-dom';\n\nconst MSO_COMMENT_ANCHOR_HREF_REGEX = /#_msocom_/;\nconst MSO_SPECIAL_CHARACTER = 'mso-special-character';\nconst MSO_SPECIAL_CHARACTER_COMMENT = 'comment';\nconst MSO_ELEMENT = 'mso-element';\nconst MSO_ELEMENT_COMMENT_LIST = 'comment-list';\n\n/**\n * @internal\n * Check whether the element contain Word attributes related to comments and if it does we should no process\n * this element.\n * @returns\n */\nexport function processWordComments(styles: Record<string, string>, element: HTMLElement) {\n    return (\n        styles[MSO_SPECIAL_CHARACTER] == MSO_SPECIAL_CHARACTER_COMMENT ||\n        (isElementOfType(element, 'a') && MSO_COMMENT_ANCHOR_HREF_REGEX.test(element.href)) ||\n        styles[MSO_ELEMENT] == MSO_ELEMENT_COMMENT_LIST\n    );\n}\n","import { getStyles } from '../utils/getStyles';\nimport { processAsListItem, setupListFormat } from '../utils/customListUtils';\nimport {\n    getListStyleTypeFromString,\n    isElementOfType,\n    isEmpty,\n    isNodeOfType,\n} from 'roosterjs-content-model-dom';\nimport type { WordMetadata } from './WordMetadata';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelListItem,\n    ContentModelListItemFormat,\n    ContentModelListItemLevelFormat,\n    ContentModelListLevel,\n    DomToModelContext,\n    DomToModelListFormat,\n} from 'roosterjs-content-model-types';\n\n/** Word list metadata style name */\nconst MSO_LIST = 'mso-list';\nconst MSO_LIST_IGNORE = 'ignore';\nconst WORD_FIRST_LIST = 'l0';\nconst TEMPLATE_VALUE_REGEX = /%[0-9a-zA-Z]+/g;\nconst BULLET_METADATA = 'bullet';\n\ninterface WordDesktopListFormat extends DomToModelListFormat {\n    wordLevel?: number | '';\n    wordList?: string;\n    wordKnownLevels?: Map<string, ContentModelListLevel[]>;\n}\n\ninterface WordListFormat extends ContentModelListItemFormat {\n    wordList?: string;\n}\n\n/**\n * @internal\n * @param styles\n * @param group\n * @param element\n * @param context\n * @returns\n */\nexport function processWordList(\n    styles: Record<string, string>,\n    group: ContentModelBlockGroup,\n    element: HTMLElement,\n    context: DomToModelContext,\n    metadata: Map<string, WordMetadata>\n) {\n    const listFormat = context.listFormat as WordDesktopListFormat;\n    if (!listFormat.wordKnownLevels) {\n        listFormat.wordKnownLevels = new Map<string, ContentModelListLevel[]>();\n    }\n    const wordListStyle = styles[MSO_LIST] || '';\n\n    // If the element contains Ignore style, do not process it,\n    // Usually this element contains the fake bullet used in Word Desktop.\n    if (wordListStyle.toLowerCase() === MSO_LIST_IGNORE) {\n        return true;\n    }\n\n    const [lNumber, level] = wordListStyle.split(' ');\n    // Try get the list metadata from word, which follows this format: l1 level1 lfo2\n    // If we are able to get the level property means we can process this element to be a list\n    listFormat.wordLevel = level && parseInt(level.substr('level'.length));\n    listFormat.wordList = lNumber || WORD_FIRST_LIST;\n\n    if (listFormat.levels.length == 0) {\n        listFormat.levels =\n            (listFormat.wordList && listFormat.wordKnownLevels.get(listFormat.wordList)) || [];\n    }\n\n    if (wordListStyle && group && typeof listFormat.wordLevel === 'number') {\n        const { wordLevel, wordList } = listFormat;\n        // Retrieve the Fake bullet on the element and also the list type\n        const listMetadata = metadata.get(`${lNumber}:${level}`);\n        const listType =\n            listMetadata?.['mso-level-number-format']?.toLowerCase() != BULLET_METADATA\n                ? 'OL'\n                : 'UL';\n\n        // Create the new level of the list item and parse the format\n        setupListFormat(listType, element, context, wordLevel, listFormat, group, [\n            wordListPaddingParser,\n        ]);\n        (listFormat.levels[listFormat.levels.length - 1]\n            .format as WordListFormat).wordList = wordList;\n\n        const bullet = getBulletFromMetadata(listMetadata, listType);\n        const listFormatMetadata = bullet\n            ? {\n                  unorderedStyleType: listType == 'UL' ? bullet : undefined,\n                  orderedStyleType: listType == 'OL' ? bullet : undefined,\n              }\n            : undefined;\n\n        processAsListItem(\n            context,\n            element,\n            group,\n            listFormatMetadata,\n            getBulletElement(element),\n            listItem => {\n                if (listType == 'OL') {\n                    setStartNumber(listItem, context, listMetadata, element);\n                }\n            }\n        );\n\n        if (\n            listFormat.levels.length > 0 &&\n            listFormat.wordKnownLevels.get(wordList) != listFormat.levels\n        ) {\n            listFormat.wordKnownLevels.set(wordList, [...listFormat.levels]);\n        }\n        return true;\n    }\n\n    return false;\n}\n\nfunction getBulletFromMetadata(listMetadata: WordMetadata | undefined, listType: 'OL' | 'UL') {\n    const templateType = listMetadata?.['mso-level-number-format'] || 'decimal';\n    let templateFinal: string;\n\n    if (listMetadata?.['mso-level-text']) {\n        let templateValue: string = '';\n        switch (templateType) {\n            case 'alpha-upper':\n                templateValue = 'UpperAlpha';\n                break;\n            case 'alpha-lower':\n                templateValue = 'LowerAlpha';\n                break;\n            case 'roman-lower':\n                templateValue = 'LowerRoman';\n                break;\n            case 'roman-upper':\n                templateValue = 'UpperRoman';\n                break;\n            default:\n                templateValue = 'Number';\n                break;\n        }\n        const template = (listMetadata['mso-level-text'] || '')\n            .replace('\\\\', '')\n            .replace('\"', '')\n            .replace(TEMPLATE_VALUE_REGEX, '${' + templateValue + '}');\n\n        templateFinal = '\"' + template + ' \"';\n    } else {\n        switch (templateType) {\n            case 'alpha-lower':\n                templateFinal = 'lower-alpha';\n                break;\n            case 'roman-lower':\n                templateFinal = 'lower-roman';\n                break;\n            case 'roman-upper':\n                templateFinal = 'upper-roman';\n                break;\n            default:\n                templateFinal = 'decimal';\n                break;\n        }\n    }\n\n    return getListStyleTypeFromString(listType, templateFinal);\n}\n\nfunction setStartNumber(\n    listItem: ContentModelListItem,\n    context: DomToModelContext,\n    listMetadata: WordMetadata | undefined,\n    element: HTMLElement\n) {\n    const {\n        listParent,\n        wordList,\n        wordKnownLevels,\n        wordLevel,\n        levels,\n    } = context.listFormat as WordDesktopListFormat;\n\n    const block = getLastNotEmptyBlock(listParent);\n    if (\n        (block?.blockType != 'BlockGroup' ||\n            block.blockGroupType != 'ListItem' ||\n            (wordLevel &&\n                (block.levels[wordLevel]?.format as WordListFormat)?.wordList != wordList)) &&\n        wordList\n    ) {\n        const start = listMetadata?.['mso-level-start-at']\n            ? parseInt(listMetadata['mso-level-start-at'])\n            : NaN;\n        const knownLevel = wordKnownLevels?.get(wordList) || [];\n\n        if (start != undefined && !isNaN(start) && knownLevel.length != levels.length) {\n            listItem.levels[listItem.levels.length - 1].format.startNumberOverride = start;\n        } else if (\n            isElementOfType(element, 'li') &&\n            isNodeOfType(element.parentElement, 'ELEMENT_NODE') &&\n            isElementOfType(element.parentElement, 'ol') &&\n            element.parentElement.firstElementChild == element &&\n            knownLevel.length != element.parentElement.start\n        ) {\n            listItem.levels[listItem.levels.length - 1].format.startNumberOverride =\n                element.parentElement.start;\n        }\n    }\n}\n\nfunction getLastNotEmptyBlock(listParent: ContentModelBlockGroup | undefined) {\n    for (let index = (listParent?.blocks.length || 0) - 1; index > 0; index--) {\n        const result = listParent?.blocks[index];\n        if (result && !isEmpty(result)) {\n            return result;\n        }\n    }\n\n    return undefined;\n}\n\nfunction wordListPaddingParser(\n    format: ContentModelListItemLevelFormat,\n    element: HTMLElement\n): void {\n    if (element.style.marginLeft && parseInt(element.style.marginLeft) != 0) {\n        format.paddingLeft = '0px';\n    }\n    if (element.style.marginRight && parseInt(element.style.marginRight) != 0) {\n        format.paddingRight = '0px';\n    }\n}\n/**\n * Get the bullet element from word list item.\n * The first element of the list contains the bullet element, which contains the mso-list:ignore style.\n * @example\n *  <p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt;mso-list:l0 level1 lfo1'>\n *      <![if !supportLists]>\n *          <span lang=EN-US style='mso-fareast-font-family:Aptos;mso-fareast-theme-font:minor-latin; mso-bidi-font-family:Aptos;mso-bidi-theme-font:minor-latin;color:#C00000; mso-ansi-language:EN-US'>\n *              <span style='mso-list:Ignore'> <-- This is the bullet element\n *                  1.\n *                  <span style='font:7.0pt \"Times New Roman\"'>\n *                      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n *                  </span>\n *              </span>\n *          </span>\n *      <![endif]>\n *      <span lang=EN-US style='color:#C00000; mso-ansi-language:EN-US'>\n *          Content in list<o:p></o:p>\n *      </span>\n *  </p>\n * @returns\n */\nfunction getBulletElement(element: HTMLElement): HTMLElement | undefined {\n    const firstChild = element.firstElementChild;\n    let isBulletElement = false;\n\n    if (firstChild) {\n        for (let i = 0; i < firstChild.childNodes.length; i++) {\n            const child = firstChild.childNodes[i];\n            if (isNodeOfType(child, 'ELEMENT_NODE')) {\n                const styles = getStyles(child);\n                const wordListStyle = styles[MSO_LIST] || '';\n\n                if (wordListStyle.toLowerCase() === MSO_LIST_IGNORE) {\n                    isBulletElement = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    return firstChild && isBulletElement ? (firstChild as HTMLElement) : undefined;\n}\n","import { setProcessor } from '../utils/setProcessor';\nimport type {\n    BeforePasteEvent,\n    DomToModelContext,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\nconst OrderedListStyleMap = {\n    1: 'decimal',\n    a: 'lower-alpha',\n    A: 'upper-alpha',\n    i: 'lower-roman',\n    I: 'upper-roman',\n} as const;\n\nconst UnorderedListStyleMap = {\n    disc: 'disc',\n    circle: 'circle',\n    square: 'square',\n} as const;\n\n/**\n * @internal\n */\nexport interface OneNoteListContext {\n    listStyleType?: string;\n    startNumberOverride?: number;\n}\n\n/**\n * @internal\n */\nexport interface OneNoteDomToModelContext extends DomToModelContext {\n    oneNoteListContext?: OneNoteListContext;\n}\n\n/**\n * @internal\n * Processes the content pasted from OneNote by setting up custom processors\n * for ordered lists (`<ol>`) and list items (`<li>`). These processors handle\n * specific list styles and numbering overrides that may be present in OneNote\n * content.\n *\n * @param event - The `BeforePasteEvent` containing the DOM-to-model options\n * and other context information for the paste operation.\n */\nexport function processPastedContentFromOneNote(event: BeforePasteEvent): void {\n    setProcessor(event.domToModelOption, 'ol', processOrderedList);\n    setProcessor(event.domToModelOption, 'ul', processUnorderedList);\n    setProcessor(event.domToModelOption, 'li', processListItem);\n}\n\n/**\n * @internal exported only for unit test\n * Content from OneNote may have ordered lists with specific styles and start numbers.\n * This function processes the `<ol>` elements, extracting the `type` and `start` custom attributes\n * to set the appropriate list style and starting number in the `oneNoteListContext` of the provided context.\n * Which is then used to format the list items within the list.\n */\nexport const processOrderedList: ElementProcessor<HTMLOListElement> = (\n    group,\n    element,\n    cmContext\n) => {\n    const context = ensureOneNoteListContext(cmContext);\n\n    if (context.oneNoteListContext) {\n        const typeOfList = element.getAttribute('type');\n        if (typeOfList) {\n            const listStyle = OrderedListStyleMap[typeOfList as keyof typeof OrderedListStyleMap];\n            const startNumberOverride = parseInt(element.getAttribute('start') || '1') || 1;\n\n            context.oneNoteListContext.listStyleType = listStyle;\n            context.oneNoteListContext.startNumberOverride = startNumberOverride;\n        }\n    }\n\n    context.defaultElementProcessors.ol?.(group, element, context);\n};\n\n/**\n * @internal exported only for unit test\n * Content from OneNote may have ordered lists with specific styles and start numbers.\n * This function processes the `<ul>` elements, extracting the `type` custom attribute\n * to set the appropriate list style in the `oneNoteListContext` of the provided context.\n * Which is then used to format the list items within the list.\n */\nexport const processUnorderedList: ElementProcessor<HTMLUListElement> = (\n    group,\n    element,\n    cmContext\n) => {\n    const context = ensureOneNoteListContext(cmContext);\n\n    if (context.oneNoteListContext) {\n        const typeOfList = element.getAttribute('type');\n        if (typeOfList) {\n            const listStyle =\n                UnorderedListStyleMap[typeOfList as keyof typeof UnorderedListStyleMap];\n            context.oneNoteListContext.listStyleType = listStyle;\n        }\n    }\n\n    context.defaultElementProcessors.ul?.(group, element, context);\n};\n\n/**\n * @internal exported only for unit test\n * Processes the `<li>` elements within a list. It checks if the `oneNoteListContext`\n * is present in the provided context. If so, it applies the list style type and\n * start number override to the last level of the list format.\n * This ensures that the list items are formatted correctly according to the\n * OneNote list context.\n */\nexport const processListItem: ElementProcessor<HTMLLIElement> = (group, element, cmContext) => {\n    const context = ensureOneNoteListContext(cmContext);\n    let removeStartNumberOverride = false;\n\n    if (context.oneNoteListContext) {\n        const { listStyleType, startNumberOverride } = context.oneNoteListContext;\n        if (listStyleType) {\n            const lastLevel = context.listFormat.levels[context.listFormat.levels.length - 1];\n            lastLevel.format.listStyleType = listStyleType;\n\n            if (startNumberOverride) {\n                removeStartNumberOverride = true;\n                lastLevel.format.startNumberOverride = startNumberOverride;\n\n                delete context.oneNoteListContext.startNumberOverride;\n            }\n            delete context.oneNoteListContext.listStyleType;\n        }\n    }\n\n    context.defaultElementProcessors.li?.(group, element, context);\n\n    if (removeStartNumberOverride) {\n        delete context.listFormat.levels[context.listFormat.levels.length - 1].format\n            .startNumberOverride;\n    }\n};\n\nfunction ensureOneNoteListContext(cmContext: DomToModelContext): OneNoteDomToModelContext {\n    const context = cmContext as OneNoteDomToModelContext;\n\n    if (!context.oneNoteListContext) {\n        context.oneNoteListContext = {};\n    }\n\n    return context;\n}\n","import type { ContentModelBlockFormat } from 'roosterjs-content-model-types';\n\nconst PERCENTAGE_REGEX = /%/;\n// Default line height in browsers according to https://developer.mozilla.org/en-US/docs/Web/CSS/line-height#normal\nconst DEFAULT_BROWSER_LINE_HEIGHT_PERCENTAGE = 1.2;\n\n/**\n * @internal\n * Parser for adjusting percentage-based line heights and converting 'normal' to a specific percentage\n * @param format The block format to modify\n * @param element The HTML element being processed\n */\nexport function adjustPercentileLineHeight(\n    format: ContentModelBlockFormat,\n    element: HTMLElement\n): void {\n    // If the line height is less than the browser default line height, line between the text is going to be too narrow\n    let parsedLineHeight: number;\n    if (\n        PERCENTAGE_REGEX.test(element.style.lineHeight) &&\n        !isNaN((parsedLineHeight = parseInt(element.style.lineHeight)))\n    ) {\n        format.lineHeight = (\n            DEFAULT_BROWSER_LINE_HEIGHT_PERCENTAGE *\n            (parsedLineHeight / 100)\n        ).toString();\n    } else if (element.style.lineHeight.toLowerCase() === 'normal') {\n        format.lineHeight = '120%';\n    }\n}\n","import type { ContentModelBlockFormat, FormatParser } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * For block elements that have background color style, remove the background color when user selects the merge current format\n * paste option\n */\nexport const blockElementParser: FormatParser<ContentModelBlockFormat> = (\n    format: ContentModelBlockFormat,\n    element: HTMLElement\n) => {\n    if (element.style.backgroundColor) {\n        delete format.backgroundColor;\n    }\n};\n","import { BorderKeys, DeprecatedColors } from 'roosterjs-content-model-dom';\nimport type { BorderFormat, FormatParser } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const deprecatedBorderColorParser: FormatParser<BorderFormat> = (\n    format: BorderFormat\n): void => {\n    BorderKeys.forEach(key => {\n        const value = format[key];\n        let color: string = '';\n        if (\n            value &&\n            DeprecatedColors.some(dColor => value.indexOf(dColor) > -1 && (color = dColor))\n        ) {\n            const newValue = value.replace(color, '').trimRight();\n            format[key] = newValue;\n        }\n    });\n};\n","import { parseValueWithUnit } from 'roosterjs-content-model-dom';\nimport type { ContentModelImageFormat, FormatParser } from 'roosterjs-content-model-types';\n\n// Only process absolute units (px, pt, in, cm, mm)\nconst AbsoluteUnitRegex = /^\\s*\\d+(\\.\\d+)?\\s*(px|pt|in|cm|mm)\\s*$/i;\n\n/**\n * @internal\n * Remove image size if it is larger than editor view width to let it auto size\n */\nexport const imageSizeParser: FormatParser<ContentModelImageFormat> = (\n    format,\n    element,\n    context\n) => {\n    const maxImageSize = context.editorViewWidth;\n    const { width } = format;\n\n    if (width && maxImageSize && AbsoluteUnitRegex.test(width)) {\n        const widthValue = parseValueWithUnit(width, element);\n\n        // If the given width is larger than editor view width, we clear both width and height to let it auto size\n        if (widthValue > maxImageSize) {\n            delete format.width;\n            delete format.height;\n        }\n    }\n};\n","import { isElementOfType } from 'roosterjs-content-model-dom';\nimport type { ContentModelHyperLinkFormat, FormatParser } from 'roosterjs-content-model-types';\n\nconst SUPPORTED_PROTOCOLS = ['http:', 'https:', 'notes:', 'mailto:', 'onenote:'];\nconst INVALID_LINKS_REGEX = /^file:\\/\\/\\/[a-zA-Z\\/]/i;\n\n/**\n * @internal\n */\nexport const parseLink: FormatParser<ContentModelHyperLinkFormat> = (format, element) => {\n    if (!isElementOfType(element, 'a')) {\n        return;\n    }\n\n    let url: URL | undefined;\n    try {\n        url = new URL(element.href);\n    } catch {\n        url = undefined;\n    }\n\n    if (\n        (url && SUPPORTED_PROTOCOLS.indexOf(url.protocol) === -1) ||\n        INVALID_LINKS_REGEX.test(element.href)\n    ) {\n        element.removeAttribute('href');\n        format.href = '';\n    }\n};\n","import type {\n    ContentModelListItemLevelFormat,\n    DomToModelContext,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Parser for processing list level formatting specific to Word Desktop\n * @param format The list item level format to modify\n * @param element The HTML element being processed\n * @param _context The DOM to model context\n * @param defaultStyle The default style properties\n */\nexport const listLevelParser: FormatParser<ContentModelListItemLevelFormat> = (\n    format: ContentModelListItemLevelFormat,\n    element: HTMLElement,\n    _context: DomToModelContext,\n    defaultStyle: Readonly<Partial<CSSStyleDeclaration>>\n) => {\n    if (element.style.marginLeft !== '') {\n        format.marginLeft = defaultStyle.marginLeft;\n    }\n\n    format.marginBottom = undefined;\n};\n","import type { FormatParser, TextIndentFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const removeNegativeTextIndentParser: FormatParser<TextIndentFormat> = (format, element) => {\n    if (format.textIndent?.startsWith('-')) {\n        delete format.textIndent;\n    }\n};\n","import { BorderKeys } from 'roosterjs-content-model-dom';\nimport type {\n    BorderFormat,\n    ContentModelTableCellFormat,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\nconst ElementBorderKeys = new Map<\n    keyof BorderFormat,\n    {\n        c: keyof CSSStyleDeclaration;\n        s: keyof CSSStyleDeclaration;\n        w: keyof CSSStyleDeclaration;\n    }\n>([\n    ['borderTop', { w: 'borderTopWidth', s: 'borderTopStyle', c: 'borderTopColor' }],\n    ['borderRight', { w: 'borderRightWidth', s: 'borderRightStyle', c: 'borderRightColor' }],\n    ['borderBottom', { w: 'borderBottomWidth', s: 'borderBottomStyle', c: 'borderBottomColor' }],\n    ['borderLeft', { w: 'borderLeftWidth', s: 'borderLeftStyle', c: 'borderLeftColor' }],\n]);\n\n/**\n * @internal\n */\nexport const tableBorderParser: FormatParser<ContentModelTableCellFormat> = (format, element) => {\n    BorderKeys.forEach(key => {\n        if (!format[key]) {\n            const styleSet = ElementBorderKeys.get(key);\n\n            if (\n                styleSet &&\n                element.style[styleSet.w] &&\n                element.style[styleSet.s] &&\n                !element.style[styleSet.c]\n            ) {\n                format[key] = `${element.style[styleSet.w]} ${element.style[styleSet.s]}`;\n            }\n        }\n    });\n};\n","import type {\n    ContentModelFormatContainerFormat,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Parser for processing container formatting specific to Word Desktop\n * Removes negative margin-left values which are commonly used in Word lists\n * @param format The container format to modify\n */\nexport const wordContainerParser: FormatParser<ContentModelFormatContainerFormat> = (\n    format\n): void => {\n    if (format.marginLeft?.startsWith('-')) {\n        delete format.marginLeft;\n    }\n};\n","import type { ContentModelTableFormat, FormatParser } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Parser for processing table formatting specific to Word Desktop\n * @param format The table format to modify\n * @param element The HTML element being processed\n */\nexport const wordTableParser: FormatParser<ContentModelTableFormat> = (format, element): void => {\n    if (format.marginLeft?.startsWith('-')) {\n        delete format.marginLeft;\n    }\n    if (format.htmlAlign) {\n        delete format.htmlAlign;\n    }\n};\n","/**\n * @internal\n */\nexport const PastePropertyNames = {\n    /**\n     * Node attribute used to identify if the content is from Google Sheets.\n     */\n    GOOGLE_SHEET_NODE_NAME: 'google-sheets-html-origin',\n\n    /**\n     * Name of the HTMLMeta Property that provides the Office App Source of the pasted content\n     */\n    PROG_ID_NAME: 'ProgId',\n\n    /**\n     * Name of the HTMLMeta Property that identifies pated content as from Excel Desktop\n     */\n    EXCEL_DESKTOP_ATTRIBUTE_NAME: 'xmlns:x',\n};\n","import { WAC_IDENTIFY_SELECTOR } from '../WacComponents/constants';\nimport type { GetSourceFunction } from './getDocumentSource';\n\n/**\n * @internal\n * Check whether the fragment provided contain Wac Elements\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const documentContainWacElements: GetSourceFunction = props => {\n    const { fragment } = props;\n    return !!fragment.querySelector(WAC_IDENTIFY_SELECTOR);\n};\n","import { documentContainWacElements } from './documentContainWacElements';\nimport { isExcelDesktopDocument } from './isExcelDesktopDocument';\nimport { isExcelNotNativeEvent } from './isExcelNonNativeEvent';\nimport { isExcelOnlineDocument } from './isExcelOnlineDocument';\nimport { isGoogleSheetDocument } from './isGoogleSheetDocument';\nimport { isOneNoteDesktopDocument } from './isOneNoteDocument';\nimport { isPowerPointDesktopDocument } from './isPowerPointDesktopDocument';\nimport { isWordDesktopDocument } from './isWordDesktopDocument';\nimport { shouldConvertToSingleImage } from './shouldConvertToSingleImage';\nimport type { EditorEnvironment } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * The input parameters for getDocumentSource function\n */\nexport type GetSourceInputParams = {\n    /**\n     * HTML attributes from the content that is being checked\n     */\n    htmlAttributes: Record<string, string>;\n    /**\n     * Document fragment of the checked content\n     */\n    fragment: DocumentFragment | Document;\n    /**\n     * Whether convert single image is enabled\n     */\n    shouldConvertSingleImage?: boolean;\n    /**\n     * Array of tag names of the first level child nodes\n     */\n    htmlFirstLevelChildTags?: string[];\n    /**\n     * The clipboard item types\n     */\n    clipboardItemTypes?: string[];\n    /**\n     * The editor environment\n     */\n    environment: Omit<EditorEnvironment, 'domToModelSettings' | 'modelToDomSettings'>;\n    /**\n     * The raw HTML string from clipboard\n     */\n    rawHtml?: string | null;\n};\n\n/**\n * @internal\n * Represent the types of sources to handle in the Paste Plugin\n */\nexport type KnownPasteSourceType =\n    | 'wordDesktop'\n    | 'excelDesktop'\n    | 'excelOnline'\n    | 'powerPointDesktop'\n    | 'googleSheets'\n    | 'wacComponents'\n    | 'default'\n    | 'singleImage'\n    | 'excelNonNativeEvent'\n    | 'oneNoteDesktop';\n\n/**\n * @internal\n */\nexport type GetSourceFunction = (props: GetSourceInputParams) => boolean;\n\nconst getSourceFunctions = new Map<KnownPasteSourceType, GetSourceFunction>([\n    ['wordDesktop', isWordDesktopDocument],\n    ['excelDesktop', isExcelDesktopDocument],\n    ['excelOnline', isExcelOnlineDocument],\n    ['powerPointDesktop', isPowerPointDesktopDocument],\n    ['wacComponents', documentContainWacElements],\n    ['googleSheets', isGoogleSheetDocument],\n    ['singleImage', shouldConvertToSingleImage],\n    ['excelNonNativeEvent', isExcelNotNativeEvent],\n    ['oneNoteDesktop', isOneNoteDesktopDocument],\n]);\n\n/**\n * @internal\n * This function tries to get the source of the Pasted content\n * @param event the before paste event\n * @param shouldConvertSingleImage Whether convert single image is enabled.\n * @returns The Type of pasted content, if no type found will return {KnownSourceType.Default}\n */\nexport function getDocumentSource(param: GetSourceInputParams): KnownPasteSourceType {\n    let result: KnownPasteSourceType | null = null;\n\n    getSourceFunctions.forEach((func, key) => {\n        if (!result && func(param)) {\n            result = key;\n        }\n    });\n\n    return result ?? 'default';\n}\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getDocumentSource';\n\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\n\n/**\n * @internal\n * Checks whether the Array provided contains strings that identify Excel Desktop documents\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isExcelDesktopDocument: GetSourceFunction = props => {\n    const { htmlAttributes } = props;\n    // The presence of this attribute confirms its origin from Excel Desktop\n    return htmlAttributes[PastePropertyNames.EXCEL_DESKTOP_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE;\n};\n","import type { GetSourceFunction, GetSourceInputParams } from './getDocumentSource';\n\nconst ShadowWorkbookClipboardType = 'web data/shadow-workbook';\n\n/**\n * @internal\n * When the clipboard content is retrieved programatically, the clipboard html does not contain the usual\n * attributes we use to determine if the content is from Excel. This function is used to handle that case.\n */\nexport const isExcelNotNativeEvent: GetSourceFunction = (props: GetSourceInputParams) => {\n    const { clipboardItemTypes, htmlFirstLevelChildTags } = props;\n\n    return !!(\n        clipboardItemTypes &&\n        clipboardItemTypes.includes(ShadowWorkbookClipboardType) &&\n        htmlFirstLevelChildTags?.length == 1 &&\n        htmlFirstLevelChildTags[0] == 'TABLE'\n    );\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getDocumentSource';\n\n// Excel Desktop also has this attribute\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\n\n/**\n * @internal\n * Checks whether the Array provided contains strings that identify Excel Online documents\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isExcelOnlineDocument: GetSourceFunction = props => {\n    const { htmlAttributes } = props;\n    // The presence of Excel.Sheet confirms its origin from Excel, the absence of EXCEL_DESKTOP_ATTRIBUTE_NAME confirms it is from the Online version\n    return (\n        htmlAttributes[PastePropertyNames.PROG_ID_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE &&\n        htmlAttributes[PastePropertyNames.EXCEL_DESKTOP_ATTRIBUTE_NAME] == undefined\n    );\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getDocumentSource';\n\n/**\n * @internal\n * Checks whether the fragment provided contain elements from Google sheets\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isGoogleSheetDocument: GetSourceFunction = props => {\n    const { fragment } = props;\n    return !!fragment.querySelector(PastePropertyNames.GOOGLE_SHEET_NODE_NAME);\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getDocumentSource';\n\nconst ONE_NOTE_ATTRIBUTE_VALUE = 'OneNote.File';\n\n/**\n * @internal\n * Checks whether the provided HTML attributes identify a OneNote Desktop document\n * @param props Properties related to the PasteEvent\n * @returns True if the document is identified as a OneNote Desktop document, otherwise false\n */\nexport const isOneNoteDesktopDocument: GetSourceFunction = props => {\n    const { htmlAttributes } = props;\n    // The presence of this attribute confirms its origin from OneNote Desktop\n    return htmlAttributes[PastePropertyNames.PROG_ID_NAME] == ONE_NOTE_ATTRIBUTE_VALUE;\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getDocumentSource';\n\nconst POWERPOINT_ATTRIBUTE_VALUE = 'PowerPoint.Slide';\n\n/**\n * @internal\n * Checks whether the Array provided contains strings that identify Power Point Desktop documents\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isPowerPointDesktopDocument: GetSourceFunction = props => {\n    return props.htmlAttributes[PastePropertyNames.PROG_ID_NAME] == POWERPOINT_ATTRIBUTE_VALUE;\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getDocumentSource';\n\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\nconst WORD_PROG_ID = 'Word.Document';\n\n/**\n * @internal\n * Checks whether the Array provided contains strings that identify Word Desktop documents\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isWordDesktopDocument: GetSourceFunction = props => {\n    const { htmlAttributes, rawHtml, environment } = props;\n\n    return (\n        htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE ||\n        htmlAttributes[PastePropertyNames.PROG_ID_NAME] == WORD_PROG_ID ||\n        // Safari removes the metadata from the clipboard html, so we need to do this check.\n        !!(\n            environment.isSafari &&\n            rawHtml &&\n            rawHtml?.replace(/ /g, '').indexOf(`${WORD_ATTRIBUTE_NAME}=\"${WORD_ATTRIBUTE_VALUE}`) >\n                -1\n        )\n    );\n};\n","import type { GetSourceFunction } from './getDocumentSource';\n\n/**\n * @internal\n * Checks whether the fragment only contains a single image to paste\n * and the editor have the ConvertSingleImageBody Experimental feature\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const shouldConvertToSingleImage: GetSourceFunction = props => {\n    const { shouldConvertSingleImage, htmlFirstLevelChildTags } = props;\n    return !!(\n        shouldConvertSingleImage &&\n        htmlFirstLevelChildTags?.length == 1 &&\n        htmlFirstLevelChildTags[0] == 'IMG'\n    );\n};\n","import { addSegment, createText, isNodeOfType, parseFormat } from 'roosterjs-content-model-dom';\nimport type {\n    ElementProcessor,\n    ContentModelBlockGroup,\n    DomToModelContext,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * This processor is used to process <button> elements in the DOM and convert them into Content Model.\n * It handles the button element by creating a text segment for each text node within the button.\n */\nexport const pasteButtonProcessor: ElementProcessor<HTMLButtonElement> = (\n    group: ContentModelBlockGroup,\n    element: HTMLButtonElement,\n    context: DomToModelContext\n): void => {\n    const format: ContentModelSegmentFormat = {};\n    parseFormat(element, context.formatParsers.segment, format, context);\n    // Recursively process text nodes in the button\n    processTextNodesRecursively(group, element, context, format);\n};\n\n/**\n * Helper function to recursively iterate through nodes and process text nodes\n */\nfunction processTextNodesRecursively(\n    group: ContentModelBlockGroup,\n    node: Node,\n    context: DomToModelContext,\n    format: ContentModelSegmentFormat\n): void {\n    if (node.nodeType === Node.TEXT_NODE) {\n        // Process text node directly\n        const text = createText(node.nodeValue || '', format);\n        addSegment(group, text);\n    } else if (isNodeOfType(node, 'ELEMENT_NODE')) {\n        const newFormat: ContentModelSegmentFormat = { ...format };\n        parseFormat(node, context.formatParsers.segment, newFormat, context);\n        // Recursively process all child nodes\n        for (let i = 0; i < node.childNodes.length; i++) {\n            processTextNodesRecursively(group, node.childNodes[i], context, newFormat);\n        }\n    }\n}\n","import type {\n    ContentModelFormatMap,\n    DomToModelOption,\n    FormatParser,\n    ElementFormatParserPerCategory,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function addParser<TKey extends keyof ElementFormatParserPerCategory>(\n    domToModelOption: DomToModelOption,\n    entry: TKey,\n    additionalFormatParsers: FormatParser<ContentModelFormatMap[TKey]>\n) {\n    if (!domToModelOption.additionalFormatParsers) {\n        domToModelOption.additionalFormatParsers = {};\n    }\n    if (!domToModelOption.additionalFormatParsers[entry]) {\n        domToModelOption.additionalFormatParsers[entry] = [];\n    }\n\n    domToModelOption.additionalFormatParsers[entry]?.push(additionalFormatParsers);\n}\n","import type { ValueSanitizer } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Chain all callback for an style sanitizer\n * @param map The source callback map\n * @param name Name of the property to chain\n * @param newCallback A new callback to process the given name on the given map.\n */\nexport function chainSanitizerCallback(\n    map: Record<string, ValueSanitizer>,\n    name: string,\n    newCallback: ValueSanitizer\n) {\n    const finalCb =\n        typeof newCallback == 'function'\n            ? newCallback\n            : (value: string) => (newCallback ? value : null);\n    if (!map[name]) {\n        map[name] = finalCb;\n    } else {\n        const originalCallback = map[name];\n        map[name] = (value: string, tagName: string) => {\n            const og =\n                typeof originalCallback == 'function'\n                    ? originalCallback(value, tagName)\n                    : originalCallback\n                    ? value\n                    : false;\n            if (!og) {\n                return null;\n            } else {\n                return finalCb(og, tagName);\n            }\n        };\n    }\n}\n","import { removeNegativeTextIndentParser } from '../parsers/removeNegativeTextIndentParser';\nimport {\n    createListLevel,\n    parseFormat,\n    updateListMetadata,\n    createListItem,\n    addBlock,\n    isElementOfType,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DomToModelContext,\n    DomToModelListFormat,\n    ContentModelBlockGroup,\n    ContentModelListLevel,\n    ListMetadataFormat,\n    ContentModelListItem,\n    ContentModelListItemLevelFormat,\n    ContentModelListItemFormat,\n    FormatParser,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\nconst removeMargin = (format: ContentModelListItemFormat): void => {\n    delete format.marginLeft;\n};\n\n/**\n * @internal\n */\nexport function setupListFormat(\n    listType: 'OL' | 'UL',\n    element: HTMLElement,\n    context: DomToModelContext,\n    listDepth: number,\n    listFormat: DomToModelListFormat,\n    group: ContentModelBlockGroup,\n    additionalParsers: FormatParser<ContentModelListItemLevelFormat>[] = []\n) {\n    const newLevel: ContentModelListLevel = createListLevel(listType);\n    parseFormat(element, context.formatParsers.listLevel, newLevel.format, context);\n    parseFormat(element, additionalParsers.concat(removeMargin), newLevel.format, context);\n\n    // If the list format is in a different level, update the array so we get the new item\n    // To be in the same level as the provided level metadata.\n    if (listDepth > listFormat.levels.length) {\n        while (listDepth != listFormat.levels.length) {\n            listFormat.levels.push(newLevel);\n        }\n    } else {\n        listFormat.levels.splice(listDepth, listFormat.levels.length - 1);\n        listFormat.levels[listDepth - 1] = newLevel;\n    }\n\n    listFormat.listParent = group;\n}\n\n/**\n * @internal\n */\nexport function processAsListItem(\n    context: DomToModelContext,\n    element: HTMLElement,\n    group: ContentModelBlockGroup,\n    listFormatMetadata: ListMetadataFormat | undefined,\n    bulletElement: HTMLElement | undefined,\n    beforeProcessingChildren?: (listItem: ContentModelListItem) => void\n) {\n    const listFormat = context.listFormat;\n    const lastLevel = listFormat.levels[listFormat.levels.length - 1];\n    if (listFormatMetadata && lastLevel) {\n        updateListMetadata(lastLevel, metadata => Object.assign({}, metadata, listFormatMetadata));\n    }\n\n    const listItem = createListItem(listFormat.levels, context.segmentFormat);\n\n    parseFormat(element, context.formatParsers.segmentOnBlock, context.segmentFormat, context);\n    parseFormat(element, context.formatParsers.listItemElement, listItem.format, context);\n    parseFormat(\n        element,\n        [removeNegativeTextIndentParser, nonListElementParser],\n        listItem.format,\n        context\n    );\n    if (bulletElement) {\n        const format: ContentModelSegmentFormat = { ...context.segmentFormat };\n        parseFormat(bulletElement, context.formatParsers.segmentOnBlock, format, context);\n        listItem.formatHolder.format = format;\n    }\n\n    beforeProcessingChildren?.(listItem);\n\n    context.elementProcessors.child(listItem, element, context);\n    addBlock(group, listItem);\n}\n\nconst nonListElementParser: FormatParser<ContentModelListItemFormat> = (\n    format,\n    element,\n    _context,\n    defaultStyle\n): void => {\n    if (!isElementOfType(element, 'li')) {\n        Object.keys(defaultStyle).forEach(keyInput => {\n            const key = keyInput as keyof CSSStyleDeclaration;\n            const formatKey = keyInput as keyof ContentModelListItemFormat;\n            if (\n                key != 'display' &&\n                format[formatKey] != undefined &&\n                format[formatKey] == defaultStyle[key]\n            ) {\n                delete format[formatKey];\n            }\n        });\n    }\n};\n","/**\n * @internal\n * Get CSS styles of a given element in name-value pair format\n * @param element The element to get styles from\n */\nexport function getStyles(element: HTMLElement): Record<string, string> {\n    const result: Record<string, string> = {};\n    const style = element?.getAttribute('style') || '';\n    style.split(';').forEach(pair => {\n        const valueIndex = pair.indexOf(':');\n        const name = pair.slice(0, valueIndex);\n        const value = pair.slice(valueIndex + 1);\n        if (name && value) {\n            result[name.trim()] = value.trim();\n        }\n    });\n    return result;\n}\n","import type { DomToModelOption, ElementProcessorMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function setProcessor<TKey extends keyof ElementProcessorMap>(\n    domToModelOption: DomToModelOption,\n    entry: TKey,\n    processorOverride: Partial<ElementProcessorMap>[TKey]\n) {\n    if (!domToModelOption.processorOverride) {\n        domToModelOption.processorOverride = {};\n    }\n\n    domToModelOption.processorOverride[entry] = processorOverride;\n}\n","import { formatTextSegmentBeforeSelectionMarker } from 'roosterjs-content-model-api';\nimport { getQueryString } from './getQueryString';\nimport { mergeModel } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelDocument,\n    ContentModelText,\n    FormatContentModelOptions,\n    IEditor,\n} from 'roosterjs-content-model-types';\nimport type { PickerDirection, PickerHandler } from './PickerHandler';\nimport type { PickerHelper } from './PickerHelper';\n\n/**\n * @internal\n */\nexport class PickerHelperImpl implements PickerHelper {\n    public direction: PickerDirection | null = null;\n\n    constructor(\n        public readonly editor: IEditor,\n        public readonly handler: PickerHandler,\n        private triggerCharacter: string\n    ) {}\n\n    /**\n     * Replace the query string with a given Content Model.\n     * This is used for commit a change from picker and insert the committed content into editor.\n     * @param model The Content Model to insert\n     * @param options Options for formatting content model\n     * @param canUndoByBackspace Whether this change can be undone using Backspace key\n     */\n    replaceQueryString(\n        model: ContentModelDocument,\n        options?: FormatContentModelOptions,\n        canUndoByBackspace?: boolean\n    ): void {\n        this.editor.focus();\n\n        formatTextSegmentBeforeSelectionMarker(\n            this.editor,\n            (target, previousSegment, paragraph, _, context) => {\n                const potentialSegments: ContentModelText[] = [];\n                const queryString = getQueryString(\n                    this.triggerCharacter,\n                    paragraph,\n                    previousSegment,\n                    potentialSegments\n                );\n\n                if (queryString) {\n                    potentialSegments.forEach(x => (x.isSelected = true));\n                    mergeModel(target, model, context);\n                    context.canUndoByBackspace = canUndoByBackspace;\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            options\n        );\n    }\n\n    /**\n     * Notify Picker Plugin that picker is closed from the handler code, so picker plugin can quit the suggesting state\n     */\n    closePicker() {\n        if (this.direction) {\n            this.direction = null;\n            this.handler.onClosePicker?.();\n        }\n    }\n}\n","import { ChangeSource, isCursorMovingKey, isPunctuation } from 'roosterjs-content-model-dom';\nimport { formatTextSegmentBeforeSelectionMarker } from 'roosterjs-content-model-api';\nimport { getQueryString } from './getQueryString';\nimport { PickerHelperImpl } from './PickerHelperImpl';\nimport type { PickerHandler } from './PickerHandler';\nimport type {\n    DOMInsertPoint,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n} from 'roosterjs-content-model-types';\n\n/**\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\n * - Show picker when special trigger key is pressed\n * - Hide picker\n * - Change selection in picker by Up/Down/Left/Right\n * - Apply selected item in picker\n *\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\n */\nexport class PickerPlugin implements EditorPlugin {\n    private isMac: boolean = false;\n    private lastQueryString = '';\n    private helper: PickerHelperImpl | null = null;\n\n    /**\n     * Construct a new instance of PickerPlugin class\n     * @param triggerCharacter The character to trigger a picker to be shown\n     * @param handler Picker handler for receiving picker state change events\n     */\n    constructor(private triggerCharacter: string, private readonly handler: PickerHandler) {}\n\n    /**\n     * Get a friendly name\n     */\n    getName() {\n        return 'Picker';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.isMac = !!editor.getEnvironment().isMac;\n        this.helper = new PickerHelperImpl(editor, this.handler, this.triggerCharacter);\n        this.handler.onInitialize(this.helper);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.handler.onDispose();\n        this.helper = null;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            !!this.helper?.direction &&\n            event.eventType == 'keyDown' &&\n            (isCursorMovingKey(event.rawEvent) ||\n                event.rawEvent.key == 'Enter' ||\n                event.rawEvent.key == 'Tab' ||\n                event.rawEvent.key == 'Escape')\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.helper) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case 'contentChanged':\n                if (this.helper.direction) {\n                    if (event.source == ChangeSource.SetContent) {\n                        this.helper.closePicker();\n                    } else {\n                        this.onSuggestingInput(this.helper);\n                    }\n                }\n                break;\n\n            case 'keyDown':\n                if (this.helper.direction) {\n                    this.onSuggestingKeyDown(this.helper, event.rawEvent);\n                }\n                break;\n\n            case 'input':\n                if (this.helper.direction) {\n                    this.onSuggestingInput(this.helper);\n                } else {\n                    this.onInput(this.helper, event.rawEvent);\n                }\n                break;\n\n            case 'mouseUp':\n                if (this.helper.direction) {\n                    this.helper.closePicker();\n                }\n                break;\n        }\n    }\n\n    private onSuggestingKeyDown(helper: PickerHelperImpl, event: KeyboardEvent) {\n        switch (event.key) {\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                if (helper.direction == 'horizontal' || helper.direction == 'both') {\n                    let isIncrement = event.key == 'ArrowRight';\n\n                    if (helper.editor.getDOMHelper().isRightToLeft()) {\n                        isIncrement = !isIncrement;\n                    }\n\n                    this.handler.onSelectionChanged?.(isIncrement ? 'next' : 'previous');\n                }\n\n                event.preventDefault();\n                break;\n            case 'ArrowUp':\n            case 'ArrowDown':\n                {\n                    const isIncrement = event.key == 'ArrowDown';\n\n                    if (helper.direction != 'horizontal') {\n                        this.handler.onSelectionChanged?.(\n                            helper.direction == 'both'\n                                ? isIncrement\n                                    ? 'nextRow'\n                                    : 'previousRow'\n                                : isIncrement\n                                ? 'next'\n                                : 'previous'\n                        );\n                    }\n                }\n\n                event.preventDefault();\n                break;\n            case 'PageUp':\n            case 'PageDown':\n                this.handler.onSelectionChanged?.(\n                    event.key == 'PageDown' ? 'nextPage' : 'previousPage'\n                );\n\n                event.preventDefault();\n                break;\n            case 'Home':\n            case 'End':\n                const hasCtrl = this.isMac ? event.metaKey : event.ctrlKey;\n                this.handler.onSelectionChanged?.(\n                    event.key == 'Home'\n                        ? hasCtrl\n                            ? 'first'\n                            : 'firstInRow'\n                        : hasCtrl\n                        ? 'last'\n                        : 'lastInRow'\n                );\n\n                event.preventDefault();\n                break;\n            case 'Escape':\n                helper.closePicker();\n                event.preventDefault();\n                break;\n\n            case 'Enter':\n            case 'Tab':\n                this.handler.onSelect?.();\n                event.preventDefault();\n                break;\n        }\n    }\n\n    private onSuggestingInput(helper: PickerHelperImpl) {\n        if (\n            !formatTextSegmentBeforeSelectionMarker(helper.editor, (_, segment, paragraph) => {\n                const newQueryString = getQueryString(\n                    this.triggerCharacter,\n                    paragraph,\n                    segment\n                ).replace(/[\\u0020\\u00A0]/g, ' ');\n                const oldQueryString = this.lastQueryString;\n\n                if (\n                    newQueryString &&\n                    ((newQueryString.length >= oldQueryString.length &&\n                        newQueryString.indexOf(oldQueryString) == 0) ||\n                        (newQueryString.length < oldQueryString.length &&\n                            oldQueryString.indexOf(newQueryString) == 0))\n                ) {\n                    this.lastQueryString = newQueryString;\n                    this.handler.onQueryStringChanged?.(newQueryString);\n                } else {\n                    helper.closePicker();\n                }\n\n                return false;\n            })\n        ) {\n            helper.closePicker();\n        }\n    }\n\n    private onInput(helper: PickerHelperImpl, event: InputEvent) {\n        if (event.inputType == 'insertText' && event.data == this.triggerCharacter) {\n            formatTextSegmentBeforeSelectionMarker(helper.editor, (_, segment) => {\n                if (segment.text.endsWith(this.triggerCharacter)) {\n                    const charBeforeTrigger = segment.text[segment.text.length - 2];\n\n                    if (\n                        !charBeforeTrigger ||\n                        !charBeforeTrigger.trim() ||\n                        isPunctuation(charBeforeTrigger)\n                    ) {\n                        const selection = helper.editor.getDOMSelection();\n                        const pos: DOMInsertPoint | null =\n                            selection?.type == 'range' && selection.range.collapsed\n                                ? {\n                                      node: selection.range.startContainer,\n                                      offset: selection.range.startOffset,\n                                  }\n                                : null;\n\n                        if (pos) {\n                            this.lastQueryString = this.triggerCharacter;\n                            helper.direction = this.handler.onTrigger(this.lastQueryString, pos);\n                        }\n                    }\n                }\n\n                return false;\n            });\n        }\n    }\n}\n","import { splitTextSegment } from 'roosterjs-content-model-api';\nimport type {\n    ContentModelText,\n    ShallowMutableContentModelParagraph,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function getQueryString(\n    triggerCharacter: string,\n    paragraph: ShallowMutableContentModelParagraph,\n    previousSegment: ContentModelText,\n    splittedSegmentResult?: ContentModelText[]\n): string {\n    let result = '';\n    let i = paragraph.segments.indexOf(previousSegment);\n\n    for (; i >= 0; i--) {\n        const segment = paragraph.segments[i];\n\n        if (segment.segmentType != 'Text') {\n            result = '';\n            break;\n        }\n\n        const index = segment.text.lastIndexOf(triggerCharacter);\n\n        if (index >= 0) {\n            result = segment.text.substring(index) + result;\n\n            splittedSegmentResult?.unshift(\n                index > 0\n                    ? splitTextSegment(segment, paragraph, index, segment.text.length)\n                    : segment\n            );\n\n            break;\n        } else {\n            result = segment.text + result;\n\n            splittedSegmentResult?.unshift(segment);\n        }\n    }\n\n    if (i < 0) {\n        result = '';\n    }\n\n    return result;\n}\n","import { getObjectKeys, isNodeOfType } from 'roosterjs-content-model-dom';\nimport type { CreateElementData } from './CreateElementData';\n\n/**\n * @internal\n * Create DOM element from the given CreateElementData\n * @param elementData The CreateElementData or an index of a known CreateElementData used for creating this element\n * @param document The document to create the element from\n * @returns The root DOM element just created\n */\nexport function createElement(elementData: CreateElementData, document: Document): Element | null {\n    if (!elementData || !elementData.tag) {\n        return null;\n    }\n\n    const { tag, namespace, className, style, dataset, attributes, children } = elementData;\n    const result = namespace\n        ? document.createElementNS(namespace, tag)\n        : document.createElement(tag);\n\n    if (style) {\n        result.setAttribute('style', style);\n    }\n\n    if (className) {\n        result.className = className;\n    }\n\n    if (dataset && isNodeOfType(result, 'ELEMENT_NODE')) {\n        getObjectKeys(dataset).forEach(datasetName => {\n            result.dataset[datasetName] = dataset[datasetName];\n        });\n    }\n\n    if (attributes) {\n        getObjectKeys(attributes).forEach(attrName => {\n            result.setAttribute(attrName, attributes[attrName]);\n        });\n    }\n\n    if (children) {\n        children.forEach(child => {\n            if (typeof child === 'string') {\n                result.appendChild(document.createTextNode(child));\n            } else if (child) {\n                const childElement = createElement(child, document);\n                if (childElement) {\n                    result.appendChild(childElement);\n                }\n            }\n        });\n    }\n\n    return result;\n}\n","import type { Disposable } from '../Disposable';\nimport type { DragAndDropHandler } from './DragAndDropHandler';\n\n/**\n * @internal\n */\ninterface MouseEventMoves {\n    MOUSEDOWN: string;\n    MOUSEMOVE: string;\n    MOUSEUP: string;\n}\n\n/**\n * @internal\n */\ninterface MouseEventInfo extends MouseEventMoves {\n    getPageXY: (e: MouseEvent) => number[];\n}\n\n/**\n * @internal\n * Compatible mouse event names for different platform\n */\ninterface TouchEventInfo extends MouseEventMoves {\n    getPageXY: (e: TouchEvent) => number[];\n}\n\n/**\n * Generate event names and getXY function based on different platforms to be compatible with desktop and mobile browsers\n */\nconst MOUSE_EVENT_INFO_DESKTOP: MouseEventInfo = (() => {\n    return {\n        MOUSEDOWN: 'mousedown',\n        MOUSEMOVE: 'mousemove',\n        MOUSEUP: 'mouseup',\n        getPageXY: getMouseEventPageXY,\n    };\n})();\n\nconst MOUSE_EVENT_INFO_MOBILE: TouchEventInfo = (() => {\n    return {\n        MOUSEDOWN: 'touchstart',\n        MOUSEMOVE: 'touchmove',\n        MOUSEUP: 'touchend',\n        getPageXY: getTouchEventPageXY,\n    };\n})();\n\nfunction getMouseEventPageXY(e: MouseEvent): [number, number] {\n    return [e.pageX, e.pageY];\n}\n\nfunction getTouchEventPageXY(e: TouchEvent): [number, number] {\n    let pageX = 0;\n    let pageY = 0;\n    if (e.targetTouches && e.targetTouches.length > 0) {\n        const touch = e.targetTouches[0];\n        pageX = touch.pageX;\n        pageY = touch.pageY;\n    }\n    return [pageX, pageY];\n}\n\n/**\n * @internal\n * A helper class to help manage drag and drop to an HTML element\n */\nexport class DragAndDropHelper<TContext, TInitValue> implements Disposable {\n    private initX: number = 0;\n    private initY: number = 0;\n    private initValue: TInitValue | undefined = undefined;\n    private dndMouse: MouseEventInfo | TouchEventInfo;\n\n    /**\n     * Create a new instance of DragAndDropHelper class\n     * @param trigger The trigger element. When user start drag on this element,\n     * events will be fired to the handler object\n     * @param context Context object that will be passed to handler function when event is fired,\n     * so that the handler object knows which element it is triggered from.\n     * @param onSubmit A callback that will be invoked when event handler in handler object returns true\n     * @param handler The event handler object, see DragAndDropHandler interface for more information\n     * @param zoomScale The zoom scale of the editor\n     * @param forceMobile A boolean to force the use of touch controls for the helper\n     */\n    constructor(\n        private trigger: HTMLElement,\n        private context: TContext,\n        private onSubmit: (context: TContext, trigger: HTMLElement) => void,\n        private handler: DragAndDropHandler<TContext, TInitValue>,\n        private zoomScale: number,\n        forceMobile?: boolean\n    ) {\n        this.dndMouse = forceMobile ? MOUSE_EVENT_INFO_MOBILE : MOUSE_EVENT_INFO_DESKTOP;\n        trigger.addEventListener(this.dndMouse.MOUSEDOWN, this.onMouseDown);\n    }\n\n    /**\n     * Dispose this object, remove all event listeners that has been attached\n     */\n    dispose() {\n        this.trigger.removeEventListener(this.dndMouse.MOUSEDOWN, this.onMouseDown);\n        this.removeDocumentEvents();\n    }\n\n    public get mouseType(): string {\n        return this.dndMouse == MOUSE_EVENT_INFO_MOBILE ? 'touch' : 'mouse';\n    }\n\n    private addDocumentEvents() {\n        const doc = this.trigger.ownerDocument;\n        doc.addEventListener(this.dndMouse.MOUSEMOVE, this.onMouseMove, true /*useCapture*/);\n        doc.addEventListener(this.dndMouse.MOUSEUP, this.onMouseUp, true /*useCapture*/);\n    }\n\n    private removeDocumentEvents() {\n        const doc = this.trigger.ownerDocument;\n        doc.removeEventListener(this.dndMouse.MOUSEMOVE, this.onMouseMove, true /*useCapture*/);\n        doc.removeEventListener(this.dndMouse.MOUSEUP, this.onMouseUp, true /*useCapture*/);\n    }\n\n    private onMouseDown = (e: Event) => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.addDocumentEvents();\n        [this.initX, this.initY] = this.dndMouse.getPageXY(e as MouseEvent & TouchEvent);\n        this.initValue = this.handler.onDragStart?.(this.context, e as MouseEvent);\n    };\n\n    private onMouseMove = (e: Event) => {\n        e.preventDefault();\n        const [pageX, pageY] = this.dndMouse.getPageXY(e as MouseEvent & TouchEvent);\n        const deltaX = (pageX - this.initX) / this.zoomScale;\n        const deltaY = (pageY - this.initY) / this.zoomScale;\n        if (\n            this.initValue &&\n            this.handler.onDragging?.(this.context, e as MouseEvent, this.initValue, deltaX, deltaY)\n        ) {\n            this.onSubmit?.(this.context, this.trigger);\n        }\n    };\n\n    private onMouseUp = (e: Event) => {\n        e.preventDefault();\n        this.removeDocumentEvents();\n        if (this.handler.onDragEnd?.(this.context, e as MouseEvent, this.initValue)) {\n            this.onSubmit?.(this.context, this.trigger);\n        }\n    };\n}\n","import { normalizeRect } from 'roosterjs-content-model-dom';\nimport type { Rect } from 'roosterjs-content-model-types';\n\n/**\n * Get the intersected Rect of elements provided\n *\n * @example\n * The result of the following Elements Rects would be:\n    {\n        top: Element2.top,\n        bottom: Element1.bottom,\n        left: Element2.left,\n        right: Element2.right\n    }\n    +-------------------------+\n    | Element 1               |\n    |   +-----------------+   |\n    |   | Element2        |   |\n    |   |                 |   |\n    |   |                 |   |\n    +-------------------------+\n        |                 |\n        +-----------------+\n * @internal\n * @param elements Elements to use.\n * @param additionalRects additional rects to use\n * @returns If the Rect is valid return the rect, if not, return null.\n */\nexport function getIntersectedRect(\n    elements: HTMLElement[],\n    additionalRects: Rect[] = []\n): Rect | null {\n    const rects = elements\n        .map(element => normalizeRect(element.getBoundingClientRect()))\n        .concat(additionalRects)\n        .filter(element => !!element) as Rect[];\n\n    const result: Rect = {\n        top: Math.max(...rects.map(r => r.top)),\n        bottom: Math.min(...rects.map(r => r.bottom)),\n        left: Math.max(...rects.map(r => r.left)),\n        right: Math.min(...rects.map(r => r.right)),\n    };\n\n    return result.top < result.bottom && result.left < result.right ? result : null;\n}\n","import { cacheGetEventData } from 'roosterjs-content-model-dom';\nimport type { ShortcutCommand, ShortcutKeyDefinition } from './ShortcutCommand';\nimport {\n    ShortcutBold,\n    ShortcutBullet,\n    ShortcutClearFormat,\n    ShortcutDecreaseFont,\n    ShortcutIncreaseFont,\n    ShortcutIndentList,\n    ShortcutItalic,\n    ShortcutNumbering,\n    ShortcutOutdentList,\n    ShortcutRedo,\n    ShortcutRedoAlt,\n    ShortcutRedoMacOS,\n    ShortcutUnderline,\n    ShortcutUndo,\n    ShortcutUndo2,\n} from './shortcuts';\nimport type {\n    EditorPlugin,\n    IEditor,\n    KeyDownEvent,\n    PluginEvent,\n} from 'roosterjs-content-model-types';\n\nconst defaultShortcuts: ShortcutCommand[] = [\n    ShortcutBold,\n    ShortcutItalic,\n    ShortcutUnderline,\n    ShortcutClearFormat,\n    ShortcutUndo,\n    ShortcutUndo2,\n    ShortcutRedo,\n    ShortcutRedoAlt,\n    ShortcutRedoMacOS,\n    ShortcutBullet,\n    ShortcutNumbering,\n    ShortcutIncreaseFont,\n    ShortcutDecreaseFont,\n    ShortcutIndentList,\n    ShortcutOutdentList,\n];\nconst CommandCacheKey = '__ShortcutCommandCache';\n\n/**\n * Shortcut plugin hook on the specified shortcut keys and trigger related format API\n */\nexport class ShortcutPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private isMac = false;\n\n    /**\n     * Create a new instance of ShortcutPlugin\n     * @param [shortcuts=defaultShortcuts] Allowed commands\n     */\n    constructor(private shortcuts: ShortcutCommand[] = defaultShortcuts) {}\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'Shortcut';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.isMac = !!this.editor.getEnvironment().isMac;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check:\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            event.eventType == 'keyDown' &&\n            (event.rawEvent.ctrlKey || event.rawEvent.altKey || event.rawEvent.metaKey) &&\n            !!this.cacheGetCommand(event)\n        );\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor && event.eventType == 'keyDown') {\n            const command = this.cacheGetCommand(event);\n\n            if (command) {\n                command.onClick(this.editor);\n                event.rawEvent.preventDefault();\n            }\n        }\n    }\n\n    private cacheGetCommand(event: KeyDownEvent) {\n        return cacheGetEventData(event, CommandCacheKey, event => {\n            const editor = this.editor;\n            const { ctrlKey, metaKey } = event.rawEvent;\n            if (ctrlKey && metaKey) {\n                // We don't support both Ctrl and Meta key pressed at the same time.\n                return null;\n            }\n            return (\n                editor &&\n                this.shortcuts.filter(\n                    command =>\n                        this.matchOS(command.environment) &&\n                        this.matchShortcut(command.shortcutKey, event.rawEvent)\n                )[0]\n            );\n        });\n    }\n\n    private matchOS(environment?: 'all' | 'mac' | 'nonMac') {\n        switch (environment) {\n            case 'mac':\n                return this.isMac;\n\n            case 'nonMac':\n                return !this.isMac;\n\n            default:\n                return true;\n        }\n    }\n\n    private matchShortcut(shortcutKey: ShortcutKeyDefinition, event: KeyboardEvent) {\n        const { ctrlKey, altKey, shiftKey, which, metaKey } = event;\n        const ctrlOrMeta = this.isMac ? metaKey : ctrlKey;\n        const matchModifier =\n            (shortcutKey.modifierKey == 'ctrl' && ctrlOrMeta && !altKey) ||\n            (shortcutKey.modifierKey == 'alt' && altKey && !ctrlOrMeta);\n\n        return matchModifier && shiftKey == shortcutKey.shiftKey && shortcutKey.which == which;\n    }\n}\n","import { redo, undo } from 'roosterjs-content-model-core';\nimport { setShortcutIndentationCommand } from './utils/setShortcutIndentationCommand';\nimport {\n    changeFontSize,\n    clearFormat,\n    toggleBold,\n    toggleBullet,\n    toggleItalic,\n    toggleNumbering,\n    toggleUnderline,\n} from 'roosterjs-content-model-api';\nimport type { ShortcutCommand } from './ShortcutCommand';\n\nconst enum Keys {\n    BACKSPACE = 8,\n    SPACE = 32,\n    B = 66,\n    I = 73,\n    U = 85,\n    Y = 89,\n    Z = 90,\n    COMMA = 188,\n    PERIOD = 190,\n    FORWARD_SLASH = 191,\n    ArrowRight = 39,\n    ArrowLeft = 37,\n}\n\n/**\n * Shortcut command for Bold\n * Windows: Ctrl + B\n * MacOS: Meta + B\n */\nexport const ShortcutBold: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: false,\n        which: Keys.B,\n    },\n    onClick: editor =>\n        toggleBold(editor, {\n            announceFormatChange: true,\n        }),\n};\n\n/**\n * Shortcut command for Italic\n * Windows: Ctrl + I\n * MacOS: Meta + I\n */\nexport const ShortcutItalic: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: false,\n        which: Keys.I,\n    },\n    onClick: editor =>\n        toggleItalic(editor, {\n            announceFormatChange: true,\n        }),\n};\n\n/**\n * Shortcut command for Underline\n * Windows: Ctrl + U\n * MacOS: Meta + U\n */\nexport const ShortcutUnderline: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: false,\n        which: Keys.U,\n    },\n    onClick: editor =>\n        toggleUnderline(editor, {\n            announceFormatChange: true,\n        }),\n};\n\n/**\n * Shortcut command for Clear Format\n * Windows: Ctrl + Space\n * MacOS: Meta + Space, this shortcut is the same as the default global spotlight shortcut, so it is invalid if the user keeps spotlights.\n */\nexport const ShortcutClearFormat: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: false,\n        which: Keys.SPACE,\n    },\n    onClick: editor => clearFormat(editor),\n};\n\n/**\n * Shortcut command for Undo 1\n * Windows: Ctrl + Z\n * MacOS: Meta + Z\n */\nexport const ShortcutUndo: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: false,\n        which: Keys.Z,\n    },\n    onClick: editor => undo(editor),\n};\n\n/**\n * Shortcut command for Undo 2\n * Windows: Alt + Backspace\n * MacOS: N/A\n */\nexport const ShortcutUndo2: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'alt',\n        shiftKey: false,\n        which: Keys.BACKSPACE,\n    },\n    onClick: editor => undo(editor),\n    environment: 'nonMac',\n};\n\n/**\n * Shortcut command for Redo 1\n * Windows: Ctrl + Y\n * MacOS: N/A\n */\nexport const ShortcutRedo: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: false,\n        which: Keys.Y,\n    },\n    onClick: editor => redo(editor),\n    environment: 'nonMac',\n};\n\n/**\n * @deprecated\n * Shortcut command for Redo 2\n * Windows: N/A\n * MacOS: Meta + Shift + Z\n */\nexport const ShortcutRedoMacOS: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: true,\n        which: Keys.Z,\n    },\n    onClick: editor => redo(editor),\n    environment: 'mac',\n};\n\n/**\n * Shortcut command for Redo 3\n * Windows: Ctrl + Shift + Z\n * MacOS: Meta + Shift + Z\n */\nexport const ShortcutRedoAlt: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: true,\n        which: Keys.Z,\n    },\n    onClick: editor => redo(editor),\n};\n\n/**\n * Shortcut command for Bullet List\n * Windows: Ctrl + . (Period)\n * MacOS: Meta + . (Period)\n */\nexport const ShortcutBullet: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: false,\n        which: Keys.PERIOD,\n    },\n    onClick: editor => toggleBullet(editor),\n};\n\n/**\n * Shortcut command for Numbering List\n * Windows: Ctrl + / (Forward slash)\n * MacOS: Meta + / (Forward slash)\n */\nexport const ShortcutNumbering: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: false,\n        which: Keys.FORWARD_SLASH,\n    },\n    onClick: editor => toggleNumbering(editor),\n};\n\n/**\n * Shortcut command for Increase Font\n * Windows: Ctrl + Shift + . (Period)\n * MacOS: Meta + Shift + . (Period)\n */\nexport const ShortcutIncreaseFont: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: true,\n        which: Keys.PERIOD,\n    },\n    onClick: editor => changeFontSize(editor, 'increase'),\n};\n\n/**\n * Shortcut command for Decrease Font\n * Windows: Ctrl + Shift + , (Comma)\n * MacOS: Meta + Shift + , (Comma)\n */\nexport const ShortcutDecreaseFont: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'ctrl',\n        shiftKey: true,\n        which: Keys.COMMA,\n    },\n    onClick: editor => changeFontSize(editor, 'decrease'),\n};\n\n/**\n * Shortcut command for Intent list\n * Windows: Alt + Shift + Arrow Right\n * MacOS: N/A\n */\nexport const ShortcutIndentList: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'alt',\n        shiftKey: true,\n        which: Keys.ArrowRight,\n    },\n    onClick: editor => {\n        setShortcutIndentationCommand(editor, 'indent');\n    },\n    environment: 'nonMac',\n};\n\n/**\n * Shortcut command for Outdent list\n * Windows: Alt + Shift + Arrow Left\n * MacOS: N/A\n */\nexport const ShortcutOutdentList: ShortcutCommand = {\n    shortcutKey: {\n        modifierKey: 'alt',\n        shiftKey: true,\n        which: Keys.ArrowLeft,\n    },\n    onClick: editor => {\n        setShortcutIndentationCommand(editor, 'outdent');\n    },\n    environment: 'nonMac',\n};\n","import { getFirstSelectedListItem } from 'roosterjs-content-model-dom';\nimport { setModelIndentation } from 'roosterjs-content-model-api';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function setShortcutIndentationCommand(editor: IEditor, operation: 'indent' | 'outdent') {\n    editor.formatContentModel((model, context) => {\n        const listItem = getFirstSelectedListItem(model);\n\n        if (\n            listItem &&\n            listItem.blocks[0].blockType == 'Paragraph' &&\n            listItem.blocks[0].segments[0].segmentType == 'SelectionMarker'\n        ) {\n            setModelIndentation(model, operation, undefined /*length*/, context);\n            return true;\n        }\n        return false;\n    });\n}\n","import { isNodeOfType, normalizeRect } from 'roosterjs-content-model-dom';\nimport { TableEditor } from './editors/TableEditor';\nimport type { TableWithRoot } from './TableWithRoot';\nimport type { TableEditFeatureName } from './editors/features/TableEditFeatureName';\nimport type { OnTableEditorCreatedCallback } from './OnTableEditorCreatedCallback';\nimport type {\n    DOMHelper,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    Rect,\n} from 'roosterjs-content-model-types';\n\nconst TABLE_RESIZER_LENGTH = 12;\n\n/**\n * TableEdit plugin, provides the ability to resize a table by drag-and-drop\n */\nexport class TableEditPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private onMouseMoveDisposer: (() => void) | null = null;\n    private tableRectMap: (TableWithRoot & { rect: Rect })[] | null = null;\n    private tableEditor: TableEditor | null = null;\n\n    /**\n     * Construct a new instance of TableResize plugin\n     * @param anchorContainerSelector An optional selector string to specify the container to host the plugin.\n     * The container must not be affected by transform: scale(), otherwise the position calculation will be wrong.\n     * If not specified, the plugin will be inserted in document.body\n     * @param onTableEditorCreated An optional callback to customize the Table Editors elements when created.\n     * @param disableFeatures An optional array of TableEditFeatures to disable\n     * @param tableSelector A function to select the tables to be edited. By default, it selects all contentEditable tables.\n     */\n    constructor(\n        private anchorContainerSelector?: string,\n        private onTableEditorCreated?: OnTableEditorCreatedCallback,\n        private disableFeatures?: TableEditFeatureName[],\n        private tableSelector: (domHelper: DOMHelper) => TableWithRoot[] = defaultTableSelector\n    ) {}\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'TableEdit';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.onMouseMoveDisposer = this.editor.attachDomEvent({\n            mousemove: { beforeDispatch: this.onMouseMove },\n        });\n        const scrollContainer = this.editor.getScrollContainer();\n        scrollContainer.addEventListener('mouseout', this.onMouseOut);\n    }\n\n    private onMouseOut = ({ relatedTarget, currentTarget }: MouseEvent) => {\n        const relatedTargetNode = relatedTarget as Node;\n        const currentTargetNode = currentTarget as Node;\n        if (\n            isNodeOfType(relatedTargetNode, 'ELEMENT_NODE') &&\n            isNodeOfType(currentTargetNode, 'ELEMENT_NODE') &&\n            this.tableEditor &&\n            !this.tableEditor.isOwnedElement(relatedTargetNode) &&\n            !currentTargetNode.contains(relatedTargetNode)\n        ) {\n            this.setTableEditor(null);\n        }\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        const scrollContainer = this.editor?.getScrollContainer();\n        scrollContainer?.removeEventListener('mouseout', this.onMouseOut);\n        this.onMouseMoveDisposer?.();\n        this.invalidateTableRects();\n        this.disposeTableEditor();\n        this.editor = null;\n        this.onMouseMoveDisposer = null;\n        this.onTableEditorCreated = undefined;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        switch (e.eventType) {\n            case 'input':\n            case 'contentChanged':\n            case 'scroll':\n            case 'zoomChanged':\n                this.setTableEditor(null);\n                this.invalidateTableRects();\n                break;\n        }\n    }\n\n    private onMouseMove = (event: Event) => {\n        const e = event as MouseEvent;\n        const editorWindow = this.editor?.getDocument().defaultView;\n\n        if (e.buttons > 0 || !editorWindow) {\n            return;\n        }\n\n        this.ensureTableRects();\n\n        const x = e.pageX - editorWindow.scrollX;\n        const y = e.pageY - editorWindow.scrollY;\n        let currentTable: TableWithRoot | null = null;\n\n        //Find table in range of mouse\n        if (this.tableRectMap) {\n            for (let i = this.tableRectMap.length - 1; i >= 0; i--) {\n                const entry = this.tableRectMap[i];\n                const { rect } = entry;\n\n                if (\n                    x >= rect.left - TABLE_RESIZER_LENGTH &&\n                    x <= rect.right + TABLE_RESIZER_LENGTH &&\n                    y >= rect.top - TABLE_RESIZER_LENGTH &&\n                    y <= rect.bottom + TABLE_RESIZER_LENGTH\n                ) {\n                    currentTable = entry;\n                    break;\n                }\n            }\n        }\n\n        this.setTableEditor(currentTable, e);\n        this.tableEditor?.onMouseMove(x, y);\n    };\n\n    /**\n     * @internal Public only for unit test\n     * @param entry Table to use when setting the Editors\n     * @param event (Optional) Mouse event\n     */\n    public setTableEditor(entry: TableWithRoot | null, event?: MouseEvent) {\n        if (\n            this.tableEditor &&\n            !this.tableEditor.isEditing() &&\n            entry?.table != this.tableEditor.table\n        ) {\n            this.disposeTableEditor();\n        }\n\n        if (!this.tableEditor && entry && this.editor && entry.table.rows.length > 0) {\n            // anchorContainerSelector is used to specify the container to host the plugin, which can be outside of the editor's div\n            const container = this.anchorContainerSelector\n                ? this.editor.getDocument().querySelector(this.anchorContainerSelector)\n                : undefined;\n\n            this.tableEditor = new TableEditor(\n                this.editor,\n                entry.table,\n                entry.logicalRoot,\n                this.invalidateTableRects,\n                isNodeOfType(container, 'ELEMENT_NODE') ? container : undefined,\n                event?.currentTarget,\n                this.onTableEditorCreated,\n                this.disableFeatures\n            );\n        }\n    }\n\n    private invalidateTableRects = () => {\n        this.tableRectMap = null;\n    };\n\n    private disposeTableEditor() {\n        this.tableEditor?.dispose();\n        this.tableEditor = null;\n    }\n\n    private ensureTableRects() {\n        if (!this.tableRectMap && this.editor) {\n            this.tableRectMap = [];\n\n            const tables = this.tableSelector(this.editor.getDOMHelper());\n            tables.forEach(table => {\n                const rect = normalizeRect(table.table.getBoundingClientRect());\n\n                if (rect && this.tableRectMap) {\n                    this.tableRectMap.push({\n                        ...table,\n                        rect,\n                    });\n                }\n            });\n        }\n    }\n}\n\nfunction defaultTableSelector(domHelper: DOMHelper): TableWithRoot[] {\n    return domHelper\n        .queryElements('table')\n        .filter(table => table.isContentEditable)\n        .map(table => ({\n            table,\n            logicalRoot: null,\n        }));\n}\n","import { createCellResizer } from './features/CellResizer';\nimport { createTableInserter } from './features/TableInserter';\nimport { createTableMover } from './features/TableMover';\nimport { createTableResizer } from './features/TableResizer';\nimport { createTableRowColumnSelector } from './features/TableRowColumnSelector';\nimport { disposeTableEditFeature } from './features/TableEditFeature';\nimport { isNodeOfType, normalizeRect, parseTableCells } from 'roosterjs-content-model-dom';\nimport type { OnTableEditorCreatedCallback } from '../OnTableEditorCreatedCallback';\nimport type { TableEditFeature } from './features/TableEditFeature';\nimport type { IEditor, TableSelection } from 'roosterjs-content-model-types';\nimport type { TableEditFeatureName } from './features/TableEditFeatureName';\n\nconst INSERTER_HOVER_OFFSET = 6;\nconst enum TOP_OR_SIDE {\n    top = 0,\n    side = 1,\n}\n/**\n * @internal\n *\n * A table has 6 hot areas to be resized/edited (take LTR example):\n *\n *   [6]  [                ]\n *       +[      1         ]+--------------------+\n *       |[                ]|                    |\n *      [ ]               [ ]                    |\n *      [ ]               [ ]                    |\n *      [2]               [3]                    |\n *      [ ]               [ ]                    |\n *      [ ][       4       ]|                    |\n *       +------------------+--------------------+\n *       |                  |                    |\n *       |                  |                    |\n *       |                  |                    |\n *       +------------------+--------------------+\n *                                                [5]\n *\n * 1 - Hover area to show insert column button\n * 2 - Hover area to show insert row button\n * 3 - Hover area to show vertical resizing bar\n * 4 - Hover area to show horizontal resizing bar\n * 5 - Hover area to show whole table resize handle\n * 6 - Hover area to show whole table mover handle\n *\n * When set a different current table or change current TD, we need to update these areas\n */\nexport class TableEditor {\n    // 1, 2 - Insert a column or a row\n    private horizontalInserter: TableEditFeature | null = null;\n    private verticalInserter: TableEditFeature | null = null;\n\n    // 3, 4 - Resize a column or a row from a cell\n    private horizontalResizer: TableEditFeature | null = null;\n    private verticalResizer: TableEditFeature | null = null;\n\n    // 5 - Resize whole table\n    private tableResizer: TableEditFeature | null = null;\n\n    // 6 - Move as well as select whole table\n    private tableMover: TableEditFeature | null = null;\n\n    // 7 - Select whole column or row\n    private tableColumnSelector: TableEditFeature | null = null;\n    private tableRowSelector: TableEditFeature | null = null;\n\n    private isRTL: boolean;\n    private range: Range | null = null;\n    private isCurrentlyEditing: boolean;\n\n    constructor(\n        private editor: IEditor,\n        public readonly table: HTMLTableElement,\n        public readonly logicalRoot: HTMLDivElement | null,\n        private onChanged: () => void,\n        private anchorContainer?: HTMLElement,\n        private contentDiv?: EventTarget | null,\n        private onTableEditorCreated?: OnTableEditorCreatedCallback,\n        private disableFeatures?: TableEditFeatureName[]\n    ) {\n        this.isRTL = editor.getDocument().defaultView?.getComputedStyle(table).direction == 'rtl';\n        this.setEditorFeatures();\n        this.isCurrentlyEditing = false;\n    }\n\n    dispose() {\n        this.disposeTableResizer();\n        this.disposeCellResizers();\n        this.disposeTableInserter();\n        this.disposeTableMover();\n        this.disposeTableSelector();\n    }\n\n    isEditing(): boolean {\n        return this.isCurrentlyEditing;\n    }\n\n    isOwnedElement(node: Node) {\n        return [\n            this.tableResizer,\n            this.tableMover,\n            this.horizontalInserter,\n            this.verticalInserter,\n            this.horizontalResizer,\n            this.verticalResizer,\n            this.tableColumnSelector,\n            this.tableRowSelector,\n        ]\n            .filter(feature => !!feature?.div)\n            .some(feature => feature?.div == node || (feature?.div && feature.div.contains(node)));\n    }\n    /**\n     * public only for testing purposes\n     */\n    public onMouseMove(x: number, y: number) {\n        // Get whole table rect\n        const tableRect = normalizeRect(this.table.getBoundingClientRect());\n\n        if (!tableRect) {\n            return;\n        }\n\n        // Determine if cursor is on top or side\n        const topOrSide =\n            y <= tableRect.top + INSERTER_HOVER_OFFSET\n                ? TOP_OR_SIDE.top\n                : this.isRTL\n                ? x >= tableRect.right - INSERTER_HOVER_OFFSET\n                    ? TOP_OR_SIDE.side\n                    : undefined\n                : x <= tableRect.left + INSERTER_HOVER_OFFSET\n                ? TOP_OR_SIDE.side\n                : undefined;\n        const topOrSideBinary = topOrSide ? 1 : 0;\n\n        // i is row index, j is column index\n        for (let i = 0; i < this.table.rows.length; i++) {\n            const tr = this.table.rows[i];\n            let j = 0;\n            for (; j < tr.cells.length; j++) {\n                const td = tr.cells[j];\n                const tdRect = normalizeRect(td.getBoundingClientRect());\n\n                if (!tdRect || !tableRect) {\n                    continue;\n                }\n\n                // Determine the cell the cursor is in range of\n                // Offset is only used for first row and column\n                const lessThanBottom = y <= tdRect.bottom;\n                const lessThanRight = this.isRTL\n                    ? x <= tdRect.right + INSERTER_HOVER_OFFSET * topOrSideBinary\n                    : x <= tdRect.right;\n                const moreThanLeft = this.isRTL\n                    ? x >= tdRect.left\n                    : x >= tdRect.left - INSERTER_HOVER_OFFSET * topOrSideBinary;\n\n                if (lessThanBottom && lessThanRight && moreThanLeft) {\n                    if (i === 0 && topOrSide == TOP_OR_SIDE.top) {\n                        const center = (tdRect.left + tdRect.right) / 2;\n                        const isOnRightHalf = this.isRTL ? x < center : x > center;\n                        !this.isFeatureDisabled('VerticalTableInserter') &&\n                            this.setInserterTd(\n                                isOnRightHalf ? td : tr.cells[j - 1],\n                                false /*isHorizontal*/\n                            );\n                    } else if (j === 0 && topOrSide == TOP_OR_SIDE.side) {\n                        const tdAbove = this.table.rows[i - 1]?.cells[0];\n                        const tdAboveRect = tdAbove\n                            ? normalizeRect(tdAbove.getBoundingClientRect())\n                            : null;\n\n                        const isTdNotAboveMerged = !tdAboveRect\n                            ? null\n                            : this.isRTL\n                            ? tdAboveRect.right === tdRect.right\n                            : tdAboveRect.left === tdRect.left;\n\n                        !this.isFeatureDisabled('HorizontalTableInserter') &&\n                            this.setInserterTd(\n                                y < (tdRect.top + tdRect.bottom) / 2 && isTdNotAboveMerged\n                                    ? tdAbove\n                                    : td,\n                                true /*isHorizontal*/\n                            );\n                    } else {\n                        this.setInserterTd(null);\n                    }\n\n                    !this.isFeatureDisabled('CellResizer') && this.setResizingTd(td);\n\n                    //Cell found\n                    break;\n                }\n            }\n\n            if (j < tr.cells.length) {\n                break;\n            }\n        }\n\n        if (topOrSide == TOP_OR_SIDE.top) {\n            !this.isFeatureDisabled('TableColumnSelector') &&\n                this.setSelectorRowColumn(false /*isRow*/);\n        } else if (topOrSide == TOP_OR_SIDE.side) {\n            !this.isFeatureDisabled('TableRowSelector') &&\n                this.setSelectorRowColumn(true /*isRow*/);\n        } else {\n            this.setSelectorRowColumn(null);\n        }\n\n        // Create Mover and Resizer\n        this.setEditorFeatures();\n    }\n\n    private setEditorFeatures() {\n        const disableSelector = this.isFeatureDisabled('TableSelector');\n        const disableMovement = this.isFeatureDisabled('TableMover');\n        if (!this.tableMover && !(disableSelector && disableMovement)) {\n            this.tableMover = createTableMover(\n                this.table,\n                this.editor,\n                this.isRTL,\n                disableSelector ? () => {} : this.onSelect,\n                this.onStartTableMove,\n                this.onEndTableMove,\n                this.contentDiv,\n                this.anchorContainer,\n                this.onEditorCreated,\n                disableMovement\n            );\n        }\n\n        if (!this.tableResizer && !this.isFeatureDisabled('TableResizer')) {\n            this.tableResizer = createTableResizer(\n                this.table,\n                this.editor,\n                this.isRTL,\n                this.onStartTableResize,\n                this.onFinishEditing,\n                this.contentDiv,\n                this.anchorContainer,\n                this.onTableEditorCreated\n            );\n        }\n    }\n\n    private onEditorCreated = (featureType: TableEditFeatureName, element: HTMLElement) => {\n        const disposer = this.onTableEditorCreated?.(featureType, element);\n        const onMouseOut = element && this.getOnMouseOut(element);\n        if (onMouseOut) {\n            element.addEventListener('mouseout', onMouseOut);\n        }\n\n        return () => {\n            disposer?.();\n            if (onMouseOut) {\n                element.removeEventListener('mouseout', onMouseOut);\n            }\n        };\n    };\n\n    private setResizingTd(td: HTMLTableCellElement) {\n        if (this.horizontalResizer && this.horizontalResizer.node != td) {\n            this.disposeCellResizers();\n        }\n\n        if (!this.horizontalResizer && td) {\n            this.horizontalResizer = createCellResizer(\n                this.editor,\n                td,\n                this.table,\n                this.isRTL,\n                true /*isHorizontal*/,\n                this.onStartCellResize,\n                this.onFinishEditing,\n                this.anchorContainer,\n                this.onTableEditorCreated\n            );\n            this.verticalResizer = createCellResizer(\n                this.editor,\n                td,\n                this.table,\n                this.isRTL,\n                false /*isHorizontal*/,\n                this.onStartCellResize,\n                this.onFinishEditing,\n                this.anchorContainer,\n                this.onTableEditorCreated\n            );\n        }\n    }\n\n    /**\n     * create or remove TableInserter\n     * @param td td to attach to, set this to null to remove inserters (both horizontal and vertical)\n     */\n    private setInserterTd(td: HTMLTableCellElement | null, isHorizontal?: boolean) {\n        const inserter = isHorizontal ? this.horizontalInserter : this.verticalInserter;\n        if (td === null || (inserter && inserter.node != td)) {\n            this.disposeTableInserter();\n        }\n\n        if (!this.horizontalInserter && !this.verticalInserter && td) {\n            const newInserter = createTableInserter(\n                this.editor,\n                td,\n                this.table,\n                this.isRTL,\n                !!isHorizontal,\n                this.onBeforeEditTable,\n                this.onAfterInsert,\n                this.anchorContainer,\n                this.onEditorCreated\n            );\n            if (isHorizontal) {\n                this.horizontalInserter = newInserter;\n            } else {\n                this.verticalInserter = newInserter;\n            }\n        }\n    }\n\n    private setSelectorRowColumn(isRowSelector: boolean | null /*undefined means to clear both*/) {\n        if (isRowSelector !== null && !this.tableRowSelector && !this.tableColumnSelector) {\n            this.tableRowSelector = createTableRowColumnSelector(\n                this.editor,\n                this.table,\n                !!isRowSelector,\n                this.anchorContainer,\n                this.onEditorCreated\n            );\n        } else {\n            this.disposeTableSelector();\n        }\n    }\n\n    private disposeTableResizer() {\n        if (this.tableResizer) {\n            disposeTableEditFeature(this.tableResizer);\n            this.tableResizer = null;\n        }\n    }\n\n    private disposeTableInserter() {\n        if (this.horizontalInserter) {\n            disposeTableEditFeature(this.horizontalInserter);\n            this.horizontalInserter = null;\n        }\n        if (this.verticalInserter) {\n            disposeTableEditFeature(this.verticalInserter);\n            this.verticalInserter = null;\n        }\n    }\n\n    private disposeTableSelector() {\n        if (this.tableColumnSelector) {\n            disposeTableEditFeature(this.tableColumnSelector);\n            this.tableColumnSelector = null;\n        }\n        if (this.tableRowSelector) {\n            disposeTableEditFeature(this.tableRowSelector);\n            this.tableRowSelector = null;\n        }\n    }\n\n    private disposeCellResizers() {\n        if (this.horizontalResizer) {\n            disposeTableEditFeature(this.horizontalResizer);\n            this.horizontalResizer = null;\n        }\n        if (this.verticalResizer) {\n            disposeTableEditFeature(this.verticalResizer);\n            this.verticalResizer = null;\n        }\n    }\n\n    private disposeTableMover() {\n        if (this.tableMover) {\n            disposeTableEditFeature(this.tableMover);\n            this.tableMover = null;\n        }\n    }\n\n    private onFinishEditing = (): false => {\n        this.editor.focus();\n\n        if (this.range) {\n            this.editor.setDOMSelection({ type: 'range', range: this.range, isReverted: false });\n            this.range = null;\n        }\n\n        this.editor.takeSnapshot(); // Pass in an empty callback to make sure ContentChangedEvent is triggered\n        this.onChanged();\n        this.isCurrentlyEditing = false;\n\n        return false;\n    };\n\n    private onStartTableResize = () => {\n        this.isCurrentlyEditing = true;\n        this.onStartResize();\n    };\n\n    private onStartCellResize = () => {\n        this.isCurrentlyEditing = true;\n        this.disposeTableResizer();\n        this.onStartResize();\n    };\n\n    private onStartTableMove = () => {\n        this.onBeforeEditTable();\n        this.isCurrentlyEditing = true;\n        this.disposeTableResizer();\n        this.disposeTableInserter();\n        this.disposeCellResizers();\n        this.disposeTableSelector();\n    };\n\n    private onStartResize() {\n        this.onBeforeEditTable();\n        this.isCurrentlyEditing = true;\n        const range = this.editor.getDOMSelection();\n\n        if (range && range.type == 'range') {\n            this.range = range.range;\n        }\n\n        this.editor.takeSnapshot();\n    }\n\n    private onEndTableMove = (disposeHandler: boolean) => {\n        if (disposeHandler) {\n            this.disposeTableMover();\n        }\n        return this.onFinishEditing();\n    };\n\n    private onBeforeEditTable = () => {\n        this.editor.setLogicalRoot(this.logicalRoot);\n    };\n\n    private onAfterInsert = () => {\n        this.disposeTableResizer();\n        this.onFinishEditing();\n    };\n\n    /**\n     * Public only for testing purposes\n     * @param table the table to select\n     */\n    public onSelect = (table: HTMLTableElement) => {\n        this.editor.focus();\n\n        if (table) {\n            const parsedTable = parseTableCells(table);\n            const selection: TableSelection = {\n                table: table,\n                firstRow: 0,\n                firstColumn: 0,\n                lastRow: parsedTable.length - 1,\n                lastColumn: (parsedTable[0]?.length ?? 0) - 1,\n                type: 'table',\n            };\n\n            this.editor.setDOMSelection(selection);\n        }\n    };\n\n    private getOnMouseOut = (feature: HTMLElement) => {\n        return (ev: MouseEvent) => {\n            if (\n                feature &&\n                ev.relatedTarget != feature &&\n                isNodeOfType(this.contentDiv as Node, 'ELEMENT_NODE') &&\n                isNodeOfType(ev.relatedTarget as Node, 'ELEMENT_NODE') &&\n                !(this.contentDiv == ev.relatedTarget) &&\n                !this.isEditing()\n            ) {\n                this.dispose();\n            }\n        };\n    };\n\n    private isFeatureDisabled(feature: TableEditFeatureName) {\n        return this.disableFeatures?.includes(feature);\n    }\n}\n","import { createElement } from '../../../pluginUtils/CreateElement/createElement';\nimport { DragAndDropHelper } from '../../../pluginUtils/DragAndDrop/DragAndDropHelper';\nimport { getCMTableFromTable } from '../utils/getTableFromContentModel';\nimport type { TableEditFeature } from './TableEditFeature';\nimport {\n    normalizeRect,\n    MIN_ALLOWED_TABLE_CELL_WIDTH,\n    mutateBlock,\n    MIN_ALLOWED_TABLE_CELL_HEIGHT,\n    parseValueWithUnit,\n} from 'roosterjs-content-model-dom';\nimport type { DragAndDropHandler } from '../../../pluginUtils/DragAndDrop/DragAndDropHandler';\nimport type { IEditor, ReadonlyContentModelTable } from 'roosterjs-content-model-types';\nimport type { OnTableEditorCreatedCallback } from '../../OnTableEditorCreatedCallback';\n\nconst CELL_RESIZER_WIDTH = 4;\n/**\n * @internal\n */\nexport const HORIZONTAL_RESIZER_ID = 'horizontalResizer';\n/**\n * @internal\n */\nexport const VERTICAL_RESIZER_ID = 'verticalResizer';\n\n/**\n * @internal\n */\nexport function createCellResizer(\n    editor: IEditor,\n    td: HTMLTableCellElement,\n    table: HTMLTableElement,\n    isRTL: boolean,\n    isHorizontal: boolean,\n    onStart: () => void,\n    onEnd: () => false,\n    anchorContainer?: HTMLElement,\n    onTableEditorCreated?: OnTableEditorCreatedCallback\n): TableEditFeature | null {\n    const document = td.ownerDocument;\n    const createElementData = {\n        tag: 'div',\n        style: `position: fixed; cursor: ${isHorizontal ? 'row' : 'col'}-resize; user-select: none`,\n    };\n    const zoomScale = editor.getDOMHelper().calculateZoomScale();\n\n    const div = createElement(createElementData, document) as HTMLDivElement;\n\n    (anchorContainer || document.body).appendChild(div);\n\n    const context: CellResizerContext = {\n        editor,\n        td,\n        table,\n        isRTL,\n        zoomScale,\n        onStart,\n        originalWidth: parseValueWithUnit(table.style.width),\n    };\n    const setPosition = isHorizontal ? setHorizontalPosition : setVerticalPosition;\n    setPosition(context, div);\n\n    const handler: DragAndDropHandler<CellResizerContext, CellResizerInitValue> = {\n        onDragStart,\n        // Horizontal modifies row height, vertical modifies column width\n        onDragging: isHorizontal ? onDraggingHorizontal : onDraggingVertical,\n        onDragEnd: onEnd,\n    };\n\n    const featureHandler = new CellResizer(\n        div,\n        context,\n        setPosition,\n        handler,\n        zoomScale,\n        editor.getEnvironment().isMobileOrTablet,\n        onTableEditorCreated\n    );\n\n    return { node: td, div, featureHandler };\n}\n\nclass CellResizer extends DragAndDropHelper<CellResizerContext, CellResizerInitValue> {\n    private disposer: undefined | (() => void);\n\n    constructor(\n        trigger: HTMLElement,\n        context: CellResizerContext,\n        onSubmit: (context: CellResizerContext, trigger: HTMLElement) => void,\n        handler: DragAndDropHandler<CellResizerContext, CellResizerInitValue>,\n        zoomScale: number,\n        forceMobile?: boolean,\n        onTableEditorCreated?: OnTableEditorCreatedCallback\n    ) {\n        super(trigger, context, onSubmit, handler, zoomScale, forceMobile);\n        this.disposer = onTableEditorCreated?.('CellResizer', trigger);\n    }\n\n    dispose(): void {\n        this.disposer?.();\n        this.disposer = undefined;\n        super.dispose();\n    }\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport interface CellResizerContext {\n    editor: IEditor;\n    td: HTMLTableCellElement;\n    table: HTMLTableElement;\n    isRTL: boolean;\n    zoomScale: number;\n    originalWidth: number;\n    onStart: () => void;\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport interface CellResizerInitValue {\n    cmTable: ReadonlyContentModelTable | undefined;\n    anchorColumn: number | undefined;\n    nextColumn: number;\n    anchorRow: number | undefined;\n    anchorRowHeight: number;\n    allWidths: number[];\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragStart(context: CellResizerContext, event: MouseEvent): CellResizerInitValue {\n    const { td, onStart } = context;\n    const rect = normalizeRect(td.getBoundingClientRect());\n\n    // Get cell coordinates\n    let rowIndex: number | undefined;\n    let columnIndex: number | undefined;\n    let nextColumnIndex = -1;\n\n    const { editor, table } = context;\n\n    // Get Table block in content model\n    const cmTable = getCMTableFromTable(editor, table);\n\n    if (rect && cmTable) {\n        for (let r = 0; r < cmTable?.rows.length; r++) {\n            for (let c = 0; c < cmTable.rows[r].cells.length; c++) {\n                const cell = cmTable.rows[r].cells[c];\n\n                if (cell.cachedElement == td) {\n                    // Target cell found, record its position\n                    rowIndex = r;\n                    columnIndex = c;\n                } else if (rowIndex != undefined && columnIndex != undefined) {\n                    // rowIndex and columnIndex are already found, we can find nextColumnIndex now\n                    if (!cell.cachedElement) {\n                        // No cached element means this cell is merged, so this could potentially be the right side of column\n                        // We are trying to find the last merged cell so we can modify its width later\n                        columnIndex = c;\n                    } else {\n                        // Since we already found the target cell, the first cell with cachedElement after that must be the next column\n                        nextColumnIndex = c;\n                        break;\n                    }\n                }\n            }\n\n            // As long as rowIndex is found, we can break here, no matter if nextColumnIndex is found or not\n            // because for the last column case, nextColumnIndex will be -1\n            if (rowIndex != undefined) {\n                break;\n            }\n        }\n\n        onStart();\n\n        if (rowIndex !== undefined) {\n            return {\n                cmTable,\n                anchorColumn: columnIndex,\n                nextColumn: nextColumnIndex,\n                anchorRow: rowIndex,\n                anchorRowHeight: cmTable.rows[rowIndex].height,\n                allWidths: [...cmTable.widths],\n            };\n        }\n    }\n\n    return {\n        cmTable,\n        anchorColumn: undefined,\n        anchorRow: undefined,\n        anchorRowHeight: -1,\n        allWidths: [],\n        nextColumn: -1,\n    }; // Just a fallback\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDraggingHorizontal(\n    context: CellResizerContext,\n    event: MouseEvent,\n    initValue: CellResizerInitValue,\n    deltaX: number,\n    deltaY: number\n) {\n    const { cmTable, anchorRow, anchorRowHeight } = initValue;\n\n    // Assign new widths and heights to the CM table\n    if (cmTable && anchorRow != undefined && cmTable.rows[anchorRow] != undefined) {\n        // Modify the CM Table size\n        mutateBlock(cmTable).rows[anchorRow].height = (anchorRowHeight ?? 0) + deltaY;\n\n        // Normalize the new height value\n        const newHeight = Math.max(cmTable.rows[anchorRow].height, MIN_ALLOWED_TABLE_CELL_HEIGHT);\n\n        // Writeback CM Table size changes to DOM Table\n        const tableRow = cmTable.rows[anchorRow].cells;\n\n        for (let col = 0; col < tableRow.length; col++) {\n            const td = tableRow[col].cachedElement;\n\n            if (td) {\n                td.style.height = newHeight + 'px';\n                td.style.boxSizing = 'border-box';\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDraggingVertical(\n    context: CellResizerContext,\n    event: MouseEvent,\n    initValue: CellResizerInitValue,\n    deltaX: number\n) {\n    const { table, isRTL } = context;\n    const { cmTable, anchorColumn, nextColumn, allWidths } = initValue;\n\n    // Assign new widths and heights to the CM table\n    if (cmTable && anchorColumn != undefined) {\n        const mutableTable = mutateBlock(cmTable);\n\n        const change = deltaX * (isRTL ? -1 : 1);\n        // This is the last column\n        if (nextColumn == -1) {\n            // Only the last column changes\n            // Normalize the new width value\n            const newWidth = Math.max(\n                allWidths[anchorColumn] + change,\n                MIN_ALLOWED_TABLE_CELL_WIDTH\n            );\n            mutableTable.widths[anchorColumn] = newWidth;\n        } else {\n            // Any other two columns\n            const anchorChange = allWidths[anchorColumn] + change;\n            const nextAnchorChange = allWidths[nextColumn] - change;\n            if (\n                anchorChange < MIN_ALLOWED_TABLE_CELL_WIDTH ||\n                nextAnchorChange < MIN_ALLOWED_TABLE_CELL_WIDTH\n            ) {\n                return false;\n            }\n\n            mutableTable.widths[anchorColumn] = anchorChange;\n            mutableTable.widths[nextColumn] = nextAnchorChange;\n        }\n\n        // Write back CM Table size changes to DOM Table\n        for (let row = 0; row < cmTable.rows.length; row++) {\n            const tableRow = cmTable.rows[row].cells;\n            let lastTd: HTMLTableCellElement | null = null;\n            let lastWidth = 0;\n\n            for (let col = 0; col < tableRow.length; col++) {\n                const td = tableRow[col].cachedElement;\n\n                if (td) {\n                    td.style.boxSizing = 'border-box';\n                    lastTd = td;\n                    lastWidth = cmTable.widths[col];\n                } else if (lastTd && tableRow[col].spanLeft) {\n                    lastWidth += cmTable.widths[col];\n                } else if (tableRow[col].spanAbove) {\n                    // For span above case, we don't need to adjust width, just clear lastTd and lastWidth\n                    lastTd = null;\n                    lastWidth = 0;\n                }\n\n                if (lastTd) {\n                    lastTd.style.width = lastWidth + 'px';\n                }\n            }\n        }\n\n        if (context.originalWidth > 0) {\n            const newWidth = context.originalWidth + change + 'px';\n\n            mutableTable.format.width = newWidth;\n            table.style.width = newWidth;\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction setHorizontalPosition(context: CellResizerContext, trigger: HTMLElement) {\n    const { td } = context;\n    const rect = normalizeRect(td.getBoundingClientRect());\n    if (rect) {\n        trigger.id = HORIZONTAL_RESIZER_ID;\n        trigger.style.top = rect.bottom - CELL_RESIZER_WIDTH + 'px';\n        trigger.style.left = rect.left + 'px';\n        trigger.style.width = rect.right - rect.left + 'px';\n        trigger.style.height = CELL_RESIZER_WIDTH + 'px';\n    }\n}\n\nfunction setVerticalPosition(context: CellResizerContext, trigger: HTMLElement) {\n    const { td, isRTL } = context;\n    const rect = normalizeRect(td.getBoundingClientRect());\n    if (rect) {\n        trigger.id = VERTICAL_RESIZER_ID;\n        trigger.style.top = rect.top + 'px';\n        trigger.style.left = (isRTL ? rect.left : rect.right) - CELL_RESIZER_WIDTH + 1 + 'px';\n        trigger.style.width = CELL_RESIZER_WIDTH + 'px';\n        trigger.style.height = rect.bottom - rect.top + 'px';\n    }\n}\n","import type { Disposable } from '../../../pluginUtils/Disposable';\n\n/**\n * @internal\n */\nexport interface TableEditFeature {\n    node: Node;\n    div: HTMLDivElement | null;\n    featureHandler: Disposable | null;\n}\n\n/**\n * @internal\n */\nexport function disposeTableEditFeature(feature: TableEditFeature | null) {\n    if (feature) {\n        feature.featureHandler?.dispose();\n        feature.featureHandler = null;\n        feature.div?.parentNode?.removeChild(feature.div);\n        feature.div = null;\n    }\n}\n","import { createElement } from '../../../pluginUtils/CreateElement/createElement';\nimport { getIntersectedRect } from '../../../pluginUtils/Rect/getIntersectedRect';\nimport { isElementOfType, normalizeRect } from 'roosterjs-content-model-dom';\nimport type { TableEditFeature } from './TableEditFeature';\nimport type { OnTableEditorCreatedCallback } from '../../OnTableEditorCreatedCallback';\nimport {\n    formatTableWithContentModel,\n    insertTableColumn,\n    insertTableRow,\n} from 'roosterjs-content-model-api';\nimport type { CreateElementData } from '../../../pluginUtils/CreateElement/CreateElementData';\nimport type { Disposable } from '../../../pluginUtils/Disposable';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\nconst INSERTER_COLOR = '#4A4A4A';\nconst INSERTER_COLOR_DARK_MODE = 'white';\nconst INSERTER_SIDE_LENGTH = 12;\nconst INSERTER_BORDER_SIZE = 1;\n/**\n * @internal\n */\nexport const HORIZONTAL_INSERTER_ID = 'horizontalInserter';\n/**\n * @internal\n */\nexport const VERTICAL_INSERTER_ID = 'verticalInserter';\n\n/**\n * @internal\n */\nexport function createTableInserter(\n    editor: IEditor,\n    td: HTMLTableCellElement,\n    table: HTMLTableElement,\n    isRTL: boolean,\n    isHorizontal: boolean,\n    onBeforeInsert: () => void,\n    onAfterInserted: () => void,\n    anchorContainer?: HTMLElement,\n    onTableEditorCreated?: OnTableEditorCreatedCallback\n): TableEditFeature | null {\n    const tdRect = normalizeRect(td.getBoundingClientRect());\n    const viewPort = editor.getVisibleViewport();\n    if (tdRect && viewPort) {\n        const isOutsideTop = tdRect.top <= viewPort.top;\n        const isOutsideBottom = tdRect.bottom >= viewPort.bottom;\n\n        if (isOutsideBottom || isOutsideTop) {\n            return null;\n        }\n        const tableRect = table ? getIntersectedRect([table], [viewPort]) : null;\n        // set inserter position\n        if (tableRect) {\n            const document = td.ownerDocument;\n            const createElementData = getInsertElementData(\n                isHorizontal,\n                editor.isDarkMode(),\n                isRTL,\n                editor.getDOMHelper().getDomStyle('backgroundColor') || 'white'\n            );\n\n            const div = createElement(createElementData, document) as HTMLDivElement;\n\n            if (isHorizontal) {\n                // tableRect.left/right is used because the Inserter is always intended to be on the side\n                div.id = HORIZONTAL_INSERTER_ID;\n                div.style.left = `${\n                    isRTL\n                        ? tableRect.right\n                        : tableRect.left - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                }px`;\n                div.style.top = `${tdRect.bottom - 8}px`;\n                (div.firstChild as HTMLElement).style.width = `${\n                    tableRect.right - tableRect.left\n                }px`;\n            } else {\n                div.id = VERTICAL_INSERTER_ID;\n                div.style.left = `${isRTL ? tdRect.left - 8 : tdRect.right - 8}px`;\n                // tableRect.top is used because the Inserter is always intended to be on top\n                div.style.top = `${\n                    tableRect.top - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                }px`;\n                (div.firstChild as HTMLElement).style.height = `${\n                    tableRect.bottom - tableRect.top\n                }px`;\n            }\n\n            (anchorContainer || document.body).appendChild(div);\n\n            const handler = new TableInsertHandler(\n                div,\n                td,\n                table,\n                isHorizontal,\n                editor,\n                onBeforeInsert,\n                onAfterInserted,\n                onTableEditorCreated\n            );\n\n            return { div, featureHandler: handler, node: td };\n        }\n    }\n\n    return null;\n}\n\n/**\n * @internal\n * Exported for test only\n */\nexport class TableInsertHandler implements Disposable {\n    private disposer: undefined | (() => void);\n    constructor(\n        private div: HTMLDivElement,\n        private td: HTMLTableCellElement,\n        private table: HTMLTableElement,\n        private isHorizontal: boolean,\n        private editor: IEditor,\n        private onBeforeInsert: () => void,\n        private onAfterInsert: () => void,\n        onTableEditorCreated?: OnTableEditorCreatedCallback\n    ) {\n        this.div.addEventListener('click', this.insertTd);\n        this.disposer = onTableEditorCreated?.(\n            isHorizontal ? 'HorizontalTableInserter' : 'VerticalTableInserter',\n            div\n        );\n    }\n\n    dispose() {\n        this.div.removeEventListener('click', this.insertTd);\n        this.disposer?.();\n        this.disposer = undefined;\n    }\n\n    private insertTd = () => {\n        // Get cell coordinates\n        const columnIndex = this.td.cellIndex;\n        const row =\n            this.td.parentElement && isElementOfType(this.td.parentElement, 'tr')\n                ? this.td.parentElement\n                : undefined;\n        const rowIndex = row && row.rowIndex;\n\n        if (row?.cells == undefined || rowIndex == undefined) {\n            return;\n        }\n\n        this.onBeforeInsert();\n\n        // Insert row or column\n        formatTableWithContentModel(\n            this.editor,\n            'editTablePlugin',\n            tableModel => {\n                this.isHorizontal\n                    ? insertTableRow(tableModel, 'insertBelow')\n                    : insertTableColumn(tableModel, 'insertRight');\n            }, // Select cell to make insertion\n            {\n                type: 'table',\n                firstColumn: columnIndex,\n                firstRow: rowIndex,\n                lastColumn: columnIndex,\n                lastRow: rowIndex,\n                table: this.table,\n            }\n        );\n\n        this.onAfterInsert();\n    };\n}\n\nfunction getInsertElementData(\n    isHorizontal: boolean,\n    isDark: boolean,\n    isRTL: boolean,\n    backgroundColor: string\n): CreateElementData {\n    const inserterColor = isDark ? INSERTER_COLOR_DARK_MODE : INSERTER_COLOR;\n    const outerDivStyle = `position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: black; line-height: 8px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${inserterColor}; border-radius: 50%; background-color: ${backgroundColor}`;\n    const leftOrRight = isRTL ? 'right' : 'left';\n    const childBaseStyles = `position: absolute; box-sizing: border-box; background-color: ${backgroundColor};`;\n    const childInfo: CreateElementData = {\n        tag: 'div',\n        style:\n            childBaseStyles +\n            (isHorizontal\n                ? `${leftOrRight}: 12px; top: 5px; height: 3px; border-top: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-left: 0px;`\n                : `left: 5px; top: 12px; width: 3px; border-left: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-top: 0px;`),\n    };\n\n    return {\n        tag: 'div',\n        style: outerDivStyle,\n        children: [childInfo, '+'],\n    };\n}\n","import { createElement } from '../../../pluginUtils/CreateElement/createElement';\nimport { DragAndDropHelper } from '../../../pluginUtils/DragAndDrop/DragAndDropHelper';\nimport { formatInsertPointWithContentModel } from 'roosterjs-content-model-api';\nimport { getCMTableFromTable } from '../utils/getTableFromContentModel';\nimport { getNodePositionFromEvent } from '../../../utils/getNodePositionFromEvent';\nimport type { TableEditFeature } from './TableEditFeature';\nimport type { OnTableEditorCreatedCallback } from '../../OnTableEditorCreatedCallback';\nimport type { DragAndDropHandler } from '../../../pluginUtils/DragAndDrop/DragAndDropHandler';\nimport {\n    cloneModel,\n    createContentModelDocument,\n    createSelectionMarker,\n    getFirstSelectedTable,\n    isNodeOfType,\n    mergeModel,\n    mutateBlock,\n    normalizeRect,\n    setParagraphNotImplicit,\n    setSelection,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DOMSelection,\n    IEditor,\n    ReadonlyContentModelTable,\n    Rect,\n    ShallowMutableContentModelDocument,\n} from 'roosterjs-content-model-types';\n\nconst TABLE_MOVER_LENGTH = 12;\n/**\n * @internal\n */\nexport const TABLE_MOVER_ID = '_Table_Mover';\nconst TABLE_MOVER_STYLE_KEY = '_TableMoverCursorStyle';\n\n/**\n * @internal\n * Allows user to move table to another position\n * Contains the function to select whole table\n */\nexport function createTableMover(\n    table: HTMLTableElement,\n    editor: IEditor,\n    isRTL: boolean,\n    onFinishDragging: (table: HTMLTableElement) => void,\n    onStart: () => void,\n    onEnd: (disposeHandler: boolean) => void,\n    contentDiv?: EventTarget | null,\n    anchorContainer?: HTMLElement,\n    onTableEditorCreated?: OnTableEditorCreatedCallback,\n    disableMovement?: boolean\n): TableEditFeature | null {\n    const rect = normalizeRect(table.getBoundingClientRect());\n\n    if (!isTableTopVisible(editor, rect, contentDiv as Node)) {\n        return null;\n    }\n\n    const zoomScale = editor.getDOMHelper().calculateZoomScale();\n    const document = table.ownerDocument;\n    const createElementData = {\n        tag: 'div',\n        style: 'position: fixed; cursor: move; user-select: none; border: 1px solid #808080',\n    };\n\n    const div = createElement(createElementData, document) as HTMLDivElement;\n\n    div.id = TABLE_MOVER_ID;\n    div.style.width = `${TABLE_MOVER_LENGTH}px`;\n    div.style.height = `${TABLE_MOVER_LENGTH}px`;\n\n    (anchorContainer || document.body).appendChild(div);\n\n    const context: TableMoverContext = {\n        table,\n        zoomScale,\n        rect,\n        isRTL,\n        editor,\n        div,\n        onFinishDragging,\n        onStart,\n        onEnd,\n        disableMovement,\n    };\n\n    setDivPosition(context, div);\n\n    const featureHandler = new TableMoverFeature(\n        div,\n        context,\n        () => {},\n        disableMovement\n            ? { onDragEnd }\n            : {\n                  onDragStart,\n                  onDragging,\n                  onDragEnd,\n              },\n        context.zoomScale,\n        onTableEditorCreated,\n        editor.getEnvironment().isMobileOrTablet\n    );\n\n    return { node: table, div, featureHandler };\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport interface TableMoverContext {\n    table: HTMLTableElement;\n    zoomScale: number;\n    rect: Rect | null;\n    isRTL: boolean;\n    editor: IEditor;\n    div: HTMLElement;\n    onFinishDragging: (table: HTMLTableElement) => void;\n    onStart: () => void;\n    onEnd: (disposeHandler: boolean) => void;\n    disableMovement?: boolean;\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport interface TableMoverInitValue {\n    cmTable: ReadonlyContentModelTable | undefined;\n    initialSelection: DOMSelection | null;\n    tableRect: HTMLDivElement;\n}\n\nclass TableMoverFeature extends DragAndDropHelper<TableMoverContext, TableMoverInitValue> {\n    private disposer: undefined | (() => void);\n\n    constructor(\n        div: HTMLElement,\n        context: TableMoverContext,\n        onSubmit: (\n            context: TableMoverContext,\n            trigger: HTMLElement,\n            container?: HTMLElement\n        ) => void,\n        handler: DragAndDropHandler<TableMoverContext, TableMoverInitValue>,\n        zoomScale: number,\n        onTableEditorCreated?: OnTableEditorCreatedCallback,\n        forceMobile?: boolean | undefined\n    ) {\n        super(div, context, onSubmit, handler, zoomScale, forceMobile);\n        this.disposer = onTableEditorCreated?.('TableMover', div);\n    }\n\n    dispose(): void {\n        this.disposer?.();\n        this.disposer = undefined;\n        super.dispose();\n    }\n}\n\nfunction setDivPosition(context: TableMoverContext, trigger: HTMLElement) {\n    const { rect } = context;\n    if (rect) {\n        trigger.style.top = `${rect.top - TABLE_MOVER_LENGTH}px`;\n        trigger.style.left = `${rect.left - TABLE_MOVER_LENGTH - 2}px`;\n    }\n}\n\nfunction isTableTopVisible(editor: IEditor, rect: Rect | null, contentDiv?: Node | null): boolean {\n    const visibleViewport = editor.getVisibleViewport();\n    if (isNodeOfType(contentDiv, 'ELEMENT_NODE') && visibleViewport && rect) {\n        const containerRect = normalizeRect(contentDiv.getBoundingClientRect());\n\n        return !!containerRect && containerRect.top <= rect.top && visibleViewport.top <= rect.top;\n    }\n\n    return true;\n}\n\nfunction setTableMoverCursor(editor: IEditor, state: boolean, type?: 'move' | 'copy') {\n    editor?.setEditorStyle(TABLE_MOVER_STYLE_KEY, state ? 'cursor: ' + type ?? 'move' : null);\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragStart(context: TableMoverContext): TableMoverInitValue {\n    context.onStart();\n\n    const { editor, table, div } = context;\n\n    setTableMoverCursor(editor, true, 'move');\n\n    // Create table outline rectangle\n    const trect = table.getBoundingClientRect();\n    const createElementData = {\n        tag: 'div',\n        style: 'position: fixed; user-select: none; border: 1px solid #808080',\n    };\n    const tableRect = createElement(createElementData, editor.getDocument()) as HTMLDivElement;\n    tableRect.style.width = `${trect.width}px`;\n    tableRect.style.height = `${trect.height}px`;\n    tableRect.style.top = `${trect.top}px`;\n    tableRect.style.left = `${trect.left}px`;\n    div.parentNode?.appendChild(tableRect);\n\n    // Get drag start selection\n    const initialSelection = editor.getDOMSelection();\n\n    // Get Table block in content model\n    const cmTable = getCMTableFromTable(editor, table);\n\n    return {\n        cmTable,\n        initialSelection,\n        tableRect,\n    };\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragging(\n    context: TableMoverContext,\n    event: MouseEvent,\n    initValue: TableMoverInitValue\n) {\n    const { tableRect } = initValue;\n    const { editor } = context;\n\n    // Move table outline rectangle\n    tableRect.style.top = `${event.clientY + TABLE_MOVER_LENGTH}px`;\n    tableRect.style.left = `${event.clientX + TABLE_MOVER_LENGTH}px`;\n\n    const pos = getNodePositionFromEvent(editor, event.clientX, event.clientY);\n    if (pos) {\n        const range = editor.getDocument().createRange();\n        range.setStart(pos.node, pos.offset);\n        range.collapse(true);\n\n        editor.setDOMSelection({ type: 'range', range, isReverted: false });\n        return true;\n    }\n    return false;\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragEnd(\n    context: TableMoverContext,\n    event: MouseEvent,\n    initValue: TableMoverInitValue | undefined\n) {\n    const { editor, table, onFinishDragging: selectWholeTable, disableMovement } = context;\n    const element = event.target;\n\n    // Remove table outline rectangle\n    initValue?.tableRect.remove();\n\n    // Reset cursor\n    setTableMoverCursor(editor, false);\n\n    if (element == context.div) {\n        // Table mover was only clicked, select whole table and do not dismiss the handler element.\n        selectWholeTable(table);\n        context.onEnd(false /* disposeHandler */);\n        return true;\n    } else {\n        // Check if table was dragged on itself, element is not in editor, or movement is disabled\n        if (\n            table.contains(element as Node) ||\n            !editor.getDOMHelper().isNodeInEditor(element as Node) ||\n            disableMovement\n        ) {\n            editor.setDOMSelection(initValue?.initialSelection ?? null);\n            context.onEnd(true /* disposeHandler */);\n            return false;\n        }\n\n        let insertionSuccess: boolean = false;\n\n        // Get position to insert table\n        const insertPosition = getNodePositionFromEvent(editor, event.clientX, event.clientY);\n        if (insertPosition) {\n            // Move table to new position\n            formatInsertPointWithContentModel(\n                editor,\n                insertPosition,\n                (model, context, ip) => {\n                    // Remove old table\n                    const [oldTable, path] = getFirstSelectedTable(model);\n                    if (oldTable) {\n                        const index = path[0].blocks.indexOf(oldTable);\n                        mutateBlock(path[0]).blocks.splice(index, 1);\n                    }\n\n                    if (ip && initValue?.cmTable) {\n                        // Insert new table\n                        const doc: ShallowMutableContentModelDocument = createContentModelDocument();\n                        doc.blocks.push(oldTable ?? mutateBlock(initValue.cmTable));\n                        insertionSuccess = !!mergeModel(model, cloneModel(doc), context, {\n                            mergeFormat: 'none',\n                            insertPosition: ip,\n                        });\n\n                        if (insertionSuccess) {\n                            // After mergeModel, the new table should be selected\n                            const finalTable = getFirstSelectedTable(model)[0] ?? initValue.cmTable;\n                            if (finalTable) {\n                                // Add selection marker to the first cell of the table\n                                const firstCell = finalTable.rows[0].cells[0];\n                                const markerParagraph = firstCell?.blocks[0];\n\n                                if (markerParagraph?.blockType == 'Paragraph') {\n                                    const marker = createSelectionMarker(model.format);\n\n                                    mutateBlock(markerParagraph).segments.unshift(marker);\n                                    setParagraphNotImplicit(markerParagraph);\n                                    setSelection(model, marker);\n                                }\n                            }\n                        }\n                        return insertionSuccess;\n                    }\n                },\n                {\n                    // Select first cell of the old table\n                    selectionOverride: {\n                        type: 'table',\n                        firstColumn: 0,\n                        firstRow: 0,\n                        lastColumn: 0,\n                        lastRow: 0,\n                        table: table,\n                    },\n                    apiName: 'TableMover',\n                }\n            );\n        } else {\n            // No movement, restore initial selection\n            editor.setDOMSelection(initValue?.initialSelection ?? null);\n        }\n        context.onEnd(true /* disposeHandler */);\n        return insertionSuccess;\n    }\n}\n","import { createElement } from '../../../pluginUtils/CreateElement/createElement';\nimport { DragAndDropHelper } from '../../../pluginUtils/DragAndDrop/DragAndDropHelper';\nimport { getCMTableFromTable } from '../utils/getTableFromContentModel';\nimport {\n    MIN_ALLOWED_TABLE_CELL_HEIGHT,\n    isNodeOfType,\n    mutateBlock,\n    normalizeRect,\n} from 'roosterjs-content-model-dom';\nimport type { TableEditFeature } from './TableEditFeature';\nimport type { OnTableEditorCreatedCallback } from '../../OnTableEditorCreatedCallback';\nimport type { IEditor, ReadonlyContentModelTable, Rect } from 'roosterjs-content-model-types';\nimport type { DragAndDropHandler } from '../../../pluginUtils/DragAndDrop/DragAndDropHandler';\n\nconst TABLE_RESIZER_LENGTH = 12;\n/**\n * @internal\n */\nexport const TABLE_RESIZER_ID = '_Table_Resizer';\n\n/**\n * @internal\n */\nexport function createTableResizer(\n    table: HTMLTableElement,\n    editor: IEditor,\n    isRTL: boolean,\n    onStart: () => void,\n    onEnd: () => false,\n    contentDiv?: EventTarget | null,\n    anchorContainer?: HTMLElement,\n    onTableEditorCreated?: OnTableEditorCreatedCallback\n): TableEditFeature | null {\n    const rect = normalizeRect(table.getBoundingClientRect());\n\n    if (!isTableBottomVisible(editor, rect, contentDiv as Node)) {\n        return null;\n    }\n\n    const document = table.ownerDocument;\n    const zoomScale = editor.getDOMHelper().calculateZoomScale();\n    const createElementData = {\n        tag: 'div',\n        style: `position: fixed; cursor: ${\n            isRTL ? 'ne' : 'nw'\n        }-resize; user-select: none; border: 1px solid #808080`,\n    };\n\n    const div = createElement(createElementData, document) as HTMLDivElement;\n\n    div.id = TABLE_RESIZER_ID;\n    div.style.width = `${TABLE_RESIZER_LENGTH}px`;\n    div.style.height = `${TABLE_RESIZER_LENGTH}px`;\n\n    (anchorContainer || document.body).appendChild(div);\n\n    const context: TableResizerContext = {\n        isRTL,\n        table,\n        zoomScale,\n        onStart,\n        onEnd,\n        div,\n        editor,\n        contentDiv,\n    };\n\n    setDivPosition(context, div);\n\n    const featureHandler = new TableResizer(\n        div,\n        context,\n        hideResizer, // Resizer is hidden while dragging only\n        {\n            onDragStart,\n            onDragging,\n            onDragEnd,\n        },\n        zoomScale,\n        editor.getEnvironment().isMobileOrTablet,\n        onTableEditorCreated\n    );\n\n    return { node: table, div, featureHandler };\n}\n\nclass TableResizer extends DragAndDropHelper<TableResizerContext, TableResizerInitValue> {\n    private disposer: undefined | (() => void);\n\n    constructor(\n        trigger: HTMLElement,\n        context: TableResizerContext,\n        onSubmit: (context: TableResizerContext, trigger: HTMLElement) => void,\n        handler: DragAndDropHandler<TableResizerContext, TableResizerInitValue>,\n        zoomScale: number,\n        forceMobile?: boolean,\n        onTableEditorCreated?: OnTableEditorCreatedCallback\n    ) {\n        super(trigger, context, onSubmit, handler, zoomScale, forceMobile);\n        this.disposer = onTableEditorCreated?.('TableResizer', trigger);\n    }\n\n    dispose(): void {\n        this.disposer?.();\n        this.disposer = undefined;\n        super.dispose();\n    }\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport interface TableResizerContext {\n    table: HTMLTableElement;\n    isRTL: boolean;\n    zoomScale: number;\n    onStart: () => void;\n    onEnd: () => false;\n    div: HTMLDivElement;\n    editor: IEditor;\n    contentDiv?: EventTarget | null;\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport interface TableResizerInitValue {\n    originalRect: DOMRect;\n    originalHeights: number[];\n    originalWidths: number[];\n    cmTable: ReadonlyContentModelTable | undefined;\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragStart(\n    context: TableResizerContext,\n    event: MouseEvent\n): TableResizerInitValue {\n    context.onStart();\n\n    const { editor, table } = context;\n\n    // Get Table block in content model\n    const cmTable = getCMTableFromTable(editor, table);\n\n    // Save original widths and heights\n    const heights: number[] = [];\n    cmTable?.rows.forEach(row => {\n        heights.push(row.height);\n    });\n    const widths: number[] = [];\n    cmTable?.widths.forEach(width => {\n        widths.push(width);\n    });\n\n    return {\n        originalRect: table.getBoundingClientRect(),\n        cmTable,\n        originalHeights: heights ?? [],\n        originalWidths: widths ?? [],\n    };\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragging(\n    context: TableResizerContext,\n    event: MouseEvent,\n    initValue: TableResizerInitValue,\n    deltaX: number,\n    deltaY: number\n) {\n    const { isRTL, zoomScale, table } = context;\n    const { originalRect, originalHeights, originalWidths, cmTable } = initValue;\n\n    const ratioX = 1.0 + (deltaX / originalRect.width) * zoomScale * (isRTL ? -1 : 1);\n    const ratioY = 1.0 + (deltaY / originalRect.height) * zoomScale;\n    const shouldResizeX = Math.abs(ratioX - 1.0) > 1e-3;\n    const shouldResizeY = Math.abs(ratioY - 1.0) > 1e-3;\n\n    // If the width of some external table is fixed, we need to make it resizable\n    table.style.setProperty('width', null);\n    // If the height of some external table is fixed, we need to make it resizable\n    table.style.setProperty('height', null);\n\n    // Assign new widths and heights to the CM table\n    if (cmTable && cmTable.rows && (shouldResizeX || shouldResizeY)) {\n        const mutableTable = mutateBlock(cmTable);\n\n        // Modify the CM Table size\n        for (let i = 0; i < cmTable.rows.length; i++) {\n            for (let j = 0; j < cmTable.rows[i].cells.length; j++) {\n                const cell = cmTable.rows[i].cells[j];\n                if (cell) {\n                    if (shouldResizeX && i == 0) {\n                        mutableTable.widths[j] = (originalWidths[j] ?? 0) * ratioX;\n                    }\n                    if (shouldResizeY && j == 0) {\n                        mutableTable.rows[i].height = (originalHeights[i] ?? 0) * ratioY;\n                    }\n                }\n            }\n        }\n\n        // Writeback CM Table size changes to DOM Table\n        for (let row = 0; row < table.rows.length; row++) {\n            const tableRow = table.rows[row];\n\n            if (tableRow.cells.length == 0) {\n                // Skip empty row\n                continue;\n            }\n\n            // Normalize the new height value\n            const newHeight = Math.max(cmTable.rows[row].height, MIN_ALLOWED_TABLE_CELL_HEIGHT);\n\n            for (let col = 0; col < tableRow.cells.length; col++) {\n                const td = tableRow.cells[col];\n\n                // Normalize the new width value\n                const newWidth = Math.max(cmTable.widths[col], MIN_ALLOWED_TABLE_CELL_HEIGHT);\n\n                td.style.width = newWidth + 'px';\n                td.style.height = newHeight + 'px';\n                td.style.boxSizing = 'border-box';\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragEnd(\n    context: TableResizerContext,\n    event: MouseEvent,\n    initValue: TableResizerInitValue | undefined\n) {\n    if (context.editor.isDisposed()) {\n        return false;\n    }\n    if (\n        isTableBottomVisible(\n            context.editor,\n            normalizeRect(context.table.getBoundingClientRect()),\n            context.contentDiv as Node\n        )\n    ) {\n        context.div.style.visibility = 'visible';\n        setDivPosition(context, context.div);\n    }\n    context.onEnd();\n    return false;\n}\n\nfunction setDivPosition(context: TableResizerContext, trigger: HTMLElement) {\n    const { table, isRTL } = context;\n    const rect = normalizeRect(table.getBoundingClientRect());\n\n    if (rect) {\n        trigger.style.top = `${rect.bottom}px`;\n        trigger.style.left = isRTL\n            ? `${rect.left - TABLE_RESIZER_LENGTH - 2}px`\n            : `${rect.right}px`;\n    }\n}\n\nfunction hideResizer(context: TableResizerContext, trigger: HTMLElement) {\n    trigger.style.visibility = 'hidden';\n}\n\nfunction isTableBottomVisible(\n    editor: IEditor,\n    rect: Rect | null,\n    contentDiv?: Node | null\n): boolean {\n    const visibleViewport = editor.getVisibleViewport();\n    if (isNodeOfType(contentDiv, 'ELEMENT_NODE') && visibleViewport && rect) {\n        const containerRect = normalizeRect(contentDiv.getBoundingClientRect());\n\n        return (\n            !!containerRect &&\n            containerRect.bottom >= rect.bottom &&\n            visibleViewport.bottom >= rect.bottom\n        );\n    }\n\n    return true;\n}\n","import { createElement } from '../../../pluginUtils/CreateElement/createElement';\nimport { DragAndDropHelper } from '../../../pluginUtils/DragAndDrop/DragAndDropHelper';\nimport { normalizeRect, parseTableCells } from 'roosterjs-content-model-dom';\nimport type { CreateElementData } from '../../../pluginUtils/CreateElement/CreateElementData';\nimport type { DragAndDropHandler } from '../../../pluginUtils/DragAndDrop/DragAndDropHandler';\nimport type { Disposable } from '../../../pluginUtils/Disposable';\nimport type { TableEditFeature } from './TableEditFeature';\nimport type { OnTableEditorCreatedCallback } from '../../OnTableEditorCreatedCallback';\nimport type {\n    DOMSelection,\n    IEditor,\n    ParsedTable,\n    ReadonlyContentModelTable,\n    Rect,\n    TableSelection,\n} from 'roosterjs-content-model-types';\n\nconst STABLE_DOWN_ARROW_CURSOR =\n    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij48dGV4dCB4PSI4IiB5PSIxMiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxNCIgZmlsbD0iYmxhY2siPiYjMTI5MDk1OzwvdGV4dD48L3N2Zz4=';\n\nconst STABLE_RIGHT_ARROW_CURSOR =\n    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij48dGV4dCB4PSI4IiB5PSIxMiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxNCIgZmlsbD0iYmxhY2siIHRyYW5zZm9ybT0icm90YXRlKC05MCA4IDgpIj4mIzEyOTA5NTs8L3RleHQ+PC9zdmc+';\n\n/**\n * @internal\n */\nexport function createTableRowColumnSelector(\n    editor: IEditor,\n    table: HTMLTableElement,\n    isRowSelector: boolean,\n    anchorContainer?: HTMLElement,\n    onTableEditorCreated?: OnTableEditorCreatedCallback\n): TableEditFeature | null {\n    const doc = editor.getDocument();\n    const zoomScale = editor.getDOMHelper().calculateZoomScale();\n\n    const containerDiv = doc.createElement('div');\n    containerDiv.style.cssText = 'position: fixed; pointer-events: none;';\n\n    const cells = isRowSelector\n        ? Array.from(table.rows)\n              .map(row => row.cells[0])\n              .filter(cell => cell)\n        : Array.from(table.rows[0]?.cells || []);\n\n    const handlers: TableRowColumnSelectorHandler[] = [];\n\n    cells.forEach(cell => {\n        const cellRect = normalizeRect(cell.getBoundingClientRect());\n        if (cellRect) {\n            const createElementData = getInsertElementData(cellRect, isRowSelector);\n            const cellDiv = createElement(createElementData, doc) as HTMLDivElement;\n            containerDiv.appendChild(cellDiv);\n\n            const context: TableRowColumnSelectorContext = {\n                table,\n                zoomScale,\n                editor,\n                div: cellDiv,\n                isRow: isRowSelector,\n            };\n\n            const handler = new TableRowColumnSelectorHandler(\n                cellDiv,\n                isRowSelector,\n                context,\n                {\n                    onDragStart,\n                    onDragging,\n                    onDragEnd,\n                },\n                zoomScale,\n                onTableEditorCreated,\n                editor.getEnvironment().isMobileOrTablet\n            );\n            handlers.push(handler);\n        }\n    });\n\n    (anchorContainer || doc.body).appendChild(containerDiv);\n\n    const compositeHandler: Disposable = {\n        dispose: () => {\n            handlers.forEach(h => h.dispose());\n        },\n    };\n\n    return { div: containerDiv, featureHandler: compositeHandler, node: table };\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport interface TableRowColumnSelectorContext {\n    table: HTMLTableElement;\n    zoomScale: number;\n    editor: IEditor;\n    div: HTMLElement;\n    isRow: boolean;\n}\n\n/**\n *  @internal\n */\nexport interface TableRowColumnSelectorInitValue {\n    cmTable: ReadonlyContentModelTable | undefined;\n    initialSelection: DOMSelection | null;\n    parsedTable: ParsedTable;\n    startIndex: number;\n}\n\nclass TableRowColumnSelectorHandler\n    extends DragAndDropHelper<TableRowColumnSelectorContext, TableRowColumnSelectorInitValue>\n    implements Disposable {\n    private disposer: undefined | (() => void);\n    constructor(\n        div: HTMLDivElement,\n        private isRow: boolean,\n        context: TableRowColumnSelectorContext,\n        handler: DragAndDropHandler<TableRowColumnSelectorContext, TableRowColumnSelectorInitValue>,\n        zoomScale: number,\n        onTableEditorCreated?: OnTableEditorCreatedCallback,\n        forceMobile?: boolean | undefined\n    ) {\n        super(div, context, () => {}, handler, zoomScale, forceMobile);\n        this.disposer = onTableEditorCreated?.(\n            this.isRow ? 'TableRowSelector' : 'TableColumnSelector',\n            div\n        );\n    }\n\n    dispose() {\n        this.disposer?.();\n        this.disposer = undefined;\n    }\n}\n\n/**\n * @internal\n * Helper function to calculate current row/column index from mouse coordinates during drag\n */\nfunction getCurrentIndexFromMouse(\n    table: HTMLTableElement,\n    x: number,\n    y: number,\n    isRow: boolean\n): number {\n    if (isRow) {\n        for (let i = 0; i < table.rows.length; i++) {\n            const row = table.rows[i];\n\n            for (let j = 0; j < row.cells.length; j++) {\n                const cell = row.cells[j];\n                const cellRect = normalizeRect(cell.getBoundingClientRect());\n                if (cellRect && y >= cellRect.top && y <= cellRect.bottom) {\n                    return i;\n                }\n            }\n        }\n        return Math.max(0, table.rows.length - 1);\n    } else {\n        if (!table.rows[0]) {\n            return 0;\n        }\n        const firstRow = table.rows[0];\n        for (let i = 0; i < firstRow.cells.length; i++) {\n            const cell = firstRow.cells[i];\n            const cellRect = normalizeRect(cell.getBoundingClientRect());\n            if (cellRect && x >= cellRect.left && x <= cellRect.right) {\n                return i;\n            }\n        }\n        return firstRow.cells.length - 1;\n    }\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragStart(\n    context: TableRowColumnSelectorContext,\n    event: MouseEvent\n): TableRowColumnSelectorInitValue {\n    const { table, editor, isRow } = context;\n    editor.setDOMSelection(null);\n\n    const parsedTable = parseTableCells(table);\n\n    const startIndex = getCurrentIndexFromMouse(table, event.clientX, event.clientY, isRow);\n\n    if (isRow) {\n        const columnNumber = parsedTable[startIndex].length - 1;\n        const initialSelection: TableSelection = {\n            type: 'table',\n            table,\n            firstRow: startIndex,\n            lastRow: startIndex,\n            firstColumn: 0,\n            lastColumn: columnNumber,\n        };\n\n        return {\n            cmTable: undefined,\n            initialSelection,\n\n            parsedTable,\n            startIndex,\n        };\n    } else {\n        const rowNumber = parsedTable.length - 1;\n        const initialSelection: TableSelection = {\n            type: 'table',\n            table,\n            firstRow: 0,\n            lastRow: rowNumber,\n            firstColumn: startIndex,\n            lastColumn: startIndex,\n        };\n\n        return {\n            cmTable: undefined,\n            initialSelection,\n\n            parsedTable,\n            startIndex,\n        };\n    }\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragging(\n    context: TableRowColumnSelectorContext,\n    event: MouseEvent,\n    initValue: TableRowColumnSelectorInitValue | undefined\n): boolean {\n    if (!initValue) {\n        return false;\n    }\n\n    const { table, editor, isRow } = context;\n    const { parsedTable, startIndex } = initValue;\n\n    const currentIndex = getCurrentIndexFromMouse(table, event.clientX, event.clientY, isRow);\n\n    if (isRow) {\n        const columnNumber = parsedTable[startIndex].length - 1;\n        const firstRow = Math.min(startIndex, currentIndex);\n        const lastRow = Math.max(startIndex, currentIndex);\n\n        editor.setDOMSelection({\n            type: 'table',\n            table: table,\n            firstRow,\n            firstColumn: 0,\n            lastRow,\n            lastColumn: columnNumber,\n        });\n    } else {\n        const firstColumn = Math.min(startIndex, currentIndex);\n        const lastColumn = Math.max(startIndex, currentIndex);\n        const rowNumber = parsedTable.length - 1;\n\n        editor.setDOMSelection({\n            type: 'table',\n            table: table,\n            firstRow: 0,\n            firstColumn,\n            lastColumn,\n            lastRow: rowNumber,\n        });\n    }\n\n    return true;\n}\n\n/**\n * @internal\n * Exported for testing\n */\nexport function onDragEnd(\n    context: TableRowColumnSelectorContext,\n    event: MouseEvent,\n    initValue: TableRowColumnSelectorInitValue | undefined\n): boolean {\n    if (!initValue) {\n        return false;\n    }\n\n    const { editor } = context;\n    const selection = editor.getDOMSelection();\n\n    if (selection?.type !== 'table') {\n        editor.setDOMSelection(initValue.initialSelection);\n    }\n\n    return true;\n}\n\nfunction getInsertElementData(rect: Rect, isRowSelector: boolean): CreateElementData {\n    const MIN_DISTANCE_FROM_BOUNDARY = 5;\n    const GAP_FROM_CELL = 5;\n    const cellLength = isRowSelector ? rect.bottom - rect.top : rect.right - rect.left;\n\n    const maxSelectorSize = Math.max(16, cellLength - MIN_DISTANCE_FROM_BOUNDARY * 2);\n    const SELECTOR_SIZE = cellLength >= 32 ? Math.min(cellLength - 16, maxSelectorSize) : 16;\n\n    const centerOffset = (cellLength - SELECTOR_SIZE) / 2;\n\n    const size = isRowSelector\n        ? `width: 5px; height: ${SELECTOR_SIZE}px; top: ${rect.top + centerOffset}px; left: ${\n              rect.left - 5 - GAP_FROM_CELL\n          }px`\n        : `width: ${SELECTOR_SIZE}px; height: 5px; top: ${rect.top - 5 - GAP_FROM_CELL}px; left: ${\n              rect.left + centerOffset\n          }px`;\n\n    const cursor = isRowSelector\n        ? `url(\"${STABLE_RIGHT_ARROW_CURSOR}\"), auto`\n        : `url(\"${STABLE_DOWN_ARROW_CURSOR}\") , auto`;\n\n    const outerDivStyle = `position: fixed; ${size}; background-color: transparent; cursor: ${cursor}; pointer-events: auto;`;\n    return {\n        tag: 'div',\n        style: outerDivStyle,\n    };\n}\n","import { createContentModelDocument, createDomToModelContext } from 'roosterjs-content-model-dom';\nimport type { IEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Get ContentModelTable from a table element if it is present in the content model\n */\nexport function getCMTableFromTable(editor: IEditor, table: HTMLTableElement) {\n    const model = createContentModelDocument();\n    const context = createDomToModelContext({\n        zoomScale: editor.getDOMHelper().calculateZoomScale(),\n        recalculateTableSize: true,\n        allowCacheElement: true, // We need this cache so we can retrieve TD element and update TD width and height when resizing table\n    });\n\n    context.elementProcessors.element(model, table, context);\n\n    const firstBlock = model.blocks[0];\n\n    return firstBlock?.blockType == 'Table' ? firstBlock : undefined;\n}\n","import { getNodePositionFromEvent } from '../utils/getNodePositionFromEvent';\nimport type { EditorPlugin, IEditor, PluginEvent } from 'roosterjs-content-model-types';\n\nconst MAX_TOUCH_MOVE_DISTANCE = 6; // the max number of offsets for the touch selection to move\nconst POINTER_DETECTION_DELAY = 150; // Delay time to wait for selection to be updated and also detect if pointerup is a tap or part of double tap\nconst PUNCTUATION_MATCHING_REGEX = /[.,;:!]/;\nconst SPACE_MATCHING_REGEX = /\\s/;\n\n/**\n * Touch plugin to manage touch behaviors\n */\nexport class TouchPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private timer = 0;\n    private isDblClicked: boolean = false;\n    private isTouchPenPointerEvent: boolean = false;\n\n    /**\n     * Create an instance of Touch plugin\n     */\n    constructor() {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Touch';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.isDblClicked = false;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        if (this.timer) {\n            this.editor?.getDocument()?.defaultView?.clearTimeout(this.timer);\n            this.timer = 0;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n        switch (event.eventType) {\n            case 'pointerDown':\n                this.isDblClicked = false;\n                this.isTouchPenPointerEvent = true;\n                event.originalEvent.preventDefault();\n\n                const targetWindow = this.editor.getDocument().defaultView;\n\n                if (targetWindow) {\n                    if (this.timer) {\n                        targetWindow.clearTimeout(this.timer);\n                    }\n\n                    this.timer = targetWindow.setTimeout(() => {\n                        this.timer = 0;\n\n                        if (this.editor) {\n                            if (!this.isDblClicked) {\n                                this.editor.focus();\n                                const caretPosition = getNodePositionFromEvent(\n                                    this.editor,\n                                    event.rawEvent.x,\n                                    event.rawEvent.y\n                                );\n\n                                const newRange = this.editor.getDocument().createRange();\n                                if (caretPosition) {\n                                    const { node, offset } = caretPosition;\n\n                                    // Place cursor at same position of browser handler by default\n                                    newRange.setStart(node, offset);\n                                    newRange.setEnd(node, offset);\n\n                                    const nodeTextContent = node.textContent || '';\n                                    const charAtSelection = nodeTextContent[offset];\n                                    if (\n                                        node.nodeType === Node.TEXT_NODE &&\n                                        charAtSelection &&\n                                        !SPACE_MATCHING_REGEX.test(charAtSelection) &&\n                                        !PUNCTUATION_MATCHING_REGEX.test(charAtSelection)\n                                    ) {\n                                        const { wordStart, wordEnd } = findWordBoundaries(\n                                            nodeTextContent,\n                                            offset\n                                        );\n\n                                        // Move cursor to the calculated offset\n                                        const leftCursorWordLength = offset - wordStart;\n                                        const rightCursorWordLength = wordEnd - offset;\n                                        let movingOffset: number =\n                                            leftCursorWordLength >= rightCursorWordLength\n                                                ? rightCursorWordLength\n                                                : -leftCursorWordLength;\n                                        movingOffset =\n                                            Math.abs(movingOffset) > MAX_TOUCH_MOVE_DISTANCE\n                                                ? 0\n                                                : movingOffset;\n                                        const newOffsetPosition = offset + movingOffset;\n                                        if (\n                                            movingOffset !== 0 &&\n                                            nodeTextContent.length >= newOffsetPosition\n                                        ) {\n                                            newRange.setStart(node, newOffsetPosition);\n                                            newRange.setEnd(node, newOffsetPosition);\n                                        }\n                                    }\n                                }\n                                this.editor.setDOMSelection({\n                                    type: 'range',\n                                    range: newRange,\n                                    isReverted: false,\n                                });\n\n                                // reset values\n                                this.isTouchPenPointerEvent = false;\n                            }\n                        }\n                    }, POINTER_DETECTION_DELAY);\n                }\n                break;\n            case 'doubleClick':\n                if (this.isTouchPenPointerEvent) {\n                    event.rawEvent.preventDefault();\n\n                    this.isDblClicked = true;\n                    const caretPosition = getNodePositionFromEvent(\n                        this.editor,\n                        event.rawEvent.x,\n                        event.rawEvent.y\n                    );\n\n                    if (caretPosition) {\n                        const { node, offset } = caretPosition;\n\n                        if (node.nodeType !== Node.TEXT_NODE) {\n                            return;\n                        }\n\n                        const nodeTextContent = node.nodeValue || '';\n                        const char = nodeTextContent.charAt(offset);\n\n                        // Check if the clicked character is a punctuation mark, then highlight that character only\n                        if (PUNCTUATION_MATCHING_REGEX.test(char)) {\n                            const newRange = this.editor.getDocument()?.createRange();\n                            if (newRange) {\n                                newRange.setStart(node, offset);\n                                newRange.setEnd(node, offset + 1);\n                                this.editor.setDOMSelection({\n                                    type: 'range',\n                                    range: newRange,\n                                    isReverted: false,\n                                });\n                            }\n                        } else if (SPACE_MATCHING_REGEX.test(char)) {\n                            // If the clicked character is an open space with no word of right side\n                            const rightSideOfChar = nodeTextContent.substring(\n                                offset,\n                                nodeTextContent.length\n                            );\n                            const isRightSideAllSpaces =\n                                rightSideOfChar.length > 0 && !/\\S/.test(rightSideOfChar);\n                            if (isRightSideAllSpaces) {\n                                // select the first space only\n                                let start = offset;\n                                while (\n                                    start > 0 &&\n                                    SPACE_MATCHING_REGEX.test(nodeTextContent.charAt(start - 1))\n                                ) {\n                                    start--;\n                                }\n                                const newRange = this.editor.getDocument()?.createRange();\n                                if (newRange) {\n                                    newRange.setStart(node, start);\n                                    newRange.setEnd(node, start + 1);\n                                    this.editor.setDOMSelection({\n                                        type: 'range',\n                                        range: newRange,\n                                        isReverted: false,\n                                    });\n                                }\n                            }\n                        } else {\n                            const { wordStart, wordEnd } = findWordBoundaries(\n                                nodeTextContent,\n                                offset\n                            );\n                            const newRange = this.editor.getDocument()?.createRange();\n                            if (newRange) {\n                                newRange.setStart(node, wordStart);\n                                newRange.setEnd(node, wordEnd);\n                                this.editor.setDOMSelection({\n                                    type: 'range',\n                                    range: newRange,\n                                    isReverted: false,\n                                });\n                            }\n                        }\n                    }\n                }\n                break;\n        }\n    }\n}\n\n/**\n * @internal\n * Finds the start and end indices of the word at the given offset in the text.\n * @param text The string to search within.\n * @param offset The index within the string to find the word boundaries around.\n * @returns An object containing wordStart and wordEnd indices.\n */\nfunction findWordBoundaries(text: string, offset: number) {\n    let start = offset;\n    let end = offset;\n\n    // Move start backwards to find word start\n    while (\n        start > 0 &&\n        !SPACE_MATCHING_REGEX.test(text[start - 1]) &&\n        !PUNCTUATION_MATCHING_REGEX.test(text[start - 1])\n    ) {\n        start--;\n    }\n\n    // Move end forward to find word end\n    while (\n        end < text.length &&\n        !SPACE_MATCHING_REGEX.test(text[end]) &&\n        !PUNCTUATION_MATCHING_REGEX.test(text[end])\n    ) {\n        end++;\n    }\n\n    return {\n        wordStart: start,\n        wordEnd: end,\n    };\n}\n","import type { DOMInsertPoint, IEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal Get insertion point from coordinate.\n */\nexport function getNodePositionFromEvent(\n    editor: IEditor,\n    x: number,\n    y: number\n): DOMInsertPoint | null {\n    const doc = editor.getDocument();\n    const domHelper = editor.getDOMHelper();\n\n    if ('caretPositionFromPoint' in doc) {\n        // Firefox, Chrome, Edge, Safari, Opera\n        const pos = (doc as any).caretPositionFromPoint(x, y);\n        if (pos && domHelper.isNodeInEditor(pos.offsetNode)) {\n            return { node: pos.offsetNode, offset: pos.offset };\n        }\n    }\n\n    if (doc.caretRangeFromPoint) {\n        // Safari\n        const range = doc.caretRangeFromPoint(x, y);\n        if (range && domHelper.isNodeInEditor(range.startContainer)) {\n            return { node: range.startContainer, offset: range.startOffset };\n        }\n    }\n\n    if (doc.elementFromPoint) {\n        // Fallback\n        const element = doc.elementFromPoint(x, y);\n        if (element && domHelper.isNodeInEditor(element)) {\n            return { node: element, offset: 0 };\n        }\n    }\n\n    return null;\n}\n","import { ChangeSource, getObjectKeys } from 'roosterjs-content-model-dom';\nimport { isModelEmptyFast } from './isModelEmptyFast';\nimport type { WatermarkFormat } from './WatermarkFormat';\nimport type { EditorPlugin, IEditor, PluginEvent } from 'roosterjs-content-model-types';\n\nconst WATERMARK_CONTENT_KEY = '_WatermarkContent';\nconst styleMap: Record<keyof WatermarkFormat, string> = {\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    textColor: 'color',\n};\n\n/**\n * A watermark plugin to manage watermark string for roosterjs\n */\nexport class WatermarkPlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n    private format: WatermarkFormat;\n    private isShowing = false;\n    private darkTextColor: string | null = null;\n    private disposer: (() => void) | null = null;\n\n    /**\n     * Create an instance of Watermark plugin\n     * @param watermark The watermark string\n     */\n    constructor(protected watermark: string, format?: WatermarkFormat) {\n        this.format = format || {\n            fontSize: '14px',\n            textColor: '#AAAAAA',\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Watermark';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.attachDomEvent({\n            compositionstart: {\n                beforeDispatch: this.onCompositionStart,\n            },\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer?.();\n        this.disposer = null;\n\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        const editor = this.editor;\n\n        if (!editor) {\n            return;\n        }\n\n        if (event.eventType == 'input' && event.rawEvent.inputType == 'insertText') {\n            // When input text, editor must not be empty, so we can do hide watermark now without checking content model\n            this.showHide(editor, false /*isEmpty*/);\n        } else if (\n            event.eventType == 'contentChanged' &&\n            (event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode) &&\n            this.isShowing\n        ) {\n            // When the placeholder is shown and user switches the mode, we need to update watermark style\n            if (\n                event.source == ChangeSource.SwitchToDarkMode &&\n                !this.darkTextColor &&\n                this.format.textColor\n            ) {\n                // Get the dark color only once when dark mode is enabled for the first time\n                this.darkTextColor = editor\n                    .getColorManager()\n                    .getDarkColor(this.format.textColor, undefined, 'text');\n            }\n\n            this.applyWatermarkStyle(editor);\n        } else if (\n            event.eventType == 'editorReady' ||\n            event.eventType == 'contentChanged' ||\n            event.eventType == 'input' ||\n            event.eventType == 'beforeDispose' ||\n            event.eventType == 'compositionEnd'\n        ) {\n            this.update(editor);\n        }\n    }\n\n    private onCompositionStart = () => {\n        if (this.editor) {\n            this.showHide(this.editor, false /*isEmpty*/);\n        }\n    };\n\n    private update(editor: IEditor) {\n        editor.formatContentModel(model => {\n            const isEmpty = isModelEmptyFast(model);\n\n            this.showHide(editor, isEmpty);\n\n            return false;\n        });\n    }\n\n    private showHide(editor: IEditor, isEmpty: boolean) {\n        if (this.isShowing && !isEmpty) {\n            this.hide(editor);\n        } else if (!this.isShowing && isEmpty) {\n            this.show(editor);\n        }\n    }\n\n    protected show(editor: IEditor) {\n        this.applyWatermarkStyle(editor);\n        this.isShowing = true;\n    }\n\n    private applyWatermarkStyle(editor: IEditor) {\n        let rule = `position: absolute; pointer-events: none; margin-inline-start: 1px; content: \"${this.watermark}\";`;\n        const format = {\n            ...this.format,\n            textColor: editor.isDarkMode() ? this.darkTextColor : this.format.textColor,\n        };\n\n        getObjectKeys(styleMap).forEach(x => {\n            if (format[x]) {\n                rule += `${styleMap[x]}: ${format[x]}!important;`;\n            }\n        });\n\n        editor.setEditorStyle(WATERMARK_CONTENT_KEY, rule, 'before');\n    }\n\n    protected hide(editor: IEditor) {\n        editor.setEditorStyle(WATERMARK_CONTENT_KEY, null);\n        this.isShowing = false;\n    }\n}\n","import type { ReadonlyContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * A fast way to check if content model is empty\n */\nexport function isModelEmptyFast(model: ReadonlyContentModelBlockGroup): boolean {\n    const firstBlock = model.blocks[0];\n\n    if (model.blocks.length > 1) {\n        return false; // Multiple blocks, treat as not empty\n    } else if (!firstBlock) {\n        return true; // No block, it is empty\n    } else if (firstBlock.blockType != 'Paragraph') {\n        return false; // First block is not paragraph, treat as not empty\n    } else if (firstBlock.segments.length == 0) {\n        return true; // No segment, it is empty\n    } else if (\n        firstBlock.segments.some(\n            x =>\n                x.segmentType == 'Entity' ||\n                x.segmentType == 'Image' ||\n                x.segmentType == 'General' ||\n                (x.segmentType == 'Text' && x.text)\n        )\n    ) {\n        return false; // Has meaningful segments, it is not empty\n    } else if (\n        (firstBlock.format.marginRight && parseFloat(firstBlock.format.marginRight) > 0) ||\n        (firstBlock.format.marginLeft && parseFloat(firstBlock.format.marginLeft) > 0)\n    ) {\n        return false; // Has margin (indentation is changed), it is not empty\n    } else {\n        return firstBlock.segments.filter(x => x.segmentType == 'Br').length <= 1; // If there are more than one BR, it is not empty, otherwise it is empty\n    }\n}\n","import { Editor } from 'roosterjs-content-model-core';\r\nimport { EditPlugin, PastePlugin, ShortcutPlugin } from 'roosterjs-content-model-plugins';\r\nimport type {\r\n    ContentModelDocument,\r\n    EditorPlugin,\r\n    IEditor,\r\n    EditorOptions,\r\n} from 'roosterjs-content-model-types';\r\n\r\n/**\r\n * Create a new Editor instance using the given options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * PastePlugin, EditPlugin, user don't need to add those.\r\n * @param initialModel The initial content model to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The Editor instance\r\n */\r\nexport function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialModel?: ContentModelDocument\r\n): IEditor {\r\n    const plugins = [\r\n        new PastePlugin(),\r\n        new EditPlugin(),\r\n        new ShortcutPlugin(),\r\n        ...(additionalPlugins ?? []),\r\n    ];\r\n\r\n    const options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialModel,\r\n        defaultSegmentFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","export { createEditor } from './createEditor';\r\nexport * from 'roosterjs-content-model-types';\r\nexport * from 'roosterjs-content-model-dom';\r\nexport * from 'roosterjs-content-model-core';\r\nexport * from 'roosterjs-content-model-api';\r\nexport * from 'roosterjs-content-model-plugins';\r\nexport * from 'roosterjs-color-utils';\r\nexport * from 'roosterjs-content-model-markdown';\r\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(91055);\n"],"names":["cssKeywords","reverseKeywords","key","hasOwnProperty","convert","module","exports","rgb","channels","labels","hsl","hsv","hwb","cmyk","xyz","lab","lch","hex","keyword","ansi16","ansi256","hcg","apple","gray","model","Error","length","Object","defineProperty","value","h","l","r","g","b","min","Math","max","delta","rdif","gdif","bdif","s","v","diff","diffc","c","k","reversed","currentClosestKeyword","x","y","currentClosestDistance","Infinity","distance","pow","z","t1","t2","t3","val","i","smin","lmin","hi","floor","f","p","q","t","sl","vmin","n","wh","bl","ratio","m","y2","x2","z2","a","atan2","PI","sqrt","hr","cos","sin","args","arguments","round","ansi","color","mult","rem","string","toString","toUpperCase","substring","match","colorString","split","map","char","join","integer","parseInt","hue","chroma","mg","pure","w","conversions","route","keys","forEach","fromModel","routes","toModel","fn","wrappedFn","Array","prototype","slice","call","result","len","conversion","wrapRounded","raw","wrapRaw","link","from","to","wrapConversion","graph","path","parent","cur","unshift","models","buildGraph","queue","current","pop","adjacents","adjacent","node","deriveBFS","colorNames","swizzle","reverseNames","name","cs","get","clamp","num","hexDouble","str","toLowerCase","hexAlpha","i2","parseFloat","alpha","isNaN","rgba","percent","hsla","hwba","_slice","skippedModels","hashedModelKeys","sort","limiters","Color","obj","this","valpha","newArr","zeroArray","splice","indexOf","hashedKeys","JSON","stringify","push","limit","freeze","getset","channel","modifier","isArray","maxfn","arr","toJSON","places","self","concat","percentString","array","object","unitArray","unitObject","Number","toFixed","roundTo","roundToPlace","red","green","blue","saturationl","lightness","saturationv","white","wblack","cyan","magenta","yellow","black","rgbNumber","luminosity","lum","chan","contrast","color2","lum1","lum2","level","contrastRatio","isDark","isLight","negate","lighten","darken","saturate","desaturate","whiten","blacken","grayscale","fade","opaquer","rotate","degrees","mix","mixinColor","weight","color1","undefined","w1","w2","newAlpha","Function","getOwnPropertyDescriptor","constructor","isArrayish","results","arg","wrap","default","baseLValue","computedColor","colorLab","newLValue","insertTable","formatTable","setTableCellShade","editTable","applyTableBorderFormat","toggleBullet","toggleNumbering","toggleBold","toggleItalic","toggleUnderline","toggleStrikethrough","toggleSubscript","toggleSuperscript","setBackgroundColor","setFontName","setFontSize","setTextColor","changeFontSize","applySegmentFormat","changeCapitalization","splitTextSegment","insertImage","setListStyle","setListStartNumber","setIndentation","setAlignment","setDirection","setHeadingLevel","toggleBlockQuote","setSpacing","setImageBorder","setImageBoxShadow","changeImage","getFormatState","clearFormat","insertLink","removeLink","adjustLinkSelection","setImageAltText","adjustImageSelection","setParagraphMargin","toggleCode","insertEntity","insertTableRow","insertTableColumn","clearSelectedCells","createEditorContextForEntity","formatTableWithContentModel","formatImageWithContentModel","formatParagraphWithContentModel","formatSegmentWithContentModel","formatTextSegmentBeforeSelectionMarker","formatInsertPointWithContentModel","setListType","setModelListStyle","setModelListStartNumber","findListItemsInSameThread","setModelIndentation","matchLink","promoteLink","getPromoteLink","getListAnnounceData","queryContentModelBlocks","adjustWordSelection","ResultMap","left","ltr","rtl","center","right","justify","TableAlignMap","alignment","splitSelectedParagraphByBr","paragraphOrListItemOrTable","getOperationalBlocks","readonlyBlock","block","mutateBlock","newAlignment","format","direction","blockType","alignTable","blockGroupType","blocks","textAlign","RTL_CHAR_REGEX","URL_CHAR_REGEX","WHITESPACE_REGEX","internalSetDirection","marginLeft","paddingLeft","setProperty","marginRight","paddingRight","rows","row","cells","cell","updateTableCellMetadata","metadata","borderOverride","storeBorderLeft","borderLeft","borderRight","applyTableFormat","calcDirection","findTextSegements","segments","filter","seg","segmentType","innerText","reduce","prev","text","rtlMatches","replace","rtlCount","determineTextDirection","isBlockGroupOfType","readonlyItem","item","levels","isSelected","listItem","some","segment","calculateMarginValue","isIndent","IndentStepInPixel","isRtl","originalValue","parseValueWithUnit","newValue","ceil","indentation","context","paragraphOrListItem","modifiedBlocks","thread","firstItem","isMultilevelSelection","threadIdx","previousItem","nextItem","levelLength","lastLevel","newLevel","createListLevel","listType","dataset","updateListMetadata","applyListStyleFromLevel","startNumberOverride","announceData","currentBlock","currentParent","index","normalizeContentModel","shallowColonParagraph","para","createParagraph","segmentFormat","decorator","selections","getSelectedSegmentsAndParagraphs","currentParagraph","hasVisibleSegment","newParagraphs","isQuote","tagName","formatLtr","formatRtl","paragraphOfQuote","every","blockAndParent","unwrapBlock","createFormatContainer","target","areSameFormats","canMergeQuote","wrapBlockStep1","wrapBlockStep2","countTabsSpaces","spaces","count","countSpacesBeforeText","mutateSegment","textSegment","insertPoint","table","paragraph","marker","indentationMargin","getTableIndentation","tabsNumber","trim","numberOfSegments","clearContainerFormat","containerPathIndex","getClosestAncestorBlockGroupIndex","container","containerIndex","blockIndex","newContainer","clearListFormat","clearBlockFormat","blocksToClear","segmentsToClear","tablesToClear","pendingStructureChange","iterateSelections","tableContext","mutableSegments","mutateSegments","formatHolder","colIndex","rowIndex","isWholeTableSelected","mutableCell","isHeader","useBorderBox","find","clearTableCellFormat","includeListFormatHolder","isOnlySelectionMarkerSelected","isWholeBlockSelected","defaultSegmentFormat","textColor","code","clearSegmentsFormat","borderCollapse","updateTableMetadata","createTablesFormat","isExpectedBlockType","type","isBlockType","group","findFirstOnly","shouldExpandEntity","elements","editorContext","createDomToModelContext","domToContentModel","wrapper","nodeStack","selectionRootNode","getSelectionRootNode","selection","root","startNode","contains","isNodeOfType","parentNode","createNodeStack","stackChild","getRegularSelectionOffsets","nodeStartOffset","nodeEndOffset","child","firstChild","nextSibling","getChildIndex","handleRegularSelection","processChildNode","defaultElementProcessors","step1Result","readonlyParent","readonlyBlockToWrap","creator","canMerge","blockToWrap","readonlyPrevBlock","prevBlock","createAndAdd","setParagraphNotImplicit","addBlock","readonlyNextBlock","nextBlock","entityModel","position","isBlock","focusAfterEntity","insertPointOverride","blockParent","assign","previousSegment","deleteResult","deleteSelection","getInsertPoint","pathIndex","directChild","childIndex","blocksToInsert","nextParagraph","createBr","createSelectionMarker","setSelection","image","border","borderRadius","width","style","extractedBorder","extractBorderValues","borderColor","borderWidth","borderStyle","borderFormat","borderTop","borderBottom","COMMON_REGEX","TELEPHONE_REGEX","MAILTO_REGEX","autoLinkOptions","autoLink","autoMailto","autoTel","mailtoMatch","toLocaleLowerCase","matchMailTo","linkMatch","normalizedUrl","telMatch","matchTel","httpExcludeRegEx","labelRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","RegExp","except","normalizeUrl","url","test","https","mailto","notes","file","unc","ftp","news","telnet","gopher","wais","getObjectKeys","schema","rule","matches","scheme","originalUrl","linkUrl","getLinkUrl","label","href","promotedLink","linkSegment","trimLeft","trimRight","underline","findListItems","pushNullIfNecessary","last","areListTypesCompatible","listItems","currentIndex","compareToIndex","currentLevels","compareToLevels","currentLevel","hasStartNumberOverride","currentItem","items","isOrderedList","filterListItems","displayForDummyItem","listNumber","getListNumber","getListMetadata","listStyle","getAutoListStyleType","listStyleType","defaultStrings","formatStrings","getOrderedListNumberStr","shouldIgnoreBlock","removeMargins","paragraphOrListItems","alreadyInExpectedType","existingListItems","itemIndex","mutableBlock","copyFormat","ListFormats","isInsideTableCell","newListItem","createListItem","marginBottom","marginTop","fontFamily","fontSize","adjustListIndentation","ListFormatsToMove","ListFormatsToKeep","levelIndex","getFirstSelectedListItem","firstMatcher","siblingMatcher","first","paragraphs","getSelectedParagraphs","changed","findIndex","shouldSplitTrailingSpace","isTrailingSpace","readonlyTextSegment","trailingSpace","newText","createText","trailingSpaceLink","trailingSpaceSegment","_","__","lastTextSegment","findDelimiter","moveRightward","word","offset","isPunctuation","isSpace","found","newSegmentLeft","newSegmentRight","markerBlock","tempSegments","markerSelectionIndex","currentSegment","firstColumn","addSegment","operation","TextAlignValueMap","alignCellLeft","alignCellCenter","alignCellRight","VerticalAlignValueMap","alignCellTop","alignCellMiddle","alignCellBottom","alignTableCellInternal","callback","sel","getSelectedCells","firstRow","lastRow","lastColumn","verticalAlign","vAlignOverride","firstCol","lastCol","noSpanAbove","spanAbove","noSpanLeft","spanLeft","noDifferentBelowSpan","spanCount","getBelowSpanCount","noDifferentRightSpan","col","getRightSpanCount","j","newCell","firstSegment","newCellParagraph","br","columns","cellFormat","createTable","createTableCell","cellInNextCol","widths","collapseTableSelection","cellInNextCell","createEmptyParagraph","newPara","firstCell","shift","insertLeft","copyPreviousCellSegmentFormat","insertAbove","sourceRow","height","canMergeCells","mergingColIndex","newSelectedCol","mergingRowIndex","newSelectedRow","newWidth","belowRow","belowCell","newHeight","newRow","editor","focus","formatContentModel","setModelAlignment","apiName","setModelDirection","HeaderFontSizes","h1","h2","h3","h4","h5","h6","headingLevel","tag","fontWeight","newPendingFormat","createParagraphDecorator","spacing","lineHeight","DefaultQuoteFormatLtr","DefaultQuoteFormatRtl","BuildInQuoteFormat","quoteFormat","quoteFormatRtl","fullQuoteFormatLtr","fullQuoteFormatRtl","toggleModelBlockQuote","options","contentNode","wrapperDisplay","skipUndoSnapshot","initialEntityState","getDocument","createElement","display","appendChild","createEntity","takeSnapshot","formatOptions","changeSource","ChangeSource","InsertEntity","getChangeData","id","isReadonly","insertEntityModel","newEntities","entityState","parseEntityFormat","entityType","state","needtoRun","triedTimes","clearModelFormat","conflictSolution","pendingFormat","getPendingFormat","manager","getSnapshotsManager","canUndo","hasNewContent","canMove","canRedo","isDarkMode","retrieveModelFormatState","getDOMHelper","getColorManager","processorOverride","reducedModelChildProcessor","tryGetFromCache","adjustSegmentSelection","ref","getDOMSelection","readFile","dataUrl","isDisposed","originalSrc","getImageMetadata","src","previousSrc","alt","triggerEvent","newSrc","insertImageWithSrc","createImage","backgroundColor","doc","createContentModelDocument","mergeModel","mergeFormat","imageFileOrSrc","altText","applyImageBorderFormat","boxShadow","margin","getSelectedSegments","URI_REGEX","FTP_REGEX","anchorTitle","displayText","checkXss","prefix","search","applyLinkPrefix","originalText","createLink","addLink","adjustTrailingSpaceSelection","CreateLink","onNodeCreated","modelElement","isChanged","newFormat","italic","strikethrough","superOrSubScriptSequence","capitalization","language","toLocaleUpperCase","wordArray","charAt","regex","FONT_SIZES","change","fontSizes","sizeInPt","newSize","pt","changeBase","getNewFontSize","setFontSizeInternal","changeFontSizeInternal","lastParagraph","lastSegmentIndex","fontName","start","end","middleSegment","newSegments","isTurningOn","isBold","_model","isTurningOff","announceFormatChange","DefaultCode","addCode","applyBorderFormat","positions","pos","tableModel","getFirstSelectedTable","perimeter","Top","Bottom","Left","Right","operations","allBorders","leftBorder","rightBorder","topBorder","bottomBorder","singleCol","singleRow","modifyPerimeter","tableMeta","getTableMetadata","setFirstColumnFormatBorders","getEnvironment","isSafari","range","collapsed","collapse","setDOMSelection","isReverted","fixUpSafariSelection","alignTableCellHorizontally","alignTableCellVertically","deleteTableColumn","deleteTableRow","deleteTable","mergeTableRow","mergeTableCells","mergeTableColumn","splitTableCellHorizontally","splitTableCellVertically","keepCellShade","getTableCellWidth","tableMetadataFormat","customCellFormat","insertPosition","createTableStructure","normalizeTable","MIN_ALLOWED_TABLE_CELL_WIDTH","initCellWidth","adjustTableIndentation","firstBlock","hasSelectionInBlockGroup","setTableCellBackgroundColor","entity","domHelper","defaultFormat","darkColorHandler","addDelimiterForEntity","allowCacheElement","domIndexer","zoomScale","calculateZoomScale","experimentalFeatures","defaultView","getComputedStyle","isRootRtl","getShadowChildProcessor","bundle","contextWithPath","shouldShiftPath","offsets","getShadowSelectionOffsets","handleElementShadowSelection","addSelectionMarker","isInSelection","input","textWithSelection","getShadowTextProcessor","textNode","txt","nodeValue","shadow","handleTextSelection","subtract","originalOffset","addTextSegment","buildSelectionMarker","blockFormat","currentContainer","setStyleCallback","toggleStyleCallback","segmentHasStyleCallback","includingFormatHolder","afterFormatCallback","segmentAndParagraphs","isCollapsedSelection","formatsAndSegments","modelsFromEntities","entityFormat","formattableRoots","entityOperationEventData","element","domToModelOptions","expandEntitySelections","mergeTextSegments","modelToDomContext","createModelToDomContext","modelToDomOptions","contentModelToDom","writeBackEntities","selectionOverride","readonlyTableModel","hasSelectionInBlock","ensureFocusableParagraphForTable","hasMetadata","recalculateTableSize","selectedSegmentsAndParagraphs","rewrite","markerIndex","styles","toArray","querySelectorAll","styleNode","selectorText","sheet","ruleIndex","cssRules","CSSRule","STYLE_RULE","selectors","cssText","removeChild","selector","setAttribute","getAttribute","DefaultSanitizingOption","formatParserOverride","additionalFormatParsers","additionalAllowedTags","additionalDisallowedTags","styleSanitizers","attributeSanitizers","processNonVisibleElements","document","defaultOption","additionalSanitizingOption","sanitizingOption","getRootComputedStyleForContext","editorViewWidth","getClientWidth","pasteTextProcessor","createPasteEntityProcessor","createPasteGeneralProcessor","pasteDisplayFormatParser","whiteSpace","pasteWhiteSpaceFormatParser","containerSizeFormatParser","pasteBlockEntityParser","html","trustedHTMLHandler","createDOMCreator","htmlToDOM","body","createDomToModelContextForSanitizing","retrieveCssRules","convertInlineCss","parseFormat","formatParsers","segmentOnBlock","createEmptyModel","AllowedTags","DisallowedTags","VARIABLE_REGEX","VARIABLE_PREFIX","AllowedAttributes","DefaultStyleValue","overflow","padding","float","orphans","widows","createSanitizedElement","attributes","attribute","sanitizer","processStyles","pairs","pair","valueIndex","isCssVariable","exec","processCssVariable","sanitizedValue","startsWith","sanitizeElement","allowedTags","disallowedTags","sanitizedElement","ownerDocument","newChild","cloneNode","Range","setStartBefore","setEndAfter","pasteModel","selectionMarker","tableCtxt","includes","isElementOfType","isContentEditable","removeAttribute","onCreateCopyEntityNode","isCut","event","adjustImageSelectionOnSafari","getContentModelCopy","pruneUnselectedModel","preprocessTable","adjustSelectionForCopyCut","tempDiv","selectionForCopy","newRange","elementToSelect","parentElement","childElementCount","createRange","selectNode","domSelectionToRange","htmlContent","clonedRoot","rawEvent","textContent","contentModelToText","pruneUnselectedModelInternal","isImplicit","inheritSegmentFormatToChildren","unwrap","isSelectionAfterElement","filteredRows","newCells","getHTMLFromDOM","innerHTML","mode","optionsOrCallbacks","getTextContent","getClonedRoot","transformColor","tableBorders","isExperimentalFeatureEnabled","div","styleTag","nonWordCharacterRegex","extractHtmlIndexes","startIndex","htmlLowercase","styleIndex","nextChar","styleEndIndex","removeCommentsFromHtml","endId","startId","clipboardData","pasteType","imageDataUri","fragment","createDocumentFragment","img","maxWidth","moveChildNodes","line","lines","initialOffset","tIndex","lineBefore","lineAfter","tabCount","fill","transformTabCharacters","createTextNode","htmlFromClipboard","domToModelOption","domToModelSettings","customized","eventType","htmlBefore","htmlAfter","htmlAttributes","containsBlockElements","CloneOption","includeCachedElement","cloneModelForPaste","cloneModel","shouldMergeTable","eventResult","isFirstPaste","customizedMerge","modelBeforePaste","clonedModel","domToModelContext","selectedSegment","getSegmentTextFormat","getSegmentFormatForPaste","mergeOption","mergeTable","addParagraphAfterMergedContent","EmptySegmentFormat","getLastSegmentFormat","Paste","scrollCaretIntoView","createDOMFromHtml","domCreator","pasteTypeOrGetter","getDOMCreator","isBypassed","rawHtml","cleanHtmlComments","retrieveHtmlInfo","sourceFragment","createPasteFragment","generatePasteOptionFromPlugins","globalCssRules","mergePasteContent","START_FRAGMENT","END_FRAGMENT","checkBlockElements","el","isBlockElement","endIndex","lastIndexOf","retrieveHtmlStrings","retrieveDocumentMetadata","htmlFirstLevelChildTags","topLevelTags","retrieveTopLevelTags","snapshot","move","restoreSnapshot","addUndoSnapshot","core","canUndoByBackspace","entityStates","lifecycle","physicalRoot","logicalRoot","undo","shadowEditFragment","beforeAddUndoSnapshotEvent","additionalState","api","createSnapshotSelection","entityWrapper","findClosestEntityWrapper","logicalRootPath","getPath","snapshotsManager","addSnapshot","normalizeTableTree","isDOMChanged","tbody","insertBefore","colgroups","thead","querySelector","colgroup","startContainer","startOffset","endContainer","endOffset","setStart","setEnd","imageId","tableId","rootNode","previousSibling","childNodes","isPreviousText","announce","ariaLiveMode","announcerStringGetter","textToAnnounce","sub","formatString","announceContainer","createAriaLiveElement","ariaLive","attachDomEvent","eventMap","disposers","pluginEventType","beforeDispatch","capture","eventName","onEvent","addEventListener","removeEventListener","coreApiMap","createContentModel","createEditorContext","setContentModel","setLogicalRoot","restoreUndoSnapshot","switchShadowEdit","getVisibleViewport","setEditorStyle","option","cache","textMutationObserver","flushMutations","cachedModel","saveIndex","settings","environment","builtIn","createDomToModelContextWithConfig","calculated","updateCache","allowCacheListItem","paragraphMap","isRightToLeft","rootComputedStyle","documentElement","rootFontSize","hasFocus","handlePendingFormat","pendingParagraphFormat","newPendingParagraphFormat","paragraphFormat","getChangedEntities","autoDetectChangedEntities","deletedEntities","entry","formatter","scroll","newImages","paragraphIndexer","clearModelCache","isNested","shouldAddSnapshot","shouldMarkNewContent","handleImages","ignoreSelection","eventData","contentModel","source","Format","data","formatApiName","changedEntities","skipUndo","Keyboard","autoCompleteInsertPoint","cachedSelection","rect","getDOMInsertPointRect","visibleRect","scrollContainer","domEvent","scrollRectIntoView","getSelection","rangeCount","getRangeAt","commonAncestorContainer","focusNode","focusOffset","getNewSelection","additionalRects","rects","normalizeRect","getBoundingClientRect","top","bottom","getIntersectedRect","updateKnownColor","tryGetEntityElement","entityMap","isEntityElement","getEntityWrapperForReuse","isBlockEntityContainer","tryGetEntityFromContainer","entityId","canPersist","refNode","currentNode","next","originalEntityElement","isEntityDelimiter","clearIndex","reuseCachedElement","getAllEntityWrappers","markerNode","replaceChild","restoredLogicalRoot","getPositionFromPath","snapshotSelection","domSelection","startPos","endPos","getSafeIdSelector","newContent","isRestoring","restoreSnapshotHTML","restoreSnapshotLogicalRoot","restoreSnapshotSelection","restoreSnapshotColors","SetContent","isInitializing","modelToDomSettings","createModelToDomContextWithConfig","onFixUpModel","rewriteFromModel","currentRange","areSameRanges","removeAllRanges","setBaseAndExtent","addRange","parsedTable","coordinate","below","DOM_SELECTION_CSS_KEY","HIDE_SELECTION_CSS_KEY","TRANSPARENT_SELECTION_CSS_RULE","SELECTION_SELECTOR","setRangeSelection","addRangeToSelection","skipSelectionChangedEvent","existingSelection","areSameSelections","skipReselectOnFocus","toggleCaret","imageSelectionColor","imageSelectionBorderColorDark","imageSelectionBorderColor","ensureUniqueId","parseTableCells","lastCell","findTableCellElement","findLastedCoInMergedCell","tableSelectionInfo","tableSelector","tableSelectors","cont","indexes","tdCount","midElement","ind","middleElSelector","currentRow","cellIndex","handleTableSelected","tableSelectionColor","tableCellSelectionBackgroundColorDark","tableCellSelectionBackgroundColor","nodeToSelect","firstElementChild","newSelection","isHiding","idPrefix","cssRule","subSelectors","maxRuleLength","styleElement","styleElements","head","roosterjsStyleKey","deleteRule","rootSelector","maxLen","stringBuilder","subSelector","buildSelectors","insertRule","beforeLogicalRootEvent","contentEditable","editorCore","isOn","allowedEventsInShadowEdit","pluginEvent","broadcast","plugins","plugin","onPluginEvent","willHandleEventExclusively","handledExclusively","contentDiv","onMutation","mutation","reconcileChildList","addedNodes","removedNodes","invalidateCache","updateCachedModel","reconcileElementId","onNativeSelectionChange","DomIndexerImpl","createTextMutationObserver","enableParagraphMap","createParagraphMap","getName","initialize","startObserving","dispose","stopObserving","getState","isInShadowEdit","clear","forceUpdate","newRangeEx","reconcileSelection","CachePlugin","nextId","ParagraphMapImpl","prefixNum","assignMarkerToModel","getParagraphMarker","paragraphWithMarker","_marker","generateId","applyMarkerToDom","setParagraphMarker","getParagraphFromMarker","markerParagraph","_reset","_getMap","areSame","o1","o2","sel1","sel2","areSameTableSelections","range1","TableSelectionKeys","RangeKeys","r1","r2","isIndexedSegment","__roosterjsContentModel","getIndexedSegmentItem","getIndexedTableItem","unindex","keepSelectionMarkerWhenEnteringTextNode","onSegment","segmentNode","onParagraph","paragraphElement","previousText","onTable","tableElement","onBlockEntity","onBlockEntityDelimiter","onMergeText","targetText","sourceText","internalClearIndex","oldSelection","isCollapsed","reconcileTextSelection","selectionMarkerToKeepWhenEnteringTextNode","indexedImage","indexedTable","hasRevertedRangeSelection","reconcileNodeSelection","marker1","marker2","canHandle","segIndex","addedNode","reconcileAddedNode","removedNode","reconcileRemovedNode","pendingTextNode","indexedImg","isIndexedDelimiter","reconcileDelimiterSelection","insertMarker","lastChild","isAfter","segmentItem","formatSegment","selectable","textSegments","middle","newLast","firstIndex","lastIndex","delimiter","isBefore","existingSegment","getLastLeaf","indexNode","getFirstLeaf","removingSegment","copiedFormat","onMutationInternal","mutations","firstTarget","lastTextChangeNode","reconcileText","ignoredNodes","Set","includedNodes","has","findClosestBlockEntityContainer","add","isNodeInEditor","attributeName","observer","MutationObserver","createDOMHelper","observe","subtree","childList","characterData","disconnect","ignoreMutations","takeRecords","TextMutationObserverImpl","disposer","onContextMenuEvent","e","pointerEvent","button","pointerType","getFocusedNode","contextMenuProviders","provider","getContextMenuItems","isContextMenuProvider","eventHandlers","contextmenu","ContextMenuPlugin","onPaste","isClipboardEvent","dataTransfer","shouldPreventDefaultPaste","preventDefault","extractClipboardItems","allowedCustomPasteType","then","paste","defaultPasteType","copy","onCutCopy","cut","textAndHtmlContent","getContentForCopy","setData","deleteEmptyList","Cut","isAndroid","isNormalFile","kind","isText","CopyPastePlugin","isEmptyBlock","listItemIndex","previousBlock","createCachePlugin","createFormatPlugin","copyPaste","createCopyPastePlugin","createDOMEventPlugin","createLifecyclePlugin","createEntityPlugin","createSelectionPlugin","contextMenu","createContextMenuPlugin","createUndoPlugin","EventTypeMap","keydown","keyup","keypress","timer","onDragStart","dragEvent","onDrop","requestAnimationFrame","Drop","onScroll","keyboardEventHandler","isCharacterValue","isCursorMovingKey","stopPropagation","isComposing","isInIME","inputEventHandler","onMouseDown","mouseUpEventListerAdded","onMouseUp","mouseDownX","pageX","mouseDownY","pageY","defaultPrevented","originalEvent","removeMouseUpEventListener","isClicking","onDoubleClick","onCompositionStart","onCompositionEnd","onPointerDown","mousedown","dblclick","compositionstart","compositionend","dragstart","drop","pointerdown","clearTimeout","DOMEventPlugin","ENTITY_ID_REGEX","handleMouseUpEvent","handleContentChangedEvent","handleDelimiterKeyDownEvent","handleCompositionEndEvent","handleExtractContentWithDomEvent","modifiedEntities","isFakeEntity","className","generateEntityClassNames","shouldPersist","mapEntry","isDeleted","handleDelimiterContentChangedEvent","findAllEntities","baseId","substr","newId","EntityPlugin","shiftKey","anchorNode","movingBefore","allSel","isShrinking","pairedDelimiter","entitySegment","paraIndex","entityBlock","previousElementSibling","nextElementSibling","findPairedDelimiter","originalRange","cloneRange","setEndBefore","setStartAfter","getNewRange","DelimiterBefore","DelimiterAfter","DelimiterSelector","ZeroWidthSpace","preventTypeInDelimiter","entitySibling","classList","removeInvalidDelimiters","_path","_tableContext","_segments","nodes","sibling","checkEntity","remove","normalize","cn","deleteContents","removeDelimiterAttr","getFocusedElement","existingTextInDelimiter","normalizePos","textToCheck","closest","hasChildNodes","helper","queryElements","addDelimiters","addDelimitersIfNeeded","triggerEntityEventOnEnter","altKey","ctrlKey","metaKey","adjustSelectionAroundEntity","focusedNode","blockEntityContainer","isEnter","handleKeyDownInBlockDelimiter","handleEnterInlineEntity","handleInputOnDelimiter","readonlySelectionBlock","selectionBlockParent","selectionBlock","segmentsAfterMarker","selectionBlockIndex","entities","DefaultStyleKeyMap","lastCheckedNode","normalizeFontFamily","defaultFormatKeys","normalizeSegmentFormat","checkAndApplyPendingFormat","isAndroidIME","clearPendingFormat","size","shouldApplyDefaultFormat","applyDefaultFormat","canApplyPendingFormat","applyPendingFormat","posContainer","FormatPlugin","getNewPendingFormat","markerFormat","blockCount","isSubFormatIncluded","containerFormat","subFormat","subStr","mutableParagraph","ContentEditableAttributeName","initializer","userSelect","adjustColor","doNotAdjustEditorColor","adjustContainerColor","inDarkMode","addedBlockElements","removedBlockElements","SwitchToDarkMode","SwitchToLightMode","setColor","LifecyclePlugin","Up","Down","DEFAULT_SELECTION_BORDER_COLOR","DEFAULT_TABLE_CELL_SELECTION_BACKGROUND_COLOR","logicalRootDisposer","isMac","scrollTopCache","onMouseMove","tableSelection","hasTableSelection","lastCo","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","tableStart","newTableSelection","parseTableSelection","findCoordinate","updated","updateTableSelection","detachMouseEvent","getContainedTargetImage","previousSelection","onFocus","getScrollContainer","scrollTop","onBlur","sc","onSelectionChange","isSingleImageInSelection","getDarkColor","env","blur","onKeyDown","getClickingImage","detail","mouseDisposer","mousemove","win","isModifierKey","selectBeforeOrAfterElement","handleSelectionInTable","getTabKey","firstCo","updateTableSelectionFromKeyboard","tableSel","tabMove","oldCo","reverse","step","setRangeSelectionInTable","originalTd","td","nodeOffset","selectAll","cellStart","cellEnd","posStart","posEnd","rowChange","colChange","after","setSelectionInNextSiblingElement","selectNodeContents","tdStart","findClosestElementAncestor","SelectionPlugin","isSelection","endNode","anchorOffset","getProps","HTML_VOID_ELEMENTS","nextNode","snapshots","hasNewContentValue","totalSize","autoCompleteIndex","maxSize","newIndex","onChanged","isAutoCompleteSnapshot","currentSnapshot","isSameSnapshot","clearRedo","getSnapshotLength","removeCount","removedSize","canUndoAutoComplete","SnapshotsManagerImpl","Backspace","Delete","Enter","createSnapshotsManager","lastKeyPress","onKeyPress","clearRedoForInput","onContentChanged","onBeforeKeyboardEditing","evt","isCtrlOrMetaPressed","UndoPlugin","cloneOptionCallback","colorHandler","createEditorCore","initialModel","getCore","disposeErrorHandler","reset","setDarkModeState","startShadowEdit","stopShadowEdit","getTrustedHTMLHandler","featureName","Editor","excludeRoot","originalWidth","visualWidth","offsetWidth","setDomAttribute","getDomAttribute","getDomStyle","startFrom","startElement","closestElement","findClosestBlockElement","activeElement","clientWidth","cloneIndependentRoot","implementation","createHTMLDocument","importNode","getContainerFormat","isInDarkMode","window","getColor","fontStyle","letterSpacing","textDecoration","getRangesByText","matchCase","wholeWord","DOMHelperImpl","knownColors","generateColorKey","colorPair","darkModeColor","removeProperty","defaultGenerateColorKey","DarkColorHandlerImpl","createEditorEnvironment","navigator","userAgent","appVersion","createDomToModelSettings","createModelToDomSettings","isIOS","isMobileOrTablet","getIsMobileOrTablet","getDarkColorFallback","corePlugins","createEditorCorePlugins","coreApiOverride","originalApi","createDarkColorHandler","isDOMCreator","createTrustedHTMLHandler","getPluginState","defaultDomToModelOptions","createDomToModelConfig","metadataAppliers","listItemMetadataApplier","listLevel","listLevelMetadataApplier","defaultModelToDomOptions","createModelToDomConfig","createModelFromHtml","exportContent","redo","OrderedMapPlaceholderRegex","getListStyleValue","numberStr","template","OrderedListStyleMap","UnorderedListStyleMap","shouldApplyToItem","metadataDefinition","ListMetadataDefinition","applierFunction","depth","listFormat","threadItemCounts","listStyleTypeFormat","BlockEntityClass","OneHundredPercent","InlineBlock","DefaultStyleSanitizers","attrSanitizers","removeDisplayFlex","processor","span","isWhiteSpacePreserved","defaultStyle","defaultFormatParsers","clip","clipPath","handler","defaultTrustHtmlHandler","DOMParser","parseFromString","trustedHTMLHandlerToDOMCreator","defaultContentModelFormatMap","blockquote","dd","dl","pre","th","blockElement","defaultHTMLStyleMap","address","article","aside","marginInlineStart","dt","em","fieldset","figcaption","figure","footer","form","header","li","main","nav","ol","paddingInlineStart","section","strike","strong","sup","boxSizing","u","ul","BulletListType","Min","Disc","Dash","Square","ShortArrow","LongArrow","UnfilledArrow","Hyphen","DoubleLongArrow","Circle","BoxShadow","Xrhombus","CheckMark","Max","AutoLink","ImageResize","ListChain","AutoFormat","Replace","NumberingListType","Decimal","DecimalDash","DecimalParenthesis","DecimalDoubleParenthesis","LowerAlpha","LowerAlphaParenthesis","LowerAlphaDoubleParenthesis","LowerAlphaDash","UpperAlpha","UpperAlphaParenthesis","UpperAlphaDoubleParenthesis","UpperAlphaDash","LowerRoman","LowerRomanParenthesis","LowerRomanDoubleParenthesis","LowerRomanDash","UpperRoman","UpperRomanParenthesis","UpperRomanDoubleParenthesis","UpperRomanDash","TableBorderFormat","Default","ListWithSideBorders","NoHeaderBorders","NoSideBorders","FirstColumnHeaderExternal","EspecialType1","EspecialType2","EspecialType3","Clear","config","blockDecorator","elementProcessors","defaultProcessorMap","buildFormatParsers","overrides","additionalParsersArray","combinedOverrides","defaultFormatKeysPerCategory","formatKey","parsers","linkProcessor","knownElementProcessor","brProcessor","codeProcessor","formatContainerProcessor","del","font","fontProcessor","imageProcessor","headingProcessor","hrProcessor","listItemProcessor","listProcessor","pProcessor","tableProcessor","generalProcessor","textProcessor","textWithSelectionProcessor","elementProcessor","entityProcessor","childProcessor","delimiterProcessor","SegmentDecoratorTags","isSegmentDecorator","ContextStyles","stackFormat","tryGetProcessorForEntity","tryGetProcessorForDelimiter","isBlockEntity","FontSizes","intSize","formatContainerProcessorInternal","forceFormatContainerProcessor","forceFormatContainer","getDefaultStyle","formatContainer","zeroFontSize","shouldFallbackToParagraph","generalBlockProcessor","createGeneralBlock","isSelectedBefore","general","generalSegmentProcessor","createGeneralSegment","addDecorators","blockProcessor","divider","createDivider","imageFormat","title","isSelectedAsImageSelection","FormatContainerTriggerStyles","FormatContainerTriggerAttributes","ByPassFormatContainerTags","isBlockContainer","attr","hasAttribute","shouldForceUseFormatContainer","bgcolor","getPropertyValue","shouldUseFormatContainer","segmentUnderLink","emptyText","listParent","listItemElement","listItemThread","currentBlocks","lastItem","listLevelThread","originalListParent","translateRowSpanZero","amountOfRows","tdIndex","calcSizes","lastPos","selectionRoot","shouldRecalculateTableSize","cachedElement","tableBorder","columnPositions","hasColGroup","colFormat","tableColumn","processColGroup","rowPositions","tr","tableRow","isInTableSection","sourceCol","targetCol","hasSelectionBeforeCell","colEnd","colSpan","rowEnd","rowSpan","needCalcWidth","needCalcHeight","segmentOnTableCell","tableCell","hasTd","spannedRow","hasSelectionAfterCell","heights","internalTextProcessor","ensureParagraph","segmentCount","parser","txtStartOffset","txtEndOffset","subText","f1","f2","keys1","keys2","lastPara","formatFromParagraph","BLOCK_DISPLAY_STYLES","effectiveDisplay","SkippedStylesForBlockOnSegmentOnSegment","SkippedStylesForTable","stackFormatInternal","processType","textIndent","isTextIndentApplied","linkFormat","codeFormat","decoratorFormat","stackLinkInternal","stackCodeInternal","ENTITY_INFO_NAME","ENTITY_INFO_SELECTOR","ENTITY_TYPE_PREFIX","ENTITY_ID_PREFIX","ENTITY_READONLY_PREFIX","DELIMITER_BEFORE","DELIMITER_AFTER","BLOCK_ENTITY_CONTAINER","BLOCK_ENTITY_CONTAINER_SELECTOR","isDelimiter","insertDelimiter","isEntity","parseEntityClassName","matchBefore","matchAfter","delimiterAfter","delimiterBefore","applyFormat","formatAppliers","getter","eventDataCache","CursorMovingKeys","isCtrlKey","isAltKey","isMetaKey","ContentHandlers","customValues","linkPreview","parse","types","files","pasteNativeEvent","Promise","all","resolve","getAsFile","textType","getAllowedCustomType","getAsString","SplittingTags","isSplittingElement","iterateTextNodes","canSearchText","editableOnly","nodeText","paragraphText","isSpaceOrPunctuation","findNodeAndOffset","lengths","isEnd","segmentLength","StartsWithUnsupportedCharacter","hiddenProperty","__roosterjsHiddenProperty","nodeWithHiddenProperty","getHiddenProperty","setHiddenProperty","UndeletableLinkKey","undeletable","genericRoleElements","expectedType","nodeType","WHITESPACE_PRE_VALUES","keepExistingChildren","newElement","clientRect","FileReader","onload","onerror","readAsDataURL","meta","content","getZoomScale","knownZoomScale","targetRect","scrollMargin","preferTop","scrollUp","scrollDown","needsScrollUp","needsScrollDown","tryGetRectFromPos","getClientRects","normalizeInsertPoint","SPACES_REGEX","charCodeAt","isForward","BorderStyles","BorderSizeRegex","combinedBorder","boldStyle","process","family","existingQuotedFontsRegex","iterateElements","transformer","includeSelf","isHTMLElement","htmlElement","ELEMENT_NODE","transformColorOptions","toDarkMode","backColor","BorderKeys","borderColorProperty","BorderColorKeyMap","lightColor","getLightModeColor","transformedColor","adaptColor","transformBorderColor","trs","collection","wrapperTag","directionFormatHandler","dir","apply","justifySelf","displayFormatHandler","htmlAlignFormatHandler","htmlAlign","calcAlign","lineHeightFormatHandler","MarginKeys","DefaultMarginKey","LTR","marginFormatHandler","alternativeKey","ltrKey","implicitFormat","PaddingKeys","AlternativeKeyLtr","AlternativeKeyRtl","paddingFormatHandler","alterativeKey","defaultValue","textAlignFormatHandler","textIndentFormatHandler","whiteSpaceFormatHandler","shouldSetValue","ariaFormatHandler","ariaDescribedBy","backgroundColorFormatHandler","borderBoxFormatHandler","BorderWidthKeyMap","BorderStyleKeyMap","borderColorFormatHandler","retrieveElementColor","lightModeColor","combineBorderValue","borderValues","BorderWidthKeys","BorderRadiusKeys","AllKeys","borderFormatHandler","defaultWidth","boxShadowFormatHandler","datasetFormatHandler","floatFormatHandler","idFormatHandler","roleFormatHandler","role","PercentageRegex","tryParseSize","attrName","attrValue","sizeFormatHandler","maxHeight","minWidth","minHeight","verticalAlignFormatHandler","wordBreakFormatHandler","wordBreak","defaultFormatHandlerMap","aria","bold","boldFormatHandler","borderBox","fontFamilyFormatHandler","fontSizeFormatHandler","entityFormatHandler","imageState","imageStateFormatHandler","italicFormatHandler","legacyTableBorder","legacyTableBorderFormatHandler","letterSpacingFormatHandler","linkFormatHandler","listItemAlign","listItemAlignFormatHandler","listItemThreadFormatHandler","listLevelThreadFormatHandler","listStyleFormatHandler","strikeFormatHandler","superOrSubScript","superOrSubScriptFormatHandler","tableLayout","tableLayoutFormatHandler","tableSpacing","tableSpacingFormatHandler","textColorFormatHandler","textColorOnTableCell","textColorOnTableCellFormatHandler","undeletableLink","undeletableLinkFormatHandler","underlineFormatHandler","styleBasedSegmentFormats","elementBasedSegmentFormats","sharedBlockFormats","sharedContainerFormats","styleBasedSegment","elementBasedSegment","tableCellBorder","defaultFormatAppliers","alignSelf","align","flexDirection","isLiUnderOl","defaultStyles","startNumber","listStylePosition","blockFontWeight","wrapAllChildNodes","isSuperOrSubScript","contextFont","knownFontSize","KnownFontSizes","isRemUnit","endsWith","existingFontSize","normalizeFontSize","small","medium","large","getImageState","setImageState","rel","anchorId","relationship","anchorClass","implicitColor","isLinkUndeletable","setLinkUndeletable","cellSpacing","cellpadding","cellPadding","BorderCollapsed","BorderSeparate","borderSeparate","borderSpacing","DeprecatedColors","HEX3_REGEX","HEX6_REGEX","RGB_REGEX","RGBA_REGEX","fallback","darkColor","rgbSearch","parseColor","rgbCurrent","findLightColorFromDarkColor","colorType","existingKey","fallbackColor","isBackground","newColor","COLOR_VAR_PREFIX","initial","MarginValueRegex","getFontSize","currentSizeOrElement","styleInPt","ptToPx","currentSizePxOrElement","resultUnit","px","numStr","unit","normalValue","existingValue","updateMetadata","getMetadata","createTableRow","normalizeParagraph","isGeneralSegment","isEmpty","normalizeSingleSegment","ParagraphFormats","normalizeText","cacheGetEventData","hasSelectionInSegment","deleteSegment","deleteBlock","MIN_ALLOWED_TABLE_CELL_HEIGHT","getListStyleTypeFromString","runEditSteps","updateImageMetadata","getTableCellMetadata","targetFormat","sourceFormat","formatKeys","deleteOriginalFormat","newSegment","lastSegment","textModel","hasSpacesOnly","lastBlock","SPACE_TEXT_REGEX","isBlockEmpty","isBlockGroupEmpty","isSegmentEmpty","treatAnchorAsNotEmpty","isBlockGroup","isSegment","code1","code2","link1","link2","seg1","seg2","lastText","mutablePara","mutableSegment","secondLast","noMarkerSegments","normalizeParagraphStyle","normalizeAllSegments","mutableMarker","removeEmptyLinks","removeEmptySegments","formatsToMoveUp","firstFormat","internalMoveUpSegmentFormat","moveUpSegmentFormat","SPACE","NONE_BREAK_SPACE","LEADING_SPACE_REGEX","TRAILING_SPACE_REGEX","resetNormalizeSegmentContext","ignoreLeadingSpaces","ignoreTrailingSpaces","lastInlineSegment","normalizeSegment","normalizeTextSegments","normalizeLastTextSegment","modelHandlers","groupToUnwrap","formatsToKeep","rowCount","spanLeftOrColSpan","spanAboveOrRowSpan","DEFAULT_FORMAT","topBorderColor","bottomBorderColor","verticalBorderColor","hasHeaderRow","hasFirstColumn","hasBandedRows","hasBandedColumns","bgColorEven","bgColorOdd","headerRowColor","tableBorderFormat","mutableTable","effectiveMetadata","metaOverrides","removeCellShade","bgColorOverrides","vAlignOverrides","borderOverrides","bgColorOverride","updateOverrides","readonlyCell","transparentBorderMatrix","BorderFormatters","alwaysUseTransparent","getBorderStyleFromColor","formatCells","setBorderColor","setHeaderRowFormat","cellSegment","cloneModelWithFormat","cloneModelWithDataset","cloneBlockBase","cloneBlockGroupBase","handleCachedElement","cloneFormatContainer","cloneGeneralBlock","cloneSelectionMarker","cloneListLevel","cloneListItem","cloneDivider","cloneEntity","newParagraph","cloneSegmentBase","cloneGeneralSegment","cloneSegment","cloneParagraph","cloneTableCell","cloneTableRow","cloneTable","cloneBlock","newModel","blockToDelete","replacement","DeleteSelectionIteratingOptions","contentUnderSelectedTableCell","contentUnderSelectedGeneralElement","createInsertPoint","formatContext","undeletableSegments","readonlySegments","insertMarkerIndex","lastTableContext","removeSegment","insertIndex","readonlyParagraph","readonlySegmentToDelete","segmentToDelete","preserveWhiteSpace","isBackward","normalizePreviousSegment","deleteSingleChar","additionalSteps","deleteExpandedSelection","steps","mutableLastParagraph","mutableInsertingParagraph","mergeParagraphAfterDelete","deleteLength","deleteState","blockGroupTypes","stopTypes","isValidTarget","bullet","includingBIU","textFormat","removeUndefinedValues","HeadingTags","KeysOfSegmentFormat","mergeParagraph","markerPosition","mergeToCurrentParagraph","splitParagraph","segmentIndex","sourceKeys","mergeTables","newTable","readonlyTable","leftCell","aboveCell","oldCell","newMarker","insertBlock","mergeList","newList","newParaFormat","applyDefaultFormatOption","mergeBlockFormat","mergeSegmentFormat","getSegmentFormatInLinkFormat","getFormatWithoutSegmentFormat","getSemanticFormat","getHyperlinkTextColor","mergeLinkFormat","resultFormat","tryMoveBlocks","targetCell","sourceCell","mergeValue","isFirst","parseFn","formatState","firstTableContext","isFirstImage","isFirstSegment","modelFormat","retrieveStructureFormat","isMultilineSelection","validHeadingLevel","retrieveParagraphFormat","currentFormat","mergedFormat","superOrSubscript","retrieveSegmentFormat","canUnlink","canAddImageAltText","imageEditingMetadata","retrieveImageFormat","canMergeTableCell","tableFormat","isInTable","tableHasHeader","retrieveTableFormat","px2Pt","isValidDeleteSelectionContext","White","Black","areSameColor","rgb1","rgb2","isColorOverride","applyToSegments","colorValues","calculateLightness","setAdaptiveCellColor","removeAdaptiveCellColor","DefaultOrderedListStyles","DefaultUnorderedListStyles","OrderedListStyleRevertMap","UnorderedListStyleRevertMap","disc","circle","square","existingStyleType","orderedStyleType","unorderedStyleType","RomanValues","M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I","convertDecimalsToAlpha","decimal","isLowerCase","String","fromCharCode","convertDecimalsToRoman","romanValue","timesRomanCharAppear","repeat","styleType","isOptional","minValue","maxValue","allowNull","itemDef","minLength","maxLength","propertyDef","NumberDefinition","createNumberDefinition","BooleanDefinition","createBooleanDefinition","ImageMetadataFormatDefinition","createObjectDefinition","widthPx","heightPx","leftPercent","rightPercent","topPercent","bottomPercent","angleRad","createStringDefinition","naturalHeight","naturalWidth","flippedHorizontal","flippedVertical","list","EditingInfoDatasetName","definition","metadataString","validate","TableCellMetadataFormatDefinition","NullStringDefinition","TableFormatDefinition","def","n1","n2","abs","includingEntity","mutate","collectSelections","deepFirst","findSequence","removeUnmeaningfulSelections","groupIndex","checkFirstParagraph","allSegments","resultPath","hasSelection","internalIterateSelections","treatAllAsSelect","hasSelectedSegment","hasUnselectedSegment","newPath","handleGeneralContent","handleGeneralElement","setSelectionToBlockGroup","handleSelection","needToSetSelection","setIsSelected","blocksToDelete","findCell","wasInSelection","currentCell","setSelectionToTable","segmentsToDelete","internalSetSelectionToSegment","setSelectionToSegment","setSelectionToBlock","mutableGroup","additionAction","calcPosition","blockGroupChildren","startPosition","endPosition","imageSelection","extractSelectionRange","regularSelection","defaultContentModelHandlers","modelHandlerOverride","buildFormatAppliers","formatApplierOverride","additionalFormatAppliers","defaultModelHandlers","defaultContentModelFormatOverride","additionalAppliersArray","appliers","handleBlock","handleBlockGroupChildren","handleBr","handleEntityBlock","handleEntitySegment","generalBlock","handleGeneralBlock","generalSegment","handleGeneralSegment","handleDivider","handleImage","handleList","handleListItem","handleParagraph","handleFormatContainer","handleSegment","segmentDecorator","handleSegmentDecorator","handleTable","handleText","handlers","cleanUpNodeStack","cleanUpRestNodes","childBlock","segmentNodes","handleSegmentCommon","BlockEntityContainer","getSegmentFormat","isCursorAroundEntity","isContained","elementToReuse","before","PreChildFormat","imageModel","widthNum","heightNum","layer","parentLevel","stackLevel","itemLevel","editingInfo","lastParent","isNewlyCreated","levelRefNode","applyMetadata","leafLevel","itemRefNode","children","isGenericRoleElement","needParagraphWrapper","formatOnWrapper","handleSegments","optimize","codeNode","tableNode","applier","OptimizeTags","hasSameAttributes","element1","element2","attr1","attr2","updateSelection","mark","nextText","lastTextOriginalLength","removeUnnecessarySpan","mergeNode","originalLength","normalizeTextNode","newNode","rewriteContext","containerNode","tagNameOrFormat","defaultCallbacks","onDivider","onEntityBlock","onEntitySegment","onGeneralSegment","onImage","onText","onBlockGroup","contentModelToTextArray","textArray","callbacks","separator","headingLevels","MarkdownHeadings","convertMarkdownToContentModel","convertContentModelToMarkdown","splitParagraphSegments","formattedSegment","createImageSegment","applyLink","adjustHeading","formattedSegments","applyTextFormatting","parseMarkerAt","remaining","shouldToggleFormatting","currentState","getCurrentFormatState","toggleFormatting","createFormattedSegment","baseFormat","isOnlyFormattingMarkers","currentText","splitLinesPatternOrOptions","splitLinesPattern","markdownProcessor","MarkdownBlockGroupType","unordered_list","ordered_list","patternName","createListFromMarkdown","createBlockQuoteFromMarkdown","QuoteFormat","createParagraphFromMarkdown","quote","isDummy","isDummyListItem","itemText","createLevels","listModel","headingType","getHeadingDecorator","applySegmentFormatting","createTableModel","markdown","tableDivider","contents","getCellAlignment","addTableRow","tableLines","MarkdownPattern","heading","horizontal_line","space","MarkdownBlockType","addMarkdownBlockToModel","markdownContext","isMarkdownTable","createTableFromMarkdown","lastQuote","lastList","emptyLine","emptyLineState","blockGroup","createBlockGroupFromMarkdown","markdownText","matched","convertMarkdownText","markdownToBeRemoved","pattern","linkRegex","isValidUrl","URL","newLine","modelProcessor","DEFAULT_NEW_LINE","newLinePattern","listCounter","newLines","paragraphContext","markdownString","createMarkdownParagraph","createMarkdownBlockGroup","createMarkdownTable","ignoreLineBreaks","createMarkdownBlock","isSubList","dummyFormat","subListItemCount","listItemCount","createMarkdownListItem","createMarkdownBlockQuote","addTableDivider","headerRow","lineBreak","action","getIsSelectingOrUnselecting","retrieveStringFromParsedTable","AnnouncePlugin","tsInfo","prevTableSelection","prevFirstRow","prevLastRow","prevFirstColumn","prevLastColumn","newFirstRow","newLastRow","newFirstColumn","newLastColumn","prevArea","newArea","DefaultOptions","autoBullet","autoNumbering","autoUnlink","autoHyphen","autoFraction","autoOrdinals","removeListMargins","autoHorizontalLine","enabled","transformFunction","createAnchor","tabFeatures","_previousSegment","keyboardListTrigger","features","transformHyphen","transformFraction","transformOrdinals","enterFeatures","checkAndInsertHorizontalLine","shouldHandleInputEventExclusively","shouldHandle","inputType","_paragraph","_markerFormat","getListTypeStyle","handleEditorInputEvent","handleKeyDownEvent","handleKeyboardEvents","featureApplied","feature","handledByEditFeature","unlink","AutoFormatPlugin","anchor","HorizontalLineTriggerCharacters","commonStyles","HorizontalLineStyles","Map","insertHorizontalLineIntoModel","triggerChar","allText","acc","triggerCharacter","shouldFormat","textIndex","textLength","links","promotedSegment","letter","listIndex","indexNumber","convertAlphaToDecimals","shouldSearchForBullet","shouldSearchForNumbering","listMarkerSegment","listMarker","bulletType","bulletListType","getPreviousListLevel","previousList","hasSpaceBetween","previousIndex","getPreviousListIndex","previousListStyle","getPreviousListStyle","numberingType","getNumberingListStyle","getIndex","isNewList","previousListItem","listBlockIndex","NumberingTypes","Character","characters","lowerRomanTypes","upperRomanTypes","numberingTriggers","lowerRomanNumbers","upperRomanNumbers","numberingListTypes","DecimalsTypes","LowerAlphaTypes","UpperAlphaTypes","LowerRomanTypes","UpperRomanTypes","textBeforeCursor","previousListIndex","trigger","isDoubleParenthesis","isContinuosList","canAppendList","isValidNumbering","numbering","separatorCharacter","identifyNumberingType","identifyNumberingListType","triggerList","setAnnounceData","FRACTIONS","fraction","getOrdinal","ORDINALS","getNumericValue","checkFullText","number","numericValue","shouldAddSuperScript","numberSegment","ordinal","isMenuShowing","onDismiss","dismiss","allowDefaultMenu","initContainer","render","ContextMenuPluginBase","customReplacements","triggerKeys","stringToReplace","replacementString","replacementHandler","CustomReplacePlugin","DefaultHandleTabOptions","indentMultipleBlocks","indentTable","appendTableRow","indentList","indentParagraph","DisabledHandleTabOptions","handleTabKey","handleExpandedSelectionOnDelete","shouldHandleNextInputEvent","selectionAfterDelete","handleNormalEnter","tabOptions","createNormalEnterChecker","getHandleNormalEnter","shouldHandleEnterKey","beforeinput","handleBeforeInputEvent","hasCtrlOrMetaKey","shouldBrowserHandleBackspace","keyboardDelete","keyboardTab","keyCode","keyboardEnter","formatsToPreserveOnMerge","keyboardInput","InputEvent","handled","KeyboardEvent","which","opt","shouldHandleBackspaceKey","EditPlugin","deleteAllSegmentBefore","segmentsWithoutBr","fixupBr","shouldOutdentParagraph","lastInPath","getRoot","getLeafSiblingBlock","siblingSegment","preserveParagraphFormat","deleteEmptyQuote","quoteBlockIndex","isEmptyQuote","isEmptyParagraph","insertNewLine","quoteIndex","mutableParent","newQuote","deleteList","mutableList","removedBlocks","deleteParagraphStyle","parentGroup","DeleteWordState","getDeleteWordSelection","deleteNext","iterator","forward","punctuation","iterateSegments","curr","done","forwardDeleteWordSelection","backwardDeleteWordSelection","deleteEmptyBlockGroups","modified","handleAutoLink","segBefore","handleEnterOnList","readonlyListItem","isEmptyListItem","createNewListItem","currentPara","createNewListLevel","remainingBlockCount","handleEnterOnParagraph","handleExpandedSelection","canDeleteBefore","canDeleteAfter","shouldDeleteWithContentModel","deleteAllSegmentBeforeStep","shouldDeleteAllSegmentsBefore","deleteWordSelection","shouldDeleteWord","deleteCollapsedSelection","getDeleteCollapsedSelection","deleteQuote","getDeleteSteps","handleKeyboardEventResult","insertZWS","shouldInputWithContentModel","handleTabOnTableCell","handleTabOnParagraph","handleTabOnList","handleTab","handleTabOnTable","selectedParagraph","findSelectedParagraph","isMarkerAtStartOfBlock","tabSpaces","selectedSegments","tabText","firstSelectedSegment","spaceText","isNext","formatValue","removeImplicitParagraph","shouldPreserveImplicitParagraph","findHighlightStyle","replaceHighlightStyle","findHighlight","replaceHighlight","FindHighlightRuleKey","FindHighlightSelector","ReplaceHighlightRuleKey","ReplaceHighlightSelector","updateHighlight","FindReplacePlugin","ScrollMargin","ranges","markedIndex","createHighlightHelper","FindHighlightStyleKey","ReplaceHighlightStyleKey","setMarkedIndex","replaceText","replaceAll","isReplaced","resultRange","replaceTextInRange","addRanges","styleKey","Highlight","CSS","isWindowWithHighlight","highlights","set","highlight","delete","HighlightHelperImpl","safeSetRange","foundRanges","resultContainer","resultOffset","pendingRanges","alternativeRange","compareRange","newRanges","sortRanges","fixupHiddenProperties","HiddenPropertyPlugin","undeletableLinkChecker","checker","anchors","checkUndeletable","defaultToolTipCallback","tooltip","onLinkClick","currentLink","onMouse","runWithHyperlink","mouseover","mouseout","matchedLink","open","HyperlinkPlugin","getCropHTML","overlayHTML","ImageEditElementClass","CropOverlay","containerHTML","CropContainer","XS_CROP","YS_CROP","leftOrRight","topOrBottom","rotation","ROTATION","CropHandle","CROP_HANDLE_SIZE","CROP_HANDLE_WIDTH","bgColor","getCropHandleHTMLInternal","getCropHTMLInternal","cropper","crop","basePercentage","deltaValue","fullValue","currentPercentage","Cropper","editInfo","onDragging","base","dx","dy","rotateCoordinate","widthPercent","heightPercent","fullWidth","fullHeight","newLeft","newRight","newTop","newBottom","preserveRatio","disableRotate","disableSideResize","onSelectState","DRAG_ID","IMAGE_EDIT_CLASS","IMAGE_EDIT_CLASS_CARET","IMAGE_EDIT_FORMAT_EVENT","shadowSpan","selectedImage","imageEditInfo","imageHTMLOptions","dndHelpers","clonedImage","lastSrc","wasImageResized","isCropMode","resizers","rotators","croppers","isEditing","applyFormatWithContentModel","ev","isImageSelection","dragend","cleanInfo","mouseDownHandler","mouseUpHandler","keyDownHandler","contentChangedHandler","removeImageEditing","handleBeforeLogicalRootChange","removeImageWrapper","shouldSelectImage","onDropHandler","imageDragged","findEditingImage","imageDropped","draggedIndex","setContentHandler","formatEventHandler","isApiOperation","editingImageModel","isRTL","editingImage","getSelectedImage","previousSelectedImage","EDITING_MARKER","changeState","applyChange","isSameImage","normalizeImageSelection","updateImageEditInfo","startCropMode","startRotateAndResize","startEditing","apiOperation","getSelectedImageMetadata","complete","updateImageDimensionsIfZero","startEditingInternal","clientHeight","getHTMLImageOptions","createImageWrapper","imageClone","checkIfImageWasResized","isMobileOrTable","getDropAndDragHelpers","ResizeHandle","Resizer","updateWrapper","RotateHandle","Rotator","updateRotateHandleState","updateResizeHandleDirection","resizeHandles","filterInnerResizerHandles","updateHandleCursor","viewport","smallImage","isASmallImage","rotator","rotatorHandle","updateRotateHandle","isOperationAllowed","canRegenerateImage","cropImage","editImage","flipImage","rotateImage","ImageEditPlugin","onShowResizeHandle","cornerElements","Xs","Ys","elementData","getResizeHandleHTML","getCornerResizeHTML","sideElements","getSideResizeHTML","handle","createHandleStyle","deltaX","deltaY","horizontalOnly","verticalOnly","shouldPreserveRatio","handles","isSmall","isSideHandle","getRotateIconHTML","namespace","ROTATE_ICON_MARGIN","d","transform","stroke","htmlOptions","rotateHandleBackColor","handleLeft","ROTATE_SIZE","RotateCenter","ROTATE_HANDLE_TOP_NO_SIDE_RESIZE","ROTATE_HANDLE_TOP","ROTATE_GAP","ROTATE_WIDTH","DEFAULT_ROTATE_HANDLE_HEIGHT","newX","newY","angleInRad","minRotateDeg","angleInDeg","DEG_PER_RAD","editorRect","rotateCenter","rotateHandle","isSmallImage","rotateCenterRect","wrapperRect","ROTATOR_HEIGHT","RESIZE_HANDLE_MARGIN","adjustedDistance","MAX_SAFE_INTEGER","angle","rotateGap","rotateTop","RESIZE_HANDLE_SIZE","sw","nw","ne","se","MIN_HEIGHT_WIDTH","RESIZE_IMAGE","contentModelImage","wasResizedOrCropped","imageEditing","initEditInfo","checkEditInfoState","generateDataURL","generatedImageSize","getGeneratedImageSize","targetWidth","targetHeight","canvas","getContext","drawImage","getImageData","ROTATE_KEYS","CROP_KEYS","ROTATE_CROP_KEYS","ALL_KEYS","areSameNumber","compareTo","cloneImage","createImageRotator","createImageResizer","createImageCropper","createWrapper","imageSpan","createShadowSpan","shadowRoot","attachShadow","imageBox","createBorder","resizer","resizeBorder","actualWidth","actualHeight","resizeHandle","imageAndParagraph","nHeight","nWidth","imageWidth","imageHeight","devicePixelRatio","scale","translate","toDataURL","beforeCrop","originalHeight","visibleWidth","visibleHeight","elementClass","useTouch","getEditElements","DragAndDropHelper","LIGHT_MODE_BGCOLOR","DARK_MODE_BGCOLOR","getPx","isFixedNumberValue","numberValue","hypotenuse","flippedHorizontally","flippedVertically","isRotating","wrapperWidth","wrapperHeight","hasBorder","markerBefore","markerAfter","mutatedParagraph","DirectionRad","DirectionOrder","cursor","radIndex","idx","handleRadIndexCalculator","originalDirection","originalIndex","rotatedIndex","rotateHandles","newImageMetadata","contentModelMetadata","getInitialEditInfo","imageMetadata","modelImage","generateImageSize","marginHorizontal","marginVertical","cropLeftPx","cropRightPx","cropTopPx","cropBottomPx","setWrapperSizeDimensions","setFlipped","cropContainer","cropOverlays","cropHandles","setSize","actualDimensions","getActualWrapperDimensions","doubleCheckResize","updateSideHandlesVisibility","TableEditPlugin","PastePlugin","DefaultSanitizers","ShortcutBold","ShortcutItalic","ShortcutUnderline","ShortcutClearFormat","ShortcutUndo","ShortcutUndo2","ShortcutRedo","ShortcutRedoAlt","ShortcutRedoMacOS","ShortcutBullet","ShortcutNumbering","ShortcutIncreaseFont","ShortcutDecreaseFont","ShortcutIndentList","ShortcutOutdentList","ShortcutPlugin","WatermarkPlugin","isModelEmptyFast","MarkdownPlugin","PickerPlugin","TouchPlugin","createFindReplaceContext","moveHighlight","shouldBold","shouldItalic","shouldStrikethrough","shouldCode","lastKeyTyped","disableAllFeatures","handleBackspaceEvent","setFormat","character","textBeforeMarker","lastCharIndex","firstCharIndex","formattedText","divParagraphSanitizer","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","TABLE_SELECTOR","DEFAULT_BORDER_STYLE","validateExcelFragment","excelHandler","trMatch","tableMatch","setupExcelTableHandlers","allowExcelNoBorderTable","isNativeEvent","addParser","setProcessor","replaceChildren","domToModelForSanitizing","pasteSource","getDocumentSource","clipboardItemTypes","processPastedContentFromWordDesktop","processPastedContentWacComponents","processPastedContentFromExcel","PastePropertyNames","GOOGLE_SHEET_NODE_NAME","processPastedContentFromPowerPoint","processPastedContentFromOneNote","parseLink","deprecatedBorderColorParser","tableBorderParser","imageSizeParser","pasteButtonProcessor","blockElementParser","setEventSanitizers","chainSanitizerCallback","CssStyleKey","MsoSpecialFormatRegex","clearListItemStyles","removeNegativeTextIndentParser","bulletElement","msoSpecialFormat","bulletTypeHtml","startNumberOverrideOrBullet","unorderedBulletType","UnorderedBullets","orderedBulletType","getPptListStart","extractPowerPointListInfo","setupListFormat","listMetadata","processAsListItem","WORD_ONLINE_TABLE_TEMP_ELEMENT_CLASSES","BULLET_LIST_STYLE","NUMBER_LIST_STYLE","IMAGE_BORDER","IMAGE_CONTAINER","OUTLINE_ELEMENT","PARAGRAPH","LIST_CONTAINER_ELEMENT_CLASS_NAME","COMMENT_HIGHLIGHT_CLASS","COMMENT_HIGHLIGHT_CLICKED_CLASS","TEMP_ELEMENTS_CLASSES","REMOVE_MARGIN_ELEMENTS","WAC_IDENTIFY_SELECTOR","LIST_ELEMENT_TAGS","LIST_ELEMENT_SELECTOR","wacSubSuperParser","wacElementProcessor","elementTag","shouldClearListContext","wacLiElementProcessor","currentListLevels","lastblock","ctx","extractWordListMetadata","updateStartOverride","newLevels","wacListItemParser","wacListLevelParser","wacCommentParser","wacContainerParser","FORMATING_REGEX","STYLE_TAG","htmlString","metadataMap","styleContent","extractStyleTagsFromHtml","indexAt","indexCurlyEnd","indexCurlyStart","metadataName","dataName","record","formatedKey","formatedValue","getStyleMetadata","wordDesktopElementProcessor","adjustPercentileLineHeight","listLevelParser","wordContainerParser","wordTableParser","metadataKey","getStyles","processWordList","processWordComments","MSO_COMMENT_ANCHOR_HREF_REGEX","MSO_LIST","MSO_LIST_IGNORE","TEMPLATE_VALUE_REGEX","wordListPaddingParser","wordKnownLevels","wordListStyle","lNumber","wordLevel","wordList","templateFinal","templateType","templateValue","getBulletFromMetadata","listFormatMetadata","isBulletElement","getBulletElement","getLastNotEmptyBlock","NaN","knownLevel","setStartNumber","A","ensureOneNoteListContext","cmContext","oneNoteListContext","processOrderedList","processUnorderedList","processListItem","typeOfList","removeStartNumberOverride","PERCENTAGE_REGEX","parsedLineHeight","dColor","AbsoluteUnitRegex","maxImageSize","SUPPORTED_PROTOCOLS","INVALID_LINKS_REGEX","protocol","_context","ElementBorderKeys","styleSet","PROG_ID_NAME","EXCEL_DESKTOP_ATTRIBUTE_NAME","documentContainWacElements","props","getSourceFunctions","isWordDesktopDocument","isExcelDesktopDocument","isExcelOnlineDocument","isPowerPointDesktopDocument","isGoogleSheetDocument","shouldConvertToSingleImage","isExcelNotNativeEvent","isOneNoteDesktopDocument","param","func","WORD_ATTRIBUTE_NAME","WORD_ATTRIBUTE_VALUE","shouldConvertSingleImage","processTextNodesRecursively","TEXT_NODE","newCallback","finalCb","og","removeMargin","listDepth","additionalParsers","beforeProcessingChildren","nonListElementParser","keyInput","replaceQueryString","potentialSegments","getQueryString","closePicker","onClosePicker","PickerHelperImpl","lastQueryString","onInitialize","onDispose","onSuggestingInput","onSuggestingKeyDown","onInput","isIncrement","onSelectionChanged","hasCtrl","onSelect","newQueryString","oldQueryString","onQueryStringChanged","charBeforeTrigger","onTrigger","splittedSegmentResult","createElementNS","datasetName","childElement","MOUSE_EVENT_INFO_DESKTOP","MOUSEDOWN","MOUSEMOVE","MOUSEUP","getPageXY","MOUSE_EVENT_INFO_MOBILE","targetTouches","touch","onSubmit","forceMobile","initX","initY","initValue","addDocumentEvents","dndMouse","removeDocumentEvents","onDragEnd","defaultShortcuts","shortcuts","cacheGetCommand","command","onClick","matchOS","matchShortcut","shortcutKey","ctrlOrMeta","modifierKey","Keys","setShortcutIndentationCommand","anchorContainerSelector","onTableEditorCreated","disableFeatures","onMouseMoveDisposer","tableRectMap","tableEditor","onMouseOut","relatedTargetNode","currentTargetNode","isOwnedElement","setTableEditor","editorWindow","buttons","ensureTableRects","scrollX","scrollY","currentTable","invalidateTableRects","disposeTableEditor","TableEditor","currentTarget","defaultTableSelector","TOP_OR_SIDE","anchorContainer","horizontalInserter","verticalInserter","horizontalResizer","verticalResizer","tableResizer","tableMover","tableColumnSelector","tableRowSelector","onEditorCreated","featureType","getOnMouseOut","onFinishEditing","isCurrentlyEditing","onStartTableResize","onStartResize","onStartCellResize","disposeTableResizer","onStartTableMove","onBeforeEditTable","disposeTableInserter","disposeCellResizers","disposeTableSelector","onEndTableMove","disposeHandler","disposeTableMover","onAfterInsert","relatedTarget","setEditorFeatures","tableRect","topOrSide","topOrSideBinary","tdRect","lessThanBottom","lessThanRight","moreThanLeft","isOnRightHalf","isFeatureDisabled","setInserterTd","tdAbove","tdAboveRect","isTdNotAboveMerged","setResizingTd","setSelectorRowColumn","disableSelector","disableMovement","createTableMover","createTableResizer","createCellResizer","isHorizontal","inserter","newInserter","createTableInserter","isRowSelector","createTableRowColumnSelector","disposeTableEditFeature","HORIZONTAL_RESIZER_ID","VERTICAL_RESIZER_ID","onStart","onEnd","createElementData","setPosition","setHorizontalPosition","setVerticalPosition","featureHandler","CellResizer","onDraggingHorizontal","onDraggingVertical","columnIndex","nextColumnIndex","cmTable","getCMTableFromTable","anchorColumn","nextColumn","anchorRow","anchorRowHeight","allWidths","anchorChange","nextAnchorChange","lastTd","lastWidth","CELL_RESIZER_WIDTH","HORIZONTAL_INSERTER_ID","VERTICAL_INSERTER_ID","onBeforeInsert","onAfterInserted","viewPort","isOutsideTop","inserterColor","getInsertElementData","TableInsertHandler","insertTd","TABLE_MOVER_LENGTH","TABLE_MOVER_ID","TABLE_MOVER_STYLE_KEY","onFinishDragging","visibleViewport","containerRect","isTableTopVisible","setDivPosition","TableMoverFeature","setTableMoverCursor","trect","initialSelection","clientY","clientX","getNodePositionFromEvent","selectWholeTable","ip","oldTable","finalTable","TABLE_RESIZER_LENGTH","TABLE_RESIZER_ID","isTableBottomVisible","TableResizer","hideResizer","originalRect","originalHeights","originalWidths","ratioX","ratioY","shouldResizeX","shouldResizeY","visibility","containerDiv","cellRect","cellLength","maxSelectorSize","MIN_DISTANCE_FROM_BOUNDARY","SELECTOR_SIZE","centerOffset","cellDiv","TableRowColumnSelectorHandler","isRow","getCurrentIndexFromMouse","columnNumber","rowNumber","PUNCTUATION_MATCHING_REGEX","SPACE_MATCHING_REGEX","isDblClicked","isTouchPenPointerEvent","targetWindow","setTimeout","caretPosition","nodeTextContent","charAtSelection","findWordBoundaries","leftCursorWordLength","rightCursorWordLength","movingOffset","newOffsetPosition","rightSideOfChar","wordStart","wordEnd","caretPositionFromPoint","offsetNode","caretRangeFromPoint","elementFromPoint","WATERMARK_CONTENT_KEY","styleMap","watermark","isShowing","darkTextColor","showHide","update","applyWatermarkStyle","hide","show","additionalPlugins","createEditor","extendStatics","setPrototypeOf","__proto__","__extends","TypeError","create","__assign","__rest","getOwnPropertySymbols","propertyIsEnumerable","__decorate","decorators","desc","Reflect","decorate","__param","paramIndex","__esDecorate","ctor","descriptorIn","contextIn","initializers","extraInitializers","accept","descriptor","access","addInitializer","init","__runInitializers","thisArg","useValue","__propKey","__setFunctionName","description","configurable","__metadata","metadataValue","__awaiter","_arguments","P","generator","reject","fulfilled","rejected","__generator","sent","trys","ops","verb","Symbol","op","__createBinding","o","k2","__esModule","writable","enumerable","__exportStar","__values","__read","ar","error","__spread","__spreadArrays","il","jl","__spreadArray","pack","__await","__asyncGenerator","asyncIterator","resume","fulfill","settle","__asyncDelegator","__asyncValues","__makeTemplateObject","cooked","__setModuleDefault","__importStar","mod","__importDefault","__classPrivateFieldGet","receiver","__classPrivateFieldSet","__classPrivateFieldIn","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","prop","toStringTag","__webpack_exports__"],"sourceRoot":""}