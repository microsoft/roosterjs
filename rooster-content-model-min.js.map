{"version":3,"file":"rooster-content-model-min.js","mappings":"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","sources":["webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/index.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/block/setModelAlignment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/block/setModelDirection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/block/setModelIndentation.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/block/toggleModelBlockQuote.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/common/clearModelFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/common/retrieveModelFormatState.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/common/wrapBlock.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/domUtils/readFile.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/entity/insertEntityModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/image/applyImageBorderFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/list/findListItemsInSameThread.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/list/setListType.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/selection/adjustSegmentSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/selection/adjustWordSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/selection/collapseTableSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/alignTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/alignTableCell.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/canMergeCells.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/createTableStructure.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/deleteTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/deleteTableColumn.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/deleteTableRow.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/ensureFocusableParagraphForTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/getSelectedCells.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/insertTableColumn.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/insertTableRow.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/mergeTableCells.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/mergeTableColumn.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/mergeTableRow.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/splitTableCellHorizontally.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/modelApi/table/splitTableCellVertically.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/block/setAlignment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/block/setDirection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/block/setHeadingLevel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/block/setIndentation.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/block/setParagraphMargin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/block/setSpacing.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/block/toggleBlockQuote.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/entity/insertEntity.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/format/clearFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/format/getFormatState.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/image/adjustImageSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/image/changeImage.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/image/insertImage.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/image/setImageAltText.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/image/setImageBorder.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/image/setImageBoxShadow.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/link/adjustLinkSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/link/insertLink.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/link/removeLink.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/list/setListStartNumber.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/list/setListStyle.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/list/toggleBullet.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/list/toggleNumbering.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/applySegmentFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/changeCapitalization.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/changeFontSize.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/setBackgroundColor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/setFontName.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/setFontSize.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/setTextColor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/toggleBold.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/toggleCode.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/toggleItalic.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/toggleStrikethrough.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/toggleSubscript.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/toggleSuperscript.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/segment/toggleUnderline.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/selection/hasSelectionInBlock.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/selection/hasSelectionInBlockGroup.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/selection/hasSelectionInSegment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/table/applyTableBorderFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/table/editTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/table/formatTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/table/insertTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/table/setTableCellShade.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/utils/formatImageWithContentModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/utils/formatParagraphWithContentModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-api/lib/publicApi/utils/formatSegmentWithContentModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/constants/BulletListType.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/constants/ChangeSource.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/constants/NumberingListType.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/constants/TableBorderFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/createContentModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/createEditorContext.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/focus.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/formatContentModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/getDOMSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/getVisibleViewport.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/hasFocus.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/setContentModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/setDOMSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/coreApi/switchShadowEdit.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/ContentModelCachePlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/ContentModelCopyPastePlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/ContentModelFormatPlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/DOMEventPlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/EntityPlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/LifecyclePlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/SelectionPlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/UndoPlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/createStandaloneEditorCorePlugins.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/utils/addRangeToSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/utils/applyDefaultFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/utils/applyPendingFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/utils/areSameSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/utils/contentModelDomIndexer.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/corePlugin/utils/findAllEntities.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/editor/DarkColorHandlerImpl.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/editor/UndoSnapshotsServiceImpl.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/editor/createStandaloneEditorCore.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/editor/createStandaloneEditorDefaultSettings.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/editor/standaloneCoreApiMap.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/index.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/metadata/definitionCreators.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/metadata/updateImageMetadata.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/metadata/updateListMetadata.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/metadata/updateTableCellMetadata.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/metadata/updateTableMetadata.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/modelApi/edit/deleteExpandedSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/modelApi/edit/deleteSingleChar.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/override/tablePreProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/domUtils/borderValues.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/domUtils/eventUtils.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/domUtils/stringUtil.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/domUtils/tableCellUtils.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/model/cloneModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/model/createModelFromHtml.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/model/getClosestAncestorBlockGroupIndex.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/model/isBlockGroupOfType.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/model/isBold.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/model/mergeModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/model/paste.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/selection/collectSelections.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/selection/deleteBlock.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/selection/deleteSegment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/selection/deleteSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/selection/getSelectionRootNode.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/selection/iterateSelections.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/selection/setSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/table/applyTableFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/table/normalizeTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-core/lib/publicApi/table/setTableCellBackgroundColor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/config/defaultContentModelFormatMap.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/config/defaultHTMLStyleMap.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/context/createDomToModelContext.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/context/defaultProcessors.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/domToContentModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/blockProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/brProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/childProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/codeProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/delimiterProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/elementProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/entityProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/fontProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/formatContainerProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/generalProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/headingProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/hrProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/imageProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/knownElementProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/linkProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/listItemProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/listProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/pProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/tableProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/processors/textProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/utils/addSelectionMarker.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/utils/areSameFormats.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/utils/getBoundingClientRect.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/utils/getDefaultStyle.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/utils/getRegularSelectionOffsets.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/utils/isBlockElement.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/utils/parseFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domToModel/utils/stackFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/entityUtils.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/getObjectKeys.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/isElementOfType.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/isNodeOfType.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/metadata/updateMetadata.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/metadata/validate.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/moveChildNodes.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/toArray.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/unwrap.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/domUtils/wrap.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/block/directionFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/block/displayFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/block/htmlAlignFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/block/lineHeightFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/block/marginFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/block/paddingFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/block/textAlignFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/block/whiteSpaceFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/backgroundColorFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/borderBoxFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/borderFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/boxShadowFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/datasetFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/floatFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/idFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/sizeFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/verticalAlignFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/common/wordBreakFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/defaultFormatHandlers.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/entity/entityFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/list/listItemThreadFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/list/listLevelThreadFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/list/listStyleFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/boldFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/fontFamilyFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/fontSizeFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/italicFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/letterSpacingFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/linkFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/strikeFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/superOrSubScriptFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/textColorFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/segment/underlineFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/table/tableLayoutFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/table/tableSpacingFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/table/textColorOnTableCellFormatHandler.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/utils/color.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/utils/dir.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/formatHandlers/utils/parseValueWithUnit.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/index.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/block/setParagraphNotImplicit.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/addBlock.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/addDecorators.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/addSegment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/applySegmentFormatToElement.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/ensureParagraph.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/hasSpacesOnly.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/isEmpty.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/isGeneralSegment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/isWhiteSpacePreserved.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/normalizeContentModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/normalizeParagraph.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/normalizeSegment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/common/unwrapBlock.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createBr.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createContentModelDocument.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createDivider.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createEntity.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createFormatContainer.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createGeneralBlock.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createGeneralSegment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createImage.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createListItem.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createListLevel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createParagraph.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createParagraphDecorator.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createSelectionMarker.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createTableCell.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelApi/creators/createText.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/contentModelToDom.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/context/createModelToDomContext.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/context/defaultContentModelHandlers.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleBlock.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleBlockGroupChildren.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleBr.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleDivider.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleEntity.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleFormatContainer.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleGeneralModel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleImage.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleList.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleListItem.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleParagraph.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleSegment.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleSegmentDecorator.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleTable.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/handlers/handleText.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/optimizers/mergeNode.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/optimizers/optimize.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/optimizers/removeUnnecessarySpan.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/utils/applyFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/utils/applyMetadata.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/utils/handleSegmentCommon.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/utils/reuseCachedElement.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-dom/lib/modelToDom/utils/stackFormat.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/addUndoSnapshot.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/attachDomEvent.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/coreApiMap.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/ensureTypeInContainer.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/getContent.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/getStyleBasedFormatState.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/insertNode.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/restoreUndoSnapshot.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/setContent.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/transformColor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/coreApi/triggerEvent.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/corePlugins/EditPlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/corePlugins/EventTypeTranslatePlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/corePlugins/NormalizeTablePlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/corePlugins/createCorePlugins.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/editor/ContentModelEditor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/editor/createEditorCore.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/editor/isContentModelEditor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/editor/utils/buildRangeEx.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/editor/utils/getPendableFormatState.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/editor/utils/selectionConverter.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-editor/lib/index.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/edit/ContentModelEditPlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteAllSegmentBefore.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteCollapsedSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/edit/deleteSteps/deleteWordSelection.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/edit/handleKeyboardEventCommon.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/edit/keyboardDelete.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/edit/keyboardInput.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/edit/utils/getLeafSiblingBlock.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/entityDelimiter/EntityDelimiterPlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/index.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/ContentModelPastePlugin.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/Excel/processPastedContentFromExcel.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/PowerPoint/processPastedContentFromPowerPoint.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/WacComponents/processPastedContentWacComponents.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/WordDesktop/processPastedContentFromWordDesktop.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/WordDesktop/processWordComments.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/WordDesktop/processWordLists.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/documentContainWacElements.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/getPasteSource.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isExcelDesktopDocument.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isExcelOnlineDocument.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isGoogleSheetDocument.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isPowerPointDesktopDocument.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/isWordDesktopDocument.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/pasteSourceValidations/shouldConvertToSingleImage.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/utils/addParser.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/utils/deprecatedColorParser.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/utils/getStyles.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/utils/linkParser.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model-plugins/lib/paste/utils/setProcessor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model/lib/createContentModelEditor.ts","webpack://roosterjsContentModel/./packages-content-model/roosterjs-content-model/lib/index.ts","webpack://roosterjsContentModel/external var \"roosterjs\"","webpack://roosterjsContentModel/./node_modules/tslib/tslib.es6.mjs","webpack://roosterjsContentModel/webpack/bootstrap","webpack://roosterjsContentModel/webpack/runtime/define property getters","webpack://roosterjsContentModel/webpack/runtime/hasOwnProperty shorthand","webpack://roosterjsContentModel/webpack/runtime/make namespace object","webpack://roosterjsContentModel/webpack/startup"],"sourcesContent":["export { default as insertTable } from './publicApi/table/insertTable';\nexport { default as formatTable } from './publicApi/table/formatTable';\nexport { default as setTableCellShade } from './publicApi/table/setTableCellShade';\nexport { default as editTable } from './publicApi/table/editTable';\nexport { default as applyTableBorderFormat } from './publicApi/table/applyTableBorderFormat';\nexport { default as toggleBullet } from './publicApi/list/toggleBullet';\nexport { default as toggleNumbering } from './publicApi/list/toggleNumbering';\nexport { default as toggleBold } from './publicApi/segment/toggleBold';\nexport { default as toggleItalic } from './publicApi/segment/toggleItalic';\nexport { default as toggleUnderline } from './publicApi/segment/toggleUnderline';\nexport { default as toggleStrikethrough } from './publicApi/segment/toggleStrikethrough';\nexport { default as toggleSubscript } from './publicApi/segment/toggleSubscript';\nexport { default as toggleSuperscript } from './publicApi/segment/toggleSuperscript';\nexport { default as setBackgroundColor } from './publicApi/segment/setBackgroundColor';\nexport { default as setFontName } from './publicApi/segment/setFontName';\nexport { default as setFontSize } from './publicApi/segment/setFontSize';\nexport { default as setTextColor } from './publicApi/segment/setTextColor';\nexport { default as changeFontSize } from './publicApi/segment/changeFontSize';\nexport { default as applySegmentFormat } from './publicApi/segment/applySegmentFormat';\nexport { default as changeCapitalization } from './publicApi/segment/changeCapitalization';\nexport { default as insertImage } from './publicApi/image/insertImage';\nexport { default as setListStyle } from './publicApi/list/setListStyle';\nexport { default as setListStartNumber } from './publicApi/list/setListStartNumber';\nexport { default as hasSelectionInBlock } from './publicApi/selection/hasSelectionInBlock';\nexport { default as hasSelectionInSegment } from './publicApi/selection/hasSelectionInSegment';\nexport { default as hasSelectionInBlockGroup } from './publicApi/selection/hasSelectionInBlockGroup';\nexport { default as setIndentation } from './publicApi/block/setIndentation';\nexport { default as setAlignment } from './publicApi/block/setAlignment';\nexport { default as setDirection } from './publicApi/block/setDirection';\nexport { default as setHeadingLevel } from './publicApi/block/setHeadingLevel';\nexport { default as toggleBlockQuote } from './publicApi/block/toggleBlockQuote';\nexport { default as setSpacing } from './publicApi/block/setSpacing';\nexport { default as setImageBorder } from './publicApi/image/setImageBorder';\nexport { default as setImageBoxShadow } from './publicApi/image/setImageBoxShadow';\nexport { default as changeImage } from './publicApi/image/changeImage';\nexport { default as getFormatState } from './publicApi/format/getFormatState';\nexport { default as clearFormat } from './publicApi/format/clearFormat';\nexport { default as insertLink } from './publicApi/link/insertLink';\nexport { default as removeLink } from './publicApi/link/removeLink';\nexport { default as adjustLinkSelection } from './publicApi/link/adjustLinkSelection';\nexport { default as setImageAltText } from './publicApi/image/setImageAltText';\nexport { default as adjustImageSelection } from './publicApi/image/adjustImageSelection';\nexport { default as setParagraphMargin } from './publicApi/block/setParagraphMargin';\nexport { default as toggleCode } from './publicApi/segment/toggleCode';\nexport { default as insertEntity } from './publicApi/entity/insertEntity';\n","import { alignTable } from '../table/alignTable';\nimport { getOperationalBlocks } from 'roosterjs-content-model-core';\nimport type {\n    ContentModelDocument,\n    ContentModelListItem,\n    TableAlignOperation,\n} from 'roosterjs-content-model-types';\n\nconst ResultMap: Record<\n    'left' | 'center' | 'right',\n    Record<'ltr' | 'rtl', 'start' | 'center' | 'end'>\n> = {\n    left: {\n        ltr: 'start',\n        rtl: 'end',\n    },\n    center: {\n        ltr: 'center',\n        rtl: 'center',\n    },\n    right: {\n        ltr: 'end',\n        rtl: 'start',\n    },\n};\n\nconst TableAlignMap: Record<\n    'left' | 'center' | 'right',\n    Record<'ltr' | 'rtl', TableAlignOperation>\n> = {\n    left: {\n        ltr: 'alignLeft',\n        rtl: 'alignRight',\n    },\n    center: {\n        ltr: 'alignCenter',\n        rtl: 'alignCenter',\n    },\n    right: {\n        ltr: 'alignRight',\n        rtl: 'alignLeft',\n    },\n};\n\n/**\n * @internal\n */\nexport function setModelAlignment(\n    model: ContentModelDocument,\n    alignment: 'left' | 'center' | 'right'\n) {\n    const paragraphOrListItemOrTable = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        ['TableCell']\n    );\n\n    paragraphOrListItemOrTable.forEach(({ block }) => {\n        const newAligment = ResultMap[alignment][block.format.direction == 'rtl' ? 'rtl' : 'ltr'];\n        if (block.blockType === 'Table') {\n            alignTable(\n                block,\n                TableAlignMap[alignment][block.format.direction == 'rtl' ? 'rtl' : 'ltr']\n            );\n        } else if (block) {\n            const { format } = block;\n            format.textAlign = newAligment;\n        }\n    });\n\n    return paragraphOrListItemOrTable.length > 0;\n}\n","import { findListItemsInSameThread } from '../list/findListItemsInSameThread';\nimport { getOperationalBlocks, isBlockGroupOfType } from 'roosterjs-content-model-core';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelDocument,\n    ContentModelListItem,\n    MarginFormat,\n    PaddingFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function setModelDirection(model: ContentModelDocument, direction: 'ltr' | 'rtl') {\n    const paragraphOrListItemOrTable = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        ['TableCell']\n    );\n\n    paragraphOrListItemOrTable.forEach(({ block }) => {\n        if (isBlockGroupOfType<ContentModelListItem>(block, 'ListItem')) {\n            const items = findListItemsInSameThread(model, block);\n\n            items.forEach(item => {\n                item.levels.forEach(level => {\n                    level.format.direction = direction;\n                });\n\n                item.blocks.forEach(block => internalSetDirection(block.format, direction));\n            });\n        } else if (block) {\n            internalSetDirection(block.format, direction);\n        }\n    });\n\n    return paragraphOrListItemOrTable.length > 0;\n}\n\nfunction internalSetDirection(format: ContentModelBlockFormat, direction: 'ltr' | 'rtl') {\n    const wasRtl = format.direction == 'rtl';\n    const isRtl = direction == 'rtl';\n\n    if (wasRtl != isRtl) {\n        format.direction = direction;\n\n        // Adjust margin when change direction\n        // TODO: make margin and padding direction-aware, like what we did for textAlign. So no need to adjust them here\n        // TODO: Do we also need to handle border here?\n        const marginLeft = format.marginLeft;\n        const paddingLeft = format.paddingLeft;\n\n        setProperty(format, 'marginLeft', format.marginRight);\n        setProperty(format, 'marginRight', marginLeft);\n        setProperty(format, 'paddingLeft', format.paddingRight);\n        setProperty(format, 'paddingRight', paddingLeft);\n    }\n}\n\nfunction setProperty(\n    format: MarginFormat & PaddingFormat,\n    key: keyof (MarginFormat & PaddingFormat),\n    value: string | undefined\n) {\n    if (value) {\n        format[key] = value;\n    } else {\n        delete format[key];\n    }\n}\n","import { createListLevel, parseValueWithUnit } from 'roosterjs-content-model-dom';\nimport { getOperationalBlocks, isBlockGroupOfType } from 'roosterjs-content-model-core';\nimport type {\n    ContentModelDocument,\n    ContentModelListItem,\n    ContentModelListLevel,\n} from 'roosterjs-content-model-types';\n\nconst IndentStepInPixel = 40;\n\n/**\n * @internal\n */\nexport function setModelIndentation(\n    model: ContentModelDocument,\n    indentation: 'indent' | 'outdent',\n    length: number = IndentStepInPixel\n) {\n    const paragraphOrListItem = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        ['TableCell']\n    );\n    const isIndent = indentation == 'indent';\n\n    paragraphOrListItem.forEach(({ block }) => {\n        if (isBlockGroupOfType<ContentModelListItem>(block, 'ListItem')) {\n            if (isIndent) {\n                const lastLevel = block.levels[block.levels.length - 1];\n                const newLevel: ContentModelListLevel = createListLevel(\n                    lastLevel?.listType || 'UL',\n                    lastLevel?.format\n                );\n\n                // New level is totally new, no need to have these attributes for now\n                delete newLevel.format.startNumberOverride;\n\n                block.levels.push(newLevel);\n            } else {\n                block.levels.pop();\n            }\n        } else if (block) {\n            const { format } = block;\n            const { marginLeft, marginRight, direction } = format;\n            const isRtl = direction == 'rtl';\n            const originalValue = parseValueWithUnit(isRtl ? marginRight : marginLeft);\n            let newValue = (isIndent ? Math.ceil : Math.floor)(originalValue / length) * length;\n\n            if (newValue == originalValue) {\n                newValue = Math.max(newValue + length * (isIndent ? 1 : -1), 0);\n            }\n\n            if (isRtl) {\n                format.marginRight = newValue + 'px';\n            } else {\n                format.marginLeft = newValue + 'px';\n            }\n        }\n    });\n\n    return paragraphOrListItem.length > 0;\n}\n","import { areSameFormats, createFormatContainer, unwrapBlock } from 'roosterjs-content-model-dom';\nimport { getOperationalBlocks, isBlockGroupOfType } from 'roosterjs-content-model-core';\nimport { wrapBlockStep1, wrapBlockStep2 } from '../common/wrapBlock';\nimport type { OperationalBlocks } from 'roosterjs-content-model-core';\nimport type { WrapBlockStep1Result } from '../common/wrapBlock';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelFormatContainer,\n    ContentModelFormatContainerFormat,\n    ContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function toggleModelBlockQuote(\n    model: ContentModelDocument,\n    format: ContentModelFormatContainerFormat\n): boolean {\n    const paragraphOfQuote = getOperationalBlocks<\n        ContentModelFormatContainer | ContentModelListItem\n    >(model, ['FormatContainer', 'ListItem'], ['TableCell'], true /*deepFirst*/);\n\n    if (areAllBlockQuotes(paragraphOfQuote)) {\n        // All selections are already in quote, we need to unquote them\n        paragraphOfQuote.forEach(({ block, parent }) => {\n            unwrapBlock(parent, block);\n        });\n    } else {\n        const step1Results: WrapBlockStep1Result<ContentModelFormatContainer>[] = [];\n        const creator = () => createFormatContainer('blockquote', format);\n        const canMerge = (\n            target: ContentModelBlock,\n            current?: ContentModelFormatContainer\n        ): target is ContentModelFormatContainer =>\n            canMergeQuote(target, current?.format || format);\n\n        paragraphOfQuote.forEach(({ block, parent }) => {\n            if (isQuote(block)) {\n                // Already in quote, no op\n            } else {\n                wrapBlockStep1(step1Results, parent, block, creator, canMerge);\n            }\n        });\n\n        wrapBlockStep2(step1Results, canMerge);\n    }\n\n    return paragraphOfQuote.length > 0;\n}\n\nfunction canMergeQuote(\n    target: ContentModelBlock,\n    format: ContentModelFormatContainerFormat\n): target is ContentModelFormatContainer {\n    return isQuote(target) && areSameFormats(format, target.format);\n}\n\nfunction isQuote(block: ContentModelBlock): block is ContentModelFormatContainer {\n    return (\n        isBlockGroupOfType<ContentModelFormatContainer>(block, 'FormatContainer') &&\n        block.tagName == 'blockquote'\n    );\n}\n\nfunction areAllBlockQuotes(\n    blockAndParents: OperationalBlocks<ContentModelFormatContainer | ContentModelListItem>[]\n): blockAndParents is { block: ContentModelFormatContainer; parent: ContentModelBlockGroup }[] {\n    return blockAndParents.every(blockAndParent => isQuote(blockAndParent.block));\n}\n","import { adjustWordSelection } from '../selection/adjustWordSelection';\nimport { createFormatContainer } from 'roosterjs-content-model-dom';\nimport {\n    iterateSelections,\n    applyTableFormat,\n    getClosestAncestorBlockGroupIndex,\n    updateTableCellMetadata,\n    updateTableMetadata,\n} from 'roosterjs-content-model-core';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelFormatContainer,\n    ContentModelListItem,\n    ContentModelSegment,\n    ContentModelSegmentFormat,\n    ContentModelTable,\n    Selectable,\n    TableSelectionContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function clearModelFormat(\n    model: ContentModelDocument,\n    blocksToClear: [ContentModelBlockGroup[], ContentModelBlock][],\n    segmentsToClear: ContentModelSegment[],\n    tablesToClear: [ContentModelTable, boolean][]\n) {\n    iterateSelections(\n        model,\n        (path, tableContext, block, segments) => {\n            if (segments) {\n                segmentsToClear.push(...segments);\n            }\n\n            if (block) {\n                blocksToClear.push([path, block]);\n            } else if (tableContext) {\n                clearTableCellFormat(tableContext, tablesToClear);\n            }\n        },\n        {\n            // When there is a default format to apply, we know how to handle segment format under list.\n            // So no need to clear format of list number.\n            // Otherwise, we will clear all format of selected text. And since they are under LI tag, we\n            // also need to clear the format of LI (format holder) so that the format is really cleared\n            includeListFormatHolder: model.format ? 'never' : 'anySegment',\n        }\n    );\n\n    const marker = segmentsToClear[0];\n\n    // 2. If selection is collapsed, add selection to whole word to clear if any\n    if (\n        blocksToClear.length == 1 &&\n        isOnlySelectionMarkerSelected(blocksToClear[0][1]) &&\n        blocksToClear.length == 1\n    ) {\n        segmentsToClear.splice(0, segmentsToClear.length, ...adjustWordSelection(model, marker));\n        clearListFormat(blocksToClear[0][0]);\n    } else if (blocksToClear.length > 1 || blocksToClear.some(x => isWholeBlockSelected(x[1]))) {\n        // 2. If a full block or multiple blocks are selected, clear block format\n        for (let i = blocksToClear.length - 1; i >= 0; i--) {\n            const [path, block] = blocksToClear[i];\n\n            clearBlockFormat(path, block);\n            clearListFormat(path);\n            clearContainerFormat(path, block);\n        }\n    }\n\n    // 3. Finally clear format for segments\n    clearSegmentsFormat(segmentsToClear, model.format);\n\n    // 4. Clear format for table if any\n    createTablesFormat(tablesToClear);\n}\n\nfunction createTablesFormat(tablesToClear: [ContentModelTable, boolean][]) {\n    tablesToClear.forEach(x => {\n        const [table, isWholeTableSelected] = x;\n        if (isWholeTableSelected) {\n            table.format = {\n                useBorderBox: table.format.useBorderBox,\n                borderCollapse: table.format.borderCollapse,\n            };\n            updateTableMetadata(table, () => null);\n        }\n\n        applyTableFormat(table, undefined /*newFormat*/, true);\n    });\n}\n\nfunction clearSegmentsFormat(\n    segmentsToClear: ContentModelSegment[],\n    defaultSegmentFormat: ContentModelSegmentFormat | undefined\n) {\n    segmentsToClear.forEach(x => {\n        x.format = { ...(defaultSegmentFormat || {}) };\n\n        if (x.link) {\n            delete x.link.format.textColor;\n        }\n\n        delete x.code;\n    });\n}\n\nfunction clearTableCellFormat(\n    tableContext: TableSelectionContext | undefined,\n    tablesToClear: [ContentModelTable, boolean][]\n) {\n    if (tableContext) {\n        const { table, colIndex, rowIndex, isWholeTableSelected } = tableContext;\n        const cell = table.rows[rowIndex].cells[colIndex];\n\n        if (cell.isSelected) {\n            updateTableCellMetadata(cell, () => null);\n            cell.isHeader = false;\n            cell.format = {\n                useBorderBox: cell.format.useBorderBox,\n            };\n        }\n\n        if (!tablesToClear.find(x => x[0] == table)) {\n            tablesToClear.push([table, isWholeTableSelected]);\n        }\n    }\n}\n\nfunction clearContainerFormat(path: ContentModelBlockGroup[], block: ContentModelBlock) {\n    const containerPathIndex = getClosestAncestorBlockGroupIndex(\n        path,\n        ['FormatContainer'],\n        ['TableCell']\n    );\n\n    if (containerPathIndex >= 0 && containerPathIndex < path.length - 1) {\n        const container = path[containerPathIndex] as ContentModelFormatContainer;\n        const containerIndex = path[containerPathIndex + 1].blocks.indexOf(container);\n        const blockIndex = container.blocks.indexOf(block);\n\n        if (blockIndex >= 0 && containerIndex >= 0) {\n            const newContainer = createFormatContainer(container.tagName, container.format);\n\n            container.blocks.splice(blockIndex, 1);\n            newContainer.blocks = container.blocks.splice(blockIndex);\n\n            path[containerPathIndex + 1].blocks.splice(containerIndex + 1, 0, block, newContainer);\n        }\n    }\n}\n\nfunction clearListFormat(path: ContentModelBlockGroup[]) {\n    const listItem = path[getClosestAncestorBlockGroupIndex(path, ['ListItem'], ['TableCell'])] as\n        | ContentModelListItem\n        | undefined;\n\n    if (listItem) {\n        listItem.levels = [];\n    }\n}\n\nfunction clearBlockFormat(path: ContentModelBlockGroup[], block: ContentModelBlock) {\n    if (block.blockType == 'Divider') {\n        const index = path[0].blocks.indexOf(block);\n\n        if (index >= 0) {\n            path[0].blocks.splice(index, 1);\n        }\n    } else if (block.blockType == 'Paragraph') {\n        block.format = {};\n        delete block.decorator;\n    }\n}\n\nfunction isOnlySelectionMarkerSelected(block: ContentModelBlock) {\n    const segments = block.blockType == 'Paragraph' ? block.segments.filter(x => x.isSelected) : [];\n\n    return segments.length == 1 && segments[0].segmentType == 'SelectionMarker';\n}\n\nfunction isWholeBlockSelected(block: ContentModelBlock) {\n    return (\n        (block as Selectable).isSelected ||\n        (block.blockType == 'Paragraph' && block.segments.every(x => x.isSelected))\n    );\n}\n","import {\n    extractBorderValues,\n    getClosestAncestorBlockGroupIndex,\n    isBold,\n    iterateSelections,\n    updateTableMetadata,\n} from 'roosterjs-content-model-core';\nimport type {\n    ContentModelFormatState,\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelFormatContainer,\n    ContentModelImage,\n    ContentModelListItem,\n    ContentModelParagraph,\n    ContentModelSegmentFormat,\n    TableSelectionContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function retrieveModelFormatState(\n    model: ContentModelDocument,\n    pendingFormat: ContentModelSegmentFormat | null,\n    formatState: ContentModelFormatState\n) {\n    let firstTableContext: TableSelectionContext | undefined;\n    let firstBlock: ContentModelBlock | undefined;\n    let isFirst = true;\n    let isFirstImage = true;\n    let isFirstSegment = true;\n\n    iterateSelections(\n        model,\n        (path, tableContext, block, segments) => {\n            // Structure formats\n            retrieveStructureFormat(formatState, path, isFirst);\n\n            // Multiple line format\n            if (block) {\n                if (firstBlock) {\n                    formatState.isMultilineSelection = true;\n                } else {\n                    firstBlock = block;\n                }\n            }\n\n            if (block?.blockType == 'Paragraph') {\n                // Paragraph formats\n                retrieveParagraphFormat(formatState, block, isFirst);\n\n                // Segment formats\n                segments?.forEach(segment => {\n                    if (isFirstSegment || segment.segmentType != 'SelectionMarker') {\n                        const modelFormat = Object.assign({}, model.format);\n                        delete modelFormat?.italic;\n                        delete modelFormat?.underline;\n                        delete modelFormat?.fontWeight;\n\n                        retrieveSegmentFormat(\n                            formatState,\n                            isFirst,\n                            Object.assign(\n                                {},\n                                modelFormat,\n                                block.format,\n                                block.decorator?.format,\n                                segment.format,\n                                segment.code?.format,\n                                segment.link?.format,\n                                pendingFormat\n                            )\n                        );\n\n                        mergeValue(formatState, 'isCodeInline', !!segment?.code, isFirst);\n                    }\n\n                    // We only care the format of selection marker when it is the first selected segment. This is because when selection marker\n                    // is after some other selected segments, it mostly like appears at the beginning of a seconde line when the whole first line\n                    // is selected (e.g. triple-click on a line) then the second selection marker doesn't contain a correct format, so we need to\n                    // ignore it\n                    isFirstSegment = false;\n\n                    formatState.canUnlink = formatState.canUnlink || !!segment.link;\n                    formatState.canAddImageAltText =\n                        formatState.canAddImageAltText ||\n                        segments.some(segment => segment.segmentType == 'Image');\n\n                    isFirst = false;\n\n                    if (segment.segmentType === 'Image') {\n                        if (isFirstImage) {\n                            retrieveImageFormat(segment, formatState);\n                            isFirstImage = false;\n                        } else {\n                            formatState.imageFormat = undefined;\n                        }\n                    }\n                });\n\n                isFirst = false;\n            }\n\n            if (tableContext) {\n                if (firstTableContext) {\n                    const { table, colIndex, rowIndex } = firstTableContext;\n\n                    // Merge table format\n                    if (\n                        tableContext.table == table &&\n                        (tableContext.colIndex != colIndex || tableContext.rowIndex != rowIndex)\n                    ) {\n                        formatState.canMergeTableCell = true;\n                        formatState.isMultilineSelection = true;\n                    }\n                } else {\n                    // Table formats\n                    retrieveTableFormat(tableContext, formatState);\n                    firstTableContext = tableContext;\n                }\n            }\n\n            // TODO: Support Code block in format state for Content Model\n        },\n        {\n            includeListFormatHolder: 'never',\n        }\n    );\n\n    if (formatState.fontSize) {\n        formatState.fontSize = px2Pt(formatState.fontSize);\n    }\n}\n\nfunction retrieveSegmentFormat(\n    result: ContentModelFormatState,\n    isFirst: boolean,\n    mergedFormat: ContentModelSegmentFormat\n) {\n    const superOrSubscript = mergedFormat.superOrSubScriptSequence?.split(' ')?.pop();\n\n    mergeValue(result, 'isBold', isBold(mergedFormat.fontWeight), isFirst);\n    mergeValue(result, 'isItalic', mergedFormat.italic, isFirst);\n    mergeValue(result, 'isUnderline', mergedFormat.underline, isFirst);\n    mergeValue(result, 'isStrikeThrough', mergedFormat.strikethrough, isFirst);\n    mergeValue(result, 'isSuperscript', superOrSubscript == 'super', isFirst);\n    mergeValue(result, 'isSubscript', superOrSubscript == 'sub', isFirst);\n    mergeValue(result, 'letterSpacing', mergedFormat.letterSpacing, isFirst);\n\n    mergeValue(result, 'fontName', mergedFormat.fontFamily, isFirst);\n    mergeValue(result, 'fontSize', mergedFormat.fontSize, isFirst);\n    mergeValue(result, 'backgroundColor', mergedFormat.backgroundColor, isFirst);\n    mergeValue(result, 'textColor', mergedFormat.textColor, isFirst);\n    mergeValue(result, 'fontWeight', mergedFormat.fontWeight, isFirst);\n\n    //TODO: handle block owning segments with different line-heights\n    mergeValue(result, 'lineHeight', mergedFormat.lineHeight, isFirst);\n}\n\nfunction retrieveParagraphFormat(\n    result: ContentModelFormatState,\n    paragraph: ContentModelParagraph,\n    isFirst: boolean\n) {\n    const headingLevel = parseInt((paragraph.decorator?.tagName || '').substring(1));\n    const validHeadingLevel = headingLevel >= 1 && headingLevel <= 6 ? headingLevel : undefined;\n\n    mergeValue(result, 'marginBottom', paragraph.format.marginBottom, isFirst);\n    mergeValue(result, 'marginTop', paragraph.format.marginTop, isFirst);\n    mergeValue(result, 'headingLevel', validHeadingLevel, isFirst);\n    mergeValue(result, 'textAlign', paragraph.format.textAlign, isFirst);\n    mergeValue(result, 'direction', paragraph.format.direction, isFirst);\n}\n\nfunction retrieveStructureFormat(\n    result: ContentModelFormatState,\n    path: ContentModelBlockGroup[],\n    isFirst: boolean\n) {\n    const listItemIndex = getClosestAncestorBlockGroupIndex(path, ['ListItem'], []);\n    const containerIndex = getClosestAncestorBlockGroupIndex(path, ['FormatContainer'], []);\n\n    if (listItemIndex >= 0) {\n        const listItem = path[listItemIndex] as ContentModelListItem;\n        const listType = listItem?.levels[listItem.levels.length - 1]?.listType;\n\n        mergeValue(result, 'isBullet', listType == 'UL', isFirst);\n        mergeValue(result, 'isNumbering', listType == 'OL', isFirst);\n    }\n\n    mergeValue(\n        result,\n        'isBlockQuote',\n        containerIndex >= 0 &&\n            (path[containerIndex] as ContentModelFormatContainer)?.tagName == 'blockquote',\n        isFirst\n    );\n}\n\nfunction retrieveTableFormat(tableContext: TableSelectionContext, result: ContentModelFormatState) {\n    const tableFormat = updateTableMetadata(tableContext.table);\n\n    result.isInTable = true;\n    result.tableHasHeader = tableContext.table.rows.some(row =>\n        row.cells.some(cell => cell.isHeader)\n    );\n\n    if (tableFormat) {\n        result.tableFormat = tableFormat;\n    }\n}\n\nfunction retrieveImageFormat(image: ContentModelImage, result: ContentModelFormatState) {\n    const { format } = image;\n    const borderKey = 'borderTop';\n    const extractedBorder = extractBorderValues(format[borderKey]);\n    const borderColor = extractedBorder.color;\n    const borderWidth = extractedBorder.width;\n    const borderStyle = extractedBorder.style;\n    result.imageFormat = {\n        borderColor,\n        borderWidth,\n        borderStyle,\n        boxShadow: format.boxShadow,\n        borderRadius: format.borderRadius,\n    };\n}\n\nfunction mergeValue<K extends keyof ContentModelFormatState>(\n    format: ContentModelFormatState,\n    key: K,\n    newValue: ContentModelFormatState[K] | undefined,\n    isFirst: boolean\n) {\n    if (isFirst) {\n        if (newValue !== undefined) {\n            format[key] = newValue;\n        }\n    } else if (newValue !== format[key]) {\n        delete format[key];\n    }\n}\n\nfunction px2Pt(px: string) {\n    if (px && px.indexOf('px') == px.length - 2) {\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\n        // So add 0.05 to fix it\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\n    }\n    return px;\n}\n","import { addBlock, setParagraphNotImplicit } from 'roosterjs-content-model-dom';\nimport type { ContentModelBlock, ContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport interface WrapBlockStep1Result<T extends ContentModelBlockGroup & ContentModelBlock> {\n    parent: ContentModelBlockGroup;\n    wrapper: T;\n}\n\n/**\n * @internal\n */\nexport function wrapBlockStep1<T extends ContentModelBlockGroup & ContentModelBlock>(\n    step1Result: WrapBlockStep1Result<T>[],\n    parent: ContentModelBlockGroup | null,\n    blockToWrap: ContentModelBlock,\n    creator: () => T,\n    canMerge: (target: ContentModelBlock) => target is T\n) {\n    const index = parent?.blocks.indexOf(blockToWrap) ?? -1;\n\n    if (parent && index >= 0) {\n        parent.blocks.splice(index, 1);\n\n        const prevBlock = parent.blocks[index - 1];\n        const wrapper = canMerge(prevBlock) ? prevBlock : createAndAdd(parent, index, creator);\n\n        setParagraphNotImplicit(blockToWrap);\n        addBlock(wrapper, blockToWrap);\n\n        // Use reverse order, so that we can merge from last to first to avoid modifying unmerged quotes\n        step1Result.unshift({ parent, wrapper });\n    }\n}\n\n/**\n * @internal\n */\nexport function wrapBlockStep2<T extends ContentModelBlockGroup & ContentModelBlock>(\n    step1Result: WrapBlockStep1Result<T>[],\n    canMerge: (target: ContentModelBlock, current: T) => target is T\n) {\n    step1Result.forEach(({ parent, wrapper }) => {\n        const index = parent.blocks.indexOf(wrapper);\n        const nextBlock = parent.blocks[index + 1];\n\n        if (index >= 0 && canMerge(nextBlock, wrapper)) {\n            wrapper.blocks.forEach(setParagraphNotImplicit);\n            wrapper.blocks.push(...nextBlock.blocks);\n            parent.blocks.splice(index + 1, 1);\n        }\n    });\n}\n\nfunction createAndAdd<T extends ContentModelBlockGroup & ContentModelBlock>(\n    parent: ContentModelBlockGroup,\n    index: number,\n    creator: () => T\n): T {\n    const block = creator();\n\n    parent.blocks.splice(index, 0, block);\n    return block;\n}\n","/**\n * @internal\n * Read a file object and invoke a callback function with the data url of this file\n * @param file The file to read\n * @param callback the callback to invoke with data url of the file.\n * If fail to read, dataUrl will be null\n */\nexport function readFile(file: File, callback: (dataUrl: string | null) => void) {\n    if (file) {\n        const reader = new FileReader();\n        reader.onload = () => {\n            callback(reader.result as string);\n        };\n        reader.onerror = () => {\n            callback(null);\n        };\n        reader.readAsDataURL(file);\n    }\n}\n","import {\n    deleteSelection,\n    getClosestAncestorBlockGroupIndex,\n    setSelection,\n} from 'roosterjs-content-model-core';\nimport {\n    createBr,\n    createParagraph,\n    createSelectionMarker,\n    normalizeContentModel,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelEntity,\n    ContentModelParagraph,\n    DeleteSelectionResult,\n    FormatWithContentModelContext,\n    InsertEntityPosition,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function insertEntityModel(\n    model: ContentModelDocument,\n    entityModel: ContentModelEntity,\n    position: InsertEntityPosition,\n    isBlock: boolean,\n    focusAfterEntity?: boolean,\n    context?: FormatWithContentModelContext\n) {\n    let blockParent: ContentModelBlockGroup | undefined;\n    let blockIndex = -1;\n    let deleteResult: DeleteSelectionResult;\n\n    if (position == 'begin' || position == 'end') {\n        blockParent = model;\n        blockIndex = position == 'begin' ? 0 : model.blocks.length;\n    } else if ((deleteResult = deleteSelection(model, [], context)).insertPoint) {\n        const { marker, paragraph, path } = deleteResult.insertPoint;\n\n        if (deleteResult.deleteResult == 'range') {\n            normalizeContentModel(model);\n        }\n\n        if (!isBlock) {\n            const index = paragraph.segments.indexOf(marker);\n\n            if (index >= 0) {\n                paragraph.segments.splice(focusAfterEntity ? index : index + 1, 0, entityModel);\n            }\n        } else {\n            const pathIndex =\n                position == 'root'\n                    ? getClosestAncestorBlockGroupIndex(path, ['TableCell', 'Document'])\n                    : 0;\n            blockParent = path[pathIndex];\n            const child = path[pathIndex - 1];\n            const directChild: ContentModelBlock =\n                child?.blockGroupType == 'FormatContainer' ||\n                child?.blockGroupType == 'General' ||\n                child?.blockGroupType == 'ListItem'\n                    ? child\n                    : paragraph;\n            const childIndex = blockParent.blocks.indexOf(directChild);\n            blockIndex = childIndex >= 0 ? childIndex + 1 : -1;\n        }\n    }\n\n    if (blockIndex >= 0 && blockParent) {\n        const blocksToInsert: ContentModelBlock[] = [];\n        let nextParagraph: ContentModelParagraph | undefined;\n\n        if (isBlock) {\n            const nextBlock = blockParent.blocks[blockIndex];\n\n            blocksToInsert.push(entityModel);\n\n            if (nextBlock?.blockType == 'Paragraph') {\n                nextParagraph = nextBlock;\n            } else if (!nextBlock || nextBlock.blockType == 'Entity' || focusAfterEntity) {\n                nextParagraph = createParagraph(false /*isImplicit*/, {}, model.format);\n                nextParagraph.segments.push(createBr(model.format));\n                blocksToInsert.push(nextParagraph);\n            }\n        } else {\n            nextParagraph = createParagraph(\n                false /*isImplicit*/,\n                undefined /*format*/,\n                model.format\n            );\n\n            nextParagraph.segments.push(entityModel);\n            blocksToInsert.push(nextParagraph);\n        }\n\n        blockParent.blocks.splice(blockIndex, 0, ...blocksToInsert);\n\n        if (focusAfterEntity && nextParagraph) {\n            const marker = createSelectionMarker(nextParagraph.segments[0]?.format || model.format);\n            const segments = nextParagraph.segments;\n\n            isBlock ? segments.unshift(marker) : segments.push(marker);\n            setSelection(model, marker, marker);\n        }\n    }\n}\n","import { extractBorderValues } from 'roosterjs-content-model-core';\nimport { parseValueWithUnit } from 'roosterjs-content-model-dom';\nimport type { Border, ContentModelImage } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport default function applyImageBorderFormat(\n    image: ContentModelImage,\n    border: Border | null,\n    borderRadius?: string\n) {\n    if (border) {\n        const format = image.format;\n        const { width, style, color } = border;\n        const borderKey = 'borderTop';\n        const extractedBorder = extractBorderValues(format[borderKey]);\n        const borderColor = extractedBorder.color;\n        const borderWidth = extractedBorder.width;\n        const borderStyle = extractedBorder.style;\n        let borderFormat = '';\n\n        if (width) {\n            borderFormat = parseValueWithUnit(width) + 'px';\n        } else if (borderWidth) {\n            borderFormat = borderWidth;\n        } else {\n            borderFormat = '1px';\n        }\n\n        if (style) {\n            borderFormat = `${borderFormat} ${style}`;\n        } else if (borderStyle) {\n            borderFormat = `${borderFormat} ${borderStyle}`;\n        } else {\n            borderFormat = `${borderFormat} solid`;\n        }\n\n        if (color) {\n            borderFormat = `${borderFormat} ${color}`;\n        } else if (borderColor) {\n            borderFormat = `${borderFormat} ${borderColor}`;\n        }\n        image.format.borderLeft = borderFormat;\n        image.format.borderTop = borderFormat;\n        image.format.borderBottom = borderFormat;\n        image.format.borderRight = borderFormat;\n    } else {\n        delete image.format.borderLeft;\n        delete image.format.borderTop;\n        delete image.format.borderBottom;\n        delete image.format.borderRight;\n    }\n\n    if (borderRadius) {\n        image.format.borderRadius = borderRadius;\n    }\n}\n","import type {\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function findListItemsInSameThread(\n    model: ContentModelDocument,\n    currentItem: ContentModelListItem\n): ContentModelListItem[] {\n    const items: (ContentModelListItem | null)[] = [];\n\n    findListItems(model, items);\n\n    return filterListItems(items, currentItem);\n}\n\nfunction findListItems(group: ContentModelBlockGroup, result: (ContentModelListItem | null)[]) {\n    group.blocks.forEach(block => {\n        switch (block.blockType) {\n            case 'BlockGroup':\n                if (block.blockGroupType == 'ListItem') {\n                    result.push(block);\n                } else {\n                    pushNullIfNecessary(result);\n                    findListItems(block, result);\n                    pushNullIfNecessary(result);\n                }\n                break;\n\n            case 'Paragraph':\n                pushNullIfNecessary(result);\n\n                block.segments.forEach(segment => {\n                    if (segment.segmentType == 'General') {\n                        findListItems(segment, result);\n                    }\n                });\n\n                pushNullIfNecessary(result);\n                break;\n\n            case 'Table':\n                pushNullIfNecessary(result);\n\n                block.rows.forEach(row =>\n                    row.cells.forEach(cell => {\n                        findListItems(cell, result);\n                    })\n                );\n                pushNullIfNecessary(result);\n\n                break;\n        }\n    });\n}\n\nfunction pushNullIfNecessary(result: (ContentModelListItem | null)[]) {\n    const last = result[result.length - 1];\n\n    if (!last || last !== null) {\n        result.push(null);\n    }\n}\n\nfunction filterListItems(\n    items: (ContentModelListItem | null)[],\n    currentItem: ContentModelListItem\n) {\n    const result: ContentModelListItem[] = [];\n    const currentIndex = items.indexOf(currentItem);\n    const levelLength = currentItem.levels.length;\n    const isOrderedList = currentItem.levels[levelLength - 1]?.listType == 'OL';\n\n    if (currentIndex >= 0) {\n        for (let i = currentIndex; i >= 0; i--) {\n            const item = items[i];\n\n            if (!item) {\n                if (isOrderedList) {\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            const startNumberOverride = hasStartNumberOverride(item, levelLength);\n\n            if (areListTypesCompatible(items, currentIndex, i)) {\n                result.unshift(item);\n\n                if (isOrderedList && startNumberOverride) {\n                    break;\n                }\n            } else if (!isOrderedList || startNumberOverride) {\n                break;\n            }\n        }\n\n        for (let i = currentIndex + 1; i < items.length; i++) {\n            const item = items[i];\n\n            if (!item) {\n                if (isOrderedList) {\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            const startNumberOverride = hasStartNumberOverride(item, levelLength);\n\n            if (areListTypesCompatible(items, currentIndex, i) && !startNumberOverride) {\n                result.push(item);\n            } else if (!isOrderedList || startNumberOverride) {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction areListTypesCompatible(\n    listItems: (ContentModelListItem | null)[],\n    currentIndex: number,\n    compareToIndex: number\n): boolean {\n    const currentLevels = listItems[currentIndex]!.levels;\n    const compareToLevels = listItems[compareToIndex]!.levels;\n\n    return (\n        currentLevels.length <= compareToLevels.length &&\n        currentLevels.every(\n            (currentLevel, i) => currentLevel.listType == compareToLevels[i].listType\n        )\n    );\n}\n\nfunction hasStartNumberOverride(item: ContentModelListItem, levelLength: number): boolean {\n    return item.levels\n        .slice(0, levelLength)\n        .some(level => level.format.startNumberOverride !== undefined);\n}\n","import { getOperationalBlocks, isBlockGroupOfType } from 'roosterjs-content-model-core';\nimport {\n    createListItem,\n    createListLevel,\n    normalizeContentModel,\n    setParagraphNotImplicit,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlock,\n    ContentModelDocument,\n    ContentModelListItem,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function setListType(model: ContentModelDocument, listType: 'OL' | 'UL') {\n    const paragraphOrListItems = getOperationalBlocks<ContentModelListItem>(\n        model,\n        ['ListItem'],\n        [] // Set stop types to be empty so we can find list items even cross the boundary of table, then we can always operation on the list item if any\n    );\n    const alreadyInExpectedType = paragraphOrListItems.every(({ block }) =>\n        isBlockGroupOfType<ContentModelListItem>(block, 'ListItem')\n            ? block.levels[block.levels.length - 1]?.listType == listType\n            : shouldIgnoreBlock(block)\n    );\n    let existingListItems: ContentModelListItem[] = [];\n    let hasIgnoredParagraphBefore = false;\n\n    paragraphOrListItems.forEach(({ block, parent }, itemIndex) => {\n        if (isBlockGroupOfType<ContentModelListItem>(block, 'ListItem')) {\n            const level = block.levels.pop();\n\n            if (!alreadyInExpectedType && level) {\n                level.listType = listType;\n                block.levels.push(level);\n            } else if (block.blocks.length == 1) {\n                setParagraphNotImplicit(block.blocks[0]);\n            }\n\n            if (alreadyInExpectedType) {\n                //if the list item has margins or textAlign, we need to apply them to the block to preserve the indention and alignment\n                block.blocks.forEach(x => {\n                    if (block.format.marginLeft) {\n                        x.format.marginLeft = block.format.marginLeft;\n                    }\n\n                    if (block.format.marginRight) {\n                        x.format.marginRight = block.format.marginRight;\n                    }\n\n                    if (block.format.textAlign) {\n                        x.format.textAlign = block.format.textAlign;\n                    }\n                });\n            }\n        } else {\n            const index = parent.blocks.indexOf(block);\n\n            if (index >= 0) {\n                if (paragraphOrListItems.length == 1 || !shouldIgnoreBlock(block)) {\n                    const prevBlock = parent.blocks[index - 1];\n                    const segmentFormat =\n                        (block.blockType == 'Paragraph' && block.segments[0]?.format) || {};\n                    const newListItem = createListItem(\n                        [\n                            createListLevel(listType, {\n                                startNumberOverride:\n                                    itemIndex > 0 ||\n                                    (prevBlock?.blockType == 'BlockGroup' &&\n                                        prevBlock.blockGroupType == 'ListItem' &&\n                                        prevBlock.levels[0]?.listType == 'OL')\n                                        ? undefined\n                                        : 1,\n                                direction: block.format.direction,\n                                textAlign: block.format.textAlign,\n                                marginTop: hasIgnoredParagraphBefore ? '0' : undefined,\n                                marginBlockEnd: '0px',\n                                marginBlockStart: '0px',\n                            }),\n                        ],\n                        // For list bullet, we only want to carry over these formats from segments:\n                        {\n                            fontFamily: segmentFormat.fontFamily,\n                            fontSize: segmentFormat.fontSize,\n                            textColor: segmentFormat.textColor,\n                        }\n                    );\n\n                    // Since there is only one paragraph under the list item, no need to keep its paragraph element (DIV).\n                    // TODO: Do we need to keep the CSS styles applied to original DIV?\n                    if (block.blockType == 'Paragraph') {\n                        block.isImplicit = true;\n                    }\n\n                    newListItem.blocks.push(block);\n\n                    if (block.format.marginRight) {\n                        newListItem.format.marginRight = block.format.marginRight;\n                        block.format.marginRight = undefined;\n                    }\n                    if (block.format.marginLeft) {\n                        newListItem.format.marginLeft = block.format.marginLeft;\n                        block.format.marginLeft = undefined;\n                    }\n\n                    if (block.format.textAlign) {\n                        newListItem.format.textAlign = block.format.textAlign;\n                    }\n\n                    parent.blocks.splice(index, 1, newListItem);\n                    existingListItems.push(newListItem);\n                } else {\n                    hasIgnoredParagraphBefore = true;\n\n                    existingListItems.forEach(x => (x.levels[0].format.marginBottom = '0'));\n                    existingListItems = [];\n                }\n            }\n        }\n    });\n\n    normalizeContentModel(model);\n\n    return paragraphOrListItems.length > 0;\n}\n\nfunction shouldIgnoreBlock(block: ContentModelBlock) {\n    switch (block.blockType) {\n        case 'Table':\n            return false;\n        case 'Paragraph':\n            return block.segments.every(\n                x => x.segmentType == 'Br' || x.segmentType == 'SelectionMarker'\n            );\n        default:\n            return true;\n    }\n}\n","import { getSelectedParagraphs, setSelection } from 'roosterjs-content-model-core';\nimport type { ContentModelDocument, ContentModelSegment } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function adjustSegmentSelection(\n    model: ContentModelDocument,\n    firstMatcher: (target: ContentModelSegment) => boolean,\n    siblingMatcher: (target: ContentModelSegment, ref: ContentModelSegment) => boolean\n): boolean {\n    const paragraphs = getSelectedParagraphs(model);\n    let first: ContentModelSegment | undefined;\n    let last: ContentModelSegment | undefined;\n    let changed = false;\n\n    paragraphs.forEach(p => {\n        const index = first ? 0 : p.segments.findIndex(x => firstMatcher(x));\n        const segments = p.segments;\n\n        if (!first) {\n            first = segments[index];\n\n            for (let i = index; i > 0; i--) {\n                if (siblingMatcher(segments[i - 1], first)) {\n                    first = segments[i - 1];\n                    changed = changed || !segments[i - 1].isSelected;\n                } else {\n                    changed = changed || !!segments[i - 1].isSelected;\n                    break;\n                }\n            }\n        }\n\n        if (first) {\n            for (let i = index; i < p.segments.length; i++) {\n                if (i == index || siblingMatcher(segments[i], last || segments[index])) {\n                    last = segments[i];\n                    changed = changed || !segments[i].isSelected;\n                } else {\n                    changed = changed || !!segments[i].isSelected;\n                    break;\n                }\n            }\n        }\n    });\n\n    if (first && last) {\n        setSelection(model, first, last);\n    }\n\n    return changed;\n}\n","import { createText } from 'roosterjs-content-model-dom';\nimport { isPunctuation, isSpace, iterateSelections } from 'roosterjs-content-model-core';\nimport type {\n    ContentModelDocument,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelText,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function adjustWordSelection(\n    model: ContentModelDocument,\n    marker: ContentModelSegment\n): ContentModelSegment[] {\n    let markerBlock: ContentModelParagraph | undefined;\n\n    iterateSelections(model, (_, __, block, segments) => {\n        //Find the block with the selection marker\n        if (block?.blockType == 'Paragraph' && segments?.length == 1 && segments[0] == marker) {\n            markerBlock = block;\n        }\n        return true;\n    });\n\n    const tempSegments = markerBlock ? [...markerBlock.segments] : undefined;\n\n    if (tempSegments && markerBlock) {\n        const segments: ContentModelSegment[] = [];\n        let markerSelectionIndex = tempSegments.indexOf(marker);\n        for (let i = markerSelectionIndex - 1; i >= 0; i--) {\n            const currentSegment = tempSegments[i];\n            if (currentSegment.segmentType == 'Text') {\n                const found = findDelimiter(currentSegment, false /*moveRightward*/);\n                if (found > -1) {\n                    if (found == currentSegment.text.length) {\n                        break;\n                    }\n\n                    splitTextSegment(tempSegments, currentSegment, i, found);\n\n                    segments.push(tempSegments[i + 1]);\n\n                    break;\n                } else {\n                    segments.push(tempSegments[i]);\n                }\n            } else {\n                break;\n            }\n        }\n\n        markerSelectionIndex = tempSegments.indexOf(marker);\n        segments.push(marker);\n\n        // Marker is at start of word\n        if (segments.length <= 1) {\n            return segments;\n        }\n\n        for (let i = markerSelectionIndex + 1; i < tempSegments.length; i++) {\n            const currentSegment = tempSegments[i];\n            if (currentSegment.segmentType == 'Text') {\n                const found = findDelimiter(currentSegment, true /*moveRightward*/);\n                if (found > -1) {\n                    if (found == 0) {\n                        break;\n                    }\n                    splitTextSegment(tempSegments, currentSegment, i, found);\n                    segments.push(tempSegments[i]);\n                    break;\n                } else {\n                    segments.push(tempSegments[i]);\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Marker is at end of word\n        if (segments[segments.length - 1] == marker) {\n            return [marker];\n        }\n\n        markerBlock.segments = tempSegments;\n        return segments;\n    } else {\n        return [marker];\n    }\n}\n\n/*\n// These are unicode characters mostly from the Category Space Separator (Zs)\nhttps://unicode.org/Public/UNIDATA/Scripts.txt\n\n\\u2000 = EN QUAD\n\\u2009 = THIN SPACE\n\\u200a = HAIR SPACE\n​\\u200b = ZERO WIDTH SPACE\n​\\u202f = NARROW NO-BREAK SPACE\n\\u205f​ = MEDIUM MATHEMATICAL SPACE\n\\u3000 = IDEOGRAPHIC SPACE\n*/\nfunction findDelimiter(segment: ContentModelText, moveRightward: boolean): number {\n    const word = segment.text;\n    let offset = -1;\n    if (moveRightward) {\n        for (let i = 0; i < word.length; i++) {\n            const char = word[i];\n\n            if (isPunctuation(char) || isSpace(char)) {\n                offset = i;\n                break;\n            }\n        }\n    } else {\n        for (let i = word.length - 1; i >= 0; i--) {\n            const char = word[i];\n\n            if (isPunctuation(char) || isSpace(char)) {\n                offset = i + 1;\n                break;\n            }\n        }\n    }\n    return offset;\n}\n\nfunction splitTextSegment(\n    segments: ContentModelSegment[],\n    textSegment: Readonly<ContentModelText>,\n    index: number,\n    found: number\n) {\n    const text = textSegment.text;\n    const newSegmentLeft = createText(\n        text.substring(0, found),\n        textSegment.format,\n        textSegment.link,\n        textSegment.code\n    );\n    const newSegmentRight = createText(\n        text.substring(found, text.length),\n        textSegment.format,\n        textSegment.link,\n        textSegment.code\n    );\n    segments.splice(index, 1, newSegmentLeft, newSegmentRight);\n}\n","import { addSegment, createSelectionMarker } from 'roosterjs-content-model-dom';\nimport type { ContentModelTableRow } from 'roosterjs-content-model-types';\nimport type { TableSelectionCoordinates } from '../table/getSelectedCells';\n\n/**\n * @internal\n */\nexport function collapseTableSelection(\n    rows: ContentModelTableRow[],\n    selection: TableSelectionCoordinates\n) {\n    const { firstCol, firstRow } = selection;\n    const cell = rows[firstRow]?.cells[firstCol];\n    if (cell) {\n        addSegment(cell, createSelectionMarker());\n    }\n}\n","import type { ContentModelTable, TableAlignOperation } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function alignTable(table: ContentModelTable, operation: TableAlignOperation) {\n    table.format.marginLeft = operation == 'alignLeft' ? '' : 'auto';\n    table.format.marginRight = operation == 'alignRight' ? '' : 'auto';\n\n    delete table.cachedElement;\n}\n","import { getSelectedCells } from './getSelectedCells';\nimport { updateTableCellMetadata } from 'roosterjs-content-model-core';\nimport type {\n    ContentModelTable,\n    ContentModelTableCell,\n    TableCellHorizontalAlignOperation,\n    TableCellVerticalAlignOperation,\n} from 'roosterjs-content-model-types';\n\nconst TextAlignValueMap: Partial<Record<\n    TableCellHorizontalAlignOperation,\n    'start' | 'center' | 'end'\n>> = {\n    alignCellLeft: 'start',\n    alignCellCenter: 'center',\n    alignCellRight: 'end',\n};\n\nconst VerticalAlignValueMap: Partial<Record<\n    TableCellVerticalAlignOperation,\n    'top' | 'middle' | 'bottom'\n>> = {\n    alignCellTop: 'top',\n    alignCellMiddle: 'middle',\n    alignCellBottom: 'bottom',\n};\n\n/**\n * @internal\n */\nexport function alignTableCellHorizontally(\n    table: ContentModelTable,\n    operation: TableCellHorizontalAlignOperation\n) {\n    alignTableCellInternal(table, cell => {\n        cell.format.textAlign = TextAlignValueMap[operation];\n    });\n}\n\n/**\n * @internal\n */\nexport function alignTableCellVertically(\n    table: ContentModelTable,\n    operation: TableCellVerticalAlignOperation\n) {\n    alignTableCellInternal(table, cell => {\n        cell.format.verticalAlign = VerticalAlignValueMap[operation];\n\n        updateTableCellMetadata(cell, metadata => {\n            metadata = metadata || {};\n            metadata.vAlignOverride = true;\n            return metadata;\n        });\n    });\n}\n\nfunction alignTableCellInternal(\n    table: ContentModelTable,\n    callback: (cell: ContentModelTableCell) => void\n) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n            for (let colIndex = sel.firstCol; colIndex <= sel.lastCol; colIndex++) {\n                const cell = table.rows[rowIndex]?.cells[colIndex];\n                const format = cell?.format;\n\n                if (format) {\n                    delete cell.cachedElement;\n\n                    callback(cell);\n\n                    cell.blocks.forEach(block => {\n                        if (block.blockType === 'Paragraph') {\n                            delete block.format.textAlign;\n                        }\n                    });\n                }\n            }\n        }\n    }\n}\n","import type { ContentModelTableRow } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function canMergeCells(\n    rows: ContentModelTableRow[],\n    firstRow: number,\n    firstCol: number,\n    lastRow: number,\n    lastCol: number\n): boolean {\n    const noSpanAbove =\n        firstCol == lastCol ||\n        rows[firstRow].cells.every(\n            (cell, colIndex) => colIndex < firstCol || colIndex > lastCol || !cell.spanAbove\n        );\n    const noSpanLeft =\n        firstRow == lastRow ||\n        rows.every(\n            (row, rowIndex) =>\n                rowIndex < firstRow || rowIndex > lastRow || !row.cells[firstCol].spanLeft\n        );\n\n    const noDifferentBelowSpan = rows[lastRow].cells\n        .map((_, colIndex) =>\n            colIndex >= firstCol && colIndex <= lastCol\n                ? getBelowSpanCount(rows, lastRow, colIndex)\n                : -1\n        )\n        .every((x, _, a) => x < 0 || x == a[firstCol]);\n    const noDifferentRightSpan = rows\n        .map((_, rowIndex) =>\n            rowIndex >= firstRow && rowIndex <= lastRow\n                ? getRightSpanCount(rows, rowIndex, lastCol)\n                : -1\n        )\n        .every((x, _, a) => x < 0 || x == a[firstRow]);\n\n    return noSpanAbove && noSpanLeft && noDifferentBelowSpan && noDifferentRightSpan;\n}\n\nfunction getBelowSpanCount(rows: ContentModelTableRow[], rowIndex: number, colIndex: number) {\n    let spanCount = 0;\n\n    for (let row = rowIndex + 1; row < rows.length; row++) {\n        if (rows[row]?.cells[colIndex]?.spanAbove) {\n            spanCount++;\n        } else {\n            break;\n        }\n    }\n\n    return spanCount;\n}\n\nfunction getRightSpanCount(rows: ContentModelTableRow[], rowIndex: number, colIndex: number) {\n    let spanCount = 0;\n\n    for (let col = colIndex + 1; col < rows[rowIndex]?.cells.length; col++) {\n        if (rows[rowIndex]?.cells[col]?.spanLeft) {\n            spanCount++;\n        } else {\n            break;\n        }\n    }\n\n    return spanCount;\n}\n","import { addBlock, createTable, createTableCell } from 'roosterjs-content-model-dom';\nimport type { ContentModelBlockGroup, ContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function createTableStructure(\n    parent: ContentModelBlockGroup,\n    columns: number,\n    rows: number\n): ContentModelTable {\n    const table = createTable(rows);\n\n    addBlock(parent, table);\n\n    table.rows.forEach(row => {\n        for (let i = 0; i < columns; i++) {\n            const cell = createTableCell();\n\n            row.cells.push(cell);\n        }\n    });\n\n    return table;\n}\n","import type { ContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function deleteTable(table: ContentModelTable) {\n    table.rows = [];\n    delete table.cachedElement;\n}\n","import { collapseTableSelection } from '../selection/collapseTableSelection';\nimport { getSelectedCells } from './getSelectedCells';\nimport type { ContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function deleteTableColumn(table: ContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        for (let rowIndex = 0; rowIndex < table.rows.length; rowIndex++) {\n            const cellInNextCol = table.rows[rowIndex].cells[sel.lastCol + 1];\n\n            if (cellInNextCol) {\n                cellInNextCol.spanLeft =\n                    cellInNextCol.spanLeft && table.rows[rowIndex].cells[sel.firstCol].spanLeft;\n            }\n\n            table.rows[rowIndex].cells.splice(sel.firstCol, sel.lastCol - sel.firstCol + 1);\n        }\n\n        table.widths.splice(sel.firstCol, sel.lastCol - sel.firstCol + 1);\n        collapseTableSelection(table.rows, sel);\n    }\n}\n","import { collapseTableSelection } from '../selection/collapseTableSelection';\nimport { getSelectedCells } from './getSelectedCells';\nimport type { ContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function deleteTableRow(table: ContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        table.rows[sel.firstRow].cells.forEach((cell, colIndex) => {\n            const cellInNextRow = table.rows[sel.lastRow + 1]?.cells[colIndex];\n\n            if (cellInNextRow) {\n                cellInNextRow.spanAbove = cellInNextRow.spanAbove && cell.spanAbove;\n            }\n        });\n\n        table.rows.splice(sel.firstRow, sel.lastRow - sel.firstRow + 1);\n\n        collapseTableSelection(table.rows, sel);\n    }\n}\n","import { createBr, createParagraph } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelParagraph,\n    ContentModelTable,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * After edit table, it maybe in a abnormal state, e.g. selected table cell is removed, or all rows are removed causes no place to put cursor.\n * We need to make sure table is in normal state, and there is a place to put cursor.\n * @returns a new paragraph that can but put focus in, or undefined if not needed\n */\nexport function ensureFocusableParagraphForTable(\n    model: ContentModelDocument,\n    path: ContentModelBlockGroup[],\n    table: ContentModelTable\n): ContentModelParagraph | undefined {\n    let paragraph: ContentModelParagraph | undefined;\n    const firstCell = table.rows.filter(row => row.cells.length > 0)[0]?.cells[0];\n\n    if (firstCell) {\n        // When there is a valid cell to put focus, use it\n        paragraph = firstCell.blocks.filter(\n            (block): block is ContentModelParagraph => block.blockType == 'Paragraph'\n        )[0];\n\n        if (!paragraph) {\n            // If there is not a paragraph under this cell, create one\n            paragraph = createEmptyParagraph(model);\n            firstCell.blocks.push(paragraph);\n        }\n    } else {\n        // No table cell at all, which means the whole table is deleted. So we need to remove it from content model.\n        let block: ContentModelBlock = table;\n        let parent: ContentModelBlockGroup | undefined;\n        paragraph = createEmptyParagraph(model);\n\n        // If the table is the only block of its parent and parent is a FormatContainer, remove the parent as well.\n        // We need to do this in a loop in case there are multiple layer of FormatContainer that match this case\n        while ((parent = path.shift())) {\n            const index = parent.blocks.indexOf(block) ?? -1;\n\n            if (parent && index >= 0) {\n                parent.blocks.splice(index, 1, paragraph);\n            }\n\n            if (\n                parent.blockGroupType == 'FormatContainer' &&\n                parent.blocks.length == 1 &&\n                parent.blocks[0] == paragraph\n            ) {\n                // If the new paragraph is the only child of parent format container, unwrap parent as well\n                block = parent;\n            } else {\n                // Otherwise, just stop here and keep processing the new paragraph\n                break;\n            }\n        }\n    }\n\n    return paragraph;\n}\n\nfunction createEmptyParagraph(model: ContentModelDocument) {\n    const newPara = createParagraph(false /*isImplicit*/, undefined /*blockFormat*/, model.format);\n    const br = createBr(model.format);\n\n    newPara.segments.push(br);\n\n    return newPara;\n}\n","import hasSelectionInBlockGroup from '../../publicApi/selection/hasSelectionInBlockGroup';\nimport type { ContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport interface TableSelectionCoordinates {\n    firstRow: number;\n    firstCol: number;\n    lastRow: number;\n    lastCol: number;\n}\n\n/**\n * @internal\n */\nexport function getSelectedCells(table: ContentModelTable): TableSelectionCoordinates | null {\n    let firstRow = -1;\n    let firstCol = -1;\n    let lastRow = -1;\n    let lastCol = -1;\n    let hasSelection = false;\n\n    table.rows.forEach((row, rowIndex) =>\n        row.cells.forEach((cell, colIndex) => {\n            if (hasSelectionInBlockGroup(cell)) {\n                hasSelection = true;\n\n                if (firstRow < 0) {\n                    firstRow = rowIndex;\n                }\n\n                if (firstCol < 0) {\n                    firstCol = colIndex;\n                }\n\n                lastRow = Math.max(lastRow, rowIndex);\n                lastCol = Math.max(lastCol, colIndex);\n            }\n        })\n    );\n\n    return hasSelection ? { firstRow, firstCol, lastRow, lastCol } : null;\n}\n","import { createTableCell } from 'roosterjs-content-model-dom';\nimport { getSelectedCells } from './getSelectedCells';\nimport type {\n    ContentModelTable,\n    TableHorizontalInsertOperation,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function insertTableColumn(\n    table: ContentModelTable,\n    operation: TableHorizontalInsertOperation\n) {\n    const sel = getSelectedCells(table);\n    const insertLeft = operation == 'insertLeft';\n\n    if (sel) {\n        for (let i = sel?.firstCol; i <= sel.lastCol; i++) {\n            table.rows.forEach(row => {\n                const cell = row.cells[insertLeft ? sel.firstCol : sel.lastCol];\n\n                row.cells.splice(\n                    insertLeft ? sel.firstCol : sel.lastCol + 1,\n                    0,\n                    createTableCell(cell.spanLeft, cell.spanAbove, cell.isHeader, cell.format)\n                );\n            });\n            table.widths.splice(\n                insertLeft ? sel.firstCol : sel.lastCol + 1,\n                0,\n                table.widths[insertLeft ? sel.firstCol : sel.lastCol]\n            );\n        }\n    }\n}\n","import { createTableCell } from 'roosterjs-content-model-dom';\nimport { getSelectedCells } from './getSelectedCells';\nimport type {\n    ContentModelTable,\n    TableVerticalInsertOperation,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function insertTableRow(table: ContentModelTable, operation: TableVerticalInsertOperation) {\n    const sel = getSelectedCells(table);\n    const insertAbove = operation == 'insertAbove';\n\n    if (sel) {\n        for (let i = sel.firstRow; i <= sel.lastRow; i++) {\n            const sourceRow = table.rows[insertAbove ? sel.firstRow : sel.lastRow];\n\n            table.rows.splice(insertAbove ? sel.firstRow : sel.lastRow + 1, 0, {\n                format: { ...sourceRow.format },\n                cells: sourceRow.cells.map(cell =>\n                    createTableCell(cell.spanLeft, cell.spanAbove, cell.isHeader, cell.format)\n                ),\n                height: sourceRow.height,\n            });\n        }\n    }\n}\n","import { canMergeCells } from './canMergeCells';\nimport { getSelectedCells } from './getSelectedCells';\nimport type { ContentModelTable } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function mergeTableCells(table: ContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel && canMergeCells(table.rows, sel.firstRow, sel.firstCol, sel.lastRow, sel.lastCol)) {\n        for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n            for (let colIndex = sel.firstCol; colIndex <= sel.lastCol; colIndex++) {\n                const cell = table.rows[rowIndex].cells[colIndex];\n\n                if (cell) {\n                    cell.spanLeft = colIndex > sel.firstCol;\n                    cell.spanAbove = rowIndex > sel.firstRow;\n\n                    delete cell.cachedElement;\n                }\n            }\n\n            delete table.rows[rowIndex].cachedElement;\n        }\n    }\n}\n","import { canMergeCells } from './canMergeCells';\nimport { getSelectedCells } from './getSelectedCells';\nimport type {\n    ContentModelTable,\n    TableHorizontalMergeOperation,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function mergeTableColumn(\n    table: ContentModelTable,\n    operation: TableHorizontalMergeOperation\n) {\n    const sel = getSelectedCells(table);\n    const mergeLeft = operation == 'mergeLeft';\n\n    if (sel) {\n        const mergingColIndex = mergeLeft ? sel.firstCol : sel.lastCol + 1;\n\n        if (mergingColIndex > 0 && mergingColIndex < table.rows[0].cells.length) {\n            for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n                const cell = table.rows[rowIndex]?.cells[mergingColIndex];\n\n                if (\n                    cell &&\n                    canMergeCells(\n                        table.rows,\n                        rowIndex,\n                        mergingColIndex - 1,\n                        rowIndex,\n                        mergingColIndex\n                    )\n                ) {\n                    cell.spanLeft = true;\n\n                    let newSelectedCol = mergingColIndex;\n\n                    while (table.rows[rowIndex]?.cells[newSelectedCol]?.spanLeft) {\n                        delete table.rows[rowIndex].cells[newSelectedCol].cachedElement;\n                        newSelectedCol--;\n                    }\n\n                    if (table.rows[rowIndex]?.cells[newSelectedCol]) {\n                        table.rows[rowIndex].cells[newSelectedCol].isSelected = true;\n\n                        delete table.rows[rowIndex].cells[newSelectedCol].cachedElement;\n                    }\n\n                    delete cell.cachedElement;\n                }\n\n                delete table.rows[rowIndex].cachedElement;\n            }\n        }\n    }\n}\n","import { canMergeCells } from './canMergeCells';\nimport { getSelectedCells } from './getSelectedCells';\nimport type { ContentModelTable, TableVerticalMergeOperation } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function mergeTableRow(table: ContentModelTable, operation: TableVerticalMergeOperation) {\n    const sel = getSelectedCells(table);\n    const mergeAbove = operation == 'mergeAbove';\n\n    if (sel) {\n        const mergingRowIndex = mergeAbove ? sel.firstRow : sel.lastRow + 1;\n\n        if (mergingRowIndex > 0 && mergingRowIndex < table.rows.length) {\n            for (let colIndex = sel.firstCol; colIndex <= sel.lastCol; colIndex++) {\n                const cell = table.rows[mergingRowIndex].cells[colIndex];\n\n                if (\n                    cell &&\n                    canMergeCells(\n                        table.rows,\n                        mergingRowIndex - 1,\n                        colIndex,\n                        mergingRowIndex,\n                        colIndex\n                    )\n                ) {\n                    cell.spanAbove = true;\n\n                    let newSelectedRow = mergingRowIndex;\n\n                    while (table.rows[newSelectedRow]?.cells[colIndex]?.spanAbove) {\n                        delete table.rows[newSelectedRow].cells[colIndex].cachedElement;\n                        delete table.rows[newSelectedRow].cachedElement;\n                        newSelectedRow--;\n                    }\n\n                    if (table.rows[newSelectedRow]?.cells[colIndex]) {\n                        table.rows[newSelectedRow].cells[colIndex].isSelected = true;\n\n                        delete table.rows[newSelectedRow].cells[colIndex].cachedElement;\n                        delete table.rows[newSelectedRow].cachedElement;\n                    }\n\n                    delete cell.cachedElement;\n                }\n            }\n        }\n    }\n}\n","import { createTableCell } from 'roosterjs-content-model-dom';\nimport { getSelectedCells } from './getSelectedCells';\nimport type { ContentModelTable } from 'roosterjs-content-model-types';\n\nconst MIN_WIDTH = 30;\n\n/**\n * @internal\n */\nexport function splitTableCellHorizontally(table: ContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        for (let colIndex = sel.lastCol; colIndex >= sel.firstCol; colIndex--) {\n            if (\n                table.rows.every(\n                    (row, rowIndex) =>\n                        rowIndex < sel.firstRow ||\n                        rowIndex > sel.lastRow ||\n                        row.cells[colIndex + 1]?.spanLeft\n                )\n            ) {\n                table.rows.forEach((row, rowIndex) => {\n                    delete row.cells[colIndex].cachedElement;\n\n                    if (rowIndex >= sel.firstRow && rowIndex <= sel.lastRow) {\n                        row.cells[colIndex + 1].spanLeft = false;\n                        delete row.cells[colIndex + 1].cachedElement;\n                    }\n                });\n            } else {\n                table.rows.forEach((row, rowIndex) => {\n                    const cell = row.cells[colIndex];\n                    if (cell) {\n                        const newCell = createTableCell(\n                            cell.spanLeft,\n                            cell.spanAbove,\n                            cell.isHeader,\n                            cell.format\n                        );\n\n                        newCell.dataset = { ...cell.dataset };\n\n                        if (rowIndex < sel.firstRow || rowIndex > sel.lastRow) {\n                            newCell.spanLeft = true;\n                        } else {\n                            newCell.isSelected = cell.isSelected;\n                        }\n                        row.cells.splice(colIndex + 1, 0, newCell);\n\n                        delete row.cells[colIndex].cachedElement;\n                    }\n                });\n\n                const newWidth = Math.max(table.widths[colIndex] / 2, MIN_WIDTH);\n\n                table.widths.splice(colIndex, 1, newWidth, newWidth);\n            }\n        }\n    }\n}\n","import { createTableCell } from 'roosterjs-content-model-dom';\nimport { getSelectedCells } from './getSelectedCells';\nimport type { ContentModelTable, ContentModelTableRow } from 'roosterjs-content-model-types';\n\nconst MIN_HEIGHT = 22;\n\n/**\n * @internal\n */\nexport function splitTableCellVertically(table: ContentModelTable) {\n    const sel = getSelectedCells(table);\n\n    if (sel) {\n        for (let rowIndex = sel.lastRow; rowIndex >= sel.firstRow; rowIndex--) {\n            const row = table.rows[rowIndex];\n            const belowRow = table.rows[rowIndex + 1];\n\n            row.cells.forEach(cell => {\n                delete cell.cachedElement;\n            });\n\n            delete row.cachedElement;\n\n            if (\n                belowRow?.cells.every(\n                    (belowCell, colIndex) =>\n                        colIndex < sel.firstCol || colIndex > sel.lastCol || belowCell.spanAbove\n                )\n            ) {\n                belowRow.cells.forEach((belowCell, colIndex) => {\n                    if (colIndex >= sel.firstCol && colIndex <= sel.lastCol) {\n                        belowCell.spanAbove = false;\n                        delete belowCell.cachedElement;\n                    }\n                });\n\n                delete belowRow.cachedElement;\n            } else {\n                const newHeight = Math.max((row.height /= 2), MIN_HEIGHT);\n                const newRow: ContentModelTableRow = {\n                    format: { ...row.format },\n                    height: newHeight,\n                    cells: row.cells.map((cell, colIndex) => {\n                        const newCell = createTableCell(\n                            cell.spanLeft,\n                            cell.spanAbove,\n                            cell.isHeader,\n                            cell.format\n                        );\n\n                        newCell.dataset = { ...cell.dataset };\n\n                        if (colIndex < sel.firstCol || colIndex > sel.lastCol) {\n                            newCell.spanAbove = true;\n                        } else {\n                            newCell.isSelected = cell.isSelected;\n                        }\n\n                        return newCell;\n                    }),\n                };\n\n                row.height = newHeight;\n                table.rows.splice(rowIndex + 1, 0, newRow);\n            }\n        }\n    }\n}\n","import { setModelAlignment } from '../../modelApi/block/setModelAlignment';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set text alignment of selected paragraphs\n * @param editor The editor to set alignment\n * @param alignment Alignment value: left, center or right\n */\nexport default function setAlignment(\n    editor: IStandaloneEditor,\n    alignment: 'left' | 'center' | 'right'\n) {\n    editor.focus();\n\n    editor.formatContentModel(model => setModelAlignment(model, alignment), {\n        apiName: 'setAlignment',\n    });\n}\n","import { setModelDirection } from '../../modelApi/block/setModelDirection';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set text direction of selected paragraphs (Left to right or Right to left)\n * @param editor The editor to set alignment\n * @param direction Direction value: ltr (Left to right) or rtl (Right to left)\n */\nexport default function setDirection(editor: IStandaloneEditor, direction: 'ltr' | 'rtl') {\n    editor.focus();\n\n    editor.formatContentModel(model => setModelDirection(model, direction), {\n        apiName: 'setDirection',\n    });\n}\n","import { formatParagraphWithContentModel } from '../utils/formatParagraphWithContentModel';\nimport type {\n    ContentModelParagraphDecorator,\n    IStandaloneEditor,\n} from 'roosterjs-content-model-types';\n\ntype HeadingLevelTags = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n\nconst HeaderFontSizes: Record<HeadingLevelTags, string> = {\n    h1: '2em',\n    h2: '1.5em',\n    h3: '1.17em',\n    h4: '1em',\n    h5: '0.83em',\n    h6: '0.67em',\n};\n\n/**\n * Set heading level of selected paragraphs\n * @param editor The editor to set heading level to\n * @param headingLevel Level of heading, from 1 to 6. Set to 0 means set it back to a regular paragraph\n */\nexport default function setHeadingLevel(\n    editor: IStandaloneEditor,\n    headingLevel: 0 | 1 | 2 | 3 | 4 | 5 | 6\n) {\n    editor.focus();\n\n    formatParagraphWithContentModel(editor, 'setHeadingLevel', para => {\n        const tagName =\n            headingLevel > 0\n                ? (('h' + headingLevel) as HeadingLevelTags | null)\n                : getExistingHeadingTag(para.decorator);\n\n        if (headingLevel > 0) {\n            para.decorator = {\n                tagName: tagName!,\n                format: tagName\n                    ? {\n                          fontWeight: 'bold',\n                          fontSize: HeaderFontSizes[tagName],\n                      }\n                    : {},\n            };\n\n            // Remove existing formats since tags have default font size and weight\n            para.segments.forEach(segment => {\n                delete segment.format.fontSize;\n                delete segment.format.fontWeight;\n            });\n        } else if (tagName) {\n            delete para.decorator;\n        }\n    });\n}\n\nfunction getExistingHeadingTag(\n    decorator?: ContentModelParagraphDecorator\n): HeadingLevelTags | null {\n    const tag = decorator?.tagName || '';\n    const level = parseInt(tag.substring(1));\n\n    return level >= 1 && level <= 6 ? (tag as HeadingLevelTags) : null;\n}\n","import { normalizeContentModel } from 'roosterjs-content-model-dom';\nimport { setModelIndentation } from '../../modelApi/block/setModelIndentation';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Indent or outdent to selected paragraphs\n * @param editor The editor to operate on\n * @param indentation Whether indent or outdent\n * @param length The length of pixel to indent/outdent @default 40\n */\nexport default function setIndentation(\n    editor: IStandaloneEditor,\n    indentation: 'indent' | 'outdent',\n    length?: number\n) {\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            const result = setModelIndentation(model, indentation, length);\n\n            if (result) {\n                normalizeContentModel(model);\n            }\n\n            context.newPendingFormat = 'preserve';\n\n            return result;\n        },\n        {\n            apiName: 'setIndentation',\n        }\n    );\n}\n","import { createParagraphDecorator } from 'roosterjs-content-model-dom';\nimport { formatParagraphWithContentModel } from '../utils/formatParagraphWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggles the current block(s) margin properties.\n * null deletes any existing value, undefined is ignored\n * @param editor The editor to operate on\n * @param marginTop value for top margin\n * @param marginBottom value for bottom margin\n */\nexport default function setParagraphMargin(\n    editor: IStandaloneEditor,\n    marginTop?: string | null,\n    marginBottom?: string | null\n) {\n    editor.focus();\n\n    formatParagraphWithContentModel(editor, 'setParagraphMargin', para => {\n        if (!para.decorator) {\n            para.decorator = createParagraphDecorator('p');\n        }\n\n        if (marginTop) {\n            para.format.marginTop = marginTop;\n        } else if (marginTop === null) {\n            delete para.format.marginTop;\n        }\n\n        if (marginBottom) {\n            para.format.marginBottom = marginBottom;\n        } else if (marginBottom === null) {\n            delete para.format.marginBottom;\n        }\n    });\n}\n","import { formatParagraphWithContentModel } from '../utils/formatParagraphWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Sets current selected block(s) line-height property and wipes such property from child segments\n * @param editor The editor to operate on\n * @param spacing Unitless/px value to set line height\n */\nexport default function setSpacing(editor: IStandaloneEditor, spacing: number | string) {\n    editor.focus();\n\n    formatParagraphWithContentModel(editor, 'setSpacing', paragraph => {\n        paragraph.format.lineHeight = spacing.toString();\n        paragraph.segments.forEach(segment => {\n            if (segment.format.lineHeight) {\n                delete segment.format.lineHeight;\n            }\n        });\n    });\n}\n","import { toggleModelBlockQuote } from '../../modelApi/block/toggleModelBlockQuote';\nimport type {\n    ContentModelFormatContainerFormat,\n    IStandaloneEditor,\n} from 'roosterjs-content-model-types';\n\nconst DefaultQuoteFormat: ContentModelFormatContainerFormat = {\n    borderLeft: '3px solid rgb(200, 200, 200)', // TODO: Support RTL\n    textColor: 'rgb(102, 102, 102)',\n};\nconst BuildInQuoteFormat: ContentModelFormatContainerFormat = {\n    marginTop: '1em',\n    marginBottom: '1em',\n    marginLeft: '40px',\n    marginRight: '40px',\n    paddingLeft: '10px',\n};\n\n/**\n * Toggle BLOCKQUOTE state of selected paragraphs.\n * If any selected paragraph is not under a BLOCKQUOTE, wrap them into a BLOCKQUOTE.\n * Otherwise, unwrap all related BLOCKQUOTEs.\n * @param editor The editor object to toggle BLOCKQUOTE onto\n * @param quoteFormat @optional Block format for the new quote object\n */\nexport default function toggleBlockQuote(\n    editor: IStandaloneEditor,\n    quoteFormat: ContentModelFormatContainerFormat = DefaultQuoteFormat\n) {\n    const fullQuoteFormat = {\n        ...BuildInQuoteFormat,\n        ...quoteFormat,\n    };\n\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            context.newPendingFormat = 'preserve';\n\n            return toggleModelBlockQuote(model, fullQuoteFormat);\n        },\n        {\n            apiName: 'toggleBlockQuote',\n        }\n    );\n}\n","import { ChangeSource } from 'roosterjs-content-model-core';\nimport { createEntity, normalizeContentModel } from 'roosterjs-content-model-dom';\nimport { insertEntityModel } from '../../modelApi/entity/insertEntityModel';\nimport type {\n    ContentModelEntity,\n    DOMSelection,\n    InsertEntityPosition,\n    InsertEntityOptions,\n    IStandaloneEditor,\n} from 'roosterjs-content-model-types';\nimport type { Entity } from 'roosterjs-editor-types';\n\nconst BlockEntityTag = 'div';\nconst InlineEntityTag = 'span';\n\n/**\n * Insert an entity into editor\n * @param editor The Content Model editor\n * @param type Type of entity\n * @param isBlock True to insert a block entity, false to insert an inline entity\n * @param position Position of the entity to insert. It can be\n * Value of InsertEntityPosition: see InsertEntityPosition\n * selectionRangeEx: Use this range instead of current focus position to insert. After insert, focus will be moved to\n * the beginning of this range (when focusAfterEntity is not set to true) or after the new entity (when focusAfterEntity is set to true)\n * @param options Move options to insert. See InsertEntityOptions\n */\nexport default function insertEntity(\n    editor: IStandaloneEditor,\n    type: string,\n    isBlock: boolean,\n    position: 'focus' | 'begin' | 'end' | DOMSelection,\n    options?: InsertEntityOptions\n): ContentModelEntity | null;\n\n/**\n * Insert a block entity into editor\n * @param editor The Content Model editor\n * @param type Type of entity\n * @param isBlock Must be true for a block entity\n * @param position Position of the entity to insert. It can be\n * Value of InsertEntityPosition: see InsertEntityPosition\n * selectionRangeEx: Use this range instead of current focus position to insert. After insert, focus will be moved to\n * the beginning of this range (when focusAfterEntity is not set to true) or after the new entity (when focusAfterEntity is set to true)\n * @param options Move options to insert. See InsertEntityOptions\n */\nexport default function insertEntity(\n    editor: IStandaloneEditor,\n    type: string,\n    isBlock: true,\n    position: InsertEntityPosition | DOMSelection,\n    options?: InsertEntityOptions\n): ContentModelEntity | null;\n\nexport default function insertEntity(\n    editor: IStandaloneEditor,\n    type: string,\n    isBlock: boolean,\n    position?: InsertEntityPosition | DOMSelection,\n    options?: InsertEntityOptions\n): ContentModelEntity | null {\n    const { contentNode, focusAfterEntity, wrapperDisplay, skipUndoSnapshot } = options || {};\n    const wrapper = editor.getDocument().createElement(isBlock ? BlockEntityTag : InlineEntityTag);\n    const display = wrapperDisplay ?? (isBlock ? undefined : 'inline-block');\n\n    wrapper.style.setProperty('display', display || null);\n\n    if (contentNode) {\n        wrapper.appendChild(contentNode);\n    }\n\n    const entityModel = createEntity(wrapper, true /*isReadonly*/, undefined /*format*/, type);\n\n    editor.formatContentModel(\n        (model, context) => {\n            insertEntityModel(\n                model,\n                entityModel,\n                typeof position == 'string' ? position : 'focus',\n                isBlock,\n                focusAfterEntity,\n                context\n            );\n\n            normalizeContentModel(model);\n\n            context.skipUndoSnapshot = skipUndoSnapshot;\n            context.newEntities.push(entityModel);\n\n            return true;\n        },\n        {\n            selectionOverride: typeof position === 'object' ? position : undefined,\n            changeSource: ChangeSource.InsertEntity,\n            getChangeData: () => {\n                // TODO: Remove this entity when we have standalone editor\n                const entity: Entity = {\n                    wrapper,\n                    type,\n                    id: '',\n                    isReadonly: true,\n                };\n\n                return entity;\n            },\n            apiName: 'insertEntity',\n        }\n    );\n\n    return entityModel;\n}\n","import { clearModelFormat } from '../../modelApi/common/clearModelFormat';\nimport { normalizeContentModel } from 'roosterjs-content-model-dom';\nimport type {\n    IStandaloneEditor,\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelSegment,\n    ContentModelTable,\n} from 'roosterjs-content-model-types';\n\n/**\n * Clear format of selection\n * @param editor The editor to clear format from\n */\nexport default function clearFormat(editor: IStandaloneEditor) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            const blocksToClear: [ContentModelBlockGroup[], ContentModelBlock][] = [];\n            const segmentsToClear: ContentModelSegment[] = [];\n            const tablesToClear: [ContentModelTable, boolean][] = [];\n\n            clearModelFormat(model, blocksToClear, segmentsToClear, tablesToClear);\n\n            normalizeContentModel(model);\n\n            return (\n                blocksToClear.length > 0 || segmentsToClear.length > 0 || tablesToClear.length > 0\n            );\n        },\n        {\n            apiName: 'clearFormat',\n        }\n    );\n}\n","import { getSelectionRootNode } from 'roosterjs-content-model-core';\nimport { retrieveModelFormatState } from '../../modelApi/common/retrieveModelFormatState';\nimport type {\n    IStandaloneEditor,\n    ContentModelBlockGroup,\n    ContentModelFormatState,\n    DomToModelContext,\n} from 'roosterjs-content-model-types';\n\nimport {\n    getRegularSelectionOffsets,\n    handleRegularSelection,\n    isNodeOfType,\n    processChildNode,\n} from 'roosterjs-content-model-dom';\n\n/**\n * Get current format state\n * @param editor The editor to get format from\n */\nexport default function getFormatState(editor: IStandaloneEditor): ContentModelFormatState {\n    const pendingFormat = editor.getPendingFormat();\n    const model = editor.createContentModel({\n        processorOverride: {\n            child: reducedModelChildProcessor,\n        },\n    });\n    const result: ContentModelFormatState = {\n        ...editor.getUndoState(),\n        isDarkMode: editor.isDarkMode(),\n        zoomScale: editor.getZoomScale(),\n    };\n\n    retrieveModelFormatState(model, pendingFormat, result);\n\n    return result;\n}\n\n/**\n * @internal\n */\ninterface FormatStateContext extends DomToModelContext {\n    /**\n     * An optional stack of parent elements to process. When provided, the child nodes of current parent element will be ignored,\n     * but use the top element in this stack instead in childProcessor.\n     */\n    nodeStack?: Node[];\n}\n\n/**\n * @internal\n * Export for test only\n * In order to get format, we can still use the regular child processor. However, to improve performance, we don't need to create\n * content model for the whole doc, instead we only need to traverse the tree path that can arrive current selected node.\n * This \"reduced\" child processor will first create a node stack that stores DOM node from root to current common ancestor node of selection,\n * then use this stack as a faked DOM tree to create a reduced content model which we can use to retrieve format state\n */\nexport function reducedModelChildProcessor(\n    group: ContentModelBlockGroup,\n    parent: ParentNode,\n    context: FormatStateContext\n) {\n    if (!context.nodeStack) {\n        const selectionRootNode = getSelectionRootNode(context.selection);\n        context.nodeStack = selectionRootNode ? createNodeStack(parent, selectionRootNode) : [];\n    }\n\n    const stackChild = context.nodeStack.pop();\n\n    if (stackChild) {\n        const [nodeStartOffset, nodeEndOffset] = getRegularSelectionOffsets(context, parent);\n\n        // If selection is not on this node, skip getting node index to save some time since we don't need it here\n        const index =\n            nodeStartOffset >= 0 || nodeEndOffset >= 0 ? getChildIndex(parent, stackChild) : -1;\n\n        if (index >= 0) {\n            handleRegularSelection(index, context, group, nodeStartOffset, nodeEndOffset);\n        }\n\n        processChildNode(group, stackChild, context);\n\n        if (index >= 0) {\n            handleRegularSelection(index + 1, context, group, nodeStartOffset, nodeEndOffset);\n        }\n    } else {\n        // No child node from node stack, that means we have reached the deepest node of selection.\n        // Now we can use default child processor to perform full sub tree scanning for content model,\n        // So that all selected node will be included.\n        context.defaultElementProcessors.child(group, parent, context);\n    }\n}\n\nfunction createNodeStack(root: Node, startNode: Node): Node[] {\n    const result: Node[] = [];\n    let node: Node | null = startNode;\n\n    while (node && root != node && root.contains(node)) {\n        if (isNodeOfType(node, 'ELEMENT_NODE') && node.tagName == 'TABLE') {\n            // For table, we can't do a reduced model creation since we need to handle their cells and indexes,\n            // so clean up whatever we already have, and just put table into the stack\n            result.splice(0, result.length, node);\n        } else {\n            result.push(node);\n        }\n\n        node = node.parentNode;\n    }\n\n    return result;\n}\n\nfunction getChildIndex(parent: ParentNode, stackChild: Node) {\n    let index = 0;\n    let child = parent.firstChild;\n\n    while (child && child != stackChild) {\n        index++;\n        child = child.nextSibling;\n    }\n    return index;\n}\n","import { adjustSegmentSelection } from '../../modelApi/selection/adjustSegmentSelection';\nimport type { ContentModelImage, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Adjust selection to make sure select an image if any\n * @return Content Model Image object if an image is select, or null\n */\nexport default function adjustImageSelection(editor: IStandaloneEditor): ContentModelImage | null {\n    let image: ContentModelImage | null = null;\n\n    editor.formatContentModel(\n        model =>\n            adjustSegmentSelection(\n                model,\n                target => {\n                    if (target.isSelected && target.segmentType == 'Image') {\n                        image = target;\n                        return true;\n                    } else {\n                        return false;\n                    }\n                },\n                (target, ref) => target == ref\n            ),\n        {\n            apiName: 'adjustImageSelection',\n        }\n    );\n\n    return image;\n}\n","import formatImageWithContentModel from '../utils/formatImageWithContentModel';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport { readFile } from '../../modelApi/domUtils/readFile';\nimport { updateImageMetadata } from 'roosterjs-content-model-core';\nimport type { ContentModelImage, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Change the selected image src\n * @param editor The editor instance\n * @param file The image file\n */\nexport default function changeImage(editor: IStandaloneEditor, file: File) {\n    editor.focus();\n\n    const selection = editor.getDOMSelection();\n    readFile(file, dataUrl => {\n        if (dataUrl && !editor.isDisposed() && selection?.type === 'image') {\n            formatImageWithContentModel(editor, 'changeImage', (image: ContentModelImage) => {\n                const originalSrc = updateImageMetadata(image)?.src ?? '';\n                const previousSrc = image.src;\n\n                image.src = dataUrl;\n                image.dataset = {};\n                image.format.width = '';\n                image.format.height = '';\n                image.alt = '';\n\n                editor.triggerPluginEvent(PluginEventType.EditImage, {\n                    image: selection.image,\n                    previousSrc,\n                    newSrc: dataUrl,\n                    originalSrc,\n                });\n            });\n        }\n    });\n}\n","import { addSegment, createContentModelDocument, createImage } from 'roosterjs-content-model-dom';\nimport { mergeModel } from 'roosterjs-content-model-core';\nimport { readFile } from '../../modelApi/domUtils/readFile';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Insert an image into current selected position\n * @param editor The editor to operate on\n * @param file Image Blob file or source string\n */\nexport default function insertImage(editor: IStandaloneEditor, imageFileOrSrc: File | string) {\n    editor.focus();\n\n    if (typeof imageFileOrSrc == 'string') {\n        insertImageWithSrc(editor, imageFileOrSrc);\n    } else {\n        readFile(imageFileOrSrc, dataUrl => {\n            if (dataUrl && !editor.isDisposed()) {\n                insertImageWithSrc(editor, dataUrl);\n            }\n        });\n    }\n}\n\nfunction insertImageWithSrc(editor: IStandaloneEditor, src: string) {\n    editor.formatContentModel(\n        (model, context) => {\n            const image = createImage(src, { backgroundColor: '' });\n            const doc = createContentModelDocument();\n\n            addSegment(doc, image);\n            mergeModel(model, doc, context, {\n                mergeFormat: 'mergeAll',\n            });\n\n            return true;\n        },\n        {\n            apiName: 'insertImage',\n        }\n    );\n}\n","import formatImageWithContentModel from '../utils/formatImageWithContentModel';\nimport type { ContentModelImage, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set image alt text for all selected images at selection. If no images is contained\n * in selection, do nothing.\n * @param editor The editor instance\n * @param altText The image alt text\n */\nexport default function setImageAltText(editor: IStandaloneEditor, altText: string) {\n    editor.focus();\n\n    formatImageWithContentModel(editor, 'setImageAltText', (image: ContentModelImage) => {\n        image.alt = altText;\n    });\n}\n","import applyImageBorderFormat from '../../modelApi/image/applyImageBorderFormat';\nimport formatImageWithContentModel from '../utils/formatImageWithContentModel';\nimport type { Border, ContentModelImage, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set image border style for all selected images at selection.\n * @param editor The editor instance\n * @param border the border format object. Ex: { color: 'red', width: '10px', style: 'solid'}, if one of the value in object is undefined\n * its value will not be changed. Passing null instead of an object will remove the border\n * @param borderRadius the border radius value, if undefined, the border radius will keep the actual value\n */\nexport default function setImageBorder(\n    editor: IStandaloneEditor,\n    border: Border | null,\n    borderRadius?: string\n) {\n    editor.focus();\n\n    formatImageWithContentModel(editor, 'setImageBorder', (image: ContentModelImage) => {\n        applyImageBorderFormat(image, border, borderRadius);\n    });\n}\n","import formatImageWithContentModel from '../utils/formatImageWithContentModel';\nimport type { ContentModelImage, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set image box shadow for all selected images at selection.\n * @param editor The editor instance\n * @param boxShadow The image box boxShadow\n * @param margin The image margin for all sides (eg. \"4px\"), null to remove margin\n */\nexport default function setImageBoxShadow(\n    editor: IStandaloneEditor,\n    boxShadow: string,\n    margin?: string | null\n) {\n    editor.focus();\n\n    formatImageWithContentModel(editor, 'setImageBoxShadow', (image: ContentModelImage) => {\n        image.format.boxShadow = boxShadow;\n        if (margin) {\n            image.format.marginBottom = margin;\n            image.format.marginLeft = margin;\n            image.format.marginRight = margin;\n            image.format.marginTop = margin;\n        } else if (margin === null) {\n            delete image.format.marginBottom;\n            delete image.format.marginLeft;\n            delete image.format.marginRight;\n            delete image.format.marginTop;\n        }\n    });\n}\n","import { adjustSegmentSelection } from '../../modelApi/selection/adjustSegmentSelection';\nimport { adjustWordSelection } from '../../modelApi/selection/adjustWordSelection';\nimport { getSelectedSegments, setSelection } from 'roosterjs-content-model-core';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Adjust selection to make sure select a hyperlink if any, or a word if original selection is collapsed\n * @return A combination of existing link display text and url if any. If there is no existing link, return selected text and null\n */\nexport default function adjustLinkSelection(editor: IStandaloneEditor): [string, string | null] {\n    let text = '';\n    let url: string | null = null;\n\n    editor.formatContentModel(\n        model => {\n            let changed = adjustSegmentSelection(\n                model,\n                target => !!target.isSelected && !!target.link,\n                (target, ref) => !!target.link && target.link.format.href == ref.link!.format.href\n            );\n            let segments = getSelectedSegments(model, false /*includingFormatHolder*/);\n            const firstSegment = segments[0];\n\n            if (segments.length == 1 && firstSegment.segmentType == 'SelectionMarker') {\n                segments = adjustWordSelection(model, firstSegment);\n\n                if (segments.length > 1) {\n                    changed = true;\n                    setSelection(model, segments[0], segments[segments.length - 1]);\n                }\n            }\n\n            text = segments.map(x => (x.segmentType == 'Text' ? x.text : '')).join('');\n            url = segments[0]?.link?.format.href || null;\n\n            return changed;\n        },\n        {\n            apiName: 'adjustLinkSelection',\n        }\n    );\n\n    return [text, url];\n}\n","import { ChangeSource, getSelectedSegments, mergeModel } from 'roosterjs-content-model-core';\nimport { HtmlSanitizer, matchLink } from 'roosterjs-editor-dom';\nimport type { ContentModelLink, IStandaloneEditor } from 'roosterjs-content-model-types';\nimport {\n    addLink,\n    addSegment,\n    createContentModelDocument,\n    createText,\n} from 'roosterjs-content-model-dom';\n\n// Regex matching Uri scheme\nconst URI_REGEX = /^[a-zA-Z]+:/i;\n// Regex matching begin of email address\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\nconst FTP_REGEX = /^ftp\\./i;\n\n/**\n * Insert a hyperlink at cursor.\n * When there is a selection, hyperlink will be applied to the selection,\n * otherwise a hyperlink will be inserted to the cursor position.\n * @param editor Editor object\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\n * When protocol is not specified, a best matched protocol will be predicted.\n * @param anchorTitle Optional alt text of the link, will be shown when hover on the link\n * @param displayText Optional display text for the link.\n * @param target Optional display target for the link (\"_blank\"|\"_self\"|\"_parent\"|\"_top\"|\"{framename}\")\n * If specified, the display text of link will be replaced with this text.\n * If not specified and there wasn't a link, the link url will be used as display text.\n */\nexport default function insertLink(\n    editor: IStandaloneEditor,\n    link: string,\n    anchorTitle?: string,\n    displayText?: string,\n    target?: string\n) {\n    editor.focus();\n\n    const url = (checkXss(link) || '').trim();\n    if (url) {\n        const linkData = matchLink(url);\n        const linkUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\n        const links: ContentModelLink[] = [];\n        let anchorNode: Node | undefined;\n\n        editor.formatContentModel(\n            (model, context) => {\n                const segments = getSelectedSegments(model, false /*includingFormatHolder*/);\n                const originalText = segments\n                    .map(x => (x.segmentType == 'Text' ? x.text : ''))\n                    .join('');\n                const text = displayText || originalText || '';\n\n                if (\n                    segments.some(x => x.segmentType != 'SelectionMarker') &&\n                    originalText == text\n                ) {\n                    segments.forEach(x => {\n                        const link = createLink(\n                            linkUrl,\n                            anchorTitle,\n                            target,\n                            x.segmentType == 'Text'\n                        );\n                        addLink(x, link);\n                        if (x.link) {\n                            links.push(x.link);\n                        }\n                    });\n                } else if (\n                    segments.every(x => x.segmentType == 'SelectionMarker') ||\n                    (!!text && text != originalText)\n                ) {\n                    const segment = createText(text || (linkData ? linkData.originalUrl : url), {\n                        ...segments[0]?.format,\n                        ...editor.getPendingFormat(),\n                    });\n                    const doc = createContentModelDocument();\n                    const link = createLink(linkUrl, anchorTitle, target);\n\n                    addLink(segment, link);\n                    addSegment(doc, segment);\n\n                    if (segment.link) {\n                        links.push(segment.link);\n                    }\n\n                    mergeModel(model, doc, context, {\n                        mergeFormat: 'mergeAll',\n                    });\n                }\n\n                return segments.length > 0;\n            },\n            {\n                changeSource: ChangeSource.CreateLink,\n                onNodeCreated: (modelElement, node) => {\n                    if (!anchorNode && links.indexOf(modelElement as ContentModelLink) >= 0) {\n                        anchorNode = node;\n                    }\n                },\n                getChangeData: () => anchorNode,\n                apiName: 'insertLink',\n            }\n        );\n    }\n}\n\nconst createLink = (\n    url: string,\n    anchorTitle?: string,\n    target?: string,\n    underline: boolean = true\n): ContentModelLink => {\n    return {\n        dataset: {},\n        format: {\n            href: url,\n            anchorTitle,\n            target,\n            underline: underline,\n        },\n    };\n};\n\n// TODO: This is copied from original code. We may need to integrate this logic into matchLink() later.\nfunction applyLinkPrefix(url: string): string {\n    if (!url) {\n        return url;\n    }\n\n    // Add link prefix per rule:\n    // (a) if the url always starts with a URI scheme, leave it as it is\n    // (b) if the url is an email address, xxx@... add mailto: prefix\n    // (c) if the url starts with ftp., add ftp:// prefix\n    // (d) rest, add http:// prefix\n    let prefix = '';\n    if (url.search(URI_REGEX) < 0) {\n        if (url.search(MAILTO_REGEX) == 0) {\n            prefix = 'mailto:';\n        } else if (url.search(FTP_REGEX) == 0) {\n            prefix = 'ftp://';\n        } else {\n            // fallback to http://\n            prefix = 'http://';\n        }\n    }\n\n    return prefix + url;\n}\n\n// TODO: This is copied from original code. However, ContentModel should be able to filter out malicious\n// attributes later, so no need to use HtmlSanitizer here\nfunction checkXss(link: string): string {\n    const sanitizer = new HtmlSanitizer();\n    const a = document.createElement('a');\n\n    a.href = link || '';\n\n    sanitizer.sanitize(a);\n    // We use getAttribute because some browsers will try to make the href property a valid link.\n    // This has unintended side effects when the link lacks a protocol.\n    return a.getAttribute('href') || '';\n}\n","import { adjustSegmentSelection } from '../../modelApi/selection/adjustSegmentSelection';\nimport { getSelectedSegments } from 'roosterjs-content-model-core';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Remove link at selection. If no links at selection, do nothing.\n * If selection contains multiple links, all of the link styles will be removed.\n * If only part of a link is selected, the whole link style will be removed.\n * @param editor The editor instance\n */\nexport default function removeLink(editor: IStandaloneEditor) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            adjustSegmentSelection(\n                model,\n                target => !!target.isSelected && !!target.link,\n                (target, ref) =>\n                    target.isSelected || // Expand the selection to any link that is involved. So we can remove multiple links together\n                    (!!target.link && target.link.format.href == ref.link!.format.href)\n            );\n\n            const segments = getSelectedSegments(model, false /*includingFormatHolder*/);\n            let isChanged = false;\n\n            segments.forEach(segment => {\n                if (segment.link) {\n                    isChanged = true;\n\n                    delete segment.link;\n                }\n            });\n\n            return isChanged;\n        },\n        {\n            apiName: 'removeLink',\n        }\n    );\n}\n","import { getFirstSelectedListItem } from 'roosterjs-content-model-core';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set start number of a list item\n * @param editor The editor to operate on\n * @param value The number to set to, must be equal or greater than 1\n */\nexport default function setListStartNumber(editor: IStandaloneEditor, value: number) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            const listItem = getFirstSelectedListItem(model);\n            const level = listItem?.levels[listItem?.levels.length - 1];\n\n            if (level) {\n                level.format.startNumberOverride = value;\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'setListStartNumber',\n        }\n    );\n}\n","import { findListItemsInSameThread } from '../../modelApi/list/findListItemsInSameThread';\nimport { getFirstSelectedListItem, updateListMetadata } from 'roosterjs-content-model-core';\nimport type { IStandaloneEditor, ListMetadataFormat } from 'roosterjs-content-model-types';\n\n/**\n * Set style of list items with in same thread of current item\n * @param editor The editor to operate on\n * @param style The target list item style to set\n */\nexport default function setListStyle(editor: IStandaloneEditor, style: ListMetadataFormat) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            const listItem = getFirstSelectedListItem(model);\n\n            if (listItem) {\n                const listItems = findListItemsInSameThread(model, listItem);\n                const levelIndex = listItem.levels.length - 1;\n\n                listItems.forEach(listItem => {\n                    const level = listItem.levels[levelIndex];\n\n                    if (level) {\n                        updateListMetadata(level, metadata => Object.assign({}, metadata, style));\n                    }\n                });\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'setListStyle',\n        }\n    );\n}\n","import { setListType } from '../../modelApi/list/setListType';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle bullet list type\n * - When there are some blocks not in bullet list, set all blocks to the given type\n * - When all blocks are already in bullet list, turn off / outdent there list type\n * @param editor The editor to operate on\n */\nexport default function toggleBullet(editor: IStandaloneEditor) {\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            context.newPendingFormat = 'preserve';\n\n            return setListType(model, 'UL');\n        },\n        {\n            apiName: 'toggleBullet',\n        }\n    );\n}\n","import { setListType } from '../../modelApi/list/setListType';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle numbering list type\n * - When there are some blocks not in numbering list, set all blocks to the given type\n * - When all blocks are already in numbering list, turn off / outdent there list type\n * @param editor The editor to operate on\n */\nexport default function toggleNumbering(editor: IStandaloneEditor) {\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            context.newPendingFormat = 'preserve';\n\n            return setListType(model, 'OL');\n        },\n        {\n            apiName: 'toggleNumbering',\n        }\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { ContentModelSegmentFormat, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Bulk apply segment format to all selected content. This is usually used for format painter.\n * @param editor The editor to operate on\n * @param newFormat The segment format to apply\n */\nexport default function applySegmentFormat(\n    editor: IStandaloneEditor,\n    newFormat: ContentModelSegmentFormat\n) {\n    formatSegmentWithContentModel(\n        editor,\n        'applySegmentFormat',\n        format => {\n            format.backgroundColor = newFormat.backgroundColor;\n            format.fontFamily = newFormat.fontFamily;\n            format.fontSize = newFormat.fontSize;\n            format.fontWeight = newFormat.fontWeight;\n            format.italic = newFormat.italic;\n            format.strikethrough = newFormat.strikethrough;\n            format.superOrSubScriptSequence = newFormat.superOrSubScriptSequence;\n            format.textColor = newFormat.textColor;\n            format.underline = newFormat.underline;\n        },\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Change the capitalization of text in the selection\n * @param editor The editor instance\n * @param capitalization The case option\n * @param language Optional parameter for language string that should comply to \"IETF BCP 47 Tags for\n * Identifying Languages\". For example: 'en' or 'en-US' for English, 'tr' for Turkish.\n * Default is the host environment’s current locale.\n */\nexport default function changeCapitalization(\n    editor: IStandaloneEditor,\n    capitalization: 'sentence' | 'lowerCase' | 'upperCase' | 'capitalize',\n    language?: string\n) {\n    editor.focus();\n\n    formatSegmentWithContentModel(editor, 'changeCapitalization', (_, __, segment) => {\n        if (segment?.segmentType == 'Text') {\n            switch (capitalization) {\n                case 'lowerCase':\n                    segment.text = segment.text.toLocaleLowerCase(language);\n                    break;\n\n                case 'upperCase':\n                    segment.text = segment.text.toLocaleUpperCase(language);\n                    break;\n\n                case 'capitalize':\n                    const wordArray = segment.text.toLocaleLowerCase(language).split(' ');\n\n                    for (let i = 0; i < wordArray.length; i++) {\n                        wordArray[i] =\n                            wordArray[i].charAt(0).toLocaleUpperCase(language) +\n                            wordArray[i].slice(1);\n                    }\n\n                    segment.text = wordArray.join(' ');\n                    break;\n\n                case 'sentence':\n                    // TODO: Add rules on punctuation for internationalization - TASK 104769\n                    const punctuationMarks = '[\\\\.\\\\!\\\\?]';\n                    // Find a match of a word character either:\n                    // - At the beginning of a string with or without preceding whitespace, for\n                    // example: '  hello world' and 'hello world' strings would both match 'h'.\n                    // - Or preceded by a punctuation mark and at least one whitespace, for\n                    // example 'yes. hello world' would match 'y' and 'h'.\n                    const regex = new RegExp('^\\\\s*\\\\w|' + punctuationMarks + '\\\\s+\\\\w', 'g');\n\n                    segment.text = segment.text\n                        .toLocaleLowerCase(language)\n                        .replace(regex, match => match.toLocaleUpperCase(language));\n                    break;\n            }\n        }\n    });\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport { parseValueWithUnit } from 'roosterjs-content-model-dom';\nimport { setFontSizeInternal } from './setFontSize';\nimport type {\n    ContentModelParagraph,\n    ContentModelSegmentFormat,\n    IStandaloneEditor,\n} from 'roosterjs-content-model-types';\n\n/**\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\n */\nconst FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\nconst MIN_FONT_SIZE = 1;\nconst MAX_FONT_SIZE = 1000;\n\n/**\n * Increase or decrease font size in selection\n * @param editor The editor instance\n * @param change Whether increase or decrease font size\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\n */\nexport default function changeFontSize(editor: IStandaloneEditor, change: 'increase' | 'decrease') {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'changeFontSize',\n        (format, _, __, paragraph) => changeFontSizeInternal(change, format, paragraph),\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n\nfunction changeFontSizeInternal(\n    change: 'increase' | 'decrease',\n    format: ContentModelSegmentFormat,\n    paragraph: ContentModelParagraph | null\n) {\n    if (format.fontSize) {\n        const sizeInPt = parseValueWithUnit(format.fontSize, undefined /*element*/, 'pt');\n\n        if (sizeInPt > 0) {\n            const newSize = getNewFontSize(sizeInPt, change == 'increase' ? 1 : -1, FONT_SIZES);\n\n            setFontSizeInternal(newSize + 'pt', format, paragraph);\n        }\n    }\n}\n\nfunction getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\n    const last = fontSizes[fontSizes.length - 1];\n    if (pt <= fontSizes[0]) {\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\n    } else if (pt > last || (pt == last && changeBase == 1)) {\n        pt = pt / 10;\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\n    } else if (changeBase == 1) {\n        for (let i = 0; i < fontSizes.length; i++) {\n            if (pt < fontSizes[i]) {\n                pt = fontSizes[i];\n                break;\n            }\n        }\n    } else {\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\n            if (pt > fontSizes[i]) {\n                pt = fontSizes[i];\n                break;\n            }\n        }\n    }\n    return pt;\n}\n","import { createSelectionMarker } from 'roosterjs-content-model-dom';\nimport { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport { setSelection } from 'roosterjs-content-model-core';\nimport type { ContentModelParagraph, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set background color\n * @param editor The editor to operate on\n * @param backgroundColor The color to set. Pass null to remove existing color.\n */\nexport default function setBackgroundColor(\n    editor: IStandaloneEditor,\n    backgroundColor: string | null\n) {\n    editor.focus();\n\n    let lastParagraph: ContentModelParagraph | null = null;\n    let lastSegmentIndex: number = -1;\n\n    formatSegmentWithContentModel(\n        editor,\n        'setBackgroundColor',\n        (format, _, segment, paragraph) => {\n            if (backgroundColor === null) {\n                delete format.backgroundColor;\n            } else {\n                format.backgroundColor = backgroundColor;\n            }\n\n            if (segment && paragraph && segment.segmentType != 'SelectionMarker') {\n                lastParagraph = paragraph;\n                lastSegmentIndex = lastParagraph.segments.indexOf(segment);\n            }\n        },\n        undefined /*segmentHasStyleCallback*/,\n        undefined /*includingFormatHolder*/,\n        model => {\n            if (lastParagraph && lastSegmentIndex >= 0) {\n                const marker = createSelectionMarker(\n                    lastParagraph.segments[lastSegmentIndex]?.format\n                );\n\n                lastParagraph.segments.splice(lastSegmentIndex + 1, 0, marker);\n                setSelection(model, marker, marker);\n            }\n        }\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set font name\n * @param editor The editor to operate on\n * @param fontName The font name to set\n */\nexport default function setFontName(editor: IStandaloneEditor, fontName: string) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'setFontName',\n        (format, _, segment) => {\n            format.fontFamily = fontName;\n\n            if (segment?.code) {\n                segment.code.format.fontFamily = fontName;\n            }\n        },\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type {\n    ContentModelParagraph,\n    ContentModelSegmentFormat,\n    IStandaloneEditor,\n} from 'roosterjs-content-model-types';\n\n/**\n * Set font size\n * @param editor The editor to operate on\n * @param fontSize The font size to set\n */\nexport default function setFontSize(editor: IStandaloneEditor, fontSize: string) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'setFontSize',\n        (format, _, __, paragraph) => setFontSizeInternal(fontSize, format, paragraph),\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n\n/**\n * @internal\n * Internal set font function shared by setFontSize and changeFontSize\n */\nexport function setFontSizeInternal(\n    fontSize: string,\n    format: ContentModelSegmentFormat,\n    paragraph: ContentModelParagraph | null\n) {\n    format.fontSize = fontSize;\n\n    // Since we have set font size to segment, it can be smaller than the one in paragraph format, so delete font size from paragraph\n    if (paragraph?.segmentFormat?.fontSize) {\n        const size = paragraph.segmentFormat.fontSize;\n\n        paragraph.segments.forEach(segment => {\n            if (!segment.format.fontSize) {\n                segment.format.fontSize = size;\n            }\n        });\n\n        delete paragraph.segmentFormat.fontSize;\n    }\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set text color\n * @param editor The editor to operate on\n * @param textColor The text color to set. Pass null to remove existing color.\n */\nexport default function setTextColor(editor: IStandaloneEditor, textColor: string | null) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'setTextColor',\n        textColor === null\n            ? (format, _, segment) => {\n                  delete format.textColor;\n\n                  if (segment?.link) {\n                      delete segment.link.format.textColor;\n                  }\n              }\n            : (format, _, segment) => {\n                  format.textColor = textColor;\n\n                  if (segment?.link) {\n                      segment.link.format.textColor = textColor;\n                  }\n              },\n        undefined /* segmentHasStyleCallback*/,\n        true /*includingFormatHandler*/\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport { isBold } from 'roosterjs-content-model-core';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle bold style\n * @param editor The editor to operate on\n */\nexport default function toggleBold(editor: IStandaloneEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleBold',\n        (format, isTurningOn) => {\n            format.fontWeight = isTurningOn ? 'bold' : 'normal';\n        },\n        (format, _, paragraph) =>\n            isBold(\n                typeof format.fontWeight == 'undefined'\n                    ? paragraph?.decorator?.format.fontWeight\n                    : format.fontWeight\n            )\n    );\n}\n","import { addCode } from 'roosterjs-content-model-dom';\nimport { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { ContentModelCode, IStandaloneEditor } from 'roosterjs-content-model-types';\n\nconst DefaultCode: ContentModelCode = {\n    format: {\n        fontFamily: 'monospace',\n    },\n};\n\n/**\n * Toggle italic style\n * @param editor The editor to operate on\n */\nexport default function toggleCode(editor: IStandaloneEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleCode',\n        (_, isTurningOn, segment) => {\n            if (segment) {\n                if (isTurningOn) {\n                    addCode(segment, DefaultCode);\n                } else {\n                    delete segment.code;\n                }\n            }\n        },\n        (_, segment) => !!segment?.code\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle italic style\n * @param editor The editor to operate on\n */\nexport default function toggleItalic(editor: IStandaloneEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleItalic',\n        (format, isTurningOn) => {\n            format.italic = !!isTurningOn;\n        },\n        format => !!format.italic\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle strikethrough style\n * @param editor The editor to operate on\n */\nexport default function toggleStrikethrough(editor: IStandaloneEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleStrikethrough',\n        (format, isTurningOn) => {\n            format.strikethrough = !!isTurningOn;\n        },\n        format => !!format.strikethrough\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle subscript style\n * @param editor The editor to operate on\n */\nexport default function toggleSubscript(editor: IStandaloneEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleSubscript',\n        (format, isTurningOn) => {\n            format.superOrSubScriptSequence = isTurningOn ? 'sub' : '';\n        },\n        format => format.superOrSubScriptSequence?.split(' ').pop() == 'sub'\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle superscript style\n * @param editor The editor to operate on\n */\nexport default function toggleSuperscript(editor: IStandaloneEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleSuperscript',\n        (format, isTurningOn) => {\n            format.superOrSubScriptSequence = isTurningOn ? 'super' : '';\n        },\n        format => format.superOrSubScriptSequence?.split(' ').pop() == 'super'\n    );\n}\n","import { formatSegmentWithContentModel } from '../utils/formatSegmentWithContentModel';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Toggle underline style\n * @param editor The editor to operate on\n */\nexport default function toggleUnderline(editor: IStandaloneEditor) {\n    editor.focus();\n\n    formatSegmentWithContentModel(\n        editor,\n        'toggleUnderline',\n        (format, isTurningOn, segment) => {\n            format.underline = !!isTurningOn;\n\n            if (segment?.link) {\n                segment.link.format.underline = !!isTurningOn;\n            }\n        },\n        (format, segment) => !!format.underline || !!segment?.link?.format?.underline\n    );\n}\n","import hasSelectionInBlockGroup from './hasSelectionInBlockGroup';\nimport hasSelectionInSegment from './hasSelectionInSegment';\nimport type { ContentModelBlock } from 'roosterjs-content-model-types';\n\n/**\n * Check if there is selection within the given block\n * @param block The block to check\n */\nexport default function hasSelectionInBlock(block: ContentModelBlock): boolean {\n    switch (block.blockType) {\n        case 'Paragraph':\n            return block.segments.some(hasSelectionInSegment);\n\n        case 'Table':\n            return block.rows.some(row => row.cells.some(hasSelectionInBlockGroup));\n\n        case 'BlockGroup':\n            return hasSelectionInBlockGroup(block);\n\n        case 'Divider':\n        case 'Entity':\n            return !!block.isSelected;\n\n        default:\n            return false;\n    }\n}\n","import hasSelectionInBlock from './hasSelectionInBlock';\nimport type { ContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * Check if there is selection within the given block\n * @param block The block to check\n */\nexport default function hasSelectionInBlockGroup(group: ContentModelBlockGroup): boolean {\n    if (group.blockGroupType == 'TableCell' && group.isSelected) {\n        return true;\n    }\n\n    if (group.blocks.some(hasSelectionInBlock)) {\n        return true;\n    }\n\n    return false;\n}\n","import hasSelectionInBlock from './hasSelectionInBlock';\nimport type { ContentModelSegment } from 'roosterjs-content-model-types';\n\n/**\n * Check if there is selection within the given segment\n * @param segment The segment to check\n */\nexport default function hasSelectionInSegment(segment: ContentModelSegment): boolean {\n    return (\n        segment.isSelected ||\n        (segment.segmentType == 'General' && segment.blocks.some(hasSelectionInBlock))\n    );\n}\n","import { getSelectedCells } from '../../modelApi/table/getSelectedCells';\nimport { parseValueWithUnit } from 'roosterjs-content-model-dom';\nimport {\n    extractBorderValues,\n    getFirstSelectedTable,\n    updateTableCellMetadata,\n} from 'roosterjs-content-model-core';\nimport type {\n    IStandaloneEditor,\n    Border,\n    ContentModelTable,\n    ContentModelTableCell,\n    BorderOperations,\n} from 'roosterjs-content-model-types';\nimport type { TableSelectionCoordinates } from '../../modelApi/table/getSelectedCells';\n\n/**\n * @internal\n * Border positions\n */\ntype BorderPositions = 'borderTop' | 'borderBottom' | 'borderLeft' | 'borderRight';\n\n/**\n * @internal\n * Perimeter of the table selection\n * Used to determine where to apply border to the cells adjacent to the selection.\n */\ntype Perimeter = {\n    Top: boolean;\n    Bottom: boolean;\n    Left: boolean;\n    Right: boolean;\n};\n\n/**\n * Operations to apply border\n * @param editor The editor instance\n * @param border The border to apply\n * @param operation The operation to apply\n */\nexport default function applyTableBorderFormat(\n    editor: IStandaloneEditor,\n    border: Border,\n    operation: BorderOperations\n) {\n    editor.formatContentModel(\n        model => {\n            const [tableModel] = getFirstSelectedTable(model);\n\n            if (tableModel) {\n                const sel = getSelectedCells(tableModel);\n                const perimeter: Perimeter = {\n                    Top: false,\n                    Bottom: false,\n                    Left: false,\n                    Right: false,\n                };\n\n                // Create border format with table format as backup\n                let borderFormat = '';\n                const format = tableModel.format;\n                const { width, style, color } = border;\n                const extractedBorder = extractBorderValues(format.borderTop);\n                const borderColor = extractedBorder.color;\n                const borderWidth = extractedBorder.width;\n                const borderStyle = extractedBorder.style;\n\n                if (width) {\n                    borderFormat = parseValueWithUnit(width) + 'px';\n                } else if (borderWidth) {\n                    borderFormat = borderWidth;\n                } else {\n                    borderFormat = '1px';\n                }\n\n                if (style) {\n                    borderFormat = `${borderFormat} ${style}`;\n                } else if (borderStyle) {\n                    borderFormat = `${borderFormat} ${borderStyle}`;\n                } else {\n                    borderFormat = `${borderFormat} solid`;\n                }\n\n                if (color) {\n                    borderFormat = `${borderFormat} ${color}`;\n                } else if (borderColor) {\n                    borderFormat = `${borderFormat} ${borderColor}`;\n                }\n\n                if (sel) {\n                    const operations: BorderOperations[] = [operation];\n                    while (operations.length) {\n                        switch (operations.pop()) {\n                            case 'noBorders':\n                                // Do All borders but with empty border format\n                                borderFormat = '';\n                                operations.push('allBorders');\n                                break;\n                            case 'allBorders':\n                                const allBorders: BorderPositions[] = [\n                                    'borderTop',\n                                    'borderBottom',\n                                    'borderLeft',\n                                    'borderRight',\n                                ];\n                                for (\n                                    let rowIndex = sel.firstRow;\n                                    rowIndex <= sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    for (\n                                        let colIndex = sel.firstCol;\n                                        colIndex <= sel.lastCol;\n                                        colIndex++\n                                    ) {\n                                        const cell = tableModel.rows[rowIndex].cells[colIndex];\n                                        // Format cells - All borders\n                                        applyBorderFormat(cell, borderFormat, allBorders);\n                                    }\n                                }\n\n                                // Format perimeter\n                                perimeter.Top = true;\n                                perimeter.Bottom = true;\n                                perimeter.Left = true;\n                                perimeter.Right = true;\n                                break;\n                            case 'leftBorders':\n                                const leftBorder: BorderPositions[] = ['borderLeft'];\n                                for (\n                                    let rowIndex = sel.firstRow;\n                                    rowIndex <= sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    const cell = tableModel.rows[rowIndex].cells[sel.firstCol];\n                                    // Format cells - Left border\n                                    applyBorderFormat(cell, borderFormat, leftBorder);\n                                }\n\n                                // Format perimeter\n                                perimeter.Left = true;\n                                break;\n                            case 'rightBorders':\n                                const rightBorder: BorderPositions[] = ['borderRight'];\n                                for (\n                                    let rowIndex = sel.firstRow;\n                                    rowIndex <= sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    const cell = tableModel.rows[rowIndex].cells[sel.lastCol];\n                                    // Format cells - Right border\n                                    applyBorderFormat(cell, borderFormat, rightBorder);\n                                }\n\n                                // Format perimeter\n                                perimeter.Right = true;\n                                break;\n                            case 'topBorders':\n                                const topBorder: BorderPositions[] = ['borderTop'];\n                                for (\n                                    let colIndex = sel.firstCol;\n                                    colIndex <= sel.lastCol;\n                                    colIndex++\n                                ) {\n                                    const cell = tableModel.rows[sel.firstRow].cells[colIndex];\n                                    // Format cells - Top border\n                                    applyBorderFormat(cell, borderFormat, topBorder);\n                                }\n\n                                // Format perimeter\n                                perimeter.Top = true;\n                                break;\n                            case 'bottomBorders':\n                                const bottomBorder: BorderPositions[] = ['borderBottom'];\n                                for (\n                                    let colIndex = sel.firstCol;\n                                    colIndex <= sel.lastCol;\n                                    colIndex++\n                                ) {\n                                    const cell = tableModel.rows[sel.lastRow].cells[colIndex];\n                                    // Format cells - Bottom border\n                                    applyBorderFormat(cell, borderFormat, bottomBorder);\n                                }\n\n                                // Format perimeter\n                                perimeter.Bottom = true;\n                                break;\n                            case 'insideBorders':\n                                // Format cells - Inside borders\n                                const singleCol = sel.lastCol == sel.firstCol;\n                                const singleRow = sel.lastRow == sel.firstRow;\n                                // Single cell selection\n                                if (singleCol && singleRow) {\n                                    break;\n                                }\n                                // Single column selection\n                                if (singleCol) {\n                                    applyBorderFormat(\n                                        tableModel.rows[sel.firstRow].cells[sel.firstCol],\n                                        borderFormat,\n                                        ['borderBottom']\n                                    );\n                                    for (\n                                        let rowIndex = sel.firstRow + 1;\n                                        rowIndex <= sel.lastRow - 1;\n                                        rowIndex++\n                                    ) {\n                                        const cell = tableModel.rows[rowIndex].cells[sel.firstCol];\n                                        applyBorderFormat(cell, borderFormat, [\n                                            'borderTop',\n                                            'borderBottom',\n                                        ]);\n                                    }\n                                    applyBorderFormat(\n                                        tableModel.rows[sel.lastRow].cells[sel.firstCol],\n                                        borderFormat,\n                                        ['borderTop']\n                                    );\n                                    break;\n                                }\n                                // Single row selection\n                                if (singleRow) {\n                                    applyBorderFormat(\n                                        tableModel.rows[sel.firstRow].cells[sel.firstCol],\n                                        borderFormat,\n                                        ['borderRight']\n                                    );\n                                    for (\n                                        let colIndex = sel.firstCol + 1;\n                                        colIndex <= sel.lastCol - 1;\n                                        colIndex++\n                                    ) {\n                                        const cell = tableModel.rows[sel.firstRow].cells[colIndex];\n                                        applyBorderFormat(cell, borderFormat, [\n                                            'borderLeft',\n                                            'borderRight',\n                                        ]);\n                                    }\n                                    applyBorderFormat(\n                                        tableModel.rows[sel.firstRow].cells[sel.lastCol],\n                                        borderFormat,\n                                        ['borderLeft']\n                                    );\n                                    break;\n                                }\n\n                                // For multiple rows and columns selections\n                                // Top left cell\n                                applyBorderFormat(\n                                    tableModel.rows[sel.firstRow].cells[sel.firstCol],\n                                    borderFormat,\n                                    ['borderBottom', 'borderRight']\n                                );\n                                // Top right cell\n                                applyBorderFormat(\n                                    tableModel.rows[sel.firstRow].cells[sel.lastCol],\n                                    borderFormat,\n                                    ['borderBottom', 'borderLeft']\n                                );\n                                // Bottom left cell\n                                applyBorderFormat(\n                                    tableModel.rows[sel.lastRow].cells[sel.firstCol],\n                                    borderFormat,\n                                    ['borderTop', 'borderRight']\n                                );\n                                // Bottom right cell\n                                applyBorderFormat(\n                                    tableModel.rows[sel.lastRow].cells[sel.lastCol],\n                                    borderFormat,\n                                    ['borderTop', 'borderLeft']\n                                );\n                                // First row\n                                for (\n                                    let colIndex = sel.firstCol + 1;\n                                    colIndex < sel.lastCol;\n                                    colIndex++\n                                ) {\n                                    const cell = tableModel.rows[sel.firstRow].cells[colIndex];\n                                    applyBorderFormat(cell, borderFormat, [\n                                        'borderBottom',\n                                        'borderLeft',\n                                        'borderRight',\n                                    ]);\n                                }\n                                // Last row\n                                for (\n                                    let colIndex = sel.firstCol + 1;\n                                    colIndex < sel.lastCol;\n                                    colIndex++\n                                ) {\n                                    const cell = tableModel.rows[sel.lastRow].cells[colIndex];\n                                    applyBorderFormat(cell, borderFormat, [\n                                        'borderTop',\n                                        'borderLeft',\n                                        'borderRight',\n                                    ]);\n                                }\n                                // First column\n                                for (\n                                    let rowIndex = sel.firstRow + 1;\n                                    rowIndex < sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    const cell = tableModel.rows[rowIndex].cells[sel.firstCol];\n                                    applyBorderFormat(cell, borderFormat, [\n                                        'borderTop',\n                                        'borderBottom',\n                                        'borderRight',\n                                    ]);\n                                }\n                                // Last column\n                                for (\n                                    let rowIndex = sel.firstRow + 1;\n                                    rowIndex < sel.lastRow;\n                                    rowIndex++\n                                ) {\n                                    const cell = tableModel.rows[rowIndex].cells[sel.lastCol];\n                                    applyBorderFormat(cell, borderFormat, [\n                                        'borderTop',\n                                        'borderBottom',\n                                        'borderLeft',\n                                    ]);\n                                }\n                                // Inner cells\n                                sel.firstCol++;\n                                sel.firstRow++;\n                                sel.lastCol--;\n                                sel.lastRow--;\n                                operations.push('allBorders');\n                                break;\n                            case 'outsideBorders':\n                                // Format cells - Outside borders\n                                operations.push('topBorders');\n                                operations.push('bottomBorders');\n                                operations.push('leftBorders');\n                                operations.push('rightBorders');\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n\n                    //Format perimeter if necessary or possible\n                    modifyPerimeter(tableModel, sel, borderFormat, perimeter);\n                }\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'tableBorder',\n        }\n    );\n}\n\n/**\n * @internal\n * Apply border format to a cell\n * @param cell The cell to apply border format\n * @param borderFormat The border format to apply\n * @param positions The positions to apply\n */\nfunction applyBorderFormat(\n    cell: ContentModelTableCell,\n    borderFormat: string,\n    positions: BorderPositions[]\n) {\n    positions.forEach(pos => {\n        cell.format[pos] = borderFormat;\n    });\n\n    updateTableCellMetadata(cell, metadata => {\n        metadata = metadata || {};\n        metadata.borderOverride = true;\n        return metadata;\n    });\n\n    // Cell was modified, so delete cached element\n    delete cell.cachedElement;\n}\n\n/**\n * @internal\n * Modify the perimeter of the table selection\n * @param tableModel The table model\n * @param sel The table selection\n * @param borderFormat The border format to apply\n * If borderFormat is empty, the border will be removed\n * @param perimeter Where in the perimeter to apply\n */\nfunction modifyPerimeter(\n    tableModel: ContentModelTable,\n    sel: TableSelectionCoordinates,\n    borderFormat: string,\n    perimeter: Perimeter\n) {\n    // Top of selection\n    if (perimeter.Top && sel.firstRow - 1 >= 0) {\n        for (let colIndex = sel.firstCol; colIndex <= sel.lastCol; colIndex++) {\n            const cell = tableModel.rows[sel.firstRow - 1].cells[colIndex];\n            applyBorderFormat(cell, borderFormat, ['borderBottom']);\n        }\n    }\n    // Bottom of selection\n    if (perimeter.Bottom && sel.lastRow + 1 < tableModel.rows.length) {\n        for (let colIndex = sel.firstCol; colIndex <= sel.lastCol; colIndex++) {\n            const cell = tableModel.rows[sel.lastRow + 1].cells[colIndex];\n            applyBorderFormat(cell, borderFormat, ['borderTop']);\n        }\n    }\n    // Left of selection\n    if (perimeter.Left && sel.firstCol - 1 >= 0) {\n        for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n            const cell = tableModel.rows[rowIndex].cells[sel.firstCol - 1];\n            applyBorderFormat(cell, borderFormat, ['borderRight']);\n        }\n    }\n    // Right of selection\n    if (perimeter.Right && sel.lastCol + 1 < tableModel.rows[0].cells.length) {\n        for (let rowIndex = sel.firstRow; rowIndex <= sel.lastRow; rowIndex++) {\n            const cell = tableModel.rows[rowIndex].cells[sel.lastCol + 1];\n            applyBorderFormat(cell, borderFormat, ['borderLeft']);\n        }\n    }\n}\n","import hasSelectionInBlock from '../selection/hasSelectionInBlock';\nimport { alignTable } from '../../modelApi/table/alignTable';\nimport { deleteTable } from '../../modelApi/table/deleteTable';\nimport { deleteTableColumn } from '../../modelApi/table/deleteTableColumn';\nimport { deleteTableRow } from '../../modelApi/table/deleteTableRow';\nimport { ensureFocusableParagraphForTable } from '../../modelApi/table/ensureFocusableParagraphForTable';\nimport { insertTableColumn } from '../../modelApi/table/insertTableColumn';\nimport { insertTableRow } from '../../modelApi/table/insertTableRow';\nimport { mergeTableCells } from '../../modelApi/table/mergeTableCells';\nimport { mergeTableColumn } from '../../modelApi/table/mergeTableColumn';\nimport { mergeTableRow } from '../../modelApi/table/mergeTableRow';\nimport { splitTableCellHorizontally } from '../../modelApi/table/splitTableCellHorizontally';\nimport { splitTableCellVertically } from '../../modelApi/table/splitTableCellVertically';\nimport {\n    applyTableFormat,\n    getFirstSelectedTable,\n    normalizeTable,\n    setSelection,\n} from 'roosterjs-content-model-core';\nimport type { TableOperation, IStandaloneEditor } from 'roosterjs-content-model-types';\nimport {\n    alignTableCellHorizontally,\n    alignTableCellVertically,\n} from '../../modelApi/table/alignTableCell';\nimport {\n    createSelectionMarker,\n    hasMetadata,\n    setParagraphNotImplicit,\n} from 'roosterjs-content-model-dom';\n\n/**\n * Format current focused table with the given format\n * @param editor The editor instance\n * @param operation The table operation to apply\n */\nexport default function editTable(editor: IStandaloneEditor, operation: TableOperation) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            const [tableModel, path] = getFirstSelectedTable(model);\n\n            if (tableModel) {\n                switch (operation) {\n                    case 'alignCellLeft':\n                    case 'alignCellCenter':\n                    case 'alignCellRight':\n                        alignTableCellHorizontally(tableModel, operation);\n                        break;\n                    case 'alignCellTop':\n                    case 'alignCellMiddle':\n                    case 'alignCellBottom':\n                        alignTableCellVertically(tableModel, operation);\n                        break;\n                    case 'alignCenter':\n                    case 'alignLeft':\n                    case 'alignRight':\n                        alignTable(tableModel, operation);\n                        break;\n\n                    case 'deleteColumn':\n                        deleteTableColumn(tableModel);\n                        break;\n\n                    case 'deleteRow':\n                        deleteTableRow(tableModel);\n                        break;\n\n                    case 'deleteTable':\n                        deleteTable(tableModel);\n                        break;\n\n                    case 'insertAbove':\n                    case 'insertBelow':\n                        insertTableRow(tableModel, operation);\n                        break;\n\n                    case 'insertLeft':\n                    case 'insertRight':\n                        insertTableColumn(tableModel, operation);\n                        break;\n\n                    case 'mergeAbove':\n                    case 'mergeBelow':\n                        mergeTableRow(tableModel, operation);\n                        break;\n\n                    case 'mergeCells':\n                        mergeTableCells(tableModel);\n                        break;\n\n                    case 'mergeLeft':\n                    case 'mergeRight':\n                        mergeTableColumn(tableModel, operation);\n                        break;\n\n                    case 'splitHorizontally':\n                        splitTableCellHorizontally(tableModel);\n                        break;\n\n                    case 'splitVertically':\n                        splitTableCellVertically(tableModel);\n                        break;\n                }\n\n                if (!hasSelectionInBlock(tableModel)) {\n                    const paragraph = ensureFocusableParagraphForTable(model, path, tableModel);\n\n                    if (paragraph) {\n                        const marker = createSelectionMarker(model.format);\n\n                        paragraph.segments.unshift(marker);\n                        setParagraphNotImplicit(paragraph);\n                        setSelection(model, marker);\n                    }\n                }\n\n                normalizeTable(tableModel, model.format);\n\n                if (hasMetadata(tableModel)) {\n                    applyTableFormat(tableModel, undefined /*newFormat*/, true /*keepCellShade*/);\n                }\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'editTable',\n        }\n    );\n}\n","import {\n    applyTableFormat,\n    getFirstSelectedTable,\n    updateTableCellMetadata,\n} from 'roosterjs-content-model-core';\nimport type { IStandaloneEditor, TableMetadataFormat } from 'roosterjs-content-model-types';\n\n/**\n * Format current focused table with the given format\n * @param editor The editor instance\n * @param format The table format to apply\n * @param keepCellShade Whether keep existing shade color when apply format if there is a manually set shade color\n */\nexport default function formatTable(\n    editor: IStandaloneEditor,\n    format: TableMetadataFormat,\n    keepCellShade?: boolean\n) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            const [tableModel] = getFirstSelectedTable(model);\n\n            if (tableModel) {\n                // Wipe border metadata\n                tableModel.rows.forEach(row => {\n                    row.cells.forEach(cell => {\n                        updateTableCellMetadata(cell, metadata => {\n                            if (metadata) {\n                                delete metadata.borderOverride;\n                            }\n                            return metadata;\n                        });\n                    });\n                });\n                applyTableFormat(tableModel, format, keepCellShade);\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'formatTable',\n        }\n    );\n}\n","import { createContentModelDocument, createSelectionMarker } from 'roosterjs-content-model-dom';\nimport { createTableStructure } from '../../modelApi/table/createTableStructure';\nimport {\n    applyTableFormat,\n    deleteSelection,\n    mergeModel,\n    normalizeTable,\n    setSelection,\n} from 'roosterjs-content-model-core';\nimport type { IStandaloneEditor, TableMetadataFormat } from 'roosterjs-content-model-types';\n\n/**\n * Insert table into editor at current selection\n * @param editor The editor instance\n * @param columns Number of columns in table, it also controls the default table cell width:\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\n * @param rows Number of rows in table\n * @param format (Optional) The table format. If not passed, the default format will be applied:\n * background color: #FFF; border color: #ABABAB\n */\nexport default function insertTable(\n    editor: IStandaloneEditor,\n    columns: number,\n    rows: number,\n    format?: Partial<TableMetadataFormat>\n) {\n    editor.focus();\n\n    editor.formatContentModel(\n        (model, context) => {\n            const insertPosition = deleteSelection(model, [], context).insertPoint;\n\n            if (insertPosition) {\n                const doc = createContentModelDocument();\n                const table = createTableStructure(doc, columns, rows);\n\n                normalizeTable(table, editor.getPendingFormat() || insertPosition.marker.format);\n                // Assign default vertical align\n                format = format || { verticalAlign: 'top' };\n                applyTableFormat(table, format);\n                mergeModel(model, doc, context, {\n                    insertPosition,\n                    mergeFormat: 'mergeAll',\n                });\n\n                const firstBlock = table.rows[0]?.cells[0]?.blocks[0];\n\n                if (firstBlock?.blockType == 'Paragraph') {\n                    const marker = createSelectionMarker(firstBlock.segments[0]?.format);\n                    firstBlock.segments.unshift(marker);\n                    setSelection(model, marker);\n                }\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'insertTable',\n        }\n    );\n}\n","import hasSelectionInBlockGroup from '../selection/hasSelectionInBlockGroup';\nimport {\n    getFirstSelectedTable,\n    normalizeTable,\n    setTableCellBackgroundColor,\n} from 'roosterjs-content-model-core';\nimport type { IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * Set table cell shade color\n * @param editor The editor instance\n * @param color The color to set. Pass null to remove existing shade color\n */\nexport default function setTableCellShade(editor: IStandaloneEditor, color: string | null) {\n    editor.focus();\n\n    editor.formatContentModel(\n        model => {\n            const [table] = getFirstSelectedTable(model);\n\n            if (table) {\n                normalizeTable(table);\n\n                table.rows.forEach(row =>\n                    row.cells.forEach(cell => {\n                        if (hasSelectionInBlockGroup(cell)) {\n                            setTableCellBackgroundColor(cell, color, true /*isColorOverride*/);\n                        }\n                    })\n                );\n\n                return true;\n            } else {\n                return false;\n            }\n        },\n        {\n            apiName: 'setTableCellShade',\n        }\n    );\n}\n","import { formatSegmentWithContentModel } from './formatSegmentWithContentModel';\nimport type { ContentModelImage, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport default function formatImageWithContentModel(\n    editor: IStandaloneEditor,\n    apiName: string,\n    callback: (segment: ContentModelImage) => void\n) {\n    formatSegmentWithContentModel(\n        editor,\n        apiName,\n        (_, __, segment) => {\n            if (segment?.segmentType == 'Image') {\n                callback(segment);\n            }\n        },\n        undefined /** segmentHasStyleCallback **/,\n        undefined /** includingFormatHolder */\n    );\n}\n","import { getSelectedParagraphs } from 'roosterjs-content-model-core';\nimport type { ContentModelParagraph, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function formatParagraphWithContentModel(\n    editor: IStandaloneEditor,\n    apiName: string,\n    setStyleCallback: (paragraph: ContentModelParagraph) => void\n) {\n    editor.formatContentModel(\n        (model, context) => {\n            const paragraphs = getSelectedParagraphs(model);\n\n            paragraphs.forEach(setStyleCallback);\n            context.newPendingFormat = 'preserve';\n\n            return paragraphs.length > 0;\n        },\n        {\n            apiName,\n        }\n    );\n}\n","import { adjustWordSelection } from '../../modelApi/selection/adjustWordSelection';\nimport { getSelectedSegmentsAndParagraphs } from 'roosterjs-content-model-core';\nimport type {\n    ContentModelDocument,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelSegmentFormat,\n    IStandaloneEditor,\n} from 'roosterjs-content-model-types';\n/**\n * @internal\n */\nexport function formatSegmentWithContentModel(\n    editor: IStandaloneEditor,\n    apiName: string,\n    toggleStyleCallback: (\n        format: ContentModelSegmentFormat,\n        isTuringOn: boolean,\n        segment: ContentModelSegment | null,\n        paragraph: ContentModelParagraph | null\n    ) => void,\n    segmentHasStyleCallback?: (\n        format: ContentModelSegmentFormat,\n        segment: ContentModelSegment | null,\n        paragraph: ContentModelParagraph | null\n    ) => boolean,\n    includingFormatHolder?: boolean,\n    afterFormatCallback?: (model: ContentModelDocument) => void\n) {\n    editor.formatContentModel(\n        (model, context) => {\n            let segmentAndParagraphs = getSelectedSegmentsAndParagraphs(\n                model,\n                !!includingFormatHolder\n            );\n            const pendingFormat = editor.getPendingFormat();\n            let isCollapsedSelection =\n                segmentAndParagraphs.length == 1 &&\n                segmentAndParagraphs[0][0].segmentType == 'SelectionMarker';\n\n            if (isCollapsedSelection) {\n                const para = segmentAndParagraphs[0][1];\n\n                segmentAndParagraphs = adjustWordSelection(\n                    model,\n                    segmentAndParagraphs[0][0]\n                ).map(x => [x, para]);\n\n                if (segmentAndParagraphs.length > 1) {\n                    isCollapsedSelection = false;\n                }\n            }\n\n            const formatsAndSegments: [\n                ContentModelSegmentFormat,\n                ContentModelSegment | null,\n                ContentModelParagraph | null\n            ][] = pendingFormat\n                ? [[pendingFormat, null, null]]\n                : segmentAndParagraphs.map(item => [item[0].format, item[0], item[1]]);\n\n            const isTurningOff = segmentHasStyleCallback\n                ? formatsAndSegments.every(([format, segment, paragraph]) =>\n                      segmentHasStyleCallback(format, segment, paragraph)\n                  )\n                : false;\n\n            formatsAndSegments.forEach(([format, segment, paragraph]) =>\n                toggleStyleCallback(format, !isTurningOff, segment, paragraph)\n            );\n\n            afterFormatCallback?.(model);\n\n            if (!pendingFormat && isCollapsedSelection) {\n                context.newPendingFormat = segmentAndParagraphs[0][0].format;\n            }\n\n            if (isCollapsedSelection) {\n                editor.focus();\n                return false;\n            } else {\n                return formatsAndSegments.length > 0;\n            }\n        },\n        {\n            apiName,\n        }\n    );\n}\n","/**\n *  Enum used to control the different types of bullet list\n */\nexport const BulletListType = {\n    /**\n     * Minimum value of the enum\n     */\n    Min: 1,\n    /**\n     * Bullet triggered by *\n     */\n    Disc: 1,\n    /**\n     * Bullet triggered by -\n     */\n    Dash: 2,\n    /**\n     * Bullet triggered by --\n     */\n    Square: 3,\n    /**\n     * Bullet triggered by >\n     */\n    ShortArrow: 4,\n    /**\n     * Bullet triggered by ->\n     */\n    LongArrow: 5,\n    /**\n     * Bullet triggered by =>\n     */\n    UnfilledArrow: 6,\n    /**\n     * Bullet triggered by —\n     */\n    Hyphen: 7,\n    /**\n     * Bullet triggered by -->\n     */\n    DoubleLongArrow: 8,\n    /**\n     * Bullet type circle\n     */\n    Circle: 9,\n    /**\n     * Maximum value of the enum\n     */\n    Max: 9,\n};\n","/**\n * Possible change sources. Here are the predefined sources.\n * It can also be other string if the change source can't fall into these sources.\n */\nexport const ChangeSource = {\n    /**\n     * Content changed by auto link\n     */\n    AutoLink: 'AutoLink',\n    /**\n     * Content changed by create link\n     */\n    CreateLink: 'CreateLink',\n    /**\n     * Content changed by format\n     */\n    Format: 'Format',\n    /**\n     * Content changed by image resize\n     */\n    ImageResize: 'ImageResize',\n    /**\n     * Content changed by paste\n     */\n    Paste: 'Paste',\n    /**\n     * Content changed by setContent API\n     */\n    SetContent: 'SetContent',\n    /**\n     * Content changed by cut operation\n     */\n    Cut: 'Cut',\n    /**\n     * Content changed by drag & drop operation\n     */\n    Drop: 'Drop',\n    /**\n     * Insert a new entity into editor\n     */\n    InsertEntity: 'InsertEntity',\n    /**\n     * Editor is switched to dark mode, content color is changed\n     */\n    SwitchToDarkMode: 'SwitchToDarkMode',\n    /**\n     * Editor is switched to light mode, content color is changed\n     */\n    SwitchToLightMode: 'SwitchToLightMode',\n    /**\n     * List chain reorganized numbers of lists\n     */\n    ListChain: 'ListChain',\n    /**\n     * Keyboard event, used by Content Model.\n     * Data of this event will be the key code number\n     */\n    Keyboard: 'Keyboard',\n};\n","/**\n *  Enum used to control the different types of numbering list\n */\nexport const NumberingListType = {\n    /**\n     * Minimum value of the enum\n     */\n    Min: 1,\n    /**\n     * Numbering triggered by 1.\n     */\n    Decimal: 1,\n    /**\n     * Numbering triggered by 1-\n     */\n    DecimalDash: 2,\n    /**\n     * Numbering triggered by 1)\n     */\n    DecimalParenthesis: 3,\n    /**\n     * Numbering triggered by (1)\n     */\n    DecimalDoubleParenthesis: 4,\n    /**\n     * Numbering triggered by a.\n     */\n    LowerAlpha: 5,\n    /**\n     * Numbering triggered by a)\n     */\n    LowerAlphaParenthesis: 6,\n    /**\n     * Numbering triggered by (a)\n     */\n    LowerAlphaDoubleParenthesis: 7,\n    /**\n     * Numbering triggered by a-\n     */\n    LowerAlphaDash: 8,\n    /**\n     * Numbering triggered by A.\n     */\n    UpperAlpha: 9,\n    /**\n     * Numbering triggered by A)\n     */\n    UpperAlphaParenthesis: 10,\n    /**\n     * Numbering triggered by (A)\n     */\n    UpperAlphaDoubleParenthesis: 11,\n    /**\n     * Numbering triggered by A-\n     */\n    UpperAlphaDash: 12,\n    /**\n     * Numbering triggered by i.\n     */\n    LowerRoman: 13,\n    /**\n     * Numbering triggered by i)\n     */\n    LowerRomanParenthesis: 14,\n    /**\n     * Numbering triggered by (i)\n     */\n    LowerRomanDoubleParenthesis: 15,\n    /**\n     * Numbering triggered by i-\n     */\n    LowerRomanDash: 16,\n    /**\n     * Numbering triggered by I.\n     */\n    UpperRoman: 17,\n    /**\n     * Numbering triggered by I)\n     */\n    UpperRomanParenthesis: 18,\n    /**\n     * Numbering triggered by (I)\n     */\n    UpperRomanDoubleParenthesis: 19,\n    /**\n     * Numbering triggered by I-\n     */\n    UpperRomanDash: 20,\n    /**\n     * Maximum value of the enum\n     */\n    Max: 20,\n};\n","/**\n * Table format border\n */\nexport const TableBorderFormat = {\n    /**\n     * Minimum value\n     */\n    Min: 0,\n\n    /**\n     * All border of the table are displayed\n     *  __ __ __\n     * |__|__|__|\n     * |__|__|__|\n     * |__|__|__|\n     */\n    Default: 0,\n\n    /**\n     * Middle vertical border are not displayed\n     *  __ __ __\n     * |__ __ __|\n     * |__ __ __|\n     * |__ __ __|\n     */\n    ListWithSideBorders: 1,\n\n    /**\n     * All borders except header rows borders are displayed\n     *  __ __ __\n     *  __|__|__\n     *  __|__|__\n     */\n    NoHeaderBorders: 2,\n\n    /**\n     * The left and right border of the table are not displayed\n     *  __ __ __\n     *  __|__|__\n     *  __|__|__\n     *  __|__|__\n     */\n    NoSideBorders: 3,\n\n    /**\n     * Only the borders that divides the header row, first column and externals are displayed\n     *  __ __ __\n     * |__ __ __|\n     * |  |     |\n     * |__|__ __|\n     */\n    FirstColumnHeaderExternal: 4,\n\n    /**\n     * The header row has no vertical border, except for the first one\n     * The first column has no horizontal border, except for the first one\n     *  __ __ __\n     * |__ __ __\n     * |  |__|__|\n     * |  |__|__|\n     */\n    EspecialType1: 5,\n\n    /**\n     * The header row has no vertical border, except for the first one\n     * The only horizontal border of the table is the top and bottom of header row\n     *  __ __ __\n     * |__ __ __\n     * |  |     |\n     * |  |     |\n     */\n    EspecialType2: 6,\n\n    /**\n     * The only borders are the bottom of header row and the right border of first column\n     *  __ __ __\n     *    |\n     *    |\n     */\n    EspecialType3: 7,\n\n    /**\n     * No border\n     */\n    Clear: 8,\n\n    /**\n     * Maximum value\n     */\n    Max: 8,\n};\n","import { cloneModel } from '../publicApi/model/cloneModel';\nimport {\n    createDomToModelContext,\n    createDomToModelContextWithConfig,\n    domToContentModel,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DOMSelection,\n    DomToModelOption,\n    CreateContentModel,\n    StandaloneEditorCore,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create Content Model from DOM tree in this editor\n * @param core The editor core object\n * @param option The option to customize the behavior of DOM to Content Model conversion\n * @param selectionOverride When passed, use this selection range instead of current selection in editor\n */\nexport const createContentModel: CreateContentModel = (core, option, selectionOverride) => {\n    let cachedModel = selectionOverride ? null : core.cache.cachedModel;\n\n    if (cachedModel && core.lifecycle.shadowEditFragment) {\n        // When in shadow edit, use a cloned model so we won't pollute the cached one\n        cachedModel = cloneModel(cachedModel, { includeCachedElement: true });\n    }\n\n    if (cachedModel) {\n        return cachedModel;\n    } else {\n        const selection = selectionOverride || core.api.getDOMSelection(core) || undefined;\n        const model = internalCreateContentModel(core, selection, option);\n\n        if (!option && !selectionOverride) {\n            core.cache.cachedModel = model;\n            core.cache.cachedSelection = selection;\n        }\n\n        return model;\n    }\n};\n\nfunction internalCreateContentModel(\n    core: StandaloneEditorCore,\n    selection?: DOMSelection,\n    option?: DomToModelOption\n) {\n    const editorContext = core.api.createEditorContext(core);\n    const domToModelContext = option\n        ? createDomToModelContext(editorContext, ...(core.defaultDomToModelOptions || []), option)\n        : createDomToModelContextWithConfig(core.defaultDomToModelConfig, editorContext);\n\n    return domToContentModel(core.contentDiv, domToModelContext, selection);\n}\n","import type { EditorContext, CreateEditorContext } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create a EditorContext object used by ContentModel API\n */\nexport const createEditorContext: CreateEditorContext = core => {\n    const { lifecycle, format, darkColorHandler, contentDiv, cache } = core;\n\n    const context: EditorContext = {\n        isDarkMode: lifecycle.isDarkMode,\n        defaultFormat: format.defaultFormat,\n        darkColorHandler: darkColorHandler,\n        addDelimiterForEntity: true,\n        allowCacheElement: true,\n        domIndexer: cache.domIndexer,\n    };\n\n    checkRootRtl(contentDiv, context);\n    checkZoomScale(contentDiv, context);\n\n    return context;\n};\n\nfunction checkZoomScale(element: HTMLElement, context: EditorContext) {\n    const originalWidth = element?.getBoundingClientRect()?.width || 0;\n    const visualWidth = element.offsetWidth;\n\n    if (visualWidth > 0 && originalWidth > 0) {\n        context.zoomScale = Math.round((originalWidth / visualWidth) * 100) / 100;\n    }\n}\n\nfunction checkRootRtl(element: HTMLElement, context: EditorContext) {\n    const style = element?.ownerDocument.defaultView?.getComputedStyle(element);\n\n    if (style?.direction == 'rtl') {\n        context.isRootRtl = true;\n    }\n}\n","import type { Focus } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Focus to editor. If there is a cached selection range, use it as current selection\n * @param core The StandaloneEditorCore object\n */\nexport const focus: Focus = core => {\n    if (!core.lifecycle.shadowEditFragment) {\n        const { api, selection } = core;\n\n        if (!api.hasFocus(core) && selection.selection?.type == 'range') {\n            api.setDOMSelection(core, selection.selection, true /*skipSelectionChangedEvent*/);\n        }\n\n        // fallback, in case editor still have no focus\n        if (!core.api.hasFocus(core)) {\n            core.contentDiv.focus();\n        }\n    }\n};\n","import { ChangeSource } from '../constants/ChangeSource';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type {\n    ChangedEntity,\n    ContentModelContentChangedEvent,\n    DOMSelection,\n    FormatContentModel,\n    FormatWithContentModelContext,\n    StandaloneEditorCore,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * The general API to do format change with Content Model\n * It will grab a Content Model for current editor content, and invoke a callback function\n * to do format change. Then according to the return value, write back the modified content model into editor.\n * If there is cached model, it will be used and updated.\n * @param core The StandaloneEditorCore object\n * @param formatter Formatter function, see ContentModelFormatter\n * @param options More options, see FormatWithContentModelOptions\n */\nexport const formatContentModel: FormatContentModel = (core, formatter, options) => {\n    const { apiName, onNodeCreated, getChangeData, changeSource, rawEvent, selectionOverride } =\n        options || {};\n\n    const model = core.api.createContentModel(core, undefined /*option*/, selectionOverride);\n    const context: FormatWithContentModelContext = {\n        newEntities: [],\n        deletedEntities: [],\n        rawEvent,\n        newImages: [],\n    };\n    let selection: DOMSelection | undefined;\n\n    if (formatter(model, context)) {\n        const writeBack = () => {\n            handleImages(core, context);\n\n            selection =\n                core.api.setContentModel(core, model, undefined /*options*/, onNodeCreated) ||\n                undefined;\n\n            handlePendingFormat(core, context, selection);\n        };\n\n        if (context.skipUndoSnapshot) {\n            writeBack();\n        } else {\n            core.api.addUndoSnapshot(\n                core,\n                writeBack,\n                null /*changeSource, passing undefined here to avoid triggering ContentChangedEvent. We will trigger it using it with Content Model below */,\n                false /*canUndoByBackspace*/,\n                {\n                    formatApiName: apiName,\n                }\n            );\n        }\n\n        const eventData: ContentModelContentChangedEvent = {\n            eventType: PluginEventType.ContentChanged,\n            contentModel: context.clearModelCache ? undefined : model,\n            selection: context.clearModelCache ? undefined : selection,\n            source: changeSource || ChangeSource.Format,\n            data: getChangeData?.(),\n            additionalData: {\n                formatApiName: apiName,\n            },\n            changedEntities: context.newEntities\n                .map(\n                    (entity): ChangedEntity => ({\n                        entity,\n                        operation: 'newEntity',\n                        rawEvent,\n                    })\n                )\n                .concat(\n                    context.deletedEntities.map(entry => ({\n                        entity: entry.entity,\n                        operation: entry.operation,\n                        rawEvent,\n                    }))\n                ),\n        };\n        core.api.triggerEvent(core, eventData, true /*broadcast*/);\n    } else {\n        if (context.clearModelCache) {\n            core.cache.cachedModel = undefined;\n            core.cache.cachedSelection = undefined;\n        }\n\n        handlePendingFormat(core, context, core.api.getDOMSelection(core));\n    }\n};\n\nfunction handleImages(core: StandaloneEditorCore, context: FormatWithContentModelContext) {\n    if (context.newImages.length > 0) {\n        const viewport = core.api.getVisibleViewport(core);\n\n        if (viewport) {\n            const { left, right } = viewport;\n            const minMaxImageSize = 10;\n            const maxWidth = Math.max(right - left, minMaxImageSize);\n            context.newImages.forEach(image => {\n                image.format.maxWidth = `${maxWidth}px`;\n            });\n        }\n    }\n}\n\nfunction handlePendingFormat(\n    core: StandaloneEditorCore,\n    context: FormatWithContentModelContext,\n    selection?: DOMSelection | null\n) {\n    const pendingFormat =\n        context.newPendingFormat == 'preserve'\n            ? core.format.pendingFormat?.format\n            : context.newPendingFormat;\n\n    if (pendingFormat && selection?.type == 'range' && selection.range.collapsed) {\n        core.format.pendingFormat = {\n            format: { ...pendingFormat },\n            posContainer: selection.range.startContainer,\n            posOffset: selection.range.startOffset,\n        };\n    }\n}\n","import type {\n    DOMSelection,\n    GetDOMSelection,\n    StandaloneEditorCore,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const getDOMSelection: GetDOMSelection = core => {\n    return core.lifecycle.shadowEditFragment\n        ? null\n        : core.selection.selection ?? getNewSelection(core);\n};\n\nfunction getNewSelection(core: StandaloneEditorCore): DOMSelection | null {\n    const selection = core.contentDiv.ownerDocument.defaultView?.getSelection();\n    const range = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;\n\n    return range && core.contentDiv.contains(range.commonAncestorContainer)\n        ? {\n              type: 'range',\n              range: range,\n          }\n        : null;\n}\n","import type { Rect } from 'roosterjs-editor-types';\nimport type { GetVisibleViewport } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Retrieves the rect of the visible viewport of the editor.\n * @param core The StandaloneEditorCore object\n */\nexport const getVisibleViewport: GetVisibleViewport = core => {\n    const scrollContainer = core.domEvent.scrollContainer;\n\n    return getIntersectedRect(\n        scrollContainer == core.contentDiv ? [scrollContainer] : [scrollContainer, core.contentDiv]\n    );\n};\n\n/**\n * Get the intersected Rect of elements provided\n *\n * @example\n * The result of the following Elements Rects would be:\n    {\n        top: Element2.top,\n        bottom: Element1.bottom,\n        left: Element2.left,\n        right: Element2.right\n    }\n    +-------------------------+\n    | Element 1               |\n    |   +-----------------+   |\n    |   | Element2        |   |\n    |   |                 |   |\n    |   |                 |   |\n    +-------------------------+\n        |                 |\n        +-----------------+\n\n * @param elements Elements to use.\n * @param additionalRects additional rects to use\n * @returns If the Rect is valid return the rect, if not, return null.\n */\nfunction getIntersectedRect(elements: HTMLElement[], additionalRects: Rect[] = []): Rect | null {\n    const rects = elements\n        .map(element => normalizeRect(element.getBoundingClientRect()))\n        .concat(additionalRects)\n        .filter((rect: Rect | null): rect is Rect => !!rect);\n\n    const result: Rect = {\n        top: Math.max(...rects.map(r => r.top)),\n        bottom: Math.min(...rects.map(r => r.bottom)),\n        left: Math.max(...rects.map(r => r.left)),\n        right: Math.min(...rects.map(r => r.right)),\n    };\n\n    return result.top < result.bottom && result.left < result.right ? result : null;\n}\n\nfunction normalizeRect(clientRect: DOMRect): Rect | null {\n    const { left, right, top, bottom } =\n        clientRect || <DOMRect>{ left: 0, right: 0, top: 0, bottom: 0 };\n    return left === 0 && right === 0 && top === 0 && bottom === 0\n        ? null\n        : {\n              left: Math.round(left),\n              right: Math.round(right),\n              top: Math.round(top),\n              bottom: Math.round(bottom),\n          };\n}\n","import type { HasFocus } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Check if the editor has focus now\n * @param core The StandaloneEditorCore object\n * @returns True if the editor has focus, otherwise false\n */\nexport const hasFocus: HasFocus = core => {\n    const activeElement = core.contentDiv.ownerDocument.activeElement;\n    return !!(activeElement && core.contentDiv.contains(activeElement));\n};\n","import {\n    contentModelToDom,\n    createModelToDomContext,\n    createModelToDomContextWithConfig,\n} from 'roosterjs-content-model-dom';\nimport type { SetContentModel } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Set content with content model\n * @param core The editor core object\n * @param model The content model to set\n * @param option Additional options to customize the behavior of Content Model to DOM conversion\n */\nexport const setContentModel: SetContentModel = (core, model, option, onNodeCreated) => {\n    const editorContext = core.api.createEditorContext(core);\n    const modelToDomContext = option\n        ? createModelToDomContext(editorContext, ...(core.defaultModelToDomOptions || []), option)\n        : createModelToDomContextWithConfig(core.defaultModelToDomConfig, editorContext);\n\n    const selection = contentModelToDom(\n        core.contentDiv.ownerDocument,\n        core.contentDiv,\n        model,\n        modelToDomContext,\n        onNodeCreated\n    );\n\n    if (!core.lifecycle.shadowEditFragment) {\n        core.cache.cachedSelection = selection || undefined;\n\n        if (!option?.ignoreSelection && selection) {\n            core.api.setDOMSelection(core, selection);\n        }\n\n        core.cache.cachedModel = model;\n    }\n\n    return selection;\n};\n","import { addRangeToSelection } from '../corePlugin/utils/addRangeToSelection';\nimport { isNodeOfType, toArray } from 'roosterjs-content-model-dom';\nimport { parseTableCells } from '../publicApi/domUtils/tableCellUtils';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type {\n    ContentModelSelectionChangedEvent,\n    SetDOMSelection,\n    TableSelection,\n} from 'roosterjs-content-model-types';\n\nconst IMAGE_ID = 'image';\nconst TABLE_ID = 'table';\nconst CONTENT_DIV_ID = 'contentDiv';\nconst DEFAULT_SELECTION_BORDER_COLOR = '#DB626C';\nconst TABLE_CSS_RULE = '{background-color: rgb(198,198,198) !important; caret-color: transparent}';\nconst MAX_RULE_SELECTOR_LENGTH = 9000;\n\n/**\n * @internal\n */\nexport const setDOMSelection: SetDOMSelection = (core, selection, skipSelectionChangedEvent) => {\n    // We are applying a new selection, so we don't need to apply cached selection in DOMEventPlugin.\n    // Set skipReselectOnFocus to skip this behavior\n    const skipReselectOnFocus = core.selection.skipReselectOnFocus;\n\n    const doc = core.contentDiv.ownerDocument;\n    const sheet = core.selection.selectionStyleNode?.sheet;\n\n    core.selection.skipReselectOnFocus = true;\n\n    try {\n        let selectionRules: string[] | undefined;\n        const rootSelector = '#' + addUniqueId(core.contentDiv, CONTENT_DIV_ID);\n\n        switch (selection?.type) {\n            case 'image':\n                const image = selection.image;\n\n                selectionRules = buildImageCSS(\n                    rootSelector + ' #' + addUniqueId(image, IMAGE_ID),\n                    core.selection.imageSelectionBorderColor\n                );\n                core.selection.selection = selection;\n\n                setRangeSelection(doc, image);\n                break;\n            case 'table':\n                const { table, firstColumn, firstRow } = selection;\n\n                selectionRules = buildTableCss(\n                    rootSelector + ' #' + addUniqueId(table, TABLE_ID),\n                    selection\n                );\n                core.selection.selection = selection;\n\n                setRangeSelection(doc, table.rows[firstRow]?.cells[firstColumn]);\n                break;\n            case 'range':\n                addRangeToSelection(doc, selection.range);\n\n                core.selection.selection = core.api.hasFocus(core) ? null : selection;\n                break;\n\n            default:\n                core.selection.selection = null;\n                break;\n        }\n\n        if (sheet) {\n            for (let i = sheet.cssRules.length - 1; i >= 0; i--) {\n                sheet.deleteRule(i);\n            }\n\n            if (selectionRules) {\n                for (let i = 0; i < selectionRules.length; i++) {\n                    sheet.insertRule(selectionRules[i]);\n                }\n            }\n        }\n    } finally {\n        core.selection.skipReselectOnFocus = skipReselectOnFocus;\n    }\n\n    if (!skipSelectionChangedEvent) {\n        const eventData: ContentModelSelectionChangedEvent = {\n            eventType: PluginEventType.SelectionChanged,\n            newSelection: selection,\n            selectionRangeEx: null,\n        };\n\n        core.api.triggerEvent(core, eventData, true /*broadcast*/);\n    }\n};\n\nfunction buildImageCSS(rootSelector: string, borderColor?: string): string[] {\n    const color = borderColor || DEFAULT_SELECTION_BORDER_COLOR;\n\n    return [\n        `${rootSelector} {outline-style:auto!important;outline-color:${color}!important;caret-color:transparent;}`,\n    ];\n}\n\nfunction buildTableCss(rootSelector: string, selection: TableSelection): string[] {\n    const { firstColumn, firstRow, lastColumn, lastRow } = selection;\n    const cells = parseTableCells(selection.table);\n    const isAllTableSelected =\n        firstRow == 0 &&\n        firstColumn == 0 &&\n        lastRow == cells.length - 1 &&\n        lastColumn == (cells[lastRow]?.length ?? 0) - 1;\n    const selectors = isAllTableSelected\n        ? [rootSelector, `${rootSelector} *`]\n        : handleTableSelected(rootSelector, selection, cells);\n\n    const cssRules: string[] = [];\n    let currentRules: string = '';\n\n    for (let i = 0; i < selectors.length; i++) {\n        currentRules += (currentRules.length > 0 ? ',' : '') + selectors[i] || '';\n\n        if (\n            currentRules.length + (selectors[0]?.length || 0) > MAX_RULE_SELECTOR_LENGTH ||\n            i == selectors.length - 1\n        ) {\n            cssRules.push(currentRules + ' ' + TABLE_CSS_RULE);\n            currentRules = '';\n        }\n    }\n\n    return cssRules;\n}\n\nfunction handleTableSelected(\n    rootSelector: string,\n    selection: TableSelection,\n    cells: (HTMLTableCellElement | null)[][]\n) {\n    const { firstRow, firstColumn, lastRow, lastColumn, table } = selection;\n    const selectors: string[] = [];\n\n    // Get whether table has thead, tbody or tfoot, then Set the start and end of each of the table children,\n    // so we can build the selector according the element between the table and the row.\n    let cont = 0;\n    const indexes = toArray(table.childNodes)\n        .filter(\n            (node): node is HTMLTableSectionElement =>\n                ['THEAD', 'TBODY', 'TFOOT'].indexOf(\n                    isNodeOfType(node, 'ELEMENT_NODE') ? node.tagName : ''\n                ) > -1\n        )\n        .map(node => {\n            const result = {\n                el: node.tagName,\n                start: cont,\n                end: node.childNodes.length + cont,\n            };\n\n            cont = result.end;\n            return result;\n        });\n\n    cells.forEach((row, rowIndex) => {\n        let tdCount = 0;\n\n        //Get current TBODY/THEAD/TFOOT\n        const midElement = indexes.filter(ind => ind.start <= rowIndex && ind.end > rowIndex)[0];\n        const middleElSelector = midElement ? '>' + midElement.el + '>' : '>';\n        const currentRow =\n            midElement && rowIndex + 1 >= midElement.start\n                ? rowIndex + 1 - midElement.start\n                : rowIndex + 1;\n\n        for (let cellIndex = 0; cellIndex < row.length; cellIndex++) {\n            const cell = row[cellIndex];\n\n            if (cell) {\n                tdCount++;\n\n                if (\n                    rowIndex >= firstRow &&\n                    rowIndex <= lastRow &&\n                    cellIndex >= firstColumn &&\n                    cellIndex <= lastColumn\n                ) {\n                    const selector = `${rootSelector}${middleElSelector} tr:nth-child(${currentRow})>${cell.tagName}:nth-child(${tdCount})`;\n\n                    selectors.push(selector, selector + ' *');\n                }\n            }\n        }\n    });\n\n    return selectors;\n}\n\nfunction setRangeSelection(doc: Document, element: HTMLElement | undefined) {\n    if (element) {\n        const range = doc.createRange();\n\n        range.selectNode(element);\n        range.collapse();\n\n        addRangeToSelection(doc, range);\n    }\n}\n\nfunction addUniqueId(element: HTMLElement, idPrefix: string): string {\n    idPrefix = element.id || idPrefix;\n\n    const doc = element.ownerDocument;\n    let i = 0;\n\n    while (!element.id || doc.querySelectorAll('#' + element.id).length > 1) {\n        element.id = idPrefix + '_' + i++;\n    }\n\n    return element.id;\n}\n","import { iterateSelections } from '../publicApi/selection/iterateSelections';\nimport { moveChildNodes } from 'roosterjs-content-model-dom';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type { SwitchShadowEdit } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Switch the Shadow Edit mode of editor On/Off\n * @param editorCore The StandaloneEditorCore object\n * @param isOn True to switch On, False to switch Off\n */\nexport const switchShadowEdit: SwitchShadowEdit = (editorCore, isOn): void => {\n    // TODO: Use strong-typed editor core object\n    const core = editorCore;\n\n    if (isOn != !!core.lifecycle.shadowEditFragment) {\n        if (isOn) {\n            const model = !core.cache.cachedModel ? core.api.createContentModel(core) : null;\n\n            // Fake object, not used in Content Model Editor, just to satisfy original editor code\n            // TODO: we can remove them once we have standalone Content Model Editor\n            const fragment = core.contentDiv.ownerDocument.createDocumentFragment();\n            const clonedRoot = core.contentDiv.cloneNode(true /*deep*/);\n\n            moveChildNodes(fragment, clonedRoot);\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.EnteredShadowEdit,\n                    fragment,\n                    selectionPath: null,\n                },\n                false /*broadcast*/\n            );\n\n            // This need to be done after EnteredShadowEdit event is triggered since EnteredShadowEdit event will cause a SelectionChanged event\n            // if current selection is table selection or image selection\n            if (!core.cache.cachedModel && model) {\n                core.cache.cachedModel = model;\n            }\n\n            core.lifecycle.shadowEditFragment = fragment;\n        } else {\n            core.lifecycle.shadowEditFragment = null;\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.LeavingShadowEdit,\n                },\n                false /*broadcast*/\n            );\n\n            if (core.cache.cachedModel) {\n                // Force clear cached element from selected block\n                iterateSelections(core.cache.cachedModel, () => {});\n\n                core.api.setContentModel(core, core.cache.cachedModel, {\n                    ignoreSelection: true, // Do not set focus and selection when quit shadow edit, focus may remain in UI control (picker, ...)\n                });\n            }\n        }\n    }\n};\n","import { areSameSelection } from './utils/areSameSelection';\nimport { contentModelDomIndexer } from './utils/contentModelDomIndexer';\nimport { isCharacterValue } from '../publicApi/domUtils/eventUtils';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type {\n    ContentModelCachePluginState,\n    ContentModelContentChangedEvent,\n    IStandaloneEditor,\n    StandaloneEditorOptions,\n} from 'roosterjs-content-model-types';\nimport type {\n    IEditor,\n    PluginEvent,\n    PluginKeyDownEvent,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * ContentModel cache plugin manages cached Content Model, and refresh the cache when necessary\n */\nclass ContentModelCachePlugin implements PluginWithState<ContentModelCachePluginState> {\n    private editor: (IEditor & IStandaloneEditor) | null = null;\n    private state: ContentModelCachePluginState;\n\n    /**\n     * Construct a new instance of ContentModelEditPlugin class\n     * @param option The editor option\n     */\n    constructor(option: StandaloneEditorOptions) {\n        this.state = {\n            domIndexer: option.cacheModel ? contentModelDomIndexer : undefined,\n        };\n    }\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'ContentModelCache';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        // TODO: Later we may need a different interface for Content Model editor plugin\n        this.editor = editor as IEditor & IStandaloneEditor;\n        this.editor.getDocument().addEventListener('selectionchange', this.onNativeSelectionChange);\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        if (this.editor) {\n            this.editor\n                .getDocument()\n                .removeEventListener('selectionchange', this.onNativeSelectionChange);\n            this.editor = null;\n        }\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState(): ContentModelCachePluginState {\n        return this.state;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.KeyDown:\n                if (this.shouldClearCache(event)) {\n                    this.invalidateCache();\n                }\n                break;\n\n            case PluginEventType.Input:\n                {\n                    this.updateCachedModel(this.editor, true /*forceUpdate*/);\n                }\n                break;\n\n            case PluginEventType.SelectionChanged:\n                this.updateCachedModel(this.editor);\n                break;\n\n            case PluginEventType.ContentChanged:\n                {\n                    const { contentModel, selection } = event as ContentModelContentChangedEvent;\n\n                    if (contentModel && this.state.domIndexer) {\n                        this.state.cachedModel = contentModel;\n                        this.state.cachedSelection = selection;\n                    } else {\n                        this.invalidateCache();\n                    }\n                }\n\n                break;\n        }\n    }\n\n    private onNativeSelectionChange = () => {\n        if (this.editor?.hasFocus()) {\n            this.updateCachedModel(this.editor);\n        }\n    };\n\n    private invalidateCache() {\n        if (!this.editor?.isInShadowEdit()) {\n            this.state.cachedModel = undefined;\n            this.state.cachedSelection = undefined;\n        }\n    }\n\n    private updateCachedModel(editor: IStandaloneEditor, forceUpdate?: boolean) {\n        const cachedSelection = this.state.cachedSelection;\n        this.state.cachedSelection = undefined; // Clear it to force getDOMSelection() retrieve the latest selection range\n\n        const newRangeEx = editor.getDOMSelection() || undefined;\n        const model = this.state.cachedModel;\n        const isSelectionChanged =\n            forceUpdate ||\n            !cachedSelection ||\n            !newRangeEx ||\n            !areSameSelection(newRangeEx, cachedSelection);\n\n        if (isSelectionChanged) {\n            if (\n                !model ||\n                !newRangeEx ||\n                !this.state.domIndexer?.reconcileSelection(model, newRangeEx, cachedSelection)\n            ) {\n                this.invalidateCache();\n            } else {\n                this.state.cachedSelection = newRangeEx;\n            }\n        } else {\n            this.state.cachedSelection = cachedSelection;\n        }\n    }\n\n    private shouldClearCache(event: PluginKeyDownEvent) {\n        const { rawEvent, handledByEditFeature } = event;\n\n        // In these cases we can't update the model, so clear cache:\n        // 1. It is already handled by Content Edit Features\n        if (handledByEditFeature) {\n            return true;\n        }\n\n        // 2. Default behavior is prevented, which means other plugins has handled the event\n        if (rawEvent.defaultPrevented) {\n            return true;\n        }\n\n        // 3. ENTER key is pressed. ENTER key will create new paragraph, so need to update cache to reflect this change\n        // TODO: Handle ENTER key to better reuse content model\n\n        if (rawEvent.key == 'Enter') {\n            return true;\n        }\n\n        // 4. Current selection is image or table or expanded range selection, and is inputting some text\n        if (\n            (this.state.cachedSelection?.type != 'range' ||\n                !this.state.cachedSelection.range.collapsed) &&\n            isCharacterValue(rawEvent)\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n}\n\n/**\n * @internal\n * Create a new instance of ContentModelCachePlugin class.\n * @param option The editor option\n */\nexport function createContentModelCachePlugin(\n    option: StandaloneEditorOptions\n): PluginWithState<ContentModelCachePluginState> {\n    return new ContentModelCachePlugin(option);\n}\n","import { addRangeToSelection } from './utils/addRangeToSelection';\nimport { ChangeSource } from '../constants/ChangeSource';\nimport { cloneModel } from '../publicApi/model/cloneModel';\nimport { ColorTransformDirection, PluginEventType } from 'roosterjs-editor-types';\nimport { deleteSelection } from '../publicApi/selection/deleteSelection';\nimport { extractClipboardItems } from 'roosterjs-editor-dom';\nimport { iterateSelections } from '../publicApi/selection/iterateSelections';\nimport { paste } from '../publicApi/model/paste';\nimport {\n    contentModelToDom,\n    createModelToDomContext,\n    isElementOfType,\n    isNodeOfType,\n    moveChildNodes,\n    normalizeContentModel,\n    toArray,\n    wrap,\n} from 'roosterjs-content-model-dom';\nimport type {\n    DOMSelection,\n    IStandaloneEditor,\n    OnNodeCreated,\n    StandaloneEditorOptions,\n} from 'roosterjs-content-model-types';\nimport type {\n    CopyPastePluginState,\n    IEditor,\n    PluginWithState,\n    ClipboardData,\n} from 'roosterjs-editor-types';\n\n/**\n * Copy and paste plugin for handling onCopy and onPaste event\n */\nclass ContentModelCopyPastePlugin implements PluginWithState<CopyPastePluginState> {\n    private editor: (IStandaloneEditor & IEditor) | null = null;\n    private disposer: (() => void) | null = null;\n    private state: CopyPastePluginState;\n\n    /**\n     * Construct a new instance of CopyPastePlugin\n     * @param option The editor option\n     */\n    constructor(option: StandaloneEditorOptions) {\n        this.state = {\n            allowedCustomPasteType: option.allowedCustomPasteType || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContentModelCopyPaste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor as IStandaloneEditor & IEditor;\n        this.disposer = this.editor.addDomEventHandler({\n            paste: e => this.onPaste(e),\n            copy: e => this.onCutCopy(e, false /*isCut*/),\n            cut: e => this.onCutCopy(e, true /*isCut*/),\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        if (this.disposer) {\n            this.disposer();\n        }\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onCutCopy(event: Event, isCut: boolean) {\n        if (!this.editor) {\n            return;\n        }\n\n        const doc = this.editor.getDocument();\n        const selection = this.editor.getDOMSelection();\n\n        if (selection && (selection.type != 'range' || !selection.range.collapsed)) {\n            const model = this.editor.createContentModel();\n\n            const pasteModel = cloneModel(model, {\n                includeCachedElement: this.editor.isDarkMode()\n                    ? (node, type) => {\n                          if (type == 'cache') {\n                              return undefined;\n                          } else {\n                              const result = node.cloneNode(true /*deep*/) as HTMLElement;\n\n                              this.editor?.transformToDarkColor(\n                                  result,\n                                  ColorTransformDirection.DarkToLight\n                              );\n\n                              result.style.color = result.style.color || 'inherit';\n                              result.style.backgroundColor =\n                                  result.style.backgroundColor || 'inherit';\n\n                              return result;\n                          }\n                      }\n                    : false,\n            });\n            if (selection.type === 'table') {\n                iterateSelections(pasteModel, (_, tableContext) => {\n                    if (tableContext?.table) {\n                        const table = tableContext?.table;\n                        table.rows = table.rows\n                            .map(row => {\n                                return {\n                                    ...row,\n                                    cells: row.cells.filter(cell => cell.isSelected),\n                                };\n                            })\n                            .filter(row => row.cells.length > 0);\n                        return true;\n                    }\n                    return false;\n                });\n            }\n            const tempDiv = this.getTempDiv(this.editor);\n            const selectionForCopy = contentModelToDom(\n                tempDiv.ownerDocument,\n                tempDiv,\n                pasteModel,\n                createModelToDomContext(),\n                onNodeCreated\n            );\n\n            let newRange: Range | null = selectionForCopy\n                ? domSelectionToRange(doc, selectionForCopy, tempDiv)\n                : null;\n            if (newRange) {\n                newRange = this.editor.triggerPluginEvent(PluginEventType.BeforeCutCopy, {\n                    clonedRoot: tempDiv,\n                    range: newRange,\n                    rawEvent: event as ClipboardEvent,\n                    isCut,\n                }).range;\n\n                if (newRange) {\n                    addRangeToSelection(doc, newRange);\n                }\n\n                this.editor.runAsync(e => {\n                    const editor = e as IStandaloneEditor & IEditor;\n\n                    cleanUpAndRestoreSelection(tempDiv);\n                    editor.focus();\n                    editor.setDOMSelection(selection);\n\n                    if (isCut) {\n                        editor.formatContentModel(\n                            (model, context) => {\n                                if (deleteSelection(model, [], context).deleteResult == 'range') {\n                                    normalizeContentModel(model);\n                                }\n\n                                return true;\n                            },\n                            {\n                                apiName: 'cut',\n                                changeSource: ChangeSource.Cut,\n                            }\n                        );\n                    }\n                });\n            } else {\n                cleanUpAndRestoreSelection(tempDiv);\n            }\n        }\n    }\n\n    private onPaste = (event: Event) => {\n        if (this.editor && isClipboardEvent(event)) {\n            const editor = this.editor;\n\n            const dataTransfer = event.clipboardData;\n\n            if (dataTransfer?.items) {\n                event.preventDefault();\n                extractClipboardItems(\n                    toArray(dataTransfer.items),\n                    {\n                        allowedCustomPasteType: this.state.allowedCustomPasteType,\n                    },\n                    true /*pasteNativeEvent*/\n                ).then((clipboardData: ClipboardData) => {\n                    if (!editor.isDisposed()) {\n                        paste(editor, clipboardData);\n                    }\n                });\n            }\n        }\n    };\n\n    private getTempDiv(editor: IEditor) {\n        const div = editor.getCustomData(\n            'CopyPasteTempDiv',\n            () => {\n                const tempDiv = editor.getDocument().createElement('div');\n\n                tempDiv.style.width = '600px';\n                tempDiv.style.height = '1px';\n                tempDiv.style.overflow = 'hidden';\n                tempDiv.style.position = 'fixed';\n                tempDiv.style.top = '0';\n                tempDiv.style.left = '0';\n                tempDiv.style.userSelect = 'text';\n                tempDiv.contentEditable = 'true';\n\n                editor.getDocument().body.appendChild(tempDiv);\n\n                return tempDiv;\n            },\n            tempDiv => tempDiv.parentNode?.removeChild(tempDiv)\n        );\n\n        div.style.backgroundColor = 'white';\n        div.style.color = 'black';\n        div.childNodes.forEach(node => div.removeChild(node));\n\n        div.style.display = '';\n        div.focus();\n\n        return div;\n    }\n}\n\nfunction cleanUpAndRestoreSelection(tempDiv: HTMLDivElement) {\n    tempDiv.style.backgroundColor = '';\n    tempDiv.style.color = '';\n    tempDiv.style.display = 'none';\n    moveChildNodes(tempDiv);\n}\n\nfunction isClipboardEvent(event: Event): event is ClipboardEvent {\n    return !!(event as ClipboardEvent).clipboardData;\n}\n\nfunction domSelectionToRange(\n    doc: Document,\n    selection: DOMSelection,\n    tempDiv: HTMLDivElement\n): Range | null {\n    let newRange: Range | null = null;\n\n    if (selection.type === 'table') {\n        const table = tempDiv.querySelector(`#${selection.table.id}`) as HTMLTableElement;\n        const elementToSelect =\n            table.parentElement?.childElementCount == 1 ? table.parentElement : table;\n\n        newRange = doc.createRange();\n        newRange.selectNode(elementToSelect);\n    } else if (selection.type === 'image') {\n        const image = tempDiv.querySelector('#' + selection.image.id);\n\n        if (image) {\n            newRange = doc.createRange();\n            newRange.selectNode(image);\n        }\n    } else {\n        newRange = selection.range;\n    }\n\n    return newRange;\n}\n\n/**\n * @internal\n * Exported only for unit testing\n */\nexport const onNodeCreated: OnNodeCreated = (_, node): void => {\n    if (isNodeOfType(node, 'ELEMENT_NODE') && isElementOfType(node, 'table')) {\n        wrap(node.ownerDocument, node, 'div');\n    }\n    if (isNodeOfType(node, 'ELEMENT_NODE') && !node.isContentEditable) {\n        node.removeAttribute('contenteditable');\n    }\n};\n\n/**\n * @internal\n * Create a new instance of ContentModelCopyPastePlugin\n * @param option The editor option\n */\nexport function createContentModelCopyPastePlugin(\n    option: StandaloneEditorOptions\n): PluginWithState<CopyPastePluginState> {\n    return new ContentModelCopyPastePlugin(option);\n}\n","import { applyDefaultFormat } from './utils/applyDefaultFormat';\nimport { applyPendingFormat } from './utils/applyPendingFormat';\nimport { getObjectKeys } from 'roosterjs-content-model-dom';\nimport { isCharacterValue, isCursorMovingKey } from '../publicApi/domUtils/eventUtils';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type { IEditor, PluginEvent, PluginWithState } from 'roosterjs-editor-types';\nimport type {\n    ContentModelFormatPluginState,\n    IStandaloneEditor,\n    StandaloneEditorOptions,\n} from 'roosterjs-content-model-types';\n\n// During IME input, KeyDown event will have \"Process\" as key\nconst ProcessKey = 'Process';\n\n/**\n * ContentModelFormat plugins helps editor to do formatting on top of content model.\n * This includes:\n * 1. Handle pending format changes when selection is collapsed\n */\nclass ContentModelFormatPlugin implements PluginWithState<ContentModelFormatPluginState> {\n    private editor: (IStandaloneEditor & IEditor) | null = null;\n    private hasDefaultFormat = false;\n    private state: ContentModelFormatPluginState;\n\n    /**\n     * Construct a new instance of ContentModelEditPlugin class\n     * @param option The editor option\n     */\n    constructor(option: StandaloneEditorOptions) {\n        this.state = {\n            defaultFormat: { ...option.defaultSegmentFormat },\n            pendingFormat: null,\n        };\n    }\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'ContentModelFormat';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        // TODO: Later we may need a different interface for Content Model editor plugin\n        this.editor = editor as IStandaloneEditor & IEditor;\n        this.hasDefaultFormat =\n            getObjectKeys(this.state.defaultFormat).filter(\n                x => typeof this.state.defaultFormat[x] !== 'undefined'\n            ).length > 0;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState(): ContentModelFormatPluginState {\n        return this.state;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.Input:\n                const env = this.editor.getEnvironment();\n\n                // In Safari, isComposing will be undefined but isInIME() works\n                // For Android, we can skip checking isComposing since this property is not always reliable in all IME,\n                // and we have tested without this check it can still work correctly\n                if (env.isAndroid || (!event.rawEvent.isComposing && !this.editor.isInIME())) {\n                    this.checkAndApplyPendingFormat(event.rawEvent.data);\n                }\n\n                break;\n\n            case PluginEventType.CompositionEnd:\n                this.checkAndApplyPendingFormat(event.rawEvent.data);\n                break;\n\n            case PluginEventType.KeyDown:\n                if (isCursorMovingKey(event.rawEvent)) {\n                    this.clearPendingFormat();\n                } else if (\n                    this.hasDefaultFormat &&\n                    (isCharacterValue(event.rawEvent) || event.rawEvent.key == ProcessKey)\n                ) {\n                    applyDefaultFormat(this.editor, this.state.defaultFormat);\n                }\n\n                break;\n\n            case PluginEventType.MouseUp:\n            case PluginEventType.ContentChanged:\n                if (!this.canApplyPendingFormat()) {\n                    this.clearPendingFormat();\n                }\n                break;\n        }\n    }\n\n    private checkAndApplyPendingFormat(data: string | null) {\n        if (this.editor && data && this.state.pendingFormat) {\n            applyPendingFormat(this.editor, data, this.state.pendingFormat.format);\n            this.clearPendingFormat();\n        }\n    }\n\n    private clearPendingFormat() {\n        this.state.pendingFormat = null;\n    }\n\n    /**\n     * @internal\n     * Check if this editor can apply pending format\n     * @param editor The editor to get format from\n     */\n    private canApplyPendingFormat(): boolean {\n        let result = false;\n\n        if (this.state.pendingFormat && this.editor) {\n            const selection = this.editor.getDOMSelection();\n            const range =\n                selection?.type == 'range' && selection.range.collapsed ? selection.range : null;\n            const { posContainer, posOffset } = this.state.pendingFormat;\n\n            if (range && range.startContainer == posContainer && range.startOffset == posOffset) {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * @internal\n * Create a new instance of ContentModelFormatPlugin.\n * @param option The editor option\n */\nexport function createContentModelFormatPlugin(\n    option: StandaloneEditorOptions\n): PluginWithState<ContentModelFormatPluginState> {\n    return new ContentModelFormatPlugin(option);\n}\n","import { ChangeSource, Keys, PluginEventType } from 'roosterjs-editor-types';\nimport { isCharacterValue } from '../publicApi/domUtils/eventUtils';\nimport type {\n    DOMEventPluginState,\n    IStandaloneEditor,\n    StandaloneEditorOptions,\n} from 'roosterjs-content-model-types';\nimport type {\n    ContextMenuProvider,\n    DOMEventHandler,\n    EditorPlugin,\n    IEditor,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * DOMEventPlugin handles customized DOM events, including:\n * 1. Keyboard event\n * 2. Mouse event\n * 3. IME state\n * 4. Drop event\n * 5. Focus and blur event\n * 6. Input event\n * 7. Scroll event\n * It contains special handling for Safari since Safari cannot get correct selection when onBlur event is triggered in editor.\n */\nclass DOMEventPlugin implements PluginWithState<DOMEventPluginState> {\n    private editor: (IStandaloneEditor & IEditor) | null = null;\n    private disposer: (() => void) | null = null;\n    private state: DOMEventPluginState;\n\n    /**\n     * Construct a new instance of DOMEventPlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: StandaloneEditorOptions, contentDiv: HTMLDivElement) {\n        this.state = {\n            isInIME: false,\n            scrollContainer: options.scrollContainer || contentDiv,\n            contextMenuProviders:\n                options.plugins?.filter<ContextMenuProvider<any>>(isContextMenuProvider) || [],\n            mouseDownX: null,\n            mouseDownY: null,\n            mouseUpEventListerAdded: false,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'DOMEvent';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor as IStandaloneEditor & IEditor;\n\n        const document = this.editor.getDocument();\n        //Record<string, DOMEventHandler>\n        const eventHandlers: Partial<\n            { [P in keyof HTMLElementEventMap]: DOMEventHandler<HTMLElementEventMap[P]> }\n        > = {\n            // 1. Keyboard event\n            keypress: this.getEventHandler(PluginEventType.KeyPress),\n            keydown: this.getEventHandler(PluginEventType.KeyDown),\n            keyup: this.getEventHandler(PluginEventType.KeyUp),\n\n            // 2. Mouse event\n            mousedown: this.onMouseDown,\n            contextmenu: this.onContextMenuEvent,\n\n            // 3. IME state management\n            compositionstart: () => (this.state.isInIME = true),\n            compositionend: (rawEvent: CompositionEvent) => {\n                this.state.isInIME = false;\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\n                    rawEvent,\n                });\n            },\n\n            // 4. Drag and Drop event\n            dragstart: this.onDragStart,\n            drop: this.onDrop,\n\n            // 5. Input event\n            input: this.getEventHandler(PluginEventType.Input),\n        };\n\n        this.disposer = editor.addDomEventHandler(<Record<string, DOMEventHandler>>eventHandlers);\n\n        // 7. Scroll event\n        this.state.scrollContainer.addEventListener('scroll', this.onScroll);\n        document.defaultView?.addEventListener('scroll', this.onScroll);\n        document.defaultView?.addEventListener('resize', this.onScroll);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.removeMouseUpEventListener();\n\n        const document = this.editor?.getDocument();\n\n        document?.defaultView?.removeEventListener('resize', this.onScroll);\n        document?.defaultView?.removeEventListener('scroll', this.onScroll);\n        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);\n        this.disposer?.();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onDragStart = (e: Event) => {\n        const dragEvent = e as DragEvent;\n        const element = this.editor?.getElementAtCursor('*', dragEvent.target as Node);\n\n        if (element && !element.isContentEditable) {\n            dragEvent.preventDefault();\n        }\n    };\n    private onDrop = () => {\n        this.editor?.runAsync(editor => {\n            editor.addUndoSnapshot(() => {}, ChangeSource.Drop);\n        });\n    };\n\n    private onScroll = (e: Event) => {\n        this.editor?.triggerPluginEvent(PluginEventType.Scroll, {\n            rawEvent: e,\n            scrollContainer: this.state.scrollContainer,\n        });\n    };\n\n    private getEventHandler(eventType: PluginEventType): DOMEventHandler {\n        const beforeDispatch = (event: Event) =>\n            eventType == PluginEventType.Input\n                ? this.onInputEvent(<InputEvent>event)\n                : this.onKeyboardEvent(<KeyboardEvent>event);\n\n        return {\n            pluginEventType: eventType,\n            beforeDispatch,\n        };\n    }\n\n    private onKeyboardEvent = (event: KeyboardEvent) => {\n        if (isCharacterValue(event) || (event.which >= Keys.PAGEUP && event.which <= Keys.DOWN)) {\n            // Stop propagation for Character keys and Up/Down/Left/Right/Home/End/PageUp/PageDown\n            // since editor already handles these keys and no need to propagate to parents\n            event.stopPropagation();\n        }\n    };\n\n    private onInputEvent = (event: InputEvent) => {\n        event.stopPropagation();\n    };\n\n    private onMouseDown = (event: MouseEvent) => {\n        if (this.editor) {\n            if (!this.state.mouseUpEventListerAdded) {\n                this.editor\n                    .getDocument()\n                    .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\n                this.state.mouseUpEventListerAdded = true;\n                this.state.mouseDownX = event.pageX;\n                this.state.mouseDownY = event.pageY;\n            }\n\n            this.editor.triggerPluginEvent(PluginEventType.MouseDown, {\n                rawEvent: event,\n            });\n        }\n    };\n\n    private onMouseUp = (rawEvent: MouseEvent) => {\n        if (this.editor) {\n            this.removeMouseUpEventListener();\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\n                rawEvent,\n                isClicking:\n                    this.state.mouseDownX == rawEvent.pageX &&\n                    this.state.mouseDownY == rawEvent.pageY,\n            });\n        }\n    };\n\n    private onContextMenuEvent = (event: MouseEvent) => {\n        const allItems: any[] = [];\n\n        // TODO: Remove dependency to ContentSearcher\n        const searcher = this.editor?.getContentSearcherOfCursor();\n        const elementBeforeCursor = searcher?.getInlineElementBefore();\n\n        let eventTargetNode = event.target as Node;\n        if (event.button != 2 && elementBeforeCursor) {\n            eventTargetNode = elementBeforeCursor.getContainerNode();\n        }\n        this.state.contextMenuProviders.forEach(provider => {\n            const items = provider.getContextMenuItems(eventTargetNode) ?? [];\n            if (items?.length > 0) {\n                if (allItems.length > 0) {\n                    allItems.push(null);\n                }\n\n                allItems.push(...items);\n            }\n        });\n        this.editor?.triggerPluginEvent(PluginEventType.ContextMenu, {\n            rawEvent: event,\n            items: allItems,\n        });\n    };\n\n    private removeMouseUpEventListener() {\n        if (this.editor && this.state.mouseUpEventListerAdded) {\n            this.state.mouseUpEventListerAdded = false;\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n}\n\nfunction isContextMenuProvider(source: EditorPlugin): source is ContextMenuProvider<any> {\n    return !!(<ContextMenuProvider<any>>source)?.getContextMenuItems;\n}\n\n/**\n * @internal\n * Create a new instance of DOMEventPlugin.\n * @param option The editor option\n * @param contentDiv The editor content DIV element\n */\nexport function createDOMEventPlugin(\n    option: StandaloneEditorOptions,\n    contentDiv: HTMLDivElement\n): PluginWithState<DOMEventPluginState> {\n    return new DOMEventPlugin(option, contentDiv);\n}\n","import { findAllEntities } from './utils/findAllEntities';\nimport {\n    createEntity,\n    generateEntityClassNames,\n    getAllEntityWrappers,\n    getObjectKeys,\n    isEntityElement,\n    parseEntityClassName,\n} from 'roosterjs-content-model-dom';\nimport {\n    ColorTransformDirection,\n    EntityOperation as LegacyEntityOperation,\n    PluginEventType,\n} from 'roosterjs-editor-types';\nimport type {\n    ChangedEntity,\n    ContentModelContentChangedEvent,\n    ContentModelEntityFormat,\n    EntityOperation,\n    EntityPluginState,\n    IStandaloneEditor,\n} from 'roosterjs-content-model-types';\nimport type {\n    ContentChangedEvent,\n    IEditor,\n    PluginEvent,\n    PluginMouseUpEvent,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_ID_REGEX = /_(\\d{1,8})$/;\n\n// This is only used for compatibility with old editor\n// TODO: Remove this map once we have standalone editor\nconst EntityOperationMap: Record<EntityOperation, LegacyEntityOperation> = {\n    newEntity: LegacyEntityOperation.NewEntity,\n    overwrite: LegacyEntityOperation.Overwrite,\n    removeFromEnd: LegacyEntityOperation.RemoveFromEnd,\n    removeFromStart: LegacyEntityOperation.RemoveFromStart,\n    replaceTemporaryContent: LegacyEntityOperation.ReplaceTemporaryContent,\n    updateEntityState: LegacyEntityOperation.UpdateEntityState,\n    click: LegacyEntityOperation.Click,\n};\n\n/**\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\n */\nclass EntityPlugin implements PluginWithState<EntityPluginState> {\n    private editor: (IEditor & IStandaloneEditor) | null = null;\n    private state: EntityPluginState;\n\n    /**\n     * Construct a new instance of EntityPlugin\n     */\n    constructor() {\n        this.state = {\n            entityMap: {},\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Entity';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor as IStandaloneEditor & IEditor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.state.entityMap = {};\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case PluginEventType.MouseUp:\n                    this.handleMouseUpEvent(this.editor, event);\n                    break;\n                case PluginEventType.ContentChanged:\n                    this.handleContentChangedEvent(this.editor, event);\n                    break;\n\n                case PluginEventType.EditorReady:\n                    this.handleContentChangedEvent(this.editor);\n                    break;\n                case PluginEventType.ExtractContentWithDom:\n                    this.handleExtractContentWithDomEvent(this.editor, event.clonedRoot);\n                    break;\n            }\n        }\n    }\n\n    private handleMouseUpEvent(editor: IEditor & IStandaloneEditor, event: PluginMouseUpEvent) {\n        const { rawEvent, isClicking } = event;\n        let node: Node | null = rawEvent.target as Node;\n\n        if (isClicking && this.editor) {\n            while (node && this.editor.contains(node)) {\n                if (isEntityElement(node)) {\n                    this.triggerEvent(editor, node as HTMLElement, 'click', rawEvent);\n                    break;\n                } else {\n                    node = node.parentNode;\n                }\n            }\n        }\n    }\n\n    private handleContentChangedEvent(\n        editor: IStandaloneEditor & IEditor,\n        event?: ContentChangedEvent\n    ) {\n        const cmEvent = event as ContentModelContentChangedEvent | undefined;\n        const modifiedEntities: ChangedEntity[] =\n            cmEvent?.changedEntities ?? this.getChangedEntities(editor);\n        const entityStates = cmEvent?.entityStates;\n\n        modifiedEntities.forEach(entry => {\n            const { entity, operation, rawEvent } = entry;\n            const {\n                entityFormat: { id, entityType, isFakeEntity },\n                wrapper,\n            } = entity;\n\n            if (entityType && !isFakeEntity) {\n                if (operation == 'newEntity') {\n                    entity.entityFormat.id = this.ensureUniqueId(entityType, id ?? '', wrapper);\n                    wrapper.className = generateEntityClassNames(entity.entityFormat);\n\n                    if (entity.entityFormat.isReadonly) {\n                        wrapper.contentEditable = 'false';\n                    }\n\n                    const eventResult = this.triggerEvent(editor, wrapper, operation, rawEvent);\n\n                    this.state.entityMap[entity.entityFormat.id] = {\n                        element: wrapper,\n                        canPersist: eventResult?.shouldPersist,\n                    };\n\n                    if (editor.isDarkMode()) {\n                        editor.transformToDarkColor(wrapper, ColorTransformDirection.LightToDark);\n                    }\n                } else if (id) {\n                    const mapEntry = this.state.entityMap[id];\n\n                    if (mapEntry) {\n                        mapEntry.isDeleted = true;\n                    }\n\n                    this.triggerEvent(editor, wrapper, operation, rawEvent);\n                }\n            }\n        });\n\n        entityStates?.forEach(entityState => {\n            const { id, state } = entityState;\n            const wrapper = this.state.entityMap[id]?.element;\n\n            if (wrapper) {\n                this.triggerEvent(\n                    editor,\n                    wrapper,\n                    'updateEntityState',\n                    undefined /*rawEvent*/,\n                    state\n                );\n            }\n        });\n    }\n\n    private getChangedEntities(editor: IStandaloneEditor): ChangedEntity[] {\n        const result: ChangedEntity[] = [];\n\n        findAllEntities(editor.createContentModel(), result);\n\n        getObjectKeys(this.state.entityMap).forEach(id => {\n            const entry = this.state.entityMap[id];\n\n            if (!entry.isDeleted) {\n                const index = result.findIndex(\n                    x =>\n                        x.operation == 'newEntity' &&\n                        x.entity.entityFormat.id == id &&\n                        x.entity.wrapper == entry.element\n                );\n\n                if (index >= 0) {\n                    // Found matched entity in editor, so there is no change to this entity,\n                    // we can safely remove it from the new entity array\n                    result.splice(index, 1);\n                } else {\n                    // Entity is not in editor, which means it is deleted, use a temporary entity here to represent this entity\n                    const tempEntity = createEntity(entry.element);\n                    let isEntity = false;\n\n                    entry.element.classList.forEach(name => {\n                        isEntity = parseEntityClassName(name, tempEntity.entityFormat) || isEntity;\n                    });\n\n                    if (isEntity) {\n                        result.push({\n                            entity: tempEntity,\n                            operation: 'overwrite',\n                        });\n                    }\n                }\n            }\n        });\n\n        return result;\n    }\n\n    private handleExtractContentWithDomEvent(\n        editor: IEditor & IStandaloneEditor,\n        root: HTMLElement\n    ) {\n        getAllEntityWrappers(root).forEach(element => {\n            element.removeAttribute('contentEditable');\n\n            this.triggerEvent(editor, element, 'replaceTemporaryContent');\n        });\n    }\n\n    private triggerEvent(\n        editor: IEditor & IStandaloneEditor,\n        wrapper: HTMLElement,\n        operation: EntityOperation,\n        rawEvent?: Event,\n        state?: string\n    ) {\n        const format: ContentModelEntityFormat = {};\n        wrapper.classList.forEach(name => {\n            parseEntityClassName(name, format);\n        });\n\n        return format.id && format.entityType && !format.isFakeEntity\n            ? editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n                  operation: EntityOperationMap[operation],\n                  rawEvent,\n                  entity: {\n                      id: format.id,\n                      type: format.entityType,\n                      isReadonly: !!format.isReadonly,\n                      wrapper,\n                  },\n                  state: operation == 'updateEntityState' ? state : undefined,\n              })\n            : null;\n    }\n\n    private ensureUniqueId(type: string, id: string, wrapper: HTMLElement): string {\n        const match = ENTITY_ID_REGEX.exec(id);\n        const baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;\n\n        // Make sure entity id is unique\n        let newId = '';\n\n        for (let num = (match && parseInt(match[1])) || 0; ; num++) {\n            newId = num > 0 ? `${baseId}_${num}` : baseId;\n\n            const item = this.state.entityMap[newId];\n\n            if (!item || item.element == wrapper) {\n                break;\n            }\n        }\n\n        return newId;\n    }\n}\n\n/**\n * @internal\n * Create a new instance of EntityPlugin.\n */\nexport function createEntityPlugin(): PluginWithState<EntityPluginState> {\n    return new EntityPlugin();\n}\n","import { ChangeSource } from '../constants/ChangeSource';\nimport { ColorTransformDirection, PluginEventType } from 'roosterjs-editor-types';\nimport {\n    createBr,\n    createContentModelDocument,\n    createParagraph,\n    createSelectionMarker,\n    setColor,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelDecorator,\n    ContentModelDocument,\n    ContentModelEntity,\n    ContentModelSegment,\n    ContentModelSegmentFormat,\n    ContentModelTableRow,\n    IStandaloneEditor,\n    LifecyclePluginState,\n    OnNodeCreated,\n    StandaloneEditorOptions,\n} from 'roosterjs-content-model-types';\nimport type { IEditor, PluginWithState, PluginEvent } from 'roosterjs-editor-types';\n\nconst ContentEditableAttributeName = 'contenteditable';\nconst DefaultTextColor = '#000000';\nconst DefaultBackColor = '#ffffff';\n\n/**\n * Lifecycle plugin handles editor initialization and disposing\n */\nclass LifecyclePlugin implements PluginWithState<LifecyclePluginState> {\n    private editor: (IStandaloneEditor & IEditor) | null = null;\n    private state: LifecyclePluginState;\n    private initialModel: ContentModelDocument;\n    private initializer: (() => void) | null = null;\n    private disposer: (() => void) | null = null;\n    private adjustColor: () => void;\n\n    /**\n     * Construct a new instance of LifecyclePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: StandaloneEditorOptions, contentDiv: HTMLDivElement) {\n        this.initialModel =\n            options.initialModel ?? this.createInitModel(options.defaultSegmentFormat);\n\n        // Make the container editable and set its selection styles\n        if (contentDiv.getAttribute(ContentEditableAttributeName) === null) {\n            this.initializer = () => {\n                contentDiv.contentEditable = 'true';\n                contentDiv.style.userSelect = 'text';\n            };\n            this.disposer = () => {\n                contentDiv.style.userSelect = '';\n                contentDiv.removeAttribute(ContentEditableAttributeName);\n            };\n        }\n        this.adjustColor = options.doNotAdjustEditorColor\n            ? () => {}\n            : () => {\n                  this.adjustContainerColor(contentDiv);\n              };\n\n        this.state = {\n            isDarkMode: !!options.inDarkMode,\n            onExternalContentTransform: null,\n            shadowEditFragment: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Lifecycle';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor as IEditor & IStandaloneEditor;\n\n        this.editor.setContentModel(\n            this.initialModel,\n            { ignoreSelection: true },\n            this.editor.isDarkMode() ? this.onInitialNodeCreated : undefined\n        );\n\n        // Initial model is only used once. After that we can just clean it up to make sure we don't cache anything useless\n        // including the cached DOM element inside the model.\n        this.initialModel = createContentModelDocument();\n\n        // Set content DIV to be editable\n        this.initializer?.();\n\n        // Set editor background color for dark mode\n        this.adjustColor();\n\n        // Let other plugins know that we are ready\n        this.editor.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor?.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n            this.initializer = null;\n        }\n\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.ContentChanged &&\n            (event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode)\n        ) {\n            this.state.isDarkMode = event.source == ChangeSource.SwitchToDarkMode;\n            this.adjustColor();\n        }\n    }\n\n    private adjustContainerColor(contentDiv: HTMLElement) {\n        if (this.editor) {\n            const { isDarkMode } = this.state;\n            const darkColorHandler = this.editor.getDarkColorHandler();\n\n            setColor(\n                contentDiv,\n                DefaultTextColor,\n                false /*isBackground*/,\n                darkColorHandler,\n                isDarkMode\n            );\n            setColor(\n                contentDiv,\n                DefaultBackColor,\n                true /*isBackground*/,\n                darkColorHandler,\n                isDarkMode\n            );\n        }\n    }\n\n    private createInitModel(format?: ContentModelSegmentFormat) {\n        const model = createContentModelDocument(format);\n        const paragraph = createParagraph(false /*isImplicit*/, undefined /*blockFormat*/, format);\n\n        paragraph.segments.push(createSelectionMarker(format), createBr(format));\n        model.blocks.push(paragraph);\n\n        return model;\n    }\n\n    private onInitialNodeCreated: OnNodeCreated = (model, node) => {\n        if (isEntity(model) && this.editor) {\n            this.editor.transformToDarkColor(node, ColorTransformDirection.LightToDark);\n        }\n    };\n}\n\nfunction isEntity(\n    modelElement:\n        | ContentModelBlock\n        | ContentModelBlockGroup\n        | ContentModelSegment\n        | ContentModelDecorator\n        | ContentModelTableRow\n): modelElement is ContentModelEntity {\n    return (\n        (modelElement as ContentModelSegment).segmentType == 'Entity' ||\n        (modelElement as ContentModelBlock).blockType == 'Entity'\n    );\n}\n\n/**\n * @internal\n * Create a new instance of LifecyclePlugin.\n * @param option The editor option\n * @param contentDiv The editor content DIV element\n */\nexport function createLifecyclePlugin(\n    option: StandaloneEditorOptions,\n    contentDiv: HTMLDivElement\n): PluginWithState<LifecyclePluginState> {\n    return new LifecyclePlugin(option, contentDiv);\n}\n","import { isElementOfType, isNodeOfType, toArray } from 'roosterjs-content-model-dom';\nimport { isModifierKey } from '../publicApi/domUtils/eventUtils';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type { IEditor, PluginEvent, PluginWithState } from 'roosterjs-editor-types';\nimport type {\n    DOMSelection,\n    IStandaloneEditor,\n    SelectionPluginState,\n    StandaloneEditorOptions,\n} from 'roosterjs-content-model-types';\n\nconst MouseMiddleButton = 1;\n\nclass SelectionPlugin implements PluginWithState<SelectionPluginState> {\n    private editor: (IStandaloneEditor & IEditor) | null = null;\n    private state: SelectionPluginState;\n    private disposer: (() => void) | null = null;\n\n    constructor(options: StandaloneEditorOptions) {\n        this.state = {\n            selection: null,\n            selectionStyleNode: null,\n            imageSelectionBorderColor: options.imageSelectionBorderColor, // TODO: Move to Selection core plugin\n        };\n    }\n\n    getName() {\n        return 'Selection';\n    }\n\n    initialize(editor: IEditor) {\n        this.editor = editor as IEditor & IStandaloneEditor;\n\n        const doc = this.editor.getDocument();\n        const styleNode = doc.createElement('style');\n\n        doc.head.appendChild(styleNode);\n        this.state.selectionStyleNode = styleNode;\n\n        const env = this.editor.getEnvironment();\n        const document = this.editor.getDocument();\n\n        if (env.isSafari) {\n            document.addEventListener('mousedown', this.onMouseDownDocument, true /*useCapture*/);\n            document.addEventListener('keydown', this.onKeyDownDocument);\n            document.defaultView?.addEventListener('blur', this.onBlur);\n            this.disposer = this.editor.addDomEventHandler('focus', this.onFocus);\n        } else {\n            this.disposer = this.editor.addDomEventHandler({\n                focus: this.onFocus,\n                blur: this.onBlur,\n            });\n        }\n    }\n\n    dispose() {\n        if (this.state.selectionStyleNode) {\n            this.state.selectionStyleNode.parentNode?.removeChild(this.state.selectionStyleNode);\n            this.state.selectionStyleNode = null;\n        }\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n\n        if (this.editor) {\n            const document = this.editor.getDocument();\n\n            document.removeEventListener(\n                'mousedown',\n                this.onMouseDownDocument,\n                true /*useCapture*/\n            );\n            document.removeEventListener('keydown', this.onKeyDownDocument);\n            document.defaultView?.removeEventListener('blur', this.onBlur);\n\n            this.editor = null;\n        }\n    }\n\n    getState(): SelectionPluginState {\n        return this.state;\n    }\n\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor) {\n            return;\n        }\n\n        let image: HTMLImageElement | null;\n        let selection: DOMSelection | null;\n\n        switch (event.eventType) {\n            case PluginEventType.MouseUp:\n                if (\n                    (image = this.getClickingImage(event.rawEvent)) &&\n                    image.isContentEditable &&\n                    event.rawEvent.button != MouseMiddleButton &&\n                    event.isClicking\n                ) {\n                    this.selectImage(this.editor, image);\n                }\n                break;\n\n            case PluginEventType.MouseDown:\n                selection = this.editor.getDOMSelection();\n\n                if (selection?.type == 'image' && selection.image !== event.rawEvent.target) {\n                    this.selectBeforeImage(this.editor, selection.image);\n                }\n                break;\n\n            case PluginEventType.KeyDown:\n                const rawEvent = event.rawEvent;\n                const key = rawEvent.key;\n                selection = this.editor.getDOMSelection();\n\n                if (\n                    !isModifierKey(rawEvent) &&\n                    !rawEvent.shiftKey &&\n                    selection?.type == 'image' &&\n                    selection.image.parentNode\n                ) {\n                    if (key === 'Escape') {\n                        this.selectBeforeImage(this.editor, selection.image);\n                        event.rawEvent.stopPropagation();\n                    } else if (key !== 'Delete' && key !== 'Backspace') {\n                        this.selectBeforeImage(this.editor, selection.image);\n                    }\n                }\n                break;\n\n            case PluginEventType.ContextMenu:\n                selection = this.editor.getDOMSelection();\n\n                if (\n                    (image = this.getClickingImage(event.rawEvent)) &&\n                    (selection?.type != 'image' || selection.image != image)\n                ) {\n                    this.selectImage(this.editor, image);\n                }\n        }\n    }\n\n    private selectImage(editor: IStandaloneEditor, image: HTMLImageElement) {\n        editor.setDOMSelection({\n            type: 'image',\n            image: image,\n        });\n    }\n\n    private selectBeforeImage(editor: IStandaloneEditor, image: HTMLImageElement) {\n        const doc = editor.getDocument();\n        const parent = image.parentNode;\n        const index = parent && toArray(parent.childNodes).indexOf(image);\n\n        if (parent && index !== null && index >= 0) {\n            const range = doc.createRange();\n            range.setStart(parent, index);\n            range.collapse();\n\n            editor.setDOMSelection({\n                type: 'range',\n                range: range,\n            });\n        }\n    }\n\n    private getClickingImage(event: UIEvent): HTMLImageElement | null {\n        const target = event.target as Node;\n\n        return isNodeOfType(target, 'ELEMENT_NODE') && isElementOfType(target, 'img')\n            ? target\n            : null;\n    }\n\n    private onFocus = () => {\n        if (!this.state.skipReselectOnFocus && this.state.selection) {\n            this.editor?.setDOMSelection(this.state.selection);\n        }\n\n        if (this.state.selection?.type == 'range') {\n            // Editor is focused, now we can get live selection. So no need to keep a selection if the selection type is range.\n            this.state.selection = null;\n        }\n    };\n\n    private onBlur = () => {\n        if (!this.state.selection && this.editor) {\n            this.state.selection = this.editor.getDOMSelection();\n        }\n    };\n\n    private onKeyDownDocument = (event: KeyboardEvent) => {\n        if (event.key == 'Tab' && !event.defaultPrevented) {\n            this.onBlur();\n        }\n    };\n\n    private onMouseDownDocument = (event: MouseEvent) => {\n        if (this.editor && !this.editor.contains(event.target as Node)) {\n            this.onBlur();\n        }\n    };\n}\n\n/**\n * @internal\n * Create a new instance of SelectionPlugin.\n * @param option The editor option\n */\nexport function createSelectionPlugin(\n    options: StandaloneEditorOptions\n): PluginWithState<SelectionPluginState> {\n    return new SelectionPlugin(options);\n}\n","import { ChangeSource } from '../constants/ChangeSource';\nimport { createUndoSnapshotsService } from '../editor/UndoSnapshotsServiceImpl';\nimport { isCursorMovingKey } from '../publicApi/domUtils/eventUtils';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type {\n    IStandaloneEditor,\n    StandaloneEditorOptions,\n    UndoPluginState,\n} from 'roosterjs-content-model-types';\nimport type {\n    ContentChangedEvent,\n    IEditor,\n    PluginEvent,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\nconst Backspace = 'Backspace';\nconst Delete = 'Delete';\nconst Enter = 'Enter';\n\n/**\n * Provides snapshot based undo service for Editor\n */\nclass UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: (IStandaloneEditor & IEditor) | null = null;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: StandaloneEditorOptions) {\n        this.state = {\n            snapshotsService: options.undoSnapshotService || createUndoSnapshotsService(),\n            isRestoring: false,\n            hasNewContent: false,\n            isNested: false,\n            posContainer: null,\n            posOffset: null,\n            lastKeyPress: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor as IEditor & IStandaloneEditor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            !!this.editor &&\n            event.eventType == PluginEventType.KeyDown &&\n            event.rawEvent.key == Backspace &&\n            !event.rawEvent.ctrlKey &&\n            this.canUndoAutoComplete(this.editor)\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        // if editor is in IME, don't do anything\n        if (!this.editor || this.editor.isInIME()) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n                const undoState = this.editor.getUndoState();\n                if (!undoState.canUndo && !undoState.canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case PluginEventType.KeyDown:\n                this.onKeyDown(this.editor, event.rawEvent);\n                break;\n            case PluginEventType.KeyPress:\n                this.onKeyPress(this.editor, event.rawEvent);\n                break;\n            case PluginEventType.CompositionEnd:\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case PluginEventType.ContentChanged:\n                this.onContentChanged(event);\n                break;\n            case PluginEventType.BeforeKeyboardEditing:\n                this.onBeforeKeyboardEditing(event.rawEvent);\n                break;\n        }\n    }\n\n    private onKeyDown(editor: IStandaloneEditor, evt: KeyboardEvent): void {\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        // Ignore if keycombo is ALT+BACKSPACE\n        if ((evt.key == Backspace && !evt.altKey) || evt.key == Delete) {\n            if (evt.key == Backspace && !evt.ctrlKey && this.canUndoAutoComplete(editor)) {\n                evt.preventDefault();\n                editor.undo();\n                this.state.posContainer = null;\n                this.state.posOffset = null;\n                this.state.lastKeyPress = evt.key;\n            } else if (!evt.defaultPrevented) {\n                const selection = editor.getDOMSelection();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selection &&\n                    (selection.type != 'range' ||\n                        !selection.range.collapsed ||\n                        this.state.lastKeyPress != evt.key ||\n                        this.isCtrlOrMetaPressed(editor, evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                this.state.hasNewContent = true;\n                this.state.lastKeyPress = evt.key;\n            }\n        } else if (isCursorMovingKey(evt)) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.state.lastKeyPress = null;\n        } else if (this.state.lastKeyPress == Backspace || this.state.lastKeyPress == Delete) {\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n        }\n    }\n\n    private onKeyPress(editor: IStandaloneEditor, evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        const selection = editor.getDOMSelection();\n\n        if (\n            (selection && (selection.type != 'range' || !selection.range.collapsed)) ||\n            (evt.key == ' ' && this.state.lastKeyPress != ' ') ||\n            evt.key == Enter\n        ) {\n            this.addUndoSnapshot();\n\n            if (evt.key == Enter) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.state.lastKeyPress = evt.key;\n    }\n\n    private onBeforeKeyboardEditing(event: KeyboardEvent) {\n        // For keyboard event (triggered from Content Model), we can get its keycode from event.data\n        // And when user is keep pressing the same key, mark editor with \"hasNewContent\" so that next time user\n        // do some other action or press a different key, we will add undo snapshot\n        if (event.key != this.state.lastKeyPress) {\n            this.addUndoSnapshot();\n        }\n\n        this.state.lastKeyPress = event.key;\n        this.state.hasNewContent = true;\n    }\n\n    private onContentChanged(event: ContentChangedEvent) {\n        if (\n            !(\n                this.state.isRestoring ||\n                event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode ||\n                event.source == ChangeSource.Keyboard\n            )\n        ) {\n            this.clearRedoForInput();\n        }\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsService.clearRedo();\n        this.state.lastKeyPress = null;\n        this.state.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete(editor: IStandaloneEditor) {\n        const selection = editor.getDOMSelection();\n\n        return (\n            this.state.snapshotsService.canUndoAutoComplete() &&\n            selection?.type == 'range' &&\n            selection.range.collapsed &&\n            selection.range.startContainer == this.state.posContainer &&\n            selection.range.startOffset == this.state.posOffset\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor?.addUndoSnapshot();\n        this.state.posContainer = null;\n        this.state.posOffset = null;\n    }\n\n    private isCtrlOrMetaPressed(editor: IStandaloneEditor, event: KeyboardEvent) {\n        const env = editor.getEnvironment();\n\n        return env.isMac ? event.metaKey : event.ctrlKey;\n    }\n}\n\n/**\n * @internal\n * Create a new instance of UndoPlugin.\n * @param option The editor option\n */\nexport function createUndoPlugin(\n    option: StandaloneEditorOptions\n): PluginWithState<UndoPluginState> {\n    return new UndoPlugin(option);\n}\n","import { createContentModelCachePlugin } from './ContentModelCachePlugin';\nimport { createContentModelCopyPastePlugin } from './ContentModelCopyPastePlugin';\nimport { createContentModelFormatPlugin } from './ContentModelFormatPlugin';\nimport { createDOMEventPlugin } from './DOMEventPlugin';\nimport { createEntityPlugin } from './EntityPlugin';\nimport { createLifecyclePlugin } from './LifecyclePlugin';\nimport { createSelectionPlugin } from './SelectionPlugin';\nimport { createUndoPlugin } from './UndoPlugin';\nimport type {\n    StandaloneEditorCorePlugins,\n    StandaloneEditorOptions,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create core plugins for standalone editor\n * @param options Options of editor\n */\nexport function createStandaloneEditorCorePlugins(\n    options: StandaloneEditorOptions,\n    contentDiv: HTMLDivElement\n): StandaloneEditorCorePlugins {\n    return {\n        cache: createContentModelCachePlugin(options),\n        format: createContentModelFormatPlugin(options),\n        copyPaste: createContentModelCopyPastePlugin(options),\n        domEvent: createDOMEventPlugin(options, contentDiv),\n        lifecycle: createLifecyclePlugin(options, contentDiv),\n        entity: createEntityPlugin(),\n        selection: createSelectionPlugin(options),\n        undo: createUndoPlugin(options),\n    };\n}\n","/**\n * @internal\n */\nexport function addRangeToSelection(doc: Document, range: Range) {\n    const selection = doc.defaultView?.getSelection();\n\n    if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n}\n","import { deleteSelection } from '../../publicApi/selection/deleteSelection';\nimport { isBlockElement, isNodeOfType, normalizeContentModel } from 'roosterjs-content-model-dom';\nimport type { IEditor } from 'roosterjs-editor-types';\nimport type { ContentModelSegmentFormat, IStandaloneEditor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * When necessary, set default format as current pending format so it will be applied when Input event is fired\n * @param editor The Content Model Editor\n * @param defaultFormat The default segment format to apply\n */\nexport function applyDefaultFormat(\n    editor: IStandaloneEditor & IEditor,\n    defaultFormat: ContentModelSegmentFormat\n) {\n    const selection = editor.getDOMSelection();\n    const range = selection?.type == 'range' ? selection.range : null;\n    const posContainer = range?.startContainer ?? null;\n    const posOffset = range?.startOffset ?? null;\n\n    if (posContainer) {\n        let node: Node | null = posContainer;\n\n        while (node && editor.contains(node)) {\n            if (isNodeOfType(node, 'ELEMENT_NODE')) {\n                if (node.getAttribute?.('style')) {\n                    return;\n                } else if (isBlockElement(node)) {\n                    break;\n                }\n            }\n\n            node = node.parentNode;\n        }\n    } else {\n        return;\n    }\n\n    editor.formatContentModel((model, context) => {\n        const result = deleteSelection(model, [], context);\n\n        if (result.deleteResult == 'range') {\n            normalizeContentModel(model);\n            editor.addUndoSnapshot();\n\n            return true;\n        } else if (\n            result.deleteResult == 'notDeleted' &&\n            result.insertPoint &&\n            posContainer &&\n            posOffset !== null\n        ) {\n            const { paragraph, path, marker } = result.insertPoint;\n            const blocks = path[0].blocks;\n            const blockCount = blocks.length;\n            const blockIndex = blocks.indexOf(paragraph);\n\n            if (\n                paragraph.isImplicit &&\n                paragraph.segments.length == 1 &&\n                paragraph.segments[0] == marker &&\n                blockCount > 0 &&\n                blockIndex == blockCount - 1\n            ) {\n                // Focus is in the last paragraph which is implicit and there is not other segments.\n                // This can happen when focus is moved after all other content under current block group.\n                // We need to check if browser will merge focus into previous paragraph by checking if\n                // previous block is block. If previous block is paragraph, browser will most likely merge\n                // the input into previous paragraph, then nothing need to do here. Otherwise we need to\n                // apply pending format since this input event will start a new real paragraph.\n                const previousBlock = blocks[blockIndex - 1];\n\n                if (previousBlock?.blockType != 'Paragraph') {\n                    context.newPendingFormat = getNewPendingFormat(\n                        editor,\n                        defaultFormat,\n                        marker.format\n                    );\n                }\n            } else if (paragraph.segments.every(x => x.segmentType != 'Text')) {\n                context.newPendingFormat = getNewPendingFormat(\n                    editor,\n                    defaultFormat,\n                    marker.format\n                );\n            }\n        }\n\n        // We didn't do any change but just apply default format to pending format, so no need to write back\n        return false;\n    });\n}\n\nfunction getNewPendingFormat(\n    editor: IStandaloneEditor,\n    defaultFormat: ContentModelSegmentFormat,\n    markerFormat: ContentModelSegmentFormat\n): ContentModelSegmentFormat {\n    return {\n        ...defaultFormat,\n        ...editor.getPendingFormat(),\n        ...markerFormat,\n    };\n}\n","import { iterateSelections } from '../../publicApi/selection/iterateSelections';\nimport type { ContentModelSegmentFormat, IStandaloneEditor } from 'roosterjs-content-model-types';\nimport {\n    createText,\n    normalizeContentModel,\n    setParagraphNotImplicit,\n} from 'roosterjs-content-model-dom';\n\nconst ANSI_SPACE = '\\u0020';\nconst NON_BREAK_SPACE = '\\u00A0';\n\n/**\n * @internal\n * Apply pending format to the text user just input\n * @param editor The editor to get format from\n * @param data The text user just input\n */\nexport function applyPendingFormat(\n    editor: IStandaloneEditor,\n    data: string,\n    format: ContentModelSegmentFormat\n) {\n    let isChanged = false;\n\n    editor.formatContentModel(\n        (model, context) => {\n            iterateSelections(model, (_, __, block, segments) => {\n                if (\n                    block?.blockType == 'Paragraph' &&\n                    segments?.length == 1 &&\n                    segments[0].segmentType == 'SelectionMarker'\n                ) {\n                    const marker = segments[0];\n                    const index = block.segments.indexOf(marker);\n                    const previousSegment = block.segments[index - 1];\n\n                    if (previousSegment?.segmentType == 'Text') {\n                        const text = previousSegment.text;\n                        const subStr = text.substr(-data.length, data.length);\n\n                        // For space, there can be &#32 (space) or &#160 (&nbsp;), we treat them as the same\n                        if (subStr == data || (data == ANSI_SPACE && subStr == NON_BREAK_SPACE)) {\n                            marker.format = { ...format };\n                            previousSegment.text = text.substring(0, text.length - data.length);\n\n                            const newText = createText(\n                                data == ANSI_SPACE ? NON_BREAK_SPACE : data,\n                                {\n                                    ...previousSegment.format,\n                                    ...format,\n                                }\n                            );\n\n                            block.segments.splice(index, 0, newText);\n                            setParagraphNotImplicit(block);\n                            isChanged = true;\n                        }\n                    }\n                }\n                return true;\n            });\n\n            if (isChanged) {\n                normalizeContentModel(model);\n                context.skipUndoSnapshot = true;\n            }\n\n            return isChanged;\n        },\n        {\n            apiName: 'applyPendingFormat',\n        }\n    );\n}\n","import type { DOMSelection } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Check if the given selections are the same\n */\nexport function areSameSelection(sel1: DOMSelection, sel2: DOMSelection): boolean {\n    if (sel1 == sel2) {\n        return true;\n    }\n\n    switch (sel1.type) {\n        case 'image':\n            return sel2.type == 'image' && sel2.image == sel1.image;\n\n        case 'table':\n            return (\n                sel2.type == 'table' &&\n                sel2.table == sel1.table &&\n                sel2.firstColumn == sel1.firstColumn &&\n                sel2.lastColumn == sel1.lastColumn &&\n                sel2.firstRow == sel1.firstRow &&\n                sel2.lastRow == sel1.lastRow\n            );\n\n        case 'range':\n        default:\n            return sel2.type == 'range' && areSameRanges(sel2.range, sel1.range);\n    }\n}\n\nfunction areSameRanges(r1?: Range, r2?: Range): boolean {\n    return !!(\n        r1 &&\n        r2 &&\n        r1.startContainer == r2.startContainer &&\n        r1.startOffset == r2.startOffset &&\n        r1.endContainer == r2.endContainer &&\n        r1.endOffset == r2.endOffset\n    );\n}\n","import { createSelectionMarker, createText, isNodeOfType } from 'roosterjs-content-model-dom';\nimport { setSelection } from '../../publicApi/selection/setSelection';\nimport type {\n    ContentModelDocument,\n    ContentModelDomIndexer,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelSelectionMarker,\n    ContentModelTable,\n    ContentModelTableRow,\n    ContentModelText,\n    DOMSelection,\n    Selectable,\n} from 'roosterjs-content-model-types';\n\ninterface SegmentItem {\n    paragraph: ContentModelParagraph;\n    segments: ContentModelSegment[];\n}\n\ninterface TableItem {\n    tableRows: ContentModelTableRow[];\n}\n\ninterface IndexedSegmentNode extends Node {\n    __roosterjsContentModel: SegmentItem;\n}\n\ninterface IndexedTableElement extends HTMLTableElement {\n    __roosterjsContentModel: TableItem;\n}\n\nfunction isIndexedSegment(node: Node): node is IndexedSegmentNode {\n    const { paragraph, segments } = (node as IndexedSegmentNode).__roosterjsContentModel ?? {};\n\n    return (\n        paragraph &&\n        paragraph.blockType == 'Paragraph' &&\n        Array.isArray(paragraph.segments) &&\n        Array.isArray(segments)\n    );\n}\n\nfunction onSegment(\n    segmentNode: Node,\n    paragraph: ContentModelParagraph,\n    segment: ContentModelSegment[]\n) {\n    const indexedText = segmentNode as IndexedSegmentNode;\n    indexedText.__roosterjsContentModel = {\n        paragraph,\n        segments: segment,\n    };\n}\n\nfunction onParagraph(paragraphElement: HTMLElement) {\n    let previousText: Text | null = null;\n\n    for (let child = paragraphElement.firstChild; child; child = child.nextSibling) {\n        if (isNodeOfType(child, 'TEXT_NODE')) {\n            if (!previousText) {\n                previousText = child;\n            } else {\n                const item = isIndexedSegment(previousText)\n                    ? previousText.__roosterjsContentModel\n                    : undefined;\n\n                if (item && isIndexedSegment(child)) {\n                    item.segments = item.segments.concat(child.__roosterjsContentModel.segments);\n                    child.__roosterjsContentModel.segments = [];\n                }\n            }\n        } else if (isNodeOfType(child, 'ELEMENT_NODE')) {\n            previousText = null;\n\n            onParagraph(child);\n        } else {\n            previousText = null;\n        }\n    }\n}\n\nfunction onTable(tableElement: HTMLTableElement, table: ContentModelTable) {\n    const indexedTable = tableElement as IndexedTableElement;\n    indexedTable.__roosterjsContentModel = { tableRows: table.rows };\n}\n\nfunction reconcileSelection(\n    model: ContentModelDocument,\n    newSelection: DOMSelection,\n    oldSelection?: DOMSelection\n): boolean {\n    if (oldSelection) {\n        if (\n            oldSelection.type == 'range' &&\n            oldSelection.range.collapsed &&\n            isNodeOfType(oldSelection.range.startContainer, 'TEXT_NODE')\n        ) {\n            if (isIndexedSegment(oldSelection.range.startContainer)) {\n                reconcileTextSelection(oldSelection.range.startContainer);\n            }\n        } else {\n            setSelection(model);\n        }\n    }\n\n    switch (newSelection.type) {\n        case 'image':\n        case 'table':\n            // For image and table selection, we just clear the cached model since during selecting the element id might be changed\n            return false;\n\n        case 'range':\n            const newRange = newSelection.range;\n            if (newRange) {\n                const {\n                    startContainer,\n                    startOffset,\n                    endContainer,\n                    endOffset,\n                    collapsed,\n                } = newRange;\n\n                if (collapsed) {\n                    return !!reconcileNodeSelection(startContainer, startOffset);\n                } else if (\n                    startContainer == endContainer &&\n                    isNodeOfType(startContainer, 'TEXT_NODE')\n                ) {\n                    return (\n                        isIndexedSegment(startContainer) &&\n                        !!reconcileTextSelection(startContainer, startOffset, endOffset)\n                    );\n                } else {\n                    const marker1 = reconcileNodeSelection(startContainer, startOffset);\n                    const marker2 = reconcileNodeSelection(endContainer, endOffset);\n\n                    if (marker1 && marker2) {\n                        setSelection(model, marker1, marker2);\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n\n            break;\n    }\n\n    return false;\n}\n\nfunction reconcileNodeSelection(node: Node, offset: number): Selectable | undefined {\n    if (isNodeOfType(node, 'TEXT_NODE')) {\n        return isIndexedSegment(node) ? reconcileTextSelection(node, offset) : undefined;\n    } else if (offset >= node.childNodes.length) {\n        return insertMarker(node.lastChild, true /*isAfter*/);\n    } else {\n        return insertMarker(node.childNodes[offset], false /*isAfter*/);\n    }\n}\n\nfunction insertMarker(node: Node | null, isAfter: boolean): Selectable | undefined {\n    let marker: ContentModelSelectionMarker | undefined;\n\n    if (node && isIndexedSegment(node)) {\n        const { paragraph, segments } = node.__roosterjsContentModel;\n        const index = paragraph.segments.indexOf(segments[0]);\n\n        if (index >= 0) {\n            const formatSegment =\n                (!isAfter && paragraph.segments[index - 1]) || paragraph.segments[index];\n            marker = createSelectionMarker(formatSegment.format);\n\n            paragraph.segments.splice(isAfter ? index + 1 : index, 0, marker);\n        }\n    }\n\n    return marker;\n}\n\nfunction reconcileTextSelection(\n    textNode: IndexedSegmentNode,\n    startOffset?: number,\n    endOffset?: number\n) {\n    const { paragraph, segments } = textNode.__roosterjsContentModel;\n    const first = segments[0];\n    const last = segments[segments.length - 1];\n    let selectable: Selectable | undefined;\n\n    if (first?.segmentType == 'Text' && last?.segmentType == 'Text') {\n        const newSegments: ContentModelSegment[] = [];\n        const txt = textNode.nodeValue || '';\n        const textSegments: ContentModelText[] = [];\n\n        if (startOffset === undefined) {\n            first.text = txt;\n            newSegments.push(first);\n            textSegments.push(first);\n        } else {\n            if (startOffset > 0) {\n                first.text = txt.substring(0, startOffset);\n                newSegments.push(first);\n                textSegments.push(first);\n            }\n\n            if (endOffset === undefined) {\n                const marker = createSelectionMarker(first.format);\n                newSegments.push(marker);\n\n                selectable = marker;\n                endOffset = startOffset;\n            } else if (endOffset > startOffset) {\n                const middle = createText(\n                    txt.substring(startOffset, endOffset),\n                    first.format,\n                    first.link,\n                    first.code\n                );\n\n                middle.isSelected = true;\n                newSegments.push(middle);\n                textSegments.push(middle);\n                selectable = middle;\n            }\n\n            if (endOffset < txt.length) {\n                const newLast = createText(\n                    txt.substring(endOffset),\n                    first.format,\n                    first.link,\n                    first.code\n                );\n                newSegments.push(newLast);\n                textSegments.push(newLast);\n            }\n        }\n\n        let firstIndex = paragraph.segments.indexOf(first);\n        let lastIndex = paragraph.segments.indexOf(last);\n\n        if (firstIndex >= 0 && lastIndex >= 0) {\n            while (\n                firstIndex > 0 &&\n                paragraph.segments[firstIndex - 1].segmentType == 'SelectionMarker'\n            ) {\n                firstIndex--;\n            }\n\n            while (\n                lastIndex < paragraph.segments.length - 1 &&\n                paragraph.segments[lastIndex + 1].segmentType == 'SelectionMarker'\n            ) {\n                lastIndex++;\n            }\n\n            paragraph.segments.splice(firstIndex, lastIndex - firstIndex + 1, ...newSegments);\n        }\n\n        onSegment(textNode, paragraph, textSegments);\n\n        delete paragraph.cachedElement;\n    }\n\n    return selectable;\n}\n\n/**\n * @internal\n * Implementation of ContentModelDomIndexer\n */\nexport const contentModelDomIndexer: ContentModelDomIndexer = {\n    onSegment,\n    onParagraph,\n    onTable,\n    reconcileSelection,\n};\n","import type { ChangedEntity, ContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function findAllEntities(group: ContentModelBlockGroup, entities: ChangedEntity[]) {\n    group.blocks.forEach(block => {\n        switch (block.blockType) {\n            case 'BlockGroup':\n                findAllEntities(block, entities);\n                break;\n\n            case 'Entity':\n                entities.push({\n                    entity: block,\n                    operation: 'newEntity',\n                });\n                break;\n\n            case 'Paragraph':\n                block.segments.forEach(segment => {\n                    switch (segment.segmentType) {\n                        case 'Entity':\n                            entities.push({\n                                entity: segment,\n                                operation: 'newEntity',\n                            });\n                            break;\n\n                        case 'General':\n                            findAllEntities(segment, entities);\n                            break;\n                    }\n                });\n                break;\n\n            case 'Table':\n                block.rows.forEach(row =>\n                    row.cells.forEach(cell => findAllEntities(cell, entities))\n                );\n                break;\n        }\n    });\n}\n","import { getObjectKeys, parseColor, setColor } from 'roosterjs-editor-dom';\nimport type {\n    ColorKeyAndValue,\n    DarkColorHandler,\n    ModeIndependentColor,\n} from 'roosterjs-editor-types';\n\nconst VARIABLE_REGEX = /^\\s*var\\(\\s*(\\-\\-[a-zA-Z0-9\\-_]+)\\s*(?:,\\s*(.*))?\\)\\s*$/;\nconst VARIABLE_PREFIX = 'var(';\nconst COLOR_VAR_PREFIX = 'darkColor';\nconst enum ColorAttributeEnum {\n    CssColor = 0,\n    HtmlColor = 1,\n}\nconst ColorAttributeName: { [key in ColorAttributeEnum]: string }[] = [\n    {\n        [ColorAttributeEnum.CssColor]: 'color',\n        [ColorAttributeEnum.HtmlColor]: 'color',\n    },\n    {\n        [ColorAttributeEnum.CssColor]: 'background-color',\n        [ColorAttributeEnum.HtmlColor]: 'bgcolor',\n    },\n];\n\n/**\n * @internal\n */\nexport class DarkColorHandlerImpl implements DarkColorHandler {\n    private knownColors: Record<string, Readonly<ModeIndependentColor>> = {};\n\n    constructor(private contentDiv: HTMLElement, private getDarkColor: (color: string) => string) {}\n\n    /**\n     * Get a copy of known colors\n     * @returns\n     */\n    getKnownColorsCopy() {\n        return Object.values(this.knownColors);\n    }\n\n    /**\n     * Given a light mode color value and an optional dark mode color value, register this color\n     * so that editor can handle it, then return the CSS color value for current color mode.\n     * @param lightModeColor Light mode color value\n     * @param isDarkMode Whether current color mode is dark mode\n     * @param darkModeColor Optional dark mode color value. If not passed, we will calculate one.\n     */\n    registerColor(lightModeColor: string, isDarkMode: boolean, darkModeColor?: string): string {\n        const parsedColor = this.parseColorValue(lightModeColor);\n        let colorKey: string | undefined;\n\n        if (parsedColor) {\n            lightModeColor = parsedColor.lightModeColor;\n            darkModeColor = parsedColor.darkModeColor || darkModeColor;\n            colorKey = parsedColor.key;\n        }\n\n        if (isDarkMode && lightModeColor) {\n            colorKey =\n                colorKey || `--${COLOR_VAR_PREFIX}_${lightModeColor.replace(/[^\\d\\w]/g, '_')}`;\n\n            if (!this.knownColors[colorKey]) {\n                darkModeColor = darkModeColor || this.getDarkColor(lightModeColor);\n\n                this.knownColors[colorKey] = { lightModeColor, darkModeColor };\n                this.contentDiv.style.setProperty(colorKey, darkModeColor);\n            }\n\n            return `var(${colorKey}, ${lightModeColor})`;\n        } else {\n            return lightModeColor;\n        }\n    }\n\n    /**\n     * Reset known color record, clean up registered color variables.\n     */\n    reset(): void {\n        getObjectKeys(this.knownColors).forEach(key => this.contentDiv.style.removeProperty(key));\n        this.knownColors = {};\n    }\n\n    /**\n     * Parse an existing color value, if it is in variable-based color format, extract color key,\n     * light color and query related dark color if any\n     * @param color The color string to parse\n     * @param isInDarkMode Whether current content is in dark mode. When set to true, if the color value is not in dark var format,\n     * we will treat is as a dark mode color and try to find a matched dark mode color.\n     */\n    parseColorValue(color: string | undefined | null, isInDarkMode?: boolean): ColorKeyAndValue {\n        let key: string | undefined;\n        let lightModeColor = '';\n        let darkModeColor: string | undefined;\n\n        if (color) {\n            const match = color.startsWith(VARIABLE_PREFIX) ? VARIABLE_REGEX.exec(color) : null;\n\n            if (match) {\n                if (match[2]) {\n                    key = match[1];\n                    lightModeColor = match[2];\n                    darkModeColor = this.knownColors[key]?.darkModeColor;\n                } else {\n                    lightModeColor = '';\n                }\n            } else if (isInDarkMode) {\n                // If editor is in dark mode but the color is not in dark color format, it is possible the color was inserted from external code\n                // without any light color info. So we first try to see if there is a known dark color can match this color, and use its related\n                // light color as light mode color. Otherwise we need to drop this color to avoid show \"white on white\" content.\n                lightModeColor = this.findLightColorFromDarkColor(color) || '';\n\n                if (lightModeColor) {\n                    darkModeColor = color;\n                }\n            } else {\n                lightModeColor = color;\n            }\n        }\n\n        return { key, lightModeColor, darkModeColor };\n    }\n\n    /**\n     * Find related light mode color from dark mode color.\n     * @param darkColor The existing dark color\n     */\n    findLightColorFromDarkColor(darkColor: string): string | null {\n        const rgbSearch = parseColor(darkColor);\n\n        if (rgbSearch) {\n            const key = getObjectKeys(this.knownColors).find(key => {\n                const rgbCurrent = parseColor(this.knownColors[key].darkModeColor);\n\n                return (\n                    rgbCurrent &&\n                    rgbCurrent[0] == rgbSearch[0] &&\n                    rgbCurrent[1] == rgbSearch[1] &&\n                    rgbCurrent[2] == rgbSearch[2]\n                );\n            });\n\n            if (key) {\n                return this.knownColors[key].lightModeColor;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Transform element color, from dark to light or from light to dark\n     * @param element The element to transform color\n     * @param fromDarkMode Whether this is transforming color from dark mode\n     * @param toDarkMode Whether this is transforming color to dark mode\n     */\n    transformElementColor(element: HTMLElement, fromDarkMode: boolean, toDarkMode: boolean): void {\n        ColorAttributeName.forEach((names, i) => {\n            const color = this.parseColorValue(\n                element.style.getPropertyValue(names[ColorAttributeEnum.CssColor]) ||\n                    element.getAttribute(names[ColorAttributeEnum.HtmlColor]),\n                !!fromDarkMode\n            ).lightModeColor;\n\n            element.style.setProperty(names[ColorAttributeEnum.CssColor], null);\n            element.removeAttribute(names[ColorAttributeEnum.HtmlColor]);\n\n            if (color && color != 'inherit') {\n                setColor(element, color, i != 0, toDarkMode, false /*shouldAdaptFontColor*/, this);\n            }\n        });\n    }\n}\n","import type { Snapshot } from 'roosterjs-content-model-types';\nimport type { Snapshots, UndoSnapshotsService } from 'roosterjs-editor-types';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAX_SIZE_LIMIT = 1e7;\n\nclass UndoSnapshotsServiceImpl implements UndoSnapshotsService<Snapshot> {\n    private snapshots: Snapshots<Snapshot>;\n\n    constructor(snapshots?: Snapshots<Snapshot>) {\n        this.snapshots = snapshots ?? {\n            snapshots: [],\n            totalSize: 0,\n            currentIndex: -1,\n            autoCompleteIndex: -1,\n            maxSize: MAX_SIZE_LIMIT,\n        };\n    }\n\n    canMove(step: number): boolean {\n        const newIndex = this.snapshots.currentIndex + step;\n        return newIndex >= 0 && newIndex < this.snapshots.snapshots.length;\n    }\n\n    move(step: number): Snapshot | null {\n        if (this.canMove(step)) {\n            this.snapshots.currentIndex += step;\n            this.snapshots.autoCompleteIndex = -1;\n            return this.snapshots.snapshots[this.snapshots.currentIndex];\n        } else {\n            return null;\n        }\n    }\n\n    addSnapshot(snapshot: Snapshot, isAutoCompleteSnapshot: boolean): void {\n        const currentSnapshot = this.snapshots.snapshots[this.snapshots.currentIndex];\n        const isSameSnapshot =\n            currentSnapshot &&\n            currentSnapshot.html == snapshot.html &&\n            !currentSnapshot.entityStates &&\n            !snapshot.entityStates;\n\n        if (this.snapshots.currentIndex < 0 || !currentSnapshot || !isSameSnapshot) {\n            this.clearRedo();\n            this.snapshots.snapshots.push(snapshot);\n            this.snapshots.currentIndex++;\n            this.snapshots.totalSize += this.getSnapshotLength(snapshot);\n\n            let removeCount = 0;\n            while (\n                removeCount < this.snapshots.snapshots.length &&\n                this.snapshots.totalSize > this.snapshots.maxSize\n            ) {\n                this.snapshots.totalSize -= this.getSnapshotLength(\n                    this.snapshots.snapshots[removeCount]\n                );\n                removeCount++;\n            }\n\n            if (removeCount > 0) {\n                this.snapshots.snapshots.splice(0, removeCount);\n                this.snapshots.currentIndex -= removeCount;\n\n                if (this.snapshots.autoCompleteIndex >= 0) {\n                    this.snapshots.autoCompleteIndex -= removeCount;\n                }\n            }\n\n            if (isAutoCompleteSnapshot) {\n                this.snapshots.autoCompleteIndex = this.snapshots.currentIndex;\n            }\n        } else if (isSameSnapshot) {\n            // replace the currentSnapshot's metadata so the selection is updated\n            this.snapshots.snapshots.splice(this.snapshots.currentIndex, 1, snapshot);\n        }\n    }\n\n    clearRedo(): void {\n        if (this.canMove(1)) {\n            let removedSize = 0;\n            for (\n                let i = this.snapshots.currentIndex + 1;\n                i < this.snapshots.snapshots.length;\n                i++\n            ) {\n                removedSize += this.getSnapshotLength(this.snapshots.snapshots[i]);\n            }\n\n            this.snapshots.snapshots.splice(this.snapshots.currentIndex + 1);\n            this.snapshots.totalSize -= removedSize;\n            this.snapshots.autoCompleteIndex = -1;\n        }\n    }\n\n    canUndoAutoComplete(): boolean {\n        return (\n            this.snapshots.autoCompleteIndex >= 0 &&\n            this.snapshots.currentIndex - this.snapshots.autoCompleteIndex == 1\n        );\n    }\n\n    private getSnapshotLength(snapshot: Snapshot) {\n        return snapshot.html?.length ?? 0;\n    }\n}\n\n/**\n * @internal\n */\nexport function createUndoSnapshotsService(\n    snapshots?: Snapshots<Snapshot>\n): UndoSnapshotsService<Snapshot> {\n    return new UndoSnapshotsServiceImpl(snapshots);\n}\n","import { createStandaloneEditorCorePlugins } from '../corePlugin/createStandaloneEditorCorePlugins';\nimport { createStandaloneEditorDefaultSettings } from './createStandaloneEditorDefaultSettings';\nimport { DarkColorHandlerImpl } from './DarkColorHandlerImpl';\nimport { standaloneCoreApiMap } from './standaloneCoreApiMap';\nimport type { EditorPlugin } from 'roosterjs-editor-types';\nimport type {\n    EditorEnvironment,\n    StandaloneEditorCore,\n    StandaloneEditorCorePluginState,\n    StandaloneEditorCorePlugins,\n    StandaloneEditorOptions,\n    UnportedCoreApiMap,\n    UnportedCorePluginState,\n} from 'roosterjs-content-model-types';\n\n/**\n * A temporary function to create Standalone Editor core\n * @param contentDiv Editor content DIV\n * @param options Editor options\n */\nexport function createStandaloneEditorCore(\n    contentDiv: HTMLDivElement,\n    options: StandaloneEditorOptions,\n    unportedCoreApiMap: UnportedCoreApiMap,\n    unportedCorePluginState: UnportedCorePluginState,\n    tempPlugins: EditorPlugin[]\n): StandaloneEditorCore {\n    const corePlugins = createStandaloneEditorCorePlugins(options, contentDiv);\n\n    return {\n        contentDiv,\n        api: { ...standaloneCoreApiMap, ...unportedCoreApiMap, ...options.coreApiOverride },\n        originalApi: { ...standaloneCoreApiMap, ...unportedCoreApiMap },\n        plugins: [\n            corePlugins.cache,\n            corePlugins.format,\n            corePlugins.copyPaste,\n            corePlugins.domEvent,\n            corePlugins.selection,\n            corePlugins.entity,\n            ...tempPlugins,\n            corePlugins.undo,\n            corePlugins.lifecycle,\n        ],\n        environment: createEditorEnvironment(),\n        darkColorHandler: new DarkColorHandlerImpl(\n            contentDiv,\n            options.getDarkColor ?? getDarkColorFallback\n        ),\n        trustedHTMLHandler: options.trustedHTMLHandler || defaultTrustHtmlHandler,\n        ...createStandaloneEditorDefaultSettings(options),\n        ...getPluginState(corePlugins),\n        ...unportedCorePluginState,\n    };\n}\n\nfunction createEditorEnvironment(): EditorEnvironment {\n    // It is ok to use global window here since the environment should always be the same for all windows in one session\n    const userAgent = window.navigator.userAgent;\n\n    return {\n        isMac: window.navigator.appVersion.indexOf('Mac') != -1,\n        isAndroid: /android/i.test(userAgent),\n        isSafari:\n            userAgent.indexOf('Safari') >= 0 &&\n            userAgent.indexOf('Chrome') < 0 &&\n            userAgent.indexOf('Android') < 0,\n    };\n}\n\n/**\n * @internal export for test only\n */\nexport function defaultTrustHtmlHandler(html: string) {\n    return html;\n}\n\nfunction getPluginState(corePlugins: StandaloneEditorCorePlugins): StandaloneEditorCorePluginState {\n    return {\n        domEvent: corePlugins.domEvent.getState(),\n        copyPaste: corePlugins.copyPaste.getState(),\n        cache: corePlugins.cache.getState(),\n        format: corePlugins.format.getState(),\n        lifecycle: corePlugins.lifecycle.getState(),\n        entity: corePlugins.entity.getState(),\n        selection: corePlugins.selection.getState(),\n        undo: corePlugins.undo.getState(),\n    };\n}\n\n// A fallback function, always return original color\nfunction getDarkColorFallback(color: string) {\n    return color;\n}\n","import { createDomToModelConfig, createModelToDomConfig } from 'roosterjs-content-model-dom';\nimport { listItemMetadataApplier, listLevelMetadataApplier } from '../metadata/updateListMetadata';\nimport { tablePreProcessor } from '../override/tablePreProcessor';\nimport type {\n    DomToModelOption,\n    ModelToDomOption,\n    StandaloneEditorDefaultSettings,\n    StandaloneEditorOptions,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create default DOM and Content Model conversion settings for a standalone editor\n * @param options The editor options\n */\nexport function createStandaloneEditorDefaultSettings(\n    options: StandaloneEditorOptions\n): StandaloneEditorDefaultSettings {\n    const defaultDomToModelOptions: (DomToModelOption | undefined)[] = [\n        {\n            processorOverride: {\n                table: tablePreProcessor,\n            },\n        },\n        options.defaultDomToModelOptions,\n    ];\n    const defaultModelToDomOptions: (ModelToDomOption | undefined)[] = [\n        {\n            metadataAppliers: {\n                listItem: listItemMetadataApplier,\n                listLevel: listLevelMetadataApplier,\n            },\n        },\n        options.defaultModelToDomOptions,\n    ];\n\n    return {\n        defaultDomToModelOptions,\n        defaultModelToDomOptions,\n        defaultDomToModelConfig: createDomToModelConfig(defaultDomToModelOptions),\n        defaultModelToDomConfig: createModelToDomConfig(defaultModelToDomOptions),\n    };\n}\n","import { createContentModel } from '../coreApi/createContentModel';\nimport { createEditorContext } from '../coreApi/createEditorContext';\nimport { focus } from '../coreApi/focus';\nimport { formatContentModel } from '../coreApi/formatContentModel';\nimport { getDOMSelection } from '../coreApi/getDOMSelection';\nimport { getVisibleViewport } from '../coreApi/getVisibleViewport';\nimport { hasFocus } from '../coreApi/hasFocus';\nimport { setContentModel } from '../coreApi/setContentModel';\nimport { setDOMSelection } from '../coreApi/setDOMSelection';\nimport { switchShadowEdit } from '../coreApi/switchShadowEdit';\nimport type { PortedCoreApiMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Core API map for Standalone Content Model Editor\n */\nexport const standaloneCoreApiMap: PortedCoreApiMap = {\n    createContentModel: createContentModel,\n    createEditorContext: createEditorContext,\n    formatContentModel: formatContentModel,\n    getDOMSelection: getDOMSelection,\n    setContentModel: setContentModel,\n    setDOMSelection: setDOMSelection,\n    switchShadowEdit: switchShadowEdit,\n    getVisibleViewport: getVisibleViewport,\n    focus: focus,\n    hasFocus: hasFocus,\n};\n","export { CachedElementHandler, CloneModelOptions, cloneModel } from './publicApi/model/cloneModel';\nexport { paste } from './publicApi/model/paste';\nexport { mergeModel, MergeModelOption } from './publicApi/model/mergeModel';\nexport { isBlockGroupOfType } from './publicApi/model/isBlockGroupOfType';\nexport {\n    getClosestAncestorBlockGroupIndex,\n    TypeOfBlockGroup,\n} from './publicApi/model/getClosestAncestorBlockGroupIndex';\nexport { isBold } from './publicApi/model/isBold';\nexport { createModelFromHtml } from './publicApi/model/createModelFromHtml';\n\nexport {\n    iterateSelections,\n    IterateSelectionsCallback,\n    IterateSelectionsOption,\n} from './publicApi/selection/iterateSelections';\nexport { getSelectionRootNode } from './publicApi/selection/getSelectionRootNode';\nexport { deleteSelection } from './publicApi/selection/deleteSelection';\nexport { deleteSegment } from './publicApi/selection/deleteSegment';\nexport { deleteBlock } from './publicApi/selection/deleteBlock';\nexport {\n    OperationalBlocks,\n    getFirstSelectedListItem,\n    getFirstSelectedTable,\n    getOperationalBlocks,\n    getSelectedParagraphs,\n    getSelectedSegments,\n    getSelectedSegmentsAndParagraphs,\n} from './publicApi/selection/collectSelections';\nexport { setSelection } from './publicApi/selection/setSelection';\n\nexport { applyTableFormat } from './publicApi/table/applyTableFormat';\nexport { normalizeTable } from './publicApi/table/normalizeTable';\nexport { setTableCellBackgroundColor } from './publicApi/table/setTableCellBackgroundColor';\n\nexport { isCharacterValue, isModifierKey } from './publicApi/domUtils/eventUtils';\nexport { combineBorderValue, extractBorderValues } from './publicApi/domUtils/borderValues';\nexport { isPunctuation, isSpace, normalizeText } from './publicApi/domUtils/stringUtil';\nexport { parseTableCells, createTableRanges } from './publicApi/domUtils/tableCellUtils';\n\nexport { updateImageMetadata } from './metadata/updateImageMetadata';\nexport { updateTableCellMetadata } from './metadata/updateTableCellMetadata';\nexport { updateTableMetadata } from './metadata/updateTableMetadata';\nexport { updateListMetadata } from './metadata/updateListMetadata';\n\nexport { ChangeSource } from './constants/ChangeSource';\nexport { BulletListType } from './constants/BulletListType';\nexport { NumberingListType } from './constants/NumberingListType';\nexport { TableBorderFormat } from './constants/TableBorderFormat';\n\nexport { createStandaloneEditorCore } from './editor/createStandaloneEditorCore';\n","import type {\n    ArrayDefinition,\n    BooleanDefinition,\n    Definition,\n    NumberDefinition,\n    ObjectDefinition,\n    ObjectPropertyDefinition,\n    StringDefinition,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Create a number definition\n * @param isOptional Whether this property is optional\n * @param value Optional value of the number\n * @param minValue Optional minimum value\n * @param maxValue Optional maximum value\n * @param allowNull Allow the property to be null\n * @returns The number definition object\n */\nexport function createNumberDefinition(\n    isOptional?: boolean,\n    value?: number,\n    minValue?: number,\n    maxValue?: number,\n    allowNull?: boolean\n): NumberDefinition {\n    return {\n        type: 'number',\n        isOptional,\n        value,\n        maxValue,\n        minValue,\n        allowNull,\n    };\n}\n\n/**\n * @internal\n * Create a boolean definition\n * @param isOptional  Whether this property is optional\n * @param value Optional expected boolean value\n * @param allowNull Allow the property to be null\n * @returns  The boolean definition object\n */\nexport function createBooleanDefinition(\n    isOptional?: boolean,\n    value?: boolean,\n    allowNull?: boolean\n): BooleanDefinition {\n    return {\n        type: 'boolean',\n        isOptional,\n        value,\n        allowNull,\n    };\n}\n\n/**\n * @internal\n * Create a string definition\n * @param isOptional  Whether this property is optional\n * @param value Optional expected string value\n * @param allowNull Allow the property to be null\n * @returns  The string definition object\n */\nexport function createStringDefinition(\n    isOptional?: boolean,\n    value?: string,\n    allowNull?: boolean\n): StringDefinition {\n    return {\n        type: 'string',\n        isOptional,\n        value,\n        allowNull,\n    };\n}\n\n/**\n * @internal\n * Create an array definition\n * @param itemDef Definition of each item of the related array\n * @param isOptional  Whether this property is optional\n * @param allowNull Allow the property to be null\n * @returns  The array definition object\n */\nexport function createArrayDefinition<T>(\n    itemDef: Definition<T>,\n    isOptional?: boolean,\n    minLength?: number,\n    maxLength?: number,\n    allowNull?: boolean\n): ArrayDefinition<T[]> {\n    return {\n        type: 'array',\n        isOptional,\n        itemDef,\n        minLength,\n        maxLength,\n        allowNull,\n    };\n}\n\n/**\n * @internal\n * Create an object definition\n * @param propertyDef Definition of each property of the related object\n * @param isOptional  Whether this property is optional\n * @param allowNull Allow the property to be null\n * @returns  The object definition object\n */\nexport function createObjectDefinition<T extends Object>(\n    propertyDef: ObjectPropertyDefinition<T>,\n    isOptional?: boolean,\n    allowNull?: boolean\n): ObjectDefinition<T> {\n    return {\n        type: 'object',\n        isOptional,\n        propertyDef,\n        allowNull,\n    };\n}\n","import { updateMetadata } from 'roosterjs-content-model-dom';\nimport {\n    createNumberDefinition,\n    createObjectDefinition,\n    createStringDefinition,\n} from './definitionCreators';\nimport type { ContentModelImage, ImageMetadataFormat } from 'roosterjs-content-model-types';\n\nconst NumberDefinition = createNumberDefinition();\n\nconst ImageMetadataFormatDefinition = createObjectDefinition<Required<ImageMetadataFormat>>({\n    widthPx: NumberDefinition,\n    heightPx: NumberDefinition,\n    leftPercent: NumberDefinition,\n    rightPercent: NumberDefinition,\n    topPercent: NumberDefinition,\n    bottomPercent: NumberDefinition,\n    angleRad: NumberDefinition,\n    src: createStringDefinition(),\n    naturalHeight: NumberDefinition,\n    naturalWidth: NumberDefinition,\n});\n\n/**\n * Update image metadata with a callback\n * @param image The image Content Model\n * @param callback The callback function used for updating metadata\n */\nexport function updateImageMetadata(\n    image: ContentModelImage,\n    callback?: (format: ImageMetadataFormat | null) => ImageMetadataFormat | null\n): ImageMetadataFormat | null {\n    return updateMetadata(image, callback, ImageMetadataFormatDefinition);\n}\n","import { BulletListType } from '../constants/BulletListType';\nimport { createNumberDefinition, createObjectDefinition } from './definitionCreators';\nimport { getObjectKeys, updateMetadata } from 'roosterjs-content-model-dom';\nimport { NumberingListType } from '../constants/NumberingListType';\nimport type {\n    ContentModelListItemFormat,\n    ContentModelListItemLevelFormat,\n    ContentModelWithDataset,\n    ListMetadataFormat,\n    MetadataApplier,\n} from 'roosterjs-content-model-types';\n\nconst DefaultOrderedListStyles = ['decimal', 'lower-alpha', 'lower-roman'];\nconst DefaultUnorderedListStyles = ['disc', 'circle', 'square'];\nconst OrderedMapPlaceholderRegex = /\\$\\{(\\w+)\\}/;\nconst CharCodeOfA = 65;\nconst RomanValues: Record<string, number> = {\n    M: 1000,\n    CM: 900,\n    D: 500,\n    CD: 400,\n    C: 100,\n    XC: 90,\n    L: 50,\n    XL: 40,\n    X: 10,\n    IX: 9,\n    V: 5,\n    IV: 4,\n    I: 1,\n};\nconst OrderedMap: Record<number, string> = {\n    [NumberingListType.Decimal]: 'decimal',\n    [NumberingListType.DecimalDash]: '\"${Number}- \"',\n    [NumberingListType.DecimalParenthesis]: '\"${Number}) \"',\n    [NumberingListType.DecimalDoubleParenthesis]: '\"(${Number}) \"',\n    [NumberingListType.LowerAlpha]: 'lower-alpha',\n    [NumberingListType.LowerAlphaDash]: '\"${LowerAlpha}- \"',\n    [NumberingListType.LowerAlphaParenthesis]: '\"${LowerAlpha}) \"',\n    [NumberingListType.LowerAlphaDoubleParenthesis]: '\"(${LowerAlpha}) \"',\n    [NumberingListType.UpperAlpha]: 'upper-alpha',\n    [NumberingListType.UpperAlphaDash]: '\"${UpperAlpha}- \"',\n    [NumberingListType.UpperAlphaParenthesis]: '\"${UpperAlpha}) \"',\n    [NumberingListType.UpperAlphaDoubleParenthesis]: '\"(${UpperAlpha}) \"',\n    [NumberingListType.LowerRoman]: 'lower-roman',\n    [NumberingListType.LowerRomanDash]: '\"${LowerRoman}- \"',\n    [NumberingListType.LowerRomanParenthesis]: '\"${LowerRoman}) \"',\n    [NumberingListType.LowerRomanDoubleParenthesis]: '\"(${LowerRoman}) \"',\n    [NumberingListType.UpperRoman]: 'upper-roman',\n    [NumberingListType.UpperRomanDash]: '\"${UpperRoman}- \"',\n    [NumberingListType.UpperRomanParenthesis]: '\"${UpperRoman}) \"',\n    [NumberingListType.UpperRomanDoubleParenthesis]: '\"(${UpperRoman}) \"',\n};\nconst UnorderedMap: Record<number, string> = {\n    [BulletListType.Disc]: 'disc',\n    [BulletListType.Square]: '\"∎ \"',\n    [BulletListType.Circle]: 'circle',\n    [BulletListType.Dash]: '\"- \"',\n    [BulletListType.LongArrow]: '\"➔ \"',\n    [BulletListType.DoubleLongArrow]: '\"➔ \"',\n    [BulletListType.ShortArrow]: '\"➢ \"',\n    [BulletListType.UnfilledArrow]: '\"➪ \"',\n    [BulletListType.Hyphen]: '\"— \"',\n};\n\nfunction getOrderedListStyleValue(\n    template: string | undefined,\n    listNumber: number\n): string | undefined {\n    return template\n        ? template.replace(OrderedMapPlaceholderRegex, (_, subStr) => {\n              switch (subStr) {\n                  case 'Number':\n                      return listNumber + '';\n                  case 'LowerAlpha':\n                      return convertDecimalsToAlpha(listNumber, true /*isLowerCase*/);\n                  case 'UpperAlpha':\n                      return convertDecimalsToAlpha(listNumber, false /*isLowerCase*/);\n                  case 'LowerRoman':\n                      return convertDecimalsToRoman(listNumber, true /*isLowerCase*/);\n                  case 'UpperRoman':\n                      return convertDecimalsToRoman(listNumber, false /*isLowerCase*/);\n              }\n\n              return '';\n          })\n        : undefined;\n}\n\nfunction convertDecimalsToAlpha(decimal: number, isLowerCase?: boolean): string {\n    let alpha = '';\n    decimal--;\n\n    while (decimal >= 0) {\n        alpha = String.fromCharCode((decimal % 26) + CharCodeOfA) + alpha;\n        decimal = Math.floor(decimal / 26) - 1;\n    }\n    return isLowerCase ? alpha.toLowerCase() : alpha;\n}\n\nfunction convertDecimalsToRoman(decimal: number, isLowerCase?: boolean) {\n    let romanValue = '';\n\n    for (const i of getObjectKeys(RomanValues)) {\n        const timesRomanCharAppear = Math.floor(decimal / RomanValues[i]);\n        decimal = decimal - timesRomanCharAppear * RomanValues[i];\n        romanValue = romanValue + i.repeat(timesRomanCharAppear);\n    }\n    return isLowerCase ? romanValue.toLocaleLowerCase() : romanValue;\n}\n\nconst listMetadataDefinition = createObjectDefinition<ListMetadataFormat>(\n    {\n        orderedStyleType: createNumberDefinition(\n            true /** isOptional */,\n            undefined /** value **/,\n            NumberingListType.Min,\n            NumberingListType.Max\n        ),\n        unorderedStyleType: createNumberDefinition(\n            true /** isOptional */,\n            undefined /** value **/,\n            BulletListType.Min,\n            BulletListType.Max\n        ),\n    },\n    true /** isOptional */,\n    true /** allowNull */\n);\n\nfunction shouldApplyToItem(listStyleType: string) {\n    return listStyleType.indexOf('\"') >= 0;\n}\n\nfunction getRawListStyleType(listType: 'OL' | 'UL', metadata: ListMetadataFormat, depth: number) {\n    const { orderedStyleType, unorderedStyleType } = metadata;\n    if (listType == 'OL') {\n        return orderedStyleType === undefined\n            ? DefaultOrderedListStyles[depth % DefaultOrderedListStyles.length]\n            : OrderedMap[orderedStyleType];\n    } else {\n        return unorderedStyleType === undefined\n            ? DefaultUnorderedListStyles[depth % DefaultUnorderedListStyles.length]\n            : UnorderedMap[unorderedStyleType];\n    }\n}\n\n/**\n * @internal\n */\nexport const listItemMetadataApplier: MetadataApplier<\n    ListMetadataFormat,\n    ContentModelListItemFormat\n> = {\n    metadataDefinition: listMetadataDefinition,\n    applierFunction: (metadata, format, context) => {\n        const depth = context.listFormat.nodeStack.length - 2; // Minus two for the parent element and convert length to index\n\n        if (depth >= 0) {\n            const listType = context.listFormat.nodeStack[depth + 1].listType ?? 'OL';\n            const listStyleType = getRawListStyleType(listType, metadata ?? {}, depth);\n\n            if (listStyleType && shouldApplyToItem(listStyleType)) {\n                format.listStyleType =\n                    listType == 'OL'\n                        ? getOrderedListStyleValue(\n                              listStyleType,\n                              context.listFormat.threadItemCounts[depth]\n                          )\n                        : listStyleType;\n            } else {\n                delete format.listStyleType;\n            }\n        }\n    },\n};\n\n/**\n * @internal\n */\nexport const listLevelMetadataApplier: MetadataApplier<\n    ListMetadataFormat,\n    ContentModelListItemLevelFormat\n> = {\n    metadataDefinition: listMetadataDefinition,\n    applierFunction: (metadata, format, context) => {\n        const depth = context.listFormat.nodeStack.length - 2; // Minus two for the parent element and convert length to index\n\n        if (depth >= 0) {\n            const listType = context.listFormat.nodeStack[depth + 1].listType ?? 'OL';\n            const listStyleType = getRawListStyleType(listType, metadata ?? {}, depth);\n\n            if (listStyleType && !shouldApplyToItem(listStyleType)) {\n                format.listStyleType = listStyleType;\n            } else {\n                delete format.listStyleType;\n            }\n        }\n    },\n};\n\n/**\n * Update list metadata with a callback\n * @param list The list Content Model (metadata holder)\n * @param callback The callback function used for updating metadata\n */\nexport function updateListMetadata(\n    list: ContentModelWithDataset<ListMetadataFormat>,\n    callback?: (format: ListMetadataFormat | null) => ListMetadataFormat | null\n): ListMetadataFormat | null {\n    return updateMetadata(list, callback, listMetadataDefinition);\n}\n","import { createBooleanDefinition, createObjectDefinition } from './definitionCreators';\nimport { updateMetadata } from 'roosterjs-content-model-dom';\nimport type { ContentModelTableCell, TableCellMetadataFormat } from 'roosterjs-content-model-types';\n\nconst TableCellMetadataFormatDefinition = createObjectDefinition<Required<TableCellMetadataFormat>>(\n    {\n        bgColorOverride: createBooleanDefinition(true /** isOptional */),\n        vAlignOverride: createBooleanDefinition(true /** isOptional */),\n        borderOverride: createBooleanDefinition(true /** isOptional */),\n    },\n    false /* isOptional */,\n    true /** allowNull */\n);\n\n/**\n * Update table cell metadata with a callback\n * @param cell The table cell Content Model\n * @param callback The callback function used for updating metadata\n */\nexport function updateTableCellMetadata(\n    cell: ContentModelTableCell,\n    callback?: (format: TableCellMetadataFormat | null) => TableCellMetadataFormat | null\n): TableCellMetadataFormat | null {\n    return updateMetadata(cell, callback, TableCellMetadataFormatDefinition);\n}\n","import { TableBorderFormat } from '../constants/TableBorderFormat';\nimport { updateMetadata } from 'roosterjs-content-model-dom';\nimport {\n    createBooleanDefinition,\n    createNumberDefinition,\n    createObjectDefinition,\n    createStringDefinition,\n} from './definitionCreators';\nimport type { ContentModelTable, TableMetadataFormat } from 'roosterjs-content-model-types';\n\nconst NullStringDefinition = createStringDefinition(\n    false /** isOptional */,\n    undefined /** value */,\n    true /** allowNull */\n);\n\nconst BooleanDefinition = createBooleanDefinition(false /** isOptional */);\n\nconst TableFormatDefinition = createObjectDefinition<Required<TableMetadataFormat>>(\n    {\n        topBorderColor: NullStringDefinition,\n        bottomBorderColor: NullStringDefinition,\n        verticalBorderColor: NullStringDefinition,\n        hasHeaderRow: BooleanDefinition,\n        headerRowColor: NullStringDefinition,\n        hasFirstColumn: BooleanDefinition,\n        hasBandedColumns: BooleanDefinition,\n        hasBandedRows: BooleanDefinition,\n        bgColorEven: NullStringDefinition,\n        bgColorOdd: NullStringDefinition,\n        tableBorderFormat: createNumberDefinition(\n            false /** isOptional */,\n            undefined /* value */,\n            TableBorderFormat.Min /* first table border format */,\n            TableBorderFormat.Max /* last table border format */\n        ),\n        verticalAlign: NullStringDefinition,\n    },\n    false /* isOptional */,\n    true /** allowNull */\n);\n\n/**\n * Update table metadata with a callback\n * @param table The table Content Model\n * @param callback The callback function used for updating metadata\n */\nexport function updateTableMetadata(\n    table: ContentModelTable,\n    callback?: (format: TableMetadataFormat | null) => TableMetadataFormat | null\n): TableMetadataFormat | null {\n    return updateMetadata(table, callback, TableFormatDefinition);\n}\n","import { deleteBlock } from '../../publicApi/selection/deleteBlock';\nimport { deleteSegment } from '../../publicApi/selection/deleteSegment';\nimport { iterateSelections } from '../../publicApi/selection/iterateSelections';\nimport type { IterateSelectionsOption } from '../../publicApi/selection/iterateSelections';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelParagraph,\n    ContentModelSelectionMarker,\n    DeleteSelectionContext,\n    FormatWithContentModelContext,\n    InsertPoint,\n    TableSelectionContext,\n} from 'roosterjs-content-model-types';\nimport {\n    createBr,\n    createParagraph,\n    createSelectionMarker,\n    setParagraphNotImplicit,\n} from 'roosterjs-content-model-dom';\n\nconst DeleteSelectionIteratingOptions: IterateSelectionsOption = {\n    contentUnderSelectedTableCell: 'ignoreForTableOrCell', // When a table cell is selected, we replace all content for this cell, so no need to go into its content\n    contentUnderSelectedGeneralElement: 'generalElementOnly', // When a general element is selected, we replace the whole element so no need to go into its content\n    includeListFormatHolder: 'never',\n};\n\n/**\n * @internal\n * Iterate the model and find all selected content if any, delete them, and keep/create an insert point\n * at the first deleted position so that we know where to put cursor to after delete\n */\nexport function deleteExpandedSelection(\n    model: ContentModelDocument,\n    formatContext?: FormatWithContentModelContext\n): DeleteSelectionContext {\n    const context: DeleteSelectionContext = {\n        deleteResult: 'notDeleted',\n        insertPoint: null,\n        formatContext,\n    };\n\n    iterateSelections(\n        model,\n        (path, tableContext, block, segments) => {\n            // Set paragraph, format and index for default position where we will put cursor to.\n            // Later we can overwrite these info when process the selections\n            let paragraph = createParagraph(\n                true /*implicit*/,\n                undefined /*blockFormat*/,\n                model.format\n            );\n            let markerFormat = model.format;\n            let insertMarkerIndex = 0;\n\n            if (segments) {\n                // Delete segments inside a paragraph\n                if (segments[0] && block?.blockType == 'Paragraph') {\n                    // Now that we have found a paragraph with selections, we can overwrite the default paragraph with this one\n                    // so we can put cursor here after delete\n                    paragraph = block;\n                    insertMarkerIndex = paragraph.segments.indexOf(segments[0]);\n                    markerFormat = segments[0].format;\n\n                    context.lastParagraph = paragraph;\n                    context.lastTableContext = tableContext;\n\n                    segments.forEach((segment, i) => {\n                        if (\n                            i == 0 &&\n                            !context.insertPoint &&\n                            segment.segmentType == 'SelectionMarker'\n                        ) {\n                            // First time we hit a selection and it is a selection marker, just mark it and not need to delete\n                            // because this is possible a collapsed selection, then it will be handled later\n                            context.insertPoint = createInsertPoint(\n                                segment,\n                                block,\n                                path,\n                                tableContext\n                            );\n                        } else if (deleteSegment(block, segment, context.formatContext)) {\n                            context.deleteResult = 'range';\n                        }\n                    });\n\n                    // Since we are operating on this paragraph and it possible we delete everything from this paragraph,\n                    // Need to make it \"not implicit\" so that it will always have a container element, so that when we do normalization\n                    // of this paragraph, a BR can be added if need\n                    if (context.deleteResult == 'range') {\n                        setParagraphNotImplicit(block);\n                    }\n                }\n            } else if (block) {\n                // Delete a whole block (divider, table, ...)\n                const blocks = path[0].blocks;\n\n                if (deleteBlock(blocks, block, paragraph, context.formatContext)) {\n                    context.deleteResult = 'range';\n                }\n            } else if (tableContext) {\n                // Delete a whole table cell\n                const { table, colIndex, rowIndex } = tableContext;\n                const row = table.rows[rowIndex];\n                const cell = row.cells[colIndex];\n\n                path = [cell, ...path];\n                paragraph.segments.push(createBr(model.format));\n                cell.blocks = [paragraph];\n\n                delete cell.cachedElement;\n                delete row.cachedElement;\n                context.deleteResult = 'range';\n            }\n\n            if (!context.insertPoint) {\n                // If we have not got a insert point after delete and we have a paragraph to put an insert point in, create insert point now\n                const marker = createSelectionMarker(markerFormat);\n\n                setParagraphNotImplicit(paragraph);\n                paragraph.segments.splice(insertMarkerIndex, 0, marker);\n                context.insertPoint = createInsertPoint(marker, paragraph, path, tableContext);\n            }\n        },\n        DeleteSelectionIteratingOptions\n    );\n\n    return context;\n}\n\nfunction createInsertPoint(\n    marker: ContentModelSelectionMarker,\n    paragraph: ContentModelParagraph,\n    path: ContentModelBlockGroup[],\n    tableContext: TableSelectionContext | undefined\n): InsertPoint {\n    return {\n        marker,\n        paragraph,\n        path,\n        tableContext,\n    };\n}\n","/**\n * @internal\n */\nexport function deleteSingleChar(text: string, isForward: boolean) {\n    // In case of emoji that occupies multiple characters, we need to delete the whole emoji\n    const array = [...text];\n    let deleteLength = 0;\n\n    for (\n        let i = isForward ? 0 : array.length - 1,\n            deleteState: 'notDeleted' | 'waiting' | 'done' = 'notDeleted';\n        i >= 0 && i < array.length && deleteState != 'done';\n        i += isForward ? 1 : -1\n    ) {\n        switch (array[i]) {\n            case '\\u200D': // ZERO WIDTH JOINER\n            case '\\u20E3': // COMBINING ENCLOSING KEYCAP\n            case '\\uFE0E': // VARIATION SELECTOR-15\n            case '\\uFE0F': // VARIATION SELECTOR-16\n                deleteState = 'notDeleted';\n                deleteLength++;\n                break;\n\n            default:\n                if (deleteState == 'notDeleted') {\n                    deleteState = 'waiting';\n                    deleteLength++;\n                } else if (deleteState == 'waiting') {\n                    deleteState = 'done';\n                }\n                break;\n        }\n    }\n\n    array.splice(isForward ? 0 : array.length - deleteLength, deleteLength);\n\n    return array.join('');\n}\n","import { entityProcessor, hasMetadata, tableProcessor } from 'roosterjs-content-model-dom';\nimport { getSelectionRootNode } from '../publicApi/selection/getSelectionRootNode';\nimport type { DomToModelContext, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const tablePreProcessor: ElementProcessor<HTMLTableElement> = (group, element, context) => {\n    const processor = shouldUseTableProcessor(element, context) ? tableProcessor : entityProcessor;\n\n    processor(group, element, context);\n};\n\nfunction shouldUseTableProcessor(element: HTMLTableElement, context: DomToModelContext) {\n    const selectionRoot = getSelectionRootNode(context.selection);\n    // Treat table as a real table when:\n    // 1. It is a roosterjs table (has metadata)\n    // 2. Table is in selection\n    // 3. There is selection inside table (or whole table is selected)\n    // Otherwise, we treat the table as entity so we will not change it when write back\n    return (\n        hasMetadata(element) ||\n        context.isInSelection ||\n        (selectionRoot && element.contains(selectionRoot))\n    );\n}\n","import type { Border } from 'roosterjs-content-model-types';\n\nconst BorderStyles = [\n    'none',\n    'hidden',\n    'dotted',\n    'dashed',\n    'solid',\n    'double',\n    'groove',\n    'ridge',\n    'inset',\n    'outset',\n];\nconst BorderSizeRegex = /^(thin|medium|thick|[\\d\\.]+\\w*)$/;\n\n/**\n * Extract an integrated border string with border width, style, color to value tuple\n * @param combinedBorder The integrated border style string\n * @returns An array with the splitted values\n */\nexport function extractBorderValues(combinedBorder?: string): Border {\n    const result: Border = {};\n    const values = (combinedBorder || '').replace(/, /g, ',').split(' ');\n\n    values.forEach(v => {\n        if (BorderStyles.indexOf(v) >= 0 && !result.style) {\n            result.style = v;\n        } else if (BorderSizeRegex.test(v) && !result.width) {\n            result.width = v;\n        } else if (v && !result.color) {\n            result.color = v; // TODO: Do we need to use a regex to match all possible colors?\n        }\n    });\n\n    return result;\n}\n\n/**\n * Combine border value array back to string\n * @param values Input string values\n * @param initialValue Initial value for those items without valid value\n */\nexport function combineBorderValue(value: Border): string {\n    return [value.width || '', value.style || '', value.color || ''].join(' ').trim() || 'none';\n}\n","const CTRL_CHAR_CODE = 'Control';\nconst ALT_CHAR_CODE = 'Alt';\nconst META_CHAR_CODE = 'Meta';\n\nconst CursorMovingKeys = new Set<string>([\n    'ArrowUp',\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight',\n    'Home',\n    'End',\n    'PageUp',\n    'PageDown',\n]);\n\n/**\n * Returns true when the event was fired from a modifier key, otherwise false\n * @param event The keyboard event object\n */\nexport function isModifierKey(event: KeyboardEvent): boolean {\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHAR_CODE;\n    const isAltKey = event.altKey || event.key === ALT_CHAR_CODE;\n    const isMetaKey = event.metaKey || event.key === META_CHAR_CODE;\n\n    return isCtrlKey || isAltKey || isMetaKey;\n}\n\n/**\n * Returns true when the event was fired from a key that produces a character value, otherwise false\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\n * So if we missed some case here it is still acceptable.\n * @param event The keyboard event object\n */\nexport function isCharacterValue(event: KeyboardEvent): boolean {\n    return !isModifierKey(event) && !!event.key && event.key.length == 1;\n}\n\n/**\n * @internal\n * Returns true if the given event is a cursor moving event (Left, Right, Up, Down, Home, End, Page Up, Page Down).\n * This does not check modifier keys (Ctrl, Alt, Meta). So if there are modifier keys pressed, it can still return true if one of the modifier key is pressed\n * @param event The keyboard event to check\n */\nexport function isCursorMovingKey(event: KeyboardEvent): boolean {\n    return CursorMovingKeys.has(event.key);\n}\n","const SPACES_REGEX = /[\\u2000\\u2009\\u200a​\\u200b​\\u202f\\u205f​\\u3000\\s\\t\\r\\n]/gm;\nconst PUNCTUATIONS = '.,?!:\"()[]\\\\/';\n\n/**\n * Check if the given character is punctuation\n * @param char The character to check\n */\nexport function isPunctuation(char: string) {\n    return PUNCTUATIONS.indexOf(char) >= 0;\n}\n\n/**\n * Check if the give character is a space. A space can be normal ASCII pace (32) or non-break space (160) or other kinds of spaces\n * such as ZeroWidthSpace, ...\n * @param char The character to check\n */\nexport function isSpace(char: string) {\n    const code = char?.charCodeAt(0) ?? 0;\n    return code == 160 || code == 32 || SPACES_REGEX.test(char);\n}\n\n/**\n * Normalize spaces of the given string. After normalization, all leading (for forward) or trailing (for backward) spaces\n * will be replaces with non-break space (160)\n * @param txt The string to normalize\n * @param isForward Whether normalize forward or backward\n */\nexport function normalizeText(txt: string, isForward: boolean): string {\n    return txt.replace(isForward ? /^\\u0020+/ : /\\u0020+$/, '\\u00A0');\n}\n","import { toArray } from 'roosterjs-content-model-dom';\nimport type { TableSelection } from 'roosterjs-content-model-types';\n\n/**\n * Parse a table into a two dimensions array of TD elements. For those merged cells, the value will be null.\n * @param table Input HTML Table element\n * @returns Array of TD elements\n */\nexport function parseTableCells(table: HTMLTableElement): (HTMLTableCellElement | null)[][] {\n    const trs = toArray(table.rows);\n    const cells: (HTMLTableCellElement | null)[][] = trs.map(row => []);\n\n    trs.forEach((tr, rowIndex) => {\n        for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\n            // Skip the cells which already initialized\n            for (; cells[rowIndex][targetCol] !== undefined; targetCol++) {}\n\n            const td = tr.cells[sourceCol];\n\n            for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\n                for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\n                    if (cells[rowIndex + rowSpan]) {\n                        cells[rowIndex + rowSpan][targetCol] =\n                            colSpan == 0 && rowSpan == 0 ? td : null;\n                    }\n                }\n            }\n        }\n\n        for (let col = 0; col < cells[rowIndex].length; col++) {\n            cells[rowIndex][col] = cells[rowIndex][col] || null;\n        }\n    });\n\n    return cells;\n}\n\n/**\n * Create ranges from a table selection\n * @param selection The source table selection\n * @returns An array of DOM ranges of selected table cells\n */\nexport function createTableRanges(selection: TableSelection): Range[] {\n    const result: Range[] = [];\n    const { table, firstColumn, firstRow, lastColumn, lastRow } = selection;\n    const cells = parseTableCells(table);\n\n    for (let row = firstRow; row <= lastRow; row++) {\n        for (let col = firstColumn; col <= lastColumn; col++) {\n            const td = cells[row]?.[col];\n\n            if (td) {\n                const range = table.ownerDocument.createRange();\n\n                range.selectNode(td);\n                result.push(range);\n            }\n        }\n    }\n\n    return result;\n}\n","import type {\n    ContentModelBlock,\n    ContentModelBlockBase,\n    ContentModelBlockGroupBase,\n    ContentModelBlockGroupType,\n    ContentModelBlockType,\n    ContentModelDivider,\n    ContentModelDocument,\n    ContentModelEntity,\n    ContentModelFormatBase,\n    ContentModelFormatContainer,\n    ContentModelGeneralBlock,\n    ContentModelImage,\n    ContentModelListItem,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelSegmentBase,\n    ContentModelSegmentType,\n    ContentModelSelectionMarker,\n    ContentModelTable,\n    ContentModelTableCell,\n    ContentModelWithDataset,\n    ContentModelWithFormat,\n    ContentModelGeneralSegment,\n    ContentModelText,\n    ContentModelTableRow,\n    ContentModelListLevel,\n} from 'roosterjs-content-model-types';\n\n/**\n * Function type used for cloneModel API to specify how to handle cached element when clone a model\n * @param node The cached node\n * @param type Type of the node, it can be\n * - general: DOM element of ContentModelGeneralSegment or ContentModelGeneralBlock\n * - entity: Wrapper element in ContentModelEntity\n * - cache: Cached node in other model element that supports cache\n */\nexport type CachedElementHandler = (\n    node: HTMLElement,\n    type: 'general' | 'entity' | 'cache'\n) => HTMLElement | undefined;\n\n/**\n *\n * Options for cloneModel API\n */\nexport interface CloneModelOptions {\n    /**\n     * Specify how to deal with cached element, including cached block element, element in General Model, and wrapper element in Entity\n     * - True: Cloned model will have the same reference to the cached element\n     * - False/Not passed: For cached block element, cached element will be undefined. For General Model and Entity, the element will have deep clone and assign to the cloned model\n     * - A callback: invoke the callback with the source cached element and a string to specify model type, let the callback return the expected value of cached element.\n     * For General Model and Entity, the callback must return a valid element, otherwise there will be exception thrown.\n     */\n    includeCachedElement?: boolean | CachedElementHandler;\n}\n\n/**\n * Clone a content model\n * @param model The content model to clone\n * @param options @optional Options to specify customize the clone behavior\n */\nexport function cloneModel(\n    model: ContentModelDocument,\n    options?: CloneModelOptions\n): ContentModelDocument {\n    const newModel: ContentModelDocument = cloneBlockGroupBase(model, options || {});\n\n    if (model.format) {\n        newModel.format = Object.assign({}, model.format);\n    }\n\n    return newModel;\n}\n\nfunction cloneBlock(block: ContentModelBlock, options: CloneModelOptions): ContentModelBlock {\n    switch (block.blockType) {\n        case 'BlockGroup':\n            switch (block.blockGroupType) {\n                case 'FormatContainer':\n                    return cloneFormatContainer(block, options);\n                case 'General':\n                    return cloneGeneralBlock(block, options);\n                case 'ListItem':\n                    return cloneListItem(block, options);\n            }\n            break;\n        case 'Divider':\n            return cloneDivider(block, options);\n        case 'Entity':\n            return cloneEntity(block, options);\n        case 'Paragraph':\n            return cloneParagraph(block, options);\n        case 'Table':\n            return cloneTable(block, options);\n    }\n}\n\nfunction cloneSegment(\n    segment: ContentModelSegment,\n    options: CloneModelOptions\n): ContentModelSegment {\n    switch (segment.segmentType) {\n        case 'Br':\n            return cloneSegmentBase(segment);\n        case 'Entity':\n            return cloneEntity(segment, options);\n        case 'General':\n            return cloneGeneralSegment(segment, options);\n        case 'Image':\n            return cloneImage(segment);\n        case 'SelectionMarker':\n            return cloneSelectionMarker(segment);\n        case 'Text':\n            return cloneText(segment);\n    }\n}\n\nfunction cloneModelWithFormat<T extends ContentModelFormatBase>(\n    model: ContentModelWithFormat<T>\n): ContentModelWithFormat<T> {\n    return {\n        format: Object.assign({}, model.format),\n    };\n}\n\nfunction cloneModelWithDataset<T>(model: ContentModelWithDataset<T>): ContentModelWithDataset<T> {\n    return {\n        dataset: Object.assign({}, model.dataset),\n    };\n}\n\nfunction cloneBlockBase<T extends ContentModelBlockType>(\n    block: ContentModelBlockBase<T>\n): ContentModelBlockBase<T> {\n    const { blockType } = block;\n\n    return Object.assign(\n        {\n            blockType,\n        },\n        cloneModelWithFormat(block)\n    );\n}\n\nfunction cloneBlockGroupBase<T extends ContentModelBlockGroupType>(\n    group: ContentModelBlockGroupBase<T>,\n    options: CloneModelOptions\n): ContentModelBlockGroupBase<T> {\n    const { blockGroupType, blocks } = group;\n\n    return {\n        blockGroupType: blockGroupType,\n        blocks: blocks.map(block => cloneBlock(block, options)),\n    };\n}\n\nfunction cloneSegmentBase<T extends ContentModelSegmentType>(\n    segment: ContentModelSegmentBase<T>\n): ContentModelSegmentBase<T> {\n    const { segmentType, isSelected, code, link } = segment;\n\n    const newSegment: ContentModelSegmentBase<T> = Object.assign(\n        {\n            segmentType,\n            isSelected,\n        },\n        cloneModelWithFormat(segment)\n    );\n\n    if (code) {\n        newSegment.code = cloneModelWithFormat(code);\n    }\n    if (link) {\n        newSegment.link = Object.assign(cloneModelWithFormat(link), cloneModelWithDataset(link));\n    }\n\n    return newSegment;\n}\n\nfunction cloneEntity(entity: ContentModelEntity, options: CloneModelOptions): ContentModelEntity {\n    const { wrapper, entityFormat } = entity;\n\n    return Object.assign(\n        {\n            wrapper: handleCachedElement(wrapper, 'entity', options),\n            entityFormat: { ...entityFormat },\n        },\n        cloneBlockBase(entity),\n        cloneSegmentBase(entity)\n    );\n}\n\nfunction cloneParagraph(\n    paragraph: ContentModelParagraph,\n    options: CloneModelOptions\n): ContentModelParagraph {\n    const { cachedElement, segments, isImplicit, decorator, segmentFormat } = paragraph;\n\n    const newParagraph: ContentModelParagraph = Object.assign(\n        {\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n            isImplicit,\n            segments: segments.map(segment => cloneSegment(segment, options)),\n            segmentFormat: segmentFormat ? { ...segmentFormat } : undefined,\n        },\n        cloneBlockBase(paragraph),\n        cloneModelWithFormat(paragraph)\n    );\n\n    if (decorator) {\n        newParagraph.decorator = Object.assign(\n            {\n                tagName: decorator.tagName,\n            },\n            cloneModelWithFormat(decorator)\n        );\n    }\n\n    return newParagraph;\n}\n\nfunction cloneTable(table: ContentModelTable, options: CloneModelOptions): ContentModelTable {\n    const { cachedElement, widths, rows } = table;\n\n    return Object.assign(\n        {\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n            widths: Array.from(widths),\n            rows: rows.map(row => cloneTableRow(row, options)),\n        },\n        cloneBlockBase(table),\n        cloneModelWithDataset(table)\n    );\n}\n\nfunction cloneTableRow(\n    row: ContentModelTableRow,\n    options: CloneModelOptions\n): ContentModelTableRow {\n    const { height, cells, cachedElement } = row;\n\n    return Object.assign(\n        {\n            height,\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n            cells: cells.map(cell => cloneTableCell(cell, options)),\n        },\n        cloneModelWithFormat(row)\n    );\n}\n\nfunction cloneTableCell(\n    cell: ContentModelTableCell,\n    options: CloneModelOptions\n): ContentModelTableCell {\n    const { cachedElement, isSelected, spanAbove, spanLeft, isHeader } = cell;\n\n    return Object.assign(\n        {\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n            isSelected,\n            spanAbove,\n            spanLeft,\n            isHeader,\n        },\n        cloneBlockGroupBase(cell, options),\n        cloneModelWithFormat(cell),\n        cloneModelWithDataset(cell)\n    );\n}\n\nfunction cloneFormatContainer(\n    container: ContentModelFormatContainer,\n    options: CloneModelOptions\n): ContentModelFormatContainer {\n    const { tagName, cachedElement } = container;\n    const newContainer: ContentModelFormatContainer = Object.assign(\n        { tagName, cachedElement: handleCachedElement(cachedElement, 'cache', options) },\n        cloneBlockBase(container),\n        cloneBlockGroupBase(container, options)\n    );\n\n    if (container.zeroFontSize) {\n        newContainer.zeroFontSize = true;\n    }\n\n    return newContainer;\n}\n\nfunction cloneListItem(\n    item: ContentModelListItem,\n    options: CloneModelOptions\n): ContentModelListItem {\n    const { formatHolder, levels } = item;\n\n    return Object.assign(\n        {\n            formatHolder: cloneSelectionMarker(formatHolder),\n            levels: levels.map(cloneListLevel),\n        },\n        cloneBlockBase(item),\n        cloneBlockGroupBase(item, options)\n    );\n}\n\nfunction cloneListLevel(level: ContentModelListLevel): ContentModelListLevel {\n    const { listType } = level;\n\n    return Object.assign({ listType }, cloneModelWithFormat(level), cloneModelWithDataset(level));\n}\nfunction cloneDivider(\n    divider: ContentModelDivider,\n    options: CloneModelOptions\n): ContentModelDivider {\n    const { tagName, isSelected, cachedElement } = divider;\n\n    return Object.assign(\n        {\n            isSelected,\n            tagName,\n            cachedElement: handleCachedElement(cachedElement, 'cache', options),\n        },\n        cloneBlockBase(divider)\n    );\n}\n\nfunction cloneGeneralBlock(\n    general: ContentModelGeneralBlock,\n    options: CloneModelOptions\n): ContentModelGeneralBlock {\n    const { element } = general;\n\n    return Object.assign(\n        {\n            element: handleCachedElement(element, 'general', options),\n        },\n        cloneBlockBase(general),\n        cloneBlockGroupBase(general, options)\n    );\n}\n\nfunction cloneSelectionMarker(marker: ContentModelSelectionMarker): ContentModelSelectionMarker {\n    return Object.assign({ isSelected: marker.isSelected }, cloneSegmentBase(marker));\n}\n\nfunction cloneImage(image: ContentModelImage): ContentModelImage {\n    const { src, alt, title, isSelectedAsImageSelection } = image;\n\n    return Object.assign(\n        { src, alt, title, isSelectedAsImageSelection },\n        cloneSegmentBase(image),\n        cloneModelWithDataset(image)\n    );\n}\n\nfunction cloneGeneralSegment(\n    general: ContentModelGeneralSegment,\n    options: CloneModelOptions\n): ContentModelGeneralSegment {\n    return Object.assign(cloneGeneralBlock(general, options), cloneSegmentBase(general));\n}\n\nfunction cloneText(textSegment: ContentModelText): ContentModelText {\n    const { text } = textSegment;\n    return Object.assign({ text }, cloneSegmentBase(textSegment));\n}\n\nfunction handleCachedElement<T extends HTMLElement>(\n    node: T,\n    type: 'general' | 'entity',\n    options: CloneModelOptions\n): T;\n\nfunction handleCachedElement<T extends HTMLElement>(\n    node: T | undefined,\n    type: 'cache',\n    options: CloneModelOptions\n): T | undefined;\n\nfunction handleCachedElement<T extends HTMLElement>(\n    node: T | undefined,\n    type: 'general' | 'entity' | 'cache',\n    options: CloneModelOptions\n): T | undefined {\n    const { includeCachedElement } = options;\n\n    if (!node) {\n        return undefined;\n    } else if (!includeCachedElement) {\n        return type == 'cache' ? undefined : (node.cloneNode(true /*deep*/) as T);\n    } else if (includeCachedElement === true) {\n        return node;\n    } else {\n        const result = includeCachedElement(node, type) as T | undefined;\n\n        if ((type == 'general' || type == 'entity') && !result) {\n            throw new Error('Entity and General Model must has wrapper element');\n        }\n\n        return result;\n    }\n}\n","import { createDomToModelContext, domToContentModel } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelDocument,\n    ContentModelSegmentFormat,\n    DomToModelOption,\n} from 'roosterjs-content-model-types';\nimport type { TrustedHTMLHandler } from 'roosterjs-editor-types';\n\n/**\n * Create Content Model from HTML string\n * @param html The source HTML string\n * @param options Options for DOM to Content Model conversion\n * @param trustedHTMLHandler A string handler to convert string to trusted string\n * @returns A Content Model Document object that contains the Content Model from the give HTML, or undefined if failed to parse the source HTML\n */\nexport function createModelFromHtml(\n    html: string,\n    options?: DomToModelOption,\n    trustedHTMLHandler?: TrustedHTMLHandler,\n    defaultSegmentFormat?: ContentModelSegmentFormat\n): ContentModelDocument | undefined {\n    const doc = new DOMParser().parseFromString(trustedHTMLHandler?.(html) ?? html, 'text/html');\n\n    return doc?.body\n        ? domToContentModel(\n              doc.body,\n              createDomToModelContext(\n                  {\n                      defaultFormat: defaultSegmentFormat,\n                  },\n                  options\n              )\n          )\n        : undefined;\n}\n","import type {\n    ContentModelBlockGroup,\n    ContentModelBlockGroupBase,\n    ContentModelBlockGroupType,\n} from 'roosterjs-content-model-types';\n\n/**\n * Retrieve block group type string from a given block group\n */\nexport type TypeOfBlockGroup<\n    T extends ContentModelBlockGroup\n> = T extends ContentModelBlockGroupBase<infer U> ? U : never;\n\n/**\n * Get index of closest ancestor block group of the expected block group type. If not found, return -1\n * @param path The block group path, from the closest one to root\n * @param blockGroupTypes The expected block group types\n * @param stopTypes @optional Block group types that will cause stop searching\n */\nexport function getClosestAncestorBlockGroupIndex<T extends ContentModelBlockGroup>(\n    path: ContentModelBlockGroup[],\n    blockGroupTypes: TypeOfBlockGroup<T>[],\n    stopTypes: ContentModelBlockGroupType[] = []\n): number {\n    for (let i = 0; i < path.length; i++) {\n        const group = path[i];\n\n        if ((blockGroupTypes as string[]).indexOf(group.blockGroupType) >= 0) {\n            return i;\n        } else if (stopTypes.indexOf(group.blockGroupType) >= 0) {\n            // Do not go across boundary specified by stopTypes.\n            // For example, in most case we will set table as the boundary,\n            // in order to allow modify list item under a table when the table itself is in another list item\n            // Although this is not very likely to happen in most case, but we still need to handle it\n            return -1;\n        }\n    }\n\n    return -1;\n}\n","import type { ContentModelBlock, ContentModelBlockGroup } from 'roosterjs-content-model-types';\nimport type { TypeOfBlockGroup } from './getClosestAncestorBlockGroupIndex';\n\n/**\n * Check if the given content model block or block group is of the expected block group type\n * @param input The object to check\n * @param type The expected type\n */\nexport function isBlockGroupOfType<T extends ContentModelBlockGroup>(\n    input: ContentModelBlock | ContentModelBlockGroup | null | undefined,\n    type: TypeOfBlockGroup<T>\n): input is T {\n    const item = <T | null | undefined>input;\n\n    return item?.blockGroupType == type;\n}\n","/**\n * Check if the given bold style represents a bold style\n * @param boldStyle The style to check\n */\nexport function isBold(boldStyle?: string): boolean {\n    return (\n        !!boldStyle && (boldStyle == 'bold' || boldStyle == 'bolder' || parseInt(boldStyle) >= 600)\n    );\n}\n","import { applyTableFormat } from '../table/applyTableFormat';\nimport { deleteSelection } from '../../publicApi/selection/deleteSelection';\nimport { getClosestAncestorBlockGroupIndex } from './getClosestAncestorBlockGroupIndex';\nimport { normalizeTable } from '../table/normalizeTable';\nimport {\n    addSegment,\n    createListItem,\n    createParagraph,\n    createSelectionMarker,\n    createTableCell,\n    getObjectKeys,\n    normalizeContentModel,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockFormat,\n    ContentModelBlockGroup,\n    ContentModelDocument,\n    ContentModelListItem,\n    ContentModelParagraph,\n    ContentModelSegmentFormat,\n    ContentModelTable,\n    FormatWithContentModelContext,\n    InsertPoint,\n} from 'roosterjs-content-model-types';\n\nconst HeadingTags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n\n/**\n * Options to specify how to merge models\n */\nexport interface MergeModelOption {\n    /**\n     * When there is only a table to merge, whether merge this table into current table (if any), or just directly insert (nested table).\n     * This is usually used when paste table inside a table\n     * @default false\n     */\n    mergeTable?: boolean;\n\n    /**\n     * Use this insert position to merge instead of querying selection from target model\n     * @default undefined\n     */\n    insertPosition?: InsertPoint;\n\n    /**\n     * Use this to decide whether to change the source model format when doing the merge.\n     * 'mergeAll': segment format of the insert position will be merged into the content that is merged into current model.\n     * If the source model already has some format, it will not be overwritten.\n     * 'keepSourceEmphasisFormat': format of the insert position will be set into the content that is merged into current model.\n     * If the source model already has emphasis format, such as, fontWeight, Italic or underline different than the default style, it will not be overwritten.\n     * 'none' the source segment format will not be modified.\n     * @default undefined\n     */\n    mergeFormat?: 'mergeAll' | 'keepSourceEmphasisFormat' | 'none';\n}\n\n/**\n * Merge source model into target mode\n * @param target Target Content Model that will merge content into\n * @param source Source Content Model will be merged to target model\n * @param context Format context. When call this function inside formatContentModel, provide this context so that formatContentModel will do extra handling to the result\n * @param options More options, see MergeModelOption\n * @returns Insert point after merge, or null if there is no insert point\n */\nexport function mergeModel(\n    target: ContentModelDocument,\n    source: ContentModelDocument,\n    context?: FormatWithContentModelContext,\n    options?: MergeModelOption\n): InsertPoint | null {\n    const insertPosition =\n        options?.insertPosition ?? deleteSelection(target, [], context).insertPoint;\n\n    if (insertPosition) {\n        if (options?.mergeFormat && options.mergeFormat != 'none') {\n            const newFormat: ContentModelSegmentFormat = {\n                ...(target.format || {}),\n                ...insertPosition.marker.format,\n            };\n\n            applyDefaultFormat(source, newFormat, options?.mergeFormat);\n        }\n\n        for (let i = 0; i < source.blocks.length; i++) {\n            const block = source.blocks[i];\n\n            switch (block.blockType) {\n                case 'Paragraph':\n                    mergeParagraph(insertPosition, block, i == 0, context, options);\n                    break;\n\n                case 'Divider':\n                    insertBlock(insertPosition, block);\n                    break;\n\n                case 'Entity':\n                    insertBlock(insertPosition, block);\n                    context?.newEntities.push(block);\n                    break;\n\n                case 'Table':\n                    if (source.blocks.length == 1 && options?.mergeTable) {\n                        mergeTable(insertPosition, block, source);\n                    } else {\n                        insertBlock(insertPosition, block);\n                    }\n                    break;\n\n                case 'BlockGroup':\n                    switch (block.blockGroupType) {\n                        case 'General':\n                        case 'FormatContainer':\n                            insertBlock(insertPosition, block);\n                            break;\n                        case 'ListItem':\n                            mergeList(insertPosition, block);\n                            break;\n                    }\n                    break;\n            }\n        }\n    }\n\n    normalizeContentModel(target);\n\n    return insertPosition;\n}\n\nfunction mergeParagraph(\n    markerPosition: InsertPoint,\n    newPara: ContentModelParagraph,\n    mergeToCurrentParagraph: boolean,\n    context?: FormatWithContentModelContext,\n    option?: MergeModelOption\n) {\n    const { paragraph, marker } = markerPosition;\n    const newParagraph = mergeToCurrentParagraph\n        ? paragraph\n        : splitParagraph(markerPosition, newPara.format);\n    const segmentIndex = newParagraph.segments.indexOf(marker);\n\n    if (option?.mergeFormat == 'none' && mergeToCurrentParagraph) {\n        newParagraph.segments.forEach(segment => {\n            segment.format = { ...(newParagraph.segmentFormat || {}), ...segment.format };\n        });\n        delete newParagraph.segmentFormat;\n    }\n    if (segmentIndex >= 0) {\n        for (let i = 0; i < newPara.segments.length; i++) {\n            const segment = newPara.segments[i];\n\n            newParagraph.segments.splice(segmentIndex + i, 0, segment);\n\n            if (context) {\n                if (segment.segmentType == 'Entity') {\n                    context.newEntities.push(segment);\n                }\n\n                if (segment.segmentType == 'Image') {\n                    context.newImages.push(segment);\n                }\n            }\n        }\n    }\n\n    if (newPara.decorator) {\n        newParagraph.decorator = { ...newPara.decorator };\n        if (HeadingTags.indexOf(newParagraph.decorator.tagName) > -1) {\n            const sourceKeys: (keyof ContentModelSegmentFormat)[] = getObjectKeys(\n                newParagraph.decorator.format\n            );\n            const segmentDecoratorKeys: (keyof ContentModelSegmentFormat)[] = getObjectKeys(\n                newParagraph.segmentFormat || {}\n            );\n\n            sourceKeys.forEach(key => {\n                if (segmentDecoratorKeys.indexOf(key) > -1) {\n                    delete newParagraph.segmentFormat?.[key];\n                }\n            });\n        }\n    }\n\n    if (!mergeToCurrentParagraph) {\n        newParagraph.format = newPara.format;\n    }\n}\n\nfunction mergeTable(\n    markerPosition: InsertPoint,\n    newTable: ContentModelTable,\n    source: ContentModelDocument\n) {\n    const { tableContext, marker } = markerPosition;\n\n    if (tableContext && source.blocks.length == 1 && source.blocks[0] == newTable) {\n        const { table, colIndex, rowIndex } = tableContext;\n        for (let i = 0; i < newTable.rows.length; i++) {\n            for (let j = 0; j < newTable.rows[i].cells.length; j++) {\n                const newCell = newTable.rows[i].cells[j];\n\n                if (i == 0 && colIndex + j >= table.rows[0].cells.length) {\n                    for (let k = 0; k < table.rows.length; k++) {\n                        const leftCell = table.rows[k]?.cells[colIndex + j - 1];\n                        table.rows[k].cells[colIndex + j] = createTableCell(\n                            false /*spanLeft*/,\n                            false /*spanAbove*/,\n                            leftCell?.isHeader,\n                            leftCell?.format\n                        );\n                    }\n                }\n\n                if (j == 0 && rowIndex + i >= table.rows.length) {\n                    if (!table.rows[rowIndex + i]) {\n                        table.rows[rowIndex + i] = {\n                            cells: [],\n                            format: {},\n                            height: 0,\n                        };\n                    }\n\n                    for (let k = 0; k < table.rows[rowIndex].cells.length; k++) {\n                        const aboveCell = table.rows[rowIndex + i - 1]?.cells[k];\n                        table.rows[rowIndex + i].cells[k] = createTableCell(\n                            false /*spanLeft*/,\n                            false /*spanAbove*/,\n                            false /*isHeader*/,\n                            aboveCell?.format\n                        );\n                    }\n                }\n\n                const oldCell = table.rows[rowIndex + i].cells[colIndex + j];\n                table.rows[rowIndex + i].cells[colIndex + j] = newCell;\n\n                if (i == 0 && j == 0) {\n                    const newMarker = createSelectionMarker(marker.format);\n                    const newPara = addSegment(newCell, newMarker);\n\n                    if (markerPosition.path[0] == oldCell) {\n                        // Update insert point to match the change result\n                        markerPosition.path[0] = newCell;\n                        markerPosition.marker = newMarker;\n                        markerPosition.paragraph = newPara;\n                    }\n                }\n            }\n        }\n\n        normalizeTable(table, markerPosition.marker.format);\n        applyTableFormat(table, undefined /*newFormat*/, true /*keepCellShade*/);\n    } else {\n        insertBlock(markerPosition, newTable);\n    }\n}\n\nfunction mergeList(markerPosition: InsertPoint, newList: ContentModelListItem) {\n    splitParagraph(markerPosition, newList.format);\n\n    const { path, paragraph } = markerPosition;\n\n    const listItemIndex = getClosestAncestorBlockGroupIndex(path, ['ListItem']);\n    const listItem = path[listItemIndex] as ContentModelListItem;\n    const listParent = path[listItemIndex + 1]; // It is ok here when index is -1, that means there is no list and we just insert a new paragraph and use path[0] as its parent\n    const blockIndex = listParent.blocks.indexOf(listItem || paragraph);\n\n    if (blockIndex >= 0) {\n        listParent.blocks.splice(blockIndex, 0, newList);\n    }\n\n    if (listItem) {\n        listItem?.levels.forEach((level, i) => {\n            newList.levels[i] = { ...level };\n        });\n    }\n}\n\nfunction splitParagraph(markerPosition: InsertPoint, newParaFormat: ContentModelBlockFormat) {\n    const { paragraph, marker, path } = markerPosition;\n    const segmentIndex = paragraph.segments.indexOf(marker);\n    const paraIndex = path[0].blocks.indexOf(paragraph);\n    const newParagraph = createParagraph(\n        false /*isImplicit*/,\n        { ...paragraph.format, ...newParaFormat },\n        paragraph.segmentFormat\n    );\n\n    if (segmentIndex >= 0) {\n        newParagraph.segments = paragraph.segments.splice(segmentIndex);\n    }\n\n    if (paraIndex >= 0) {\n        path[0].blocks.splice(paraIndex + 1, 0, newParagraph);\n    }\n\n    const listItemIndex = getClosestAncestorBlockGroupIndex(\n        path,\n        ['ListItem'],\n        ['FormatContainer', 'TableCell']\n    );\n    const listItem = path[listItemIndex] as ContentModelListItem;\n\n    if (listItem) {\n        const listParent = listItemIndex >= 0 ? path[listItemIndex + 1] : null;\n        const blockIndex = listParent ? listParent.blocks.indexOf(listItem) : -1;\n\n        if (blockIndex >= 0 && listParent) {\n            const newListItem = createListItem(listItem.levels, listItem.formatHolder.format);\n\n            if (paraIndex >= 0) {\n                newListItem.blocks = listItem.blocks.splice(paraIndex + 1);\n            }\n\n            if (blockIndex >= 0) {\n                listParent.blocks.splice(blockIndex + 1, 0, newListItem);\n            }\n\n            path[listItemIndex] = newListItem;\n        }\n    }\n\n    markerPosition.paragraph = newParagraph;\n\n    return newParagraph;\n}\n\nfunction insertBlock(markerPosition: InsertPoint, block: ContentModelBlock) {\n    const { path } = markerPosition;\n    const newParaFormat = block.blockType !== 'Paragraph' ? {} : block.format;\n    const newPara = splitParagraph(markerPosition, newParaFormat);\n    const blockIndex = path[0].blocks.indexOf(newPara);\n\n    if (blockIndex >= 0) {\n        path[0].blocks.splice(blockIndex, 0, block);\n    }\n}\n\nfunction applyDefaultFormat(\n    group: ContentModelBlockGroup,\n    format: ContentModelSegmentFormat,\n    applyDefaultFormatOption: 'mergeAll' | 'keepSourceEmphasisFormat'\n) {\n    group.blocks.forEach(block => {\n        switch (block.blockType) {\n            case 'BlockGroup':\n                if (block.blockGroupType == 'ListItem') {\n                    block.formatHolder.format = mergeSegmentFormat(\n                        applyDefaultFormatOption,\n                        format,\n                        block.formatHolder.format\n                    );\n                }\n                applyDefaultFormat(block, format, applyDefaultFormatOption);\n                break;\n\n            case 'Table':\n                block.rows.forEach(row =>\n                    row.cells.forEach(cell => {\n                        applyDefaultFormat(cell, format, applyDefaultFormatOption);\n                    })\n                );\n                break;\n\n            case 'Paragraph':\n                const paragraphFormat = block.decorator?.format || {};\n                block.segments.forEach(segment => {\n                    if (segment.segmentType == 'General') {\n                        applyDefaultFormat(segment, format, applyDefaultFormatOption);\n                    }\n\n                    segment.format = mergeSegmentFormat(applyDefaultFormatOption, format, {\n                        ...paragraphFormat,\n                        ...segment.format,\n                    });\n                });\n\n                if (applyDefaultFormatOption === 'keepSourceEmphasisFormat') {\n                    delete block.decorator;\n                }\n                break;\n        }\n    });\n}\n\nfunction mergeSegmentFormat(\n    applyDefaultFormatOption: 'mergeAll' | 'keepSourceEmphasisFormat',\n    targetformat: ContentModelSegmentFormat,\n    sourceFormat: ContentModelSegmentFormat\n): ContentModelSegmentFormat {\n    return applyDefaultFormatOption == 'mergeAll'\n        ? { ...targetformat, ...sourceFormat }\n        : {\n              ...targetformat,\n              ...getSemanticFormat(sourceFormat),\n          };\n}\n\nfunction getSemanticFormat(segmentFormat: ContentModelSegmentFormat): ContentModelSegmentFormat {\n    const result: ContentModelSegmentFormat = {};\n\n    const { fontWeight, italic, underline } = segmentFormat;\n\n    if (fontWeight && fontWeight != 'normal') {\n        result.fontWeight = fontWeight;\n    }\n    if (italic) {\n        result.italic = italic;\n    }\n    if (underline) {\n        result.underline = underline;\n    }\n\n    return result;\n}\n","import { ChangeSource } from '../../constants/ChangeSource';\nimport { GetContentMode, PasteType as OldPasteType, PluginEventType } from 'roosterjs-editor-types';\nimport { getSelectedSegments } from '../selection/collectSelections';\nimport { mergeModel } from './mergeModel';\nimport type {\n    ContentModelDocument,\n    ContentModelSegmentFormat,\n    FormatWithContentModelContext,\n    InsertPoint,\n    PasteType,\n    ContentModelBeforePasteEventData,\n    ContentModelBeforePasteEvent,\n    IStandaloneEditor,\n} from 'roosterjs-content-model-types';\nimport type { ClipboardData, IEditor } from 'roosterjs-editor-types';\nimport {\n    AllowedEntityClasses,\n    applySegmentFormatToElement,\n    createDomToModelContext,\n    domToContentModel,\n    moveChildNodes,\n} from 'roosterjs-content-model-dom';\nimport {\n    createDefaultHtmlSanitizerOptions,\n    handleImagePaste,\n    handleTextPaste,\n    retrieveMetadataFromClipboard,\n    sanitizePasteContent,\n} from 'roosterjs-editor-dom';\n\n// Map new PasteType to old PasteType\n// TODO: We can remove this once we have standalone editor\nconst PasteTypeMap: Record<PasteType, OldPasteType> = {\n    asImage: OldPasteType.AsImage,\n    asPlainText: OldPasteType.AsPlainText,\n    mergeFormat: OldPasteType.MergeFormat,\n    normal: OldPasteType.Normal,\n};\nconst EmptySegmentFormat: Required<ContentModelSegmentFormat> = {\n    backgroundColor: '',\n    fontFamily: '',\n    fontSize: '',\n    fontWeight: '',\n    italic: false,\n    letterSpacing: '',\n    lineHeight: '',\n    strikethrough: false,\n    superOrSubScriptSequence: '',\n    textColor: '',\n    underline: false,\n};\n\n/**\n * Paste into editor using a clipboardData object\n * @param editor The editor to paste content into\n * @param clipboardData Clipboard data retrieved from clipboard\n * @param pasteType Type of content to paste. @default normal\n */\nexport function paste(\n    editor: IStandaloneEditor & IEditor,\n    clipboardData: ClipboardData,\n    pasteType: PasteType = 'normal'\n) {\n    if (clipboardData.snapshotBeforePaste) {\n        // Restore original content before paste a new one\n        editor.setContent(clipboardData.snapshotBeforePaste);\n    } else {\n        clipboardData.snapshotBeforePaste = editor.getContent(GetContentMode.RawHTMLWithSelection);\n    }\n\n    editor.focus();\n    let originalFormat: ContentModelSegmentFormat | undefined;\n\n    editor.formatContentModel(\n        (model, context) => {\n            const eventData = createBeforePasteEventData(editor, clipboardData, pasteType);\n            const currentSegment = getSelectedSegments(model, true /*includingFormatHolder*/)[0];\n            const { fontFamily, fontSize, textColor, backgroundColor, letterSpacing, lineHeight } =\n                currentSegment?.format ?? {};\n            const {\n                domToModelOption,\n                fragment,\n                customizedMerge,\n            } = triggerPluginEventAndCreatePasteFragment(\n                editor,\n                clipboardData,\n                pasteType,\n                eventData,\n                { fontFamily, fontSize, textColor, backgroundColor, letterSpacing, lineHeight }\n            );\n\n            const pasteModel = domToContentModel(\n                fragment,\n                createDomToModelContext(undefined /*editorContext*/, domToModelOption)\n            );\n\n            const insertPoint = mergePasteContent(\n                model,\n                context,\n                pasteModel,\n                pasteType == 'mergeFormat',\n                customizedMerge\n            );\n\n            if (insertPoint) {\n                originalFormat = insertPoint.marker.format;\n            }\n\n            if (originalFormat) {\n                context.newPendingFormat = {\n                    ...EmptySegmentFormat,\n                    ...model.format,\n                    ...originalFormat,\n                }; // Use empty format as initial value to clear any other format inherits from pasted content\n            }\n\n            return true;\n        },\n\n        {\n            changeSource: ChangeSource.Paste,\n            getChangeData: () => clipboardData,\n            apiName: 'paste',\n        }\n    );\n}\n\n/**\n * @internal\n * Export only for unit test\n */\nexport function mergePasteContent(\n    model: ContentModelDocument,\n    context: FormatWithContentModelContext,\n    pasteModel: ContentModelDocument,\n    applyCurrentFormat: boolean,\n    customizedMerge:\n        | undefined\n        | ((source: ContentModelDocument, target: ContentModelDocument) => InsertPoint | null)\n): InsertPoint | null {\n    return customizedMerge\n        ? customizedMerge(model, pasteModel)\n        : mergeModel(model, pasteModel, context, {\n              mergeFormat: applyCurrentFormat ? 'keepSourceEmphasisFormat' : 'none',\n              mergeTable: shouldMergeTable(pasteModel),\n          });\n}\n\nfunction shouldMergeTable(pasteModel: ContentModelDocument): boolean | undefined {\n    // If model contains a table and a paragraph element after the table with a single BR segment, remove the Paragraph after the table\n    if (\n        pasteModel.blocks.length == 2 &&\n        pasteModel.blocks[0].blockType === 'Table' &&\n        pasteModel.blocks[1].blockType === 'Paragraph' &&\n        pasteModel.blocks[1].segments.length === 1 &&\n        pasteModel.blocks[1].segments[0].segmentType === 'Br'\n    ) {\n        pasteModel.blocks.splice(1);\n    }\n    // Only merge table when the document contain a single table.\n    return pasteModel.blocks.length === 1 && pasteModel.blocks[0].blockType === 'Table';\n}\n\nfunction createBeforePasteEventData(\n    editor: IEditor,\n    clipboardData: ClipboardData,\n    pasteType: PasteType\n): ContentModelBeforePasteEventData {\n    const options = createDefaultHtmlSanitizerOptions();\n\n    options.additionalAllowedCssClasses.push(...AllowedEntityClasses);\n\n    // Remove \"caret-color\" style generated by Safari to make sure caret shows in right color after paste\n    options.cssStyleCallbacks['caret-color'] = () => false;\n\n    return {\n        clipboardData,\n        fragment: editor.getDocument().createDocumentFragment(),\n        sanitizingOption: options,\n        htmlBefore: '',\n        htmlAfter: '',\n        htmlAttributes: {},\n        domToModelOption: {},\n        pasteType: PasteTypeMap[pasteType],\n    };\n}\n\n/**\n * This function is used to create a BeforePasteEvent object after trigger the event, so other plugins can modify the event object\n * This function will also create a DocumentFragment for paste.\n */\nfunction triggerPluginEventAndCreatePasteFragment(\n    editor: IEditor,\n    clipboardData: ClipboardData,\n    pasteType: PasteType,\n    eventData: ContentModelBeforePasteEventData,\n    currentFormat: ContentModelSegmentFormat\n): ContentModelBeforePasteEventData {\n    const event = {\n        eventType: PluginEventType.BeforePaste,\n        ...eventData,\n    } as ContentModelBeforePasteEvent;\n\n    const { fragment } = event;\n    const { rawHtml, text, imageDataUri } = clipboardData;\n    const trustedHTMLHandler = editor.getTrustedHTMLHandler();\n\n    const doc: Document | undefined = rawHtml\n        ? new DOMParser().parseFromString(trustedHTMLHandler(rawHtml), 'text/html')\n        : undefined;\n\n    // Step 2: Retrieve Metadata from Html and the Html that was copied.\n    retrieveMetadataFromClipboard(doc, event, trustedHTMLHandler);\n\n    // Step 3: Fill the BeforePasteEvent object, especially the fragment for paste\n    if (\n        (pasteType == 'asImage' && imageDataUri) ||\n        (pasteType != 'asPlainText' && !text && imageDataUri)\n    ) {\n        // Paste image\n        handleImagePaste(imageDataUri, fragment);\n    } else if (pasteType != 'asPlainText' && rawHtml && doc ? doc.body : false) {\n        moveChildNodes(fragment, doc?.body);\n    } else if (text) {\n        // Paste text\n        handleTextPaste(text, null /*position*/, fragment);\n    }\n\n    const formatContainer = fragment.ownerDocument.createElement('span');\n\n    moveChildNodes(formatContainer, fragment);\n    fragment.appendChild(formatContainer);\n\n    applySegmentFormatToElement(formatContainer, currentFormat);\n\n    let pluginEvent: ContentModelBeforePasteEvent = event;\n\n    // Step 4: Trigger BeforePasteEvent so that plugins can do proper change before paste, when the type of paste is different than Plain Text\n    if (pasteType !== 'asPlainText') {\n        pluginEvent = editor.triggerPluginEvent(\n            PluginEventType.BeforePaste,\n            event,\n            true /* broadcast */\n        ) as ContentModelBeforePasteEvent;\n    }\n\n    // Step 5. Sanitize the fragment before paste to make sure the content is safe\n    sanitizePasteContent(event, null /*position*/);\n\n    return pluginEvent;\n}\n","import { getClosestAncestorBlockGroupIndex } from '../model/getClosestAncestorBlockGroupIndex';\nimport { isBlockGroupOfType } from '../model/isBlockGroupOfType';\nimport { iterateSelections } from './iterateSelections';\nimport type { IterateSelectionsOption } from './iterateSelections';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelBlockGroupType,\n    ContentModelDocument,\n    ContentModelListItem,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelTable,\n    TableSelectionContext,\n} from 'roosterjs-content-model-types';\nimport type { TypeOfBlockGroup } from '../model/getClosestAncestorBlockGroupIndex';\n\n/**\n * Represent a pair of parent block group and child block\n */\nexport type OperationalBlocks<T extends ContentModelBlockGroup> = {\n    /**\n     * The parent block group\n     */\n    parent: ContentModelBlockGroup;\n\n    /**\n     * The child block\n     */\n    block: ContentModelBlock | T;\n};\n\n/**\n * Get an array of selected parent paragraph and child segment pair\n * @param model The Content Model to get selection from\n * @param includingFormatHolder True means also include format holder as segment from list item, in that case paragraph will be null\n */\nexport function getSelectedSegmentsAndParagraphs(\n    model: ContentModelDocument,\n    includingFormatHolder: boolean\n): [ContentModelSegment, ContentModelParagraph | null][] {\n    const selections = collectSelections(model, {\n        includeListFormatHolder: includingFormatHolder ? 'allSegments' : 'never',\n    });\n    const result: [ContentModelSegment, ContentModelParagraph | null][] = [];\n\n    selections.forEach(({ segments, block }) => {\n        if (segments && ((includingFormatHolder && !block) || block?.blockType == 'Paragraph')) {\n            segments.forEach(segment => {\n                if (segment.segmentType != 'Entity' || !segment.entityFormat.isReadonly) {\n                    result.push([segment, block?.blockType == 'Paragraph' ? block : null]);\n                }\n            });\n        }\n    });\n\n    return result;\n}\n\n/**\n * Get an array of selected segments from a content model\n * @param model The Content Model to get selection from\n * @param includingFormatHolder True means also include format holder as segment from list item\n */\nexport function getSelectedSegments(\n    model: ContentModelDocument,\n    includingFormatHolder: boolean\n): ContentModelSegment[] {\n    return getSelectedSegmentsAndParagraphs(model, includingFormatHolder).map(x => x[0]);\n}\n\n/**\n * Get any array of selected paragraphs from a content model\n * @param model The Content Model to get selection from\n */\nexport function getSelectedParagraphs(model: ContentModelDocument): ContentModelParagraph[] {\n    const selections = collectSelections(model, { includeListFormatHolder: 'never' });\n    const result: ContentModelParagraph[] = [];\n\n    removeUnmeaningfulSelections(selections);\n\n    selections.forEach(({ block }) => {\n        if (block?.blockType == 'Paragraph') {\n            result.push(block);\n        }\n    });\n\n    return result;\n}\n\n/**\n * Get an array of block group - block pair that is of the expected block group type from selection\n * @param model The Content Model to get selection from\n * @param blockGroupTypes The expected block group types\n * @param stopTypes Block group types that will stop searching when hit\n * @param deepFirst True means search in deep first, otherwise wide first\n */\nexport function getOperationalBlocks<T extends ContentModelBlockGroup>(\n    model: ContentModelDocument,\n    blockGroupTypes: TypeOfBlockGroup<T>[],\n    stopTypes: ContentModelBlockGroupType[],\n    deepFirst?: boolean\n): OperationalBlocks<T>[] {\n    const result: OperationalBlocks<T>[] = [];\n    const findSequence = deepFirst ? blockGroupTypes.map(type => [type]) : [blockGroupTypes];\n    const selections = collectSelections(model, {\n        includeListFormatHolder: 'never',\n        contentUnderSelectedTableCell: 'ignoreForTable', // When whole table is selected, we treat the table as a single block\n    });\n\n    removeUnmeaningfulSelections(selections);\n\n    selections.forEach(({ path, block }) => {\n        for (let i = 0; i < findSequence.length; i++) {\n            const groupIndex = getClosestAncestorBlockGroupIndex(path, findSequence[i], stopTypes);\n\n            if (groupIndex >= 0) {\n                if (result.filter(x => x.block == path[groupIndex]).length <= 0) {\n                    result.push({\n                        parent: path[groupIndex + 1],\n                        block: path[groupIndex] as T,\n                    });\n                }\n                break;\n            } else if (i == findSequence.length - 1 && block) {\n                result.push({\n                    parent: path[0],\n                    block: block,\n                });\n                break;\n            }\n        }\n    });\n\n    return result;\n}\n\n/**\n * Get the first selected table from content model\n * @param model The Content Model to get selection from\n */\nexport function getFirstSelectedTable(\n    model: ContentModelDocument\n): [ContentModelTable | undefined, ContentModelBlockGroup[]] {\n    const selections = collectSelections(model, { includeListFormatHolder: 'never' });\n    let table: ContentModelTable | undefined;\n    let resultPath: ContentModelBlockGroup[] = [];\n\n    removeUnmeaningfulSelections(selections);\n\n    selections.forEach(({ block, tableContext, path }) => {\n        if (!table) {\n            if (block?.blockType == 'Table') {\n                table = block;\n                resultPath = [...path];\n            } else if (tableContext?.table) {\n                table = tableContext.table;\n\n                const parent = path.filter(\n                    group => group.blocks.indexOf(tableContext.table) >= 0\n                )[0];\n                const index = path.indexOf(parent);\n                resultPath = index >= 0 ? path.slice(index) : [];\n            }\n        }\n    });\n\n    return [table, resultPath];\n}\n\n/**\n * Get the first selected list item from content model\n * @param model The Content Model to get selection from\n */\nexport function getFirstSelectedListItem(\n    model: ContentModelDocument\n): ContentModelListItem | undefined {\n    let listItem: ContentModelListItem | undefined;\n\n    getOperationalBlocks(model, ['ListItem'], ['TableCell']).forEach(r => {\n        if (!listItem && isBlockGroupOfType<ContentModelListItem>(r.block, 'ListItem')) {\n            listItem = r.block;\n        }\n    });\n\n    return listItem;\n}\n\ninterface SelectionInfo {\n    path: ContentModelBlockGroup[];\n    segments?: ContentModelSegment[];\n    block?: ContentModelBlock;\n    tableContext?: TableSelectionContext;\n}\n\nfunction collectSelections(\n    model: ContentModelDocument,\n    option?: IterateSelectionsOption\n): SelectionInfo[] {\n    const selections: SelectionInfo[] = [];\n\n    iterateSelections(\n        model,\n        (path, tableContext, block, segments) => {\n            selections.push({\n                path,\n                tableContext,\n                block,\n                segments,\n            });\n        },\n        option\n    );\n\n    return selections;\n}\n\nfunction removeUnmeaningfulSelections(selections: SelectionInfo[]) {\n    if (\n        selections.length > 1 &&\n        isOnlySelectionMarkerSelected(selections, false /*checkFirstParagraph*/)\n    ) {\n        selections.pop();\n    }\n\n    // Remove head paragraph if first selection marker is the only selection\n    if (\n        selections.length > 1 &&\n        isOnlySelectionMarkerSelected(selections, true /*checkFirstParagraph*/)\n    ) {\n        selections.shift();\n    }\n}\n\nfunction isOnlySelectionMarkerSelected(\n    selections: SelectionInfo[],\n    checkFirstParagraph: boolean\n): boolean {\n    const selection = selections[checkFirstParagraph ? 0 : selections.length - 1];\n\n    if (\n        selection.block?.blockType == 'Paragraph' &&\n        selection.segments &&\n        selection.segments.length > 0\n    ) {\n        const allSegments = selection.block.segments;\n        const segment = selection.segments[0];\n\n        return (\n            selection.segments.length == 1 &&\n            segment.segmentType == 'SelectionMarker' &&\n            segment == allSegments[checkFirstParagraph ? allSegments.length - 1 : 0]\n        );\n    } else {\n        return false;\n    }\n}\n","import type {\n    ContentModelBlock,\n    EntityRemovalOperation,\n    FormatWithContentModelContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Delete a content model block from current selection\n * @param blocks Array of the block to delete\n * @param blockToDelete The block to delete\n * @param replacement @optional If specified, use this block to replace the deleted block\n * @param context @optional Context object provided by formatContentModel API\n * @param direction @optional Whether this is deleting forward or backward. This is only used for deleting entity.\n * If not specified, only selected entity will be deleted\n */\nexport function deleteBlock(\n    blocks: ContentModelBlock[],\n    blockToDelete: ContentModelBlock,\n    replacement?: ContentModelBlock,\n    context?: FormatWithContentModelContext,\n    direction?: 'forward' | 'backward'\n): boolean {\n    const index = blocks.indexOf(blockToDelete);\n\n    switch (blockToDelete.blockType) {\n        case 'Table':\n        case 'Divider':\n            replacement ? blocks.splice(index, 1, replacement) : blocks.splice(index, 1);\n            return true;\n\n        case 'Entity':\n            const operation: EntityRemovalOperation | undefined = blockToDelete.isSelected\n                ? 'overwrite'\n                : direction == 'forward'\n                ? 'removeFromStart'\n                : direction == 'backward'\n                ? 'removeFromEnd'\n                : undefined;\n\n            if (operation !== undefined) {\n                replacement ? blocks.splice(index, 1, replacement) : blocks.splice(index, 1);\n                context?.deletedEntities.push({\n                    entity: blockToDelete,\n                    operation,\n                });\n            }\n\n            return true;\n\n        case 'BlockGroup':\n            switch (blockToDelete.blockGroupType) {\n                case 'General':\n                    if (replacement) {\n                        blocks.splice(index, 1, replacement);\n                        return true;\n                    } else {\n                        // no op, let browser handle it\n                        return false;\n                    }\n\n                case 'ListItem':\n                case 'FormatContainer':\n                    blocks.splice(index, 1);\n                    return true;\n            }\n    }\n\n    return false;\n}\n","import { deleteSingleChar } from '../../modelApi/edit/deleteSingleChar';\nimport { isWhiteSpacePreserved, normalizeSingleSegment } from 'roosterjs-content-model-dom';\nimport { normalizeText } from '../domUtils/stringUtil';\nimport type {\n    ContentModelParagraph,\n    ContentModelSegment,\n    EntityRemovalOperation,\n    FormatWithContentModelContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Delete a content model segment from current selection\n * @param paragraph Parent paragraph of the segment to delete\n * @param segmentToDelete The segment to delete\n * @param context @optional Context object provided by formatContentModel API\n * @param direction @optional Whether this is deleting forward or backward. This is only used for deleting entity.\n * If not specified, only selected entity will be deleted\n */\nexport function deleteSegment(\n    paragraph: ContentModelParagraph,\n    segmentToDelete: ContentModelSegment,\n    context?: FormatWithContentModelContext,\n    direction?: 'forward' | 'backward'\n): boolean {\n    const segments = paragraph.segments;\n    const index = segments.indexOf(segmentToDelete);\n    const preserveWhiteSpace = isWhiteSpacePreserved(paragraph);\n    const isForward = direction == 'forward';\n    const isBackward = direction == 'backward';\n\n    if (!preserveWhiteSpace) {\n        normalizePreviousSegment(segments, index);\n    }\n\n    switch (segmentToDelete.segmentType) {\n        case 'Br':\n        case 'Image':\n        case 'SelectionMarker':\n            segments.splice(index, 1);\n            return true;\n\n        case 'Entity':\n            const operation: EntityRemovalOperation | undefined = segmentToDelete.isSelected\n                ? 'overwrite'\n                : isForward\n                ? 'removeFromStart'\n                : isBackward\n                ? 'removeFromEnd'\n                : undefined;\n            if (operation !== undefined) {\n                segments.splice(index, 1);\n                context?.deletedEntities.push({\n                    entity: segmentToDelete,\n                    operation,\n                });\n            }\n\n            return true;\n\n        case 'Text':\n            let text = segmentToDelete.text;\n\n            if (text.length == 0 || segmentToDelete.isSelected) {\n                segments.splice(index, 1);\n            } else if (direction) {\n                text = deleteSingleChar(text, isForward); //  isForward ? text.substring(1) : text.substring(0, text.length - 1);\n\n                if (!preserveWhiteSpace) {\n                    text = normalizeText(text, isForward);\n                }\n\n                if (text == '') {\n                    segments.splice(index, 1);\n                } else {\n                    segmentToDelete.text = text;\n                }\n            }\n\n            return true;\n\n        case 'General':\n            if (segmentToDelete.isSelected) {\n                segments.splice(index, 1);\n                return true;\n            } else {\n                // No op if a general segment is not selected, let browser handle general segment\n                // TODO: Need to revisit this\n                return false;\n            }\n    }\n}\n\nfunction normalizePreviousSegment(segments: ContentModelSegment[], currentIndex: number) {\n    let index = currentIndex - 1;\n\n    while (segments[index]?.segmentType == 'SelectionMarker') {\n        index--;\n    }\n\n    const segment = segments[index];\n\n    if (segment) {\n        normalizeSingleSegment(segment);\n    }\n}\n","import { deleteExpandedSelection } from '../../modelApi/edit/deleteExpandedSelection';\nimport type {\n    ContentModelDocument,\n    DeleteSelectionContext,\n    DeleteSelectionResult,\n    DeleteSelectionStep,\n    FormatWithContentModelContext,\n    ValidDeleteSelectionContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Delete selected content from Content Model\n * @param model The model to delete selected content from\n * @param additionalSteps @optional Addition delete steps\n * @param formatContext @optional A context object provided by formatContentModel API\n * @returns A DeleteSelectionResult object to specify the deletion result\n */\nexport function deleteSelection(\n    model: ContentModelDocument,\n    additionalSteps: (DeleteSelectionStep | null)[] = [],\n    formatContext?: FormatWithContentModelContext\n): DeleteSelectionResult {\n    const context = deleteExpandedSelection(model, formatContext);\n\n    additionalSteps.forEach(step => {\n        if (\n            step &&\n            isValidDeleteSelectionContext(context) &&\n            context.deleteResult == 'notDeleted'\n        ) {\n            step(context);\n        }\n    });\n\n    mergeParagraphAfterDelete(context);\n\n    return context;\n}\n\nfunction isValidDeleteSelectionContext(\n    context: DeleteSelectionContext\n): context is ValidDeleteSelectionContext {\n    return !!context.insertPoint;\n}\n\n// If we end up with multiple paragraphs impacted, we need to merge them\nfunction mergeParagraphAfterDelete(context: DeleteSelectionContext) {\n    const { insertPoint, deleteResult, lastParagraph, lastTableContext } = context;\n\n    if (\n        insertPoint &&\n        deleteResult != 'notDeleted' &&\n        deleteResult != 'nothingToDelete' &&\n        lastParagraph &&\n        lastParagraph != insertPoint.paragraph &&\n        lastTableContext == insertPoint.tableContext\n    ) {\n        insertPoint.paragraph.segments.push(...lastParagraph.segments);\n        lastParagraph.segments = [];\n    }\n}\n","import type { DOMSelection } from 'roosterjs-content-model-types';\n\n/**\n * Get root node of a given DOM selection\n * For table selection, root node is the selected table\n * For image selection, root node is the selected image\n * For range selection, root node is the common ancestor container node of the selection range\n * @param selection The selection to get root node from\n */\nexport function getSelectionRootNode(selection: DOMSelection | undefined): Node | undefined {\n    return !selection\n        ? undefined\n        : selection.type == 'range'\n        ? selection.range.commonAncestorContainer\n        : selection.type == 'table'\n        ? selection.table\n        : selection.type == 'image'\n        ? selection.image\n        : undefined;\n}\n","import type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelBlockWithCache,\n    ContentModelSegment,\n    TableSelectionContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Options for iterateSelections API\n */\nexport interface IterateSelectionsOption {\n    /**\n     * For selected table cell, this property determines how do we handle its content.\n     * include: No matter if table cell is selected, always invoke callback function for selected content (default value)\n     * ignoreForTable: When the whole table is selected we invoke callback for the table (using block parameter) but skip\n     * all its cells and content, otherwise keep invoking callback for table cell and content\n     * ignoreForTableOrCell: If whole table is selected, same with ignoreForTable, or if a table cell is selected, only\n     * invoke callback for the table cell itself but not for its content, otherwise keep invoking callback for content.\n     * @default include\n     */\n    contentUnderSelectedTableCell?: 'include' | 'ignoreForTable' | 'ignoreForTableOrCell';\n\n    /**\n     * For a selected general element, this property determines how do we handle its content.\n     * contentOnly: (Default) When the whole general element is selected, we only invoke callback for its selected content\n     * generalElementOnly: When the whole general element is selected, we only invoke callback for the general element (using block or\n     * segment parameter depends on if it is a block or segment), but skip all its content.\n     * both: When general element is selected, we invoke callback first for its content, then for general element itself\n     */\n    contentUnderSelectedGeneralElement?: 'contentOnly' | 'generalElementOnly' | 'both';\n\n    /**\n     * Whether call the callback for the list item format holder segment\n     * anySegment: call the callback if any segment is selected under a list item\n     * allSegments: call the callback only when all segments under the list item are selected\n     * never: never call the callback for list item format holder\n     * @default allSegments\n     */\n    includeListFormatHolder?: 'anySegment' | 'allSegments' | 'never';\n}\n\n/**\n * The callback function type for iterateSelections\n * @param path The block group path of current selection\n * @param tableContext Table context of current selection\n * @param block Block of current selection\n * @param segments Segments of current selection\n * @returns True to stop iterating, otherwise keep going\n */\nexport type IterateSelectionsCallback = (\n    path: ContentModelBlockGroup[],\n    tableContext?: TableSelectionContext,\n    block?: ContentModelBlock,\n    segments?: ContentModelSegment[]\n) => void | boolean;\n\n/**\n * Iterate all selected elements in a given model\n * @param group The given Content Model to iterate selection from\n * @param callback The callback function to access the selected element\n * @param option Option to determine how to iterate\n */\nexport function iterateSelections(\n    group: ContentModelBlockGroup,\n    callback: IterateSelectionsCallback,\n    option?: IterateSelectionsOption\n): void {\n    const internalCallback: IterateSelectionsCallback = (path, tableContext, block, segments) => {\n        if (!!(block as ContentModelBlockWithCache)?.cachedElement) {\n            // TODO: This is a temporary solution. A better solution would be making all results from iterationSelection() to be readonly,\n            // use a util function to change it to be editable before edit them where we clear its cached element\n            delete (block as ContentModelBlockWithCache).cachedElement;\n        }\n\n        return callback(path, tableContext, block, segments);\n    };\n\n    internalIterateSelections([group], internalCallback, option);\n}\n\nfunction internalIterateSelections(\n    path: ContentModelBlockGroup[],\n    callback: IterateSelectionsCallback,\n    option?: IterateSelectionsOption,\n    table?: TableSelectionContext,\n    treatAllAsSelect?: boolean\n): boolean {\n    const parent = path[0];\n    const includeListFormatHolder = option?.includeListFormatHolder || 'allSegments';\n    const contentUnderSelectedTableCell = option?.contentUnderSelectedTableCell || 'include';\n    const contentUnderSelectedGeneralElement =\n        option?.contentUnderSelectedGeneralElement || 'contentOnly';\n\n    let hasSelectedSegment = false;\n    let hasUnselectedSegment = false;\n\n    for (let i = 0; i < parent.blocks.length; i++) {\n        const block = parent.blocks[i];\n\n        switch (block.blockType) {\n            case 'BlockGroup':\n                const newPath = [block, ...path];\n\n                if (block.blockGroupType == 'General') {\n                    const isSelected = treatAllAsSelect || block.isSelected;\n                    const handleGeneralContent =\n                        !isSelected ||\n                        contentUnderSelectedGeneralElement == 'both' ||\n                        contentUnderSelectedGeneralElement == 'contentOnly';\n                    const handleGeneralElement =\n                        isSelected &&\n                        (contentUnderSelectedGeneralElement == 'both' ||\n                            contentUnderSelectedGeneralElement == 'generalElementOnly' ||\n                            block.blocks.length == 0);\n\n                    if (\n                        (handleGeneralContent &&\n                            internalIterateSelections(\n                                newPath,\n                                callback,\n                                option,\n                                table,\n                                isSelected\n                            )) ||\n                        (handleGeneralElement && callback(path, table, block))\n                    ) {\n                        return true;\n                    }\n                } else if (\n                    internalIterateSelections(newPath, callback, option, table, treatAllAsSelect)\n                ) {\n                    return true;\n                }\n                break;\n\n            case 'Table':\n                const rows = block.rows;\n                const isWholeTableSelected = rows.every(row =>\n                    row.cells.every(cell => cell.isSelected)\n                );\n\n                if (contentUnderSelectedTableCell != 'include' && isWholeTableSelected) {\n                    if (callback(path, table, block)) {\n                        return true;\n                    }\n                } else {\n                    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n                        const row = rows[rowIndex];\n\n                        for (let colIndex = 0; colIndex < row.cells.length; colIndex++) {\n                            const cell = row.cells[colIndex];\n                            if (!cell) {\n                                continue;\n                            }\n\n                            const newTable: TableSelectionContext = {\n                                table: block,\n                                rowIndex,\n                                colIndex,\n                                isWholeTableSelected,\n                            };\n\n                            if (cell.isSelected && callback(path, newTable)) {\n                                return true;\n                            }\n\n                            if (\n                                !cell.isSelected ||\n                                contentUnderSelectedTableCell != 'ignoreForTableOrCell'\n                            ) {\n                                const newPath = [cell, ...path];\n                                const isSelected = treatAllAsSelect || cell.isSelected;\n\n                                if (\n                                    internalIterateSelections(\n                                        newPath,\n                                        callback,\n                                        option,\n                                        newTable,\n                                        isSelected\n                                    )\n                                ) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                break;\n\n            case 'Paragraph':\n                const segments: ContentModelSegment[] = [];\n\n                for (let i = 0; i < block.segments.length; i++) {\n                    const segment = block.segments[i];\n                    const isSelected = treatAllAsSelect || segment.isSelected;\n\n                    if (segment.segmentType == 'General') {\n                        const handleGeneralContent =\n                            !isSelected ||\n                            contentUnderSelectedGeneralElement == 'both' ||\n                            contentUnderSelectedGeneralElement == 'contentOnly';\n                        const handleGeneralElement =\n                            isSelected &&\n                            (contentUnderSelectedGeneralElement == 'both' ||\n                                contentUnderSelectedGeneralElement == 'generalElementOnly' ||\n                                segment.blocks.length == 0);\n\n                        if (\n                            handleGeneralContent &&\n                            internalIterateSelections(\n                                [segment, ...path],\n                                callback,\n                                option,\n                                table,\n                                isSelected\n                            )\n                        ) {\n                            return true;\n                        }\n\n                        if (handleGeneralElement) {\n                            segments.push(segment);\n                        }\n                    } else if (isSelected) {\n                        segments.push(segment);\n                    }\n\n                    if (isSelected) {\n                        hasSelectedSegment = true;\n                    } else {\n                        hasUnselectedSegment = true;\n                    }\n                }\n\n                if (segments.length > 0 && callback(path, table, block, segments)) {\n                    return true;\n                }\n                break;\n\n            case 'Divider':\n            case 'Entity':\n                if ((treatAllAsSelect || block.isSelected) && callback(path, table, block)) {\n                    return true;\n                }\n\n                break;\n        }\n    }\n\n    if (\n        includeListFormatHolder != 'never' &&\n        parent.blockGroupType == 'ListItem' &&\n        hasSelectedSegment &&\n        (!hasUnselectedSegment || includeListFormatHolder == 'anySegment') &&\n        // When whole list item is selected, also add its format holder as selected segment\n        callback(path, table, undefined /*block*/, [parent.formatHolder])\n    ) {\n        return true;\n    }\n\n    return false;\n}\n","import { isGeneralSegment } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelSegment,\n    ContentModelTable,\n    Selectable,\n} from 'roosterjs-content-model-types';\n\n/**\n * Set selection into Content Model. If the Content Model already has selection, existing selection will be overwritten by the new one.\n * @param group The root level group of Content Model\n * @param start The start selected element. If not passed, existing selection of content model will be cleared\n * @param end The end selected element. If not passed, only the start element will be selected. If passed, all elements between start and end elements will be selected\n */\nexport function setSelection(group: ContentModelBlockGroup, start?: Selectable, end?: Selectable) {\n    setSelectionToBlockGroup(group, false /*isInSelection*/, start || null, end || null);\n}\n\nfunction setSelectionToBlockGroup(\n    group: ContentModelBlockGroup,\n    isInSelection: boolean,\n    start: Selectable | null,\n    end: Selectable | null\n): boolean {\n    return handleSelection(isInSelection, group, start, end, isInSelection => {\n        if (isGeneralSegment(group)) {\n            setIsSelected(group, isInSelection);\n        }\n\n        group.blocks.forEach(block => {\n            isInSelection = setSelectionToBlock(block, isInSelection, start, end);\n        });\n\n        return isInSelection;\n    });\n}\n\nfunction setSelectionToBlock(\n    block: ContentModelBlock,\n    isInSelection: boolean,\n    start: Selectable | null,\n    end: Selectable | null\n) {\n    switch (block.blockType) {\n        case 'BlockGroup':\n            return setSelectionToBlockGroup(block, isInSelection, start, end);\n\n        case 'Table':\n            return setSelectionToTable(block, isInSelection, start, end);\n\n        case 'Divider':\n        case 'Entity':\n            return handleSelection(isInSelection, block, start, end, isInSelection => {\n                if (isInSelection) {\n                    block.isSelected = true;\n                } else {\n                    delete block.isSelected;\n                }\n\n                return isInSelection;\n            });\n\n        case 'Paragraph':\n            const segmentsToDelete: number[] = [];\n\n            block.segments.forEach((segment, i) => {\n                isInSelection = handleSelection(\n                    isInSelection,\n                    segment,\n                    start,\n                    end,\n                    isInSelection => {\n                        return setSelectionToSegment(\n                            segment,\n                            isInSelection,\n                            segmentsToDelete,\n                            start,\n                            end,\n                            i\n                        );\n                    }\n                );\n            });\n\n            while (segmentsToDelete.length > 0) {\n                const index = segmentsToDelete.pop()!;\n\n                if (index >= 0) {\n                    block.segments.splice(index, 1);\n                }\n            }\n\n            return isInSelection;\n\n        default:\n            return isInSelection;\n    }\n}\n\nfunction setSelectionToTable(\n    table: ContentModelTable,\n    isInSelection: boolean,\n    start: Selectable | null,\n    end: Selectable | null\n): boolean {\n    const first = findCell(table, start);\n    const last = end ? findCell(table, end) : first;\n\n    if (!isInSelection) {\n        for (let row = 0; row < table.rows.length; row++) {\n            const currentRow = table.rows[row];\n            for (let col = 0; col < currentRow.cells.length; col++) {\n                const currentCell = table.rows[row].cells[col];\n                const isSelected =\n                    row >= first.row && row <= last.row && col >= first.col && col <= last.col;\n\n                setIsSelected(currentCell, isSelected);\n\n                if (!isSelected) {\n                    setSelectionToBlockGroup(currentCell, false /*isInSelection*/, start, end);\n                }\n            }\n        }\n    } else {\n        table.rows.forEach(row =>\n            row.cells.forEach(cell => {\n                isInSelection = setSelectionToBlockGroup(cell, isInSelection, start, end);\n            })\n        );\n    }\n\n    return isInSelection;\n}\n\nfunction findCell(table: ContentModelTable, cell: Selectable | null): { row: number; col: number } {\n    let col = -1;\n    const row = cell\n        ? table.rows.findIndex(row => (col = (row.cells as Selectable[]).indexOf(cell)) >= 0)\n        : -1;\n\n    return { row, col };\n}\n\nfunction setSelectionToSegment(\n    segment: ContentModelSegment,\n    isInSelection: boolean,\n    segmentsToDelete: number[],\n    start: Selectable | null,\n    end: Selectable | null,\n    i: number\n) {\n    switch (segment.segmentType) {\n        case 'SelectionMarker':\n            if (!isInSelection || (segment != start && segment != end)) {\n                // Delete the selection marker when\n                // 1. It is not in selection any more. Or\n                // 2. It is in middle of selection, so no need to have it\n                segmentsToDelete.push(i);\n            }\n            return isInSelection;\n\n        case 'General':\n            setIsSelected(segment, isInSelection);\n\n            return segment != start && segment != end\n                ? setSelectionToBlockGroup(segment, isInSelection, start, end)\n                : isInSelection;\n\n        case 'Image':\n            setIsSelected(segment, isInSelection);\n            segment.isSelectedAsImageSelection = start == segment && (!end || end == segment);\n            return isInSelection;\n        default:\n            setIsSelected(segment, isInSelection);\n            return isInSelection;\n    }\n}\n\nfunction setIsSelected(selectable: Selectable, value: boolean) {\n    if (value) {\n        selectable.isSelected = true;\n    } else {\n        delete selectable.isSelected;\n    }\n\n    return value;\n}\n\nfunction handleSelection(\n    isInSelection: boolean,\n    model: ContentModelBlockGroup | ContentModelBlock | ContentModelSegment,\n    start: Selectable | null,\n    end: Selectable | null,\n    callback: (isInSelection: boolean) => boolean\n) {\n    isInSelection = isInSelection || model == start;\n    isInSelection = callback(isInSelection);\n    return isInSelection && !!end && model != end;\n}\n","import { BorderKeys } from 'roosterjs-content-model-dom';\nimport { combineBorderValue, extractBorderValues } from '../domUtils/borderValues';\nimport { setTableCellBackgroundColor } from './setTableCellBackgroundColor';\nimport { TableBorderFormat } from '../../constants/TableBorderFormat';\nimport { updateTableCellMetadata } from '../../metadata/updateTableCellMetadata';\nimport { updateTableMetadata } from '../../metadata/updateTableMetadata';\nimport type {\n    BorderFormat,\n    ContentModelTable,\n    ContentModelTableRow,\n    TableMetadataFormat,\n} from 'roosterjs-content-model-types';\n\nconst DEFAULT_FORMAT: Required<TableMetadataFormat> = {\n    topBorderColor: '#ABABAB',\n    bottomBorderColor: '#ABABAB',\n    verticalBorderColor: '#ABABAB',\n    hasHeaderRow: false,\n    hasFirstColumn: false,\n    hasBandedRows: false,\n    hasBandedColumns: false,\n    bgColorEven: null,\n    bgColorOdd: '#ABABAB20',\n    headerRowColor: '#ABABAB',\n    tableBorderFormat: TableBorderFormat.Default,\n    verticalAlign: null,\n};\n\ntype MetaOverrides = {\n    bgColorOverrides: boolean[][];\n    vAlignOverrides: boolean[][];\n    borderOverrides: boolean[][];\n};\n\n/**\n * Apply table format from table metadata and the passed in new format\n * @param table The table to apply format to\n * @param newFormat @optional New format to apply. When passed, this value will be merged into existing metadata format and default format\n * @param keepCellShade @optional When pass true, table cells with customized shade color will not be overwritten. @default false\n */\nexport function applyTableFormat(\n    table: ContentModelTable,\n    newFormat?: TableMetadataFormat,\n    keepCellShade?: boolean\n) {\n    const { rows } = table;\n\n    updateTableMetadata(table, format => {\n        const effectiveMetadata = {\n            ...DEFAULT_FORMAT,\n            ...format,\n            ...(newFormat || {}),\n        };\n\n        const metaOverrides: MetaOverrides = updateOverrides(rows, !keepCellShade);\n\n        delete table.cachedElement;\n\n        clearCache(rows);\n        formatCells(rows, effectiveMetadata, metaOverrides);\n        setFirstColumnFormat(rows, effectiveMetadata, metaOverrides);\n        setHeaderRowFormat(rows, effectiveMetadata, metaOverrides);\n        return effectiveMetadata;\n    });\n}\n\nfunction clearCache(rows: ContentModelTableRow[]) {\n    rows.forEach(row => {\n        row.cells.forEach(cell => {\n            delete cell.cachedElement;\n        });\n\n        delete row.cachedElement;\n    });\n}\n\nfunction updateOverrides(rows: ContentModelTableRow[], removeCellShade: boolean): MetaOverrides {\n    const overrides: MetaOverrides = {\n        bgColorOverrides: [],\n        vAlignOverrides: [],\n        borderOverrides: [],\n    };\n\n    rows.forEach(row => {\n        const bgColorOverrides: boolean[] = [];\n        const vAlignOverrides: boolean[] = [];\n        const borderOverrides: boolean[] = [];\n\n        overrides.bgColorOverrides.push(bgColorOverrides);\n        overrides.vAlignOverrides.push(vAlignOverrides);\n        overrides.borderOverrides.push(borderOverrides);\n\n        row.cells.forEach(cell => {\n            updateTableCellMetadata(cell, metadata => {\n                if (metadata && removeCellShade) {\n                    bgColorOverrides.push(false);\n                    delete metadata.bgColorOverride;\n                } else {\n                    bgColorOverrides.push(!!metadata?.bgColorOverride);\n                }\n                vAlignOverrides.push(!!metadata?.vAlignOverride);\n                borderOverrides.push(!!metadata?.borderOverride);\n\n                return metadata;\n            });\n        });\n    });\n\n    return overrides;\n}\n\ntype ShouldUseTransparentBorder = (indexProp: {\n    firstRow: boolean;\n    lastRow: boolean;\n    firstColumn: boolean;\n    lastColumn: boolean;\n}) => [boolean, boolean, boolean, boolean];\n\nconst BorderFormatters: Record<number, ShouldUseTransparentBorder | undefined> = {\n    [TableBorderFormat.Default]: _ => [false, false, false, false],\n    [TableBorderFormat.ListWithSideBorders]: ({ lastColumn, firstColumn }) => [\n        false,\n        !lastColumn,\n        false,\n        !firstColumn,\n    ],\n    [TableBorderFormat.FirstColumnHeaderExternal]: ({\n        firstColumn,\n        firstRow,\n        lastColumn,\n        lastRow,\n    }) => [\n        !firstRow,\n        (!lastColumn && !firstColumn) || (firstColumn && firstRow),\n        !lastRow && !firstRow,\n        !firstColumn,\n    ],\n    [TableBorderFormat.NoHeaderBorders]: ({ firstRow, firstColumn, lastColumn }) => [\n        firstRow,\n        firstRow || lastColumn,\n        false,\n        firstRow || firstColumn,\n    ],\n    [TableBorderFormat.NoSideBorders]: ({ firstColumn, lastColumn }) => [\n        false,\n        lastColumn,\n        false,\n        firstColumn,\n    ],\n    [TableBorderFormat.EspecialType1]: ({ firstRow, firstColumn }) => [\n        firstColumn && !firstRow,\n        firstRow,\n        firstColumn && !firstRow,\n        firstRow && !firstColumn,\n    ],\n    [TableBorderFormat.EspecialType2]: ({ firstRow, firstColumn }) => [\n        !firstRow,\n        firstRow || !firstColumn,\n        !firstRow,\n        !firstColumn,\n    ],\n    [TableBorderFormat.EspecialType3]: ({ firstColumn, firstRow }) => [\n        true,\n        firstRow || !firstColumn,\n        !firstRow,\n        true,\n    ],\n    [TableBorderFormat.Clear]: () => [true, true, true, true],\n};\n\n/*\n * Apply vertical align, borders, and background color to all cells in the table\n */\nfunction formatCells(\n    rows: ContentModelTableRow[],\n    format: TableMetadataFormat,\n    metaOverrides: MetaOverrides\n) {\n    const { hasBandedRows, hasBandedColumns, bgColorOdd, bgColorEven } = format;\n\n    rows.forEach((row, rowIndex) => {\n        row.cells.forEach((cell, colIndex) => {\n            // Format Borders\n            if (\n                !metaOverrides.borderOverrides[rowIndex][colIndex] &&\n                typeof format.tableBorderFormat == 'number'\n            ) {\n                const transparentBorderMatrix = BorderFormatters[format.tableBorderFormat]?.({\n                    firstRow: rowIndex === 0,\n                    lastRow: rowIndex === rows.length - 1,\n                    firstColumn: colIndex === 0,\n                    lastColumn: colIndex === row.cells.length - 1,\n                });\n\n                const formatColor = [\n                    format.topBorderColor,\n                    format.verticalBorderColor,\n                    format.bottomBorderColor,\n                    format.verticalBorderColor,\n                ];\n\n                transparentBorderMatrix?.forEach((alwaysUseTransparent, i) => {\n                    const borderColor = (!alwaysUseTransparent && formatColor[i]) || '';\n\n                    cell.format[BorderKeys[i]] = combineBorderValue({\n                        style: getBorderStyleFromColor(borderColor),\n                        width: '1px',\n                        color: borderColor,\n                    });\n                });\n            }\n\n            // Format Background Color\n            if (!metaOverrides.bgColorOverrides[rowIndex][colIndex]) {\n                const color =\n                    hasBandedRows || hasBandedColumns\n                        ? (hasBandedColumns && colIndex % 2 != 0) ||\n                          (hasBandedRows && rowIndex % 2 != 0)\n                            ? bgColorOdd\n                            : bgColorEven\n                        : bgColorEven; /* bgColorEven is the default color */\n\n                setTableCellBackgroundColor(\n                    cell,\n                    color,\n                    false /*isColorOverride*/,\n                    true /*applyToSegments*/\n                );\n            }\n\n            // Format Vertical Align\n            if (format.verticalAlign && !metaOverrides.vAlignOverrides[rowIndex][colIndex]) {\n                cell.format.verticalAlign = format.verticalAlign;\n            }\n        });\n    });\n}\n\nfunction setFirstColumnFormat(\n    rows: ContentModelTableRow[],\n    format: Partial<TableMetadataFormat>,\n    metaOverrides: MetaOverrides\n) {\n    rows.forEach((row, rowIndex) => {\n        row.cells.forEach((cell, cellIndex) => {\n            if (format.hasFirstColumn && cellIndex === 0) {\n                cell.isHeader = true;\n\n                if (rowIndex !== 0 && !metaOverrides.bgColorOverrides[rowIndex][cellIndex]) {\n                    setBorderColor(cell.format, 'borderTop');\n                    setTableCellBackgroundColor(\n                        cell,\n                        null /*color*/,\n                        false /*isColorOverride*/,\n                        true /*applyToSegments*/\n                    );\n                }\n\n                if (rowIndex !== rows.length - 1 && rowIndex !== 0) {\n                    setBorderColor(cell.format, 'borderBottom');\n                }\n            } else {\n                cell.isHeader = false;\n            }\n        });\n    });\n}\n\nfunction setHeaderRowFormat(\n    rows: ContentModelTableRow[],\n    format: TableMetadataFormat,\n    metaOverrides: MetaOverrides\n) {\n    const rowIndex = 0;\n\n    rows[rowIndex]?.cells.forEach((cell, cellIndex) => {\n        cell.isHeader = format.hasHeaderRow;\n\n        if (format.hasHeaderRow && format.headerRowColor) {\n            if (!metaOverrides.bgColorOverrides[rowIndex][cellIndex]) {\n                setTableCellBackgroundColor(\n                    cell,\n                    format.headerRowColor,\n                    false /*isColorOverride*/,\n                    true /*applyToSegments*/\n                );\n            }\n\n            setBorderColor(cell.format, 'borderTop', format.headerRowColor);\n            setBorderColor(cell.format, 'borderRight', format.headerRowColor);\n            setBorderColor(cell.format, 'borderLeft', format.headerRowColor);\n        }\n    });\n}\n\nfunction setBorderColor(format: BorderFormat, key: keyof BorderFormat, value?: string) {\n    const border = extractBorderValues(format[key]);\n    border.color = value || '';\n    border.style = getBorderStyleFromColor(border.color);\n    format[key] = combineBorderValue(border);\n}\n\nfunction getBorderStyleFromColor(color?: string): string {\n    return !color || color == 'transparent' ? 'none' : 'solid';\n}\n","import { addBlock, addSegment, createBr, createParagraph } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelSegment,\n    ContentModelSegmentFormat,\n    ContentModelTable,\n    ContentModelTableCell,\n} from 'roosterjs-content-model-types';\n\nconst MIN_HEIGHT = 22;\n\n/**\n * Normalize a Content Model table, make sure:\n * 1. Fist cells are not spanned\n * 2. Inner cells are not header\n * 3. All cells have content and width\n * 4. Table and table row have correct width/height\n * 5. Spanned cell has no child blocks\n * 6. default format is correctly applied\n * @param table The table to normalize\n * @param defaultSegmentFormat @optional Default segment format to apply to cell\n */\nexport function normalizeTable(\n    table: ContentModelTable,\n    defaultSegmentFormat?: ContentModelSegmentFormat\n) {\n    // Always collapse border and use border box for table in roosterjs to make layout simpler\n    const format = table.format;\n\n    if (!format.borderCollapse || !format.useBorderBox) {\n        format.borderCollapse = true;\n        format.useBorderBox = true;\n    }\n\n    // Make sure all first cells are not spanned\n    // Make sure all inner cells are not header\n    // Make sure all cells have content and width\n    table.rows.forEach((row, rowIndex) => {\n        row.cells.forEach((cell, colIndex) => {\n            if (cell.blocks.length == 0) {\n                const format = cell.format.textColor\n                    ? {\n                          ...defaultSegmentFormat,\n                          textColor: cell.format.textColor,\n                      }\n                    : defaultSegmentFormat;\n                addBlock(\n                    cell,\n                    createParagraph(undefined /*isImplicit*/, undefined /*blockFormat*/, format)\n                );\n                addSegment(cell, createBr(format));\n            }\n\n            if (rowIndex == 0) {\n                cell.spanAbove = false;\n            } else if (rowIndex > 0 && cell.isHeader) {\n                cell.isHeader = false;\n                delete cell.cachedElement;\n            }\n\n            if (colIndex == 0) {\n                cell.spanLeft = false;\n            }\n\n            cell.format.useBorderBox = true;\n        });\n\n        // Make sure table has correct width and height array\n        if (row.height < MIN_HEIGHT) {\n            row.height = MIN_HEIGHT;\n        }\n    });\n\n    const columns = Math.max(...table.rows.map(row => row.cells.length));\n\n    for (let i = 0; i < columns; i++) {\n        if (table.widths[i] === undefined) {\n            table.widths[i] = getTableCellWidth(columns);\n        }\n    }\n\n    // Move blocks from spanned cell to its main cell if any,\n    // and remove rows/columns if all cells in it are spanned\n    const colCount = table.rows[0]?.cells.length || 0;\n\n    for (let colIndex = colCount - 1; colIndex > 0; colIndex--) {\n        table.rows.forEach(row => {\n            const cell = row.cells[colIndex];\n            const leftCell = row.cells[colIndex - 1];\n            if (cell && leftCell && cell.spanLeft) {\n                tryMoveBlocks(leftCell, cell);\n            }\n        });\n\n        if (table.rows.every(row => row.cells[colIndex]?.spanLeft)) {\n            table.rows.forEach(row => row.cells.splice(colIndex, 1));\n            table.widths.splice(\n                colIndex - 1,\n                2,\n                table.widths[colIndex - 1] + table.widths[colIndex]\n            );\n        }\n    }\n\n    for (let rowIndex = table.rows.length - 1; rowIndex > 0; rowIndex--) {\n        const row = table.rows[rowIndex];\n\n        row.cells.forEach((cell, colIndex) => {\n            const aboveCell = table.rows[rowIndex - 1]?.cells[colIndex];\n            if (aboveCell && cell.spanAbove) {\n                tryMoveBlocks(aboveCell, cell);\n            }\n        });\n\n        if (row.cells.every(cell => cell.spanAbove)) {\n            table.rows[rowIndex - 1].height += row.height;\n            table.rows.splice(rowIndex, 1);\n        }\n    }\n}\n\nfunction getTableCellWidth(columns: number): number {\n    if (columns <= 4) {\n        return 120;\n    } else if (columns <= 6) {\n        return 100;\n    } else {\n        return 70;\n    }\n}\n\nfunction tryMoveBlocks(targetCell: ContentModelTableCell, sourceCell: ContentModelTableCell) {\n    const onlyHasEmptyOrBr = sourceCell.blocks.every(\n        block => block.blockType == 'Paragraph' && hasOnlyBrSegment(block.segments)\n    );\n\n    if (!onlyHasEmptyOrBr) {\n        targetCell.blocks.push(...sourceCell.blocks);\n        sourceCell.blocks = [];\n    }\n}\n\nfunction hasOnlyBrSegment(segments: ContentModelSegment[]): boolean {\n    segments = segments.filter(s => s.segmentType != 'SelectionMarker');\n\n    return segments.length == 0 || (segments.length == 1 && segments[0].segmentType == 'Br');\n}\n","import { updateTableCellMetadata } from '../../metadata/updateTableCellMetadata';\nimport type { ContentModelTableCell } from 'roosterjs-content-model-types';\n\n// Using the HSL (hue, saturation and lightness) representation for RGB color values.\n// If the value of the lightness is less than 20, the color is dark.\n// If the value of the lightness is more than 80, the color is bright\nconst DARK_COLORS_LIGHTNESS = 20;\nconst BRIGHT_COLORS_LIGHTNESS = 80;\nconst White = '#ffffff';\nconst Black = '#000000';\n\n/**\n * Set shade color of table cell\n * @param cell The cell to set shade color to\n * @param color The color to set\n * @param isColorOverride @optional When pass true, it means this shade color is not part of table format, so it can be preserved when apply table format\n * @param applyToSegments @optional When pass true, we will also apply text color from table cell to its child blocks and segments\n */\nexport function setTableCellBackgroundColor(\n    cell: ContentModelTableCell,\n    color: string | null | undefined,\n    isColorOverride?: boolean,\n    applyToSegments?: boolean\n) {\n    if (color) {\n        cell.format.backgroundColor = color;\n\n        if (isColorOverride) {\n            updateTableCellMetadata(cell, metadata => {\n                metadata = metadata || {};\n                metadata.bgColorOverride = true;\n                return metadata;\n            });\n        }\n\n        const lightness = calculateLightness(color);\n\n        if (lightness < DARK_COLORS_LIGHTNESS) {\n            cell.format.textColor = White;\n        } else if (lightness > BRIGHT_COLORS_LIGHTNESS) {\n            cell.format.textColor = Black;\n        } else {\n            delete cell.format.textColor;\n        }\n\n        if (applyToSegments) {\n            setAdaptiveCellColor(cell);\n        }\n    } else {\n        delete cell.format.backgroundColor;\n        delete cell.format.textColor;\n        if (applyToSegments) {\n            removeAdaptiveCellColor(cell);\n        }\n    }\n\n    delete cell.cachedElement;\n}\n\nfunction removeAdaptiveCellColor(cell: ContentModelTableCell) {\n    cell.blocks.forEach(block => {\n        if (block.blockType == 'Paragraph') {\n            if (\n                block.segmentFormat?.textColor &&\n                shouldRemoveColor(block.segmentFormat?.textColor, cell.format.backgroundColor || '')\n            ) {\n                delete block.segmentFormat.textColor;\n            }\n            block.segments.forEach(segment => {\n                if (\n                    segment.format.textColor &&\n                    shouldRemoveColor(segment.format.textColor, cell.format.backgroundColor || '')\n                ) {\n                    delete segment.format.textColor;\n                }\n            });\n        }\n    });\n}\n\nfunction setAdaptiveCellColor(cell: ContentModelTableCell) {\n    if (cell.format.textColor) {\n        cell.blocks.forEach(block => {\n            if (block.blockType == 'Paragraph') {\n                if (!block.segmentFormat?.textColor) {\n                    block.segmentFormat = {\n                        ...block.segmentFormat,\n                        textColor: cell.format.textColor,\n                    };\n                }\n                block.segments.forEach(segment => {\n                    if (!segment.format?.textColor) {\n                        segment.format = {\n                            ...segment.format,\n                            textColor: cell.format.textColor,\n                        };\n                    }\n                });\n            }\n        });\n    }\n}\n\n/**\n * If the cell background color is too dark or too bright, and the text color is white or black, we should remove the text color\n * @param textColor the segment or block text color\n * @param cellBackgroundColor the cell background color\n * @returns\n */\nfunction shouldRemoveColor(textColor: string, cellBackgroundColor: string) {\n    const lightness = calculateLightness(cellBackgroundColor);\n    if (\n        ([White, 'rgb(255,255,255)'].indexOf(textColor) > -1 &&\n            (lightness > BRIGHT_COLORS_LIGHTNESS || cellBackgroundColor == '')) ||\n        ([Black, 'rgb(0,0,0)'].indexOf(textColor) > -1 &&\n            (lightness < DARK_COLORS_LIGHTNESS || cellBackgroundColor == ''))\n    ) {\n        return true;\n    }\n    return false;\n}\n\nfunction calculateLightness(color: string) {\n    const colorValues = parseColor(color);\n\n    // Use the values of r,g,b to calculate the lightness in the HSl representation\n    //First calculate the fraction of the light in each color, since in css the value of r,g,b is in the interval of [0,255], we have\n    if (colorValues) {\n        const red = colorValues[0] / 255;\n        const green = colorValues[1] / 255;\n        const blue = colorValues[2] / 255;\n\n        //Then the lightness in the HSL representation is the average between maximum fraction of r,g,b and the minimum fraction\n        return (Math.max(red, green, blue) + Math.min(red, green, blue)) * 50;\n    } else {\n        return 255;\n    }\n}\n\nconst HEX3_REGEX = /^#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/;\nconst HEX6_REGEX = /^#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/;\nconst RGB_REGEX = /^rgb\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*\\)$/;\nconst RGBA_REGEX = /^rgba\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*\\)$/;\n\n/**\n * @internal Export for test only\n * Parse color string to r/g/b value.\n * If the given color is not in a recognized format, return null\n */\nexport function parseColor(color: string): [number, number, number] | null {\n    color = (color || '').trim();\n\n    let match: RegExpMatchArray | null;\n    if ((match = color.match(HEX3_REGEX))) {\n        return [\n            parseInt(match[1] + match[1], 16),\n            parseInt(match[2] + match[2], 16),\n            parseInt(match[3] + match[3], 16),\n        ];\n    } else if ((match = color.match(HEX6_REGEX))) {\n        return [parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16)];\n    } else if ((match = color.match(RGB_REGEX) || color.match(RGBA_REGEX))) {\n        return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];\n    } else {\n        // CSS color names such as red, green is not included for now.\n        // If need, we can add those colors from https://www.w3.org/wiki/CSS/Properties/color/keywords\n        return null;\n    }\n}\n","import type { DefaultImplicitFormatMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * A map from tag name to its default implicit formats\n */\nexport const defaultContentModelFormatMap: DefaultImplicitFormatMap = {\n    a: {\n        underline: true,\n    },\n    blockquote: {\n        marginTop: '1em',\n        marginBottom: '1em',\n        marginLeft: '40px',\n        marginRight: '40px',\n    },\n    code: {\n        fontFamily: 'monospace',\n    },\n    h1: {\n        fontWeight: 'bold',\n        fontSize: '2em',\n    },\n    h2: {\n        fontWeight: 'bold',\n        fontSize: '1.5em',\n    },\n    h3: {\n        fontWeight: 'bold',\n        fontSize: '1.17em',\n    },\n    h4: {\n        fontWeight: 'bold',\n        fontSize: '1em', // Set this default value here to overwrite existing font size when change heading level\n    },\n    h5: {\n        fontWeight: 'bold',\n        fontSize: '0.83em',\n    },\n    h6: {\n        fontWeight: 'bold',\n        fontSize: '0.67em',\n    },\n    p: {\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    pre: {\n        fontFamily: 'monospace',\n        whiteSpace: 'pre',\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n};\n","import type { DefaultStyleMap } from 'roosterjs-content-model-types';\n\nconst blockElement: Partial<CSSStyleDeclaration> = {\n    display: 'block',\n};\n\n/**\n * @internal\n */\nexport const defaultHTMLStyleMap: DefaultStyleMap = {\n    address: blockElement,\n    article: blockElement,\n    aside: blockElement,\n    b: {\n        fontWeight: 'bold',\n    },\n    blockquote: {\n        display: 'block',\n        marginTop: '1em',\n        marginBottom: '1em',\n        marginLeft: '40px',\n        marginRight: '40px',\n    },\n    br: blockElement,\n    center: {\n        display: 'block',\n        textAlign: 'center',\n    },\n    dd: blockElement,\n    div: blockElement,\n    dl: blockElement,\n    dt: blockElement,\n    em: {\n        fontStyle: 'italic',\n    },\n    fieldset: blockElement,\n    figcaption: blockElement,\n    figure: blockElement,\n    footer: blockElement,\n    form: blockElement,\n    h1: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '2em',\n    },\n    h2: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '1.5em',\n    },\n    h3: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '1.17em',\n    },\n    h4: {\n        display: 'block',\n        fontWeight: 'bold',\n    },\n    h5: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '0.83em',\n    },\n    h6: {\n        display: 'block',\n        fontWeight: 'bold',\n        fontSize: '0.67em',\n    },\n    header: blockElement,\n    hr: blockElement,\n    i: {\n        fontStyle: 'italic',\n    },\n    li: {\n        display: 'list-item',\n    },\n    main: blockElement,\n    nav: blockElement,\n    ol: blockElement,\n    p: {\n        display: 'block',\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    pre: {\n        display: 'block',\n        fontFamily: 'monospace',\n        whiteSpace: 'pre',\n        marginTop: '1em',\n        marginBottom: '1em',\n    },\n    s: {\n        textDecoration: 'line-through',\n    },\n    section: blockElement,\n    strike: {\n        textDecoration: 'line-through',\n    },\n    strong: {\n        fontWeight: 'bold',\n    },\n    sub: {\n        verticalAlign: 'sub',\n        fontSize: 'smaller',\n    },\n    sup: {\n        verticalAlign: 'super',\n        fontSize: 'smaller',\n    },\n    table: {\n        display: 'table',\n        boxSizing: 'border-box',\n    },\n    td: {\n        display: 'table-cell',\n    },\n    th: {\n        display: 'table-cell',\n    },\n    u: {\n        textDecoration: 'underline',\n    },\n    ul: blockElement,\n};\n","import { defaultProcessorMap } from './defaultProcessors';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport {\n    defaultFormatKeysPerCategory,\n    defaultFormatParsers,\n} from '../../formatHandlers/defaultFormatHandlers';\nimport type {\n    ContentModelBlockFormat,\n    DomToModelContext,\n    DomToModelDecoratorContext,\n    DomToModelFormatContext,\n    DomToModelOption,\n    DomToModelSelectionContext,\n    DomToModelSettings,\n    EditorContext,\n    FormatParser,\n    FormatParsers,\n    FormatParsersPerCategory,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create context object for DOM to Content Model conversion\n * @param editorContext Context of editor\n * @param options Option array to customize the DOM to Model conversion behavior\n */\nexport function createDomToModelContext(\n    editorContext?: EditorContext,\n    ...options: (DomToModelOption | undefined)[]\n): DomToModelContext {\n    return createDomToModelContextWithConfig(createDomToModelConfig(options), editorContext);\n}\n\n/**\n * Create context object for DOM to Content Model conversion with an existing configure\n * @param config A full config object to define how to convert DOM tree to Content Model\n * @param editorContext Context of editor\n */\nexport function createDomToModelContextWithConfig(\n    config: DomToModelSettings,\n    editorContext?: EditorContext\n) {\n    return Object.assign(\n        {},\n        editorContext,\n        createDomToModelSelectionContext(),\n        createDomToModelFormatContext(editorContext?.isRootRtl),\n        createDomToModelDecoratorContext(),\n        config\n    );\n}\n\nfunction createDomToModelSelectionContext(): DomToModelSelectionContext {\n    return { isInSelection: false };\n}\n\nfunction createDomToModelFormatContext(isRootRtl?: boolean): DomToModelFormatContext {\n    const blockFormat: ContentModelBlockFormat = isRootRtl ? { direction: 'rtl' } : {};\n\n    return {\n        blockFormat,\n        segmentFormat: {},\n\n        listFormat: {\n            levels: [],\n            threadItemCounts: [],\n        },\n    };\n}\n\nfunction createDomToModelDecoratorContext(): DomToModelDecoratorContext {\n    return {\n        link: {\n            format: {},\n            dataset: {},\n        },\n        code: {\n            format: {},\n        },\n        blockDecorator: {\n            format: {},\n            tagName: '',\n        },\n    };\n}\n\n/**\n * Create Dom to Content Model Config object\n * @param options All customizations of content model creation\n */\nexport function createDomToModelConfig(\n    options: (DomToModelOption | undefined)[]\n): DomToModelSettings {\n    return {\n        elementProcessors: Object.assign(\n            {},\n            defaultProcessorMap,\n            ...options.map(x => x?.processorOverride)\n        ),\n        formatParsers: buildFormatParsers(\n            options.map(x => x?.formatParserOverride),\n            options.map(x => x?.additionalFormatParsers)\n        ),\n        defaultElementProcessors: defaultProcessorMap,\n        defaultFormatParsers,\n    };\n}\n\n/**\n * @internal Export for test only\n * Build format parsers used by DOM to Content Model conversion\n * @param override\n * @param additionalParsersArray\n * @returns\n */\nexport function buildFormatParsers(\n    overrides: (Partial<FormatParsers> | undefined)[] = [],\n    additionalParsersArray: (Partial<FormatParsersPerCategory> | undefined)[] = []\n): FormatParsersPerCategory {\n    const combinedOverrides = Object.assign({}, ...overrides);\n\n    return getObjectKeys(defaultFormatKeysPerCategory).reduce((result, key) => {\n        const value = defaultFormatKeysPerCategory[key]\n            .map(\n                formatKey =>\n                    (combinedOverrides[formatKey] === undefined\n                        ? defaultFormatParsers[formatKey]\n                        : combinedOverrides[formatKey]) as FormatParser<any>\n            )\n            .concat(\n                ...additionalParsersArray.map(\n                    parsers => (parsers?.[key] ?? []) as FormatParser<any>[]\n                )\n            );\n\n        result[key] = value;\n\n        return result;\n    }, {} as FormatParsersPerCategory);\n}\n","import { brProcessor } from '../processors/brProcessor';\nimport { childProcessor } from '../processors/childProcessor';\nimport { codeProcessor } from '../processors/codeProcessor';\nimport { delimiterProcessor } from '../processors/delimiterProcessor';\nimport { elementProcessor } from '../processors/elementProcessor';\nimport { entityProcessor } from '../processors/entityProcessor';\nimport { fontProcessor } from '../processors/fontProcessor';\nimport { formatContainerProcessor } from '../processors/formatContainerProcessor';\nimport { generalProcessor } from '../processors/generalProcessor';\nimport { headingProcessor } from '../processors/headingProcessor';\nimport { hrProcessor } from '../processors/hrProcessor';\nimport { imageProcessor } from '../processors/imageProcessor';\nimport { knownElementProcessor } from '../processors/knownElementProcessor';\nimport { linkProcessor } from '../processors/linkProcessor';\nimport { listItemProcessor } from '../processors/listItemProcessor';\nimport { listProcessor } from '../processors/listProcessor';\nimport { pProcessor } from '../processors/pProcessor';\nimport { tableProcessor } from '../processors/tableProcessor';\nimport { textProcessor } from '../processors/textProcessor';\nimport type { ElementProcessorMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const defaultProcessorMap: ElementProcessorMap = {\n    a: linkProcessor,\n    b: knownElementProcessor,\n    blockquote: knownElementProcessor,\n    br: brProcessor,\n    code: codeProcessor,\n    div: knownElementProcessor,\n    em: knownElementProcessor,\n    font: fontProcessor,\n    i: knownElementProcessor,\n    img: imageProcessor,\n    h1: headingProcessor,\n    h2: headingProcessor,\n    h3: headingProcessor,\n    h4: headingProcessor,\n    h5: headingProcessor,\n    h6: headingProcessor,\n    hr: hrProcessor,\n    li: listItemProcessor,\n    ol: listProcessor,\n    p: pProcessor,\n    pre: formatContainerProcessor,\n    s: knownElementProcessor,\n    section: knownElementProcessor,\n    span: knownElementProcessor,\n    strike: knownElementProcessor,\n    strong: knownElementProcessor,\n    sub: knownElementProcessor,\n    sup: knownElementProcessor,\n    table: tableProcessor,\n    u: knownElementProcessor,\n    ul: listProcessor,\n\n    '*': generalProcessor,\n    '#text': textProcessor,\n    element: elementProcessor,\n    entity: entityProcessor,\n    child: childProcessor,\n    delimiter: delimiterProcessor,\n};\n","import { createContentModelDocument } from '../modelApi/creators/createContentModelDocument';\nimport { normalizeContentModel } from '../modelApi/common/normalizeContentModel';\nimport type {\n    ContentModelDocument,\n    DOMSelection,\n    DomToModelContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create Content Model from DOM tree in this editor\n * @param root Root element of DOM tree to create Content Model from\n * @param context Context object for DOM to Content Model conversion\n * @param selection Selection that already exists in content\n * @returns A ContentModelDocument object that contains all the models created from the give root element\n */\nexport function domToContentModel(\n    root: HTMLElement | DocumentFragment,\n    context: DomToModelContext,\n    selection?: DOMSelection\n): ContentModelDocument {\n    const model = createContentModelDocument(context.defaultFormat);\n\n    context.selection = selection;\n    context.elementProcessors.child(model, root, context);\n\n    normalizeContentModel(model);\n\n    return model;\n}\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { ContextStyles } from './formatContainerProcessor';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { parseFormat } from '../utils/parseFormat';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelSegmentFormat,\n    DomToModelContext,\n} from 'roosterjs-content-model-types';\n\nconst SegmentDecoratorTags = ['A', 'CODE'];\n\n/**\n * @internal\n */\nexport function blockProcessor(\n    group: ContentModelBlockGroup,\n    element: HTMLElement,\n    context: DomToModelContext,\n    segmentFormat?: ContentModelSegmentFormat\n) {\n    const decorator = context.blockDecorator.tagName ? context.blockDecorator : undefined;\n    const isSegmentDecorator = SegmentDecoratorTags.indexOf(element.tagName) >= 0;\n\n    parseFormat(element, context.formatParsers.block, context.blockFormat, context);\n\n    const blockFormat = { ...context.blockFormat };\n\n    parseFormat(element, context.formatParsers.container, blockFormat, context);\n\n    ContextStyles.forEach(style => {\n        if (blockFormat[style]) {\n            context.blockFormat[style] = blockFormat[style];\n        }\n    });\n\n    if (!isSegmentDecorator) {\n        const paragraph = createParagraph(\n            false /*isImplicit*/,\n            blockFormat,\n            segmentFormat,\n            decorator\n        );\n\n        addBlock(group, paragraph);\n    }\n\n    context.elementProcessors.child(group, element, context);\n}\n","import { addSegment } from '../../modelApi/common/addSegment';\nimport { createBr } from '../../modelApi/creators/createBr';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const brProcessor: ElementProcessor<HTMLBRElement> = (group, element, context) => {\n    const br = createBr(context.segmentFormat);\n\n    if (context.isInSelection) {\n        br.isSelected = true;\n    }\n\n    const paragraph = addSegment(group, br, context.blockFormat);\n    context.domIndexer?.onSegment(element, paragraph, [br]);\n};\n","import { addSelectionMarker } from '../utils/addSelectionMarker';\nimport { getRegularSelectionOffsets } from '../utils/getRegularSelectionOffsets';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport type {\n    ContentModelBlockGroup,\n    DomToModelContext,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\n/**\n * Content Model Element Processor for child elements\n * @param group The parent block group\n * @param parent Parent DOM node to process\n * @param context DOM to Content Model context\n */\nexport const childProcessor: ElementProcessor<ParentNode> = (\n    group: ContentModelBlockGroup,\n    parent: ParentNode,\n    context: DomToModelContext\n) => {\n    const [nodeStartOffset, nodeEndOffset] = getRegularSelectionOffsets(context, parent);\n    let index = 0;\n\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        handleRegularSelection(index, context, group, nodeStartOffset, nodeEndOffset);\n\n        processChildNode(group, child, context);\n\n        index++;\n    }\n\n    handleRegularSelection(index, context, group, nodeStartOffset, nodeEndOffset);\n};\n\n/**\n * Helper function for processing child node\n * @param group The parent block group\n * @param parent Parent DOM node to process\n * @param context DOM to Content Model context\n *\n */\nexport function processChildNode(\n    group: ContentModelBlockGroup,\n    child: Node,\n    context: DomToModelContext\n) {\n    if (isNodeOfType(child, 'ELEMENT_NODE') && child.style.display != 'none') {\n        context.elementProcessors.element(group, child, context);\n    } else if (isNodeOfType(child, 'TEXT_NODE')) {\n        context.elementProcessors['#text'](group, child, context);\n    }\n}\n\n/**\n * Helper function to handle regular (range based) selection when process child node\n * @param index Index of current child node in its parent\n * @param context DOM to Content Model context\n * @param group The parent block group\n * @param nodeStartOffset Start offset of current regular selection\n * @param nodeEndOffset  End offset of current regular selection\n */\nexport function handleRegularSelection(\n    index: number,\n    context: DomToModelContext,\n    group: ContentModelBlockGroup,\n    nodeStartOffset: number,\n    nodeEndOffset: number\n) {\n    if (index == nodeStartOffset) {\n        context.isInSelection = true;\n\n        addSelectionMarker(group, context);\n    }\n\n    if (index == nodeEndOffset && context.selection?.type == 'range') {\n        if (!context.selection.range.collapsed) {\n            addSelectionMarker(group, context);\n        }\n        context.isInSelection = false;\n    }\n}\n","import { knownElementProcessor } from './knownElementProcessor';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const codeProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    stackFormat(context, { code: 'codeDefault' }, () => {\n        parseFormat(element, context.formatParsers.code, context.code.format, context);\n\n        knownElementProcessor(group, element, context);\n    });\n};\n","import { addSelectionMarker } from '../utils/addSelectionMarker';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * @param group\n * @param node\n * @param context\n */\nexport const delimiterProcessor: ElementProcessor<Node> = (group, node, context) => {\n    const range = context.selection?.type == 'range' ? context.selection.range : null;\n\n    if (range) {\n        if (node.contains(range.startContainer)) {\n            context.isInSelection = true;\n\n            addSelectionMarker(group, context);\n        }\n\n        if (context.selection?.type == 'range' && node.contains(range.endContainer)) {\n            if (!context.selection.range.collapsed) {\n                addSelectionMarker(group, context);\n            }\n\n            context.isInSelection = false;\n        }\n    }\n};\n","import { isEntityDelimiter, isEntityElement } from '../../domUtils/entityUtils';\nimport type {\n    DomToModelContext,\n    ElementProcessor,\n    ElementProcessorMap,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * @param group\n * @param element\n * @param context\n */\nexport const elementProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const tagName = element.tagName.toLowerCase() as keyof ElementProcessorMap;\n    const processor = (tryGetProcessorForEntity(element, context) ||\n        tryGetProcessorForDelimiter(element, context) ||\n        context.elementProcessors[tagName] ||\n        (tagName.indexOf(':') >= 0 && context.elementProcessors.child) ||\n        context.elementProcessors['*']) as ElementProcessor<Node>;\n    processor(group, element, context);\n};\n\nfunction tryGetProcessorForEntity(element: HTMLElement, context: DomToModelContext) {\n    return isEntityElement(element) || element.contentEditable == 'false' // For readonly element, treat as an entity\n        ? context.elementProcessors.entity\n        : null;\n}\n\nfunction tryGetProcessorForDelimiter(element: HTMLElement, context: DomToModelContext) {\n    return isEntityDelimiter(element) ? context.elementProcessors.delimiter : null;\n}\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { addSegment } from '../../modelApi/common/addSegment';\nimport { createEntity } from '../../modelApi/creators/createEntity';\nimport { isBlockElement } from '../utils/isBlockElement';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * Content Model Element Processor for entity\n * @param group The parent block group\n * @param parent Parent DOM node to process\n * @param context DOM to Content Model context\n */\nexport const entityProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const isBlockEntity = isBlockElement(element);\n\n    stackFormat(\n        context,\n        { segment: isBlockEntity ? 'empty' : undefined, paragraph: 'empty' },\n        () => {\n            const entityModel = createEntity(element, true /*isReadonly*/, context.segmentFormat);\n\n            parseFormat(element, context.formatParsers.entity, entityModel.entityFormat, context);\n\n            // TODO: Need to handle selection for editable entity\n            if (context.isInSelection) {\n                entityModel.isSelected = true;\n            }\n\n            if (isBlockEntity) {\n                addBlock(group, entityModel);\n            } else {\n                const paragraph = addSegment(group, entityModel);\n                context.domIndexer?.onSegment(element, paragraph, [entityModel]);\n            }\n        }\n    );\n};\n","import { isBlockElement } from '../utils/isBlockElement';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\nconst FontSizes = ['10px', '13px', '16px', '18px', '24px', '32px', '48px'];\n\nfunction getFontSize(size: string | null) {\n    const intSize = parseInt(size || '');\n\n    if (Number.isNaN(intSize)) {\n        return undefined;\n    } else if (intSize < 1) {\n        return FontSizes[0];\n    } else if (intSize > FontSizes.length) {\n        return FontSizes[FontSizes.length - 1];\n    } else {\n        return FontSizes[intSize - 1];\n    }\n}\n\n/**\n * @internal\n */\nexport const fontProcessor: ElementProcessor<HTMLFontElement> = (group, element, context) => {\n    stackFormat(\n        context,\n        {\n            segment: isBlockElement(element) ? 'shallowCloneForBlock' : 'shallowClone',\n        },\n        () => {\n            const fontFamily = element.getAttribute('face');\n            const fontSize = getFontSize(element.getAttribute('size'));\n            const textColor = element.getAttribute('color');\n            const format = context.segmentFormat;\n\n            if (fontFamily) {\n                format.fontFamily = fontFamily;\n            }\n\n            if (fontSize) {\n                format.fontSize = fontSize;\n            }\n\n            if (textColor) {\n                format.textColor = textColor;\n            }\n\n            parseFormat(element, context.formatParsers.segment, context.segmentFormat, context);\n\n            context.elementProcessors.child(group, element, context);\n        }\n    );\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { createFormatContainer } from '../../modelApi/creators/createFormatContainer';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { getDefaultStyle } from '../utils/getDefaultStyle';\nimport { parseFormat } from '../utils/parseFormat';\nimport { setParagraphNotImplicit } from '../../modelApi/block/setParagraphNotImplicit';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelFormatContainer,\n    ContentModelFormatContainerFormat,\n    ContentModelParagraph,\n    ElementProcessor,\n    MarginFormat,\n    PaddingFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const ContextStyles: (keyof (MarginFormat & PaddingFormat))[] = [\n    'marginLeft',\n    'marginRight',\n    'paddingLeft',\n    'paddingRight',\n];\n\n/**\n * @internal\n */\nexport const formatContainerProcessor: ElementProcessor<HTMLElement> = (\n    group,\n    element,\n    context\n) => {\n    stackFormat(context, { segment: 'shallowCloneForBlock', paragraph: 'shallowClone' }, () => {\n        parseFormat(element, context.formatParsers.block, context.blockFormat, context);\n        parseFormat(element, context.formatParsers.segmentOnBlock, context.segmentFormat, context);\n\n        const format: ContentModelFormatContainerFormat = {\n            ...context.blockFormat,\n        };\n\n        parseFormat(element, context.formatParsers.container, format, context);\n\n        const tagName =\n            getDefaultStyle(element).display == 'block' ? element.tagName.toLowerCase() : 'div';\n        const formatContainer = createFormatContainer(tagName, format);\n\n        // It is possible to inherit margin left/right styles from parent DIV or other containers,\n        // since we are going into a deeper level of format container now,\n        // the container will render these styles so no need to keep them in context format\n        ContextStyles.forEach(style => {\n            delete context.blockFormat[style];\n        });\n\n        context.elementProcessors.child(formatContainer, element, context);\n\n        if (element.style.fontSize && parseInt(element.style.fontSize) == 0) {\n            formatContainer.zeroFontSize = true;\n        }\n\n        if (shouldFallbackToParagraph(formatContainer)) {\n            // For DIV container that only has one paragraph child, container style can be merged into paragraph\n            // and no need to have this container\n            const paragraph = formatContainer.blocks[0] as ContentModelParagraph;\n\n            if (formatContainer.zeroFontSize) {\n                paragraph.segmentFormat = Object.assign({}, paragraph.segmentFormat, {\n                    fontSize: '0',\n                });\n            }\n\n            Object.assign(paragraph.format, formatContainer.format);\n            setParagraphNotImplicit(paragraph);\n            addBlock(group, paragraph);\n        } else {\n            addBlock(group, formatContainer);\n        }\n    });\n\n    addBlock(group, createParagraph(true /*isImplicit*/, context.blockFormat));\n};\n\nfunction shouldFallbackToParagraph(formatContainer: ContentModelFormatContainer) {\n    const firstChild = formatContainer.blocks[0];\n\n    return (\n        formatContainer.tagName == 'div' &&\n        formatContainer.blocks.length == 1 &&\n        firstChild.blockType == 'Paragraph' &&\n        firstChild.isImplicit\n    );\n}\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { addDecorators } from '../../modelApi/common/addDecorators';\nimport { addSegment } from '../../modelApi/common/addSegment';\nimport { createGeneralBlock } from '../../modelApi/creators/createGeneralBlock';\nimport { createGeneralSegment } from '../../modelApi/creators/createGeneralSegment';\nimport { isBlockElement } from '../utils/isBlockElement';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\nconst generalBlockProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const block = createGeneralBlock(element);\n    const isSelectedBefore = context.isInSelection;\n\n    stackFormat(\n        context,\n        {\n            segment: 'empty',\n            paragraph: 'empty',\n            link: 'empty',\n        },\n        () => {\n            addBlock(group, block);\n\n            context.elementProcessors.child(block, element, context);\n        }\n    );\n\n    if (isSelectedBefore && context.isInSelection) {\n        block.isSelected = true;\n    }\n};\n\nconst generalSegmentProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const segment = createGeneralSegment(element, context.segmentFormat);\n    const isSelectedBefore = context.isInSelection;\n\n    addDecorators(segment, context);\n    const paragraph = addSegment(group, segment);\n    context.domIndexer?.onSegment(element, paragraph, [segment]);\n\n    stackFormat(\n        context,\n        {\n            segment:\n                'empty' /*clearFormat, General segment will include all properties and styles when generate back to HTML, so no need to carry over existing segment format*/,\n        },\n        () => {\n            context.elementProcessors.child(segment, element, context);\n        }\n    );\n\n    if (isSelectedBefore && context.isInSelection) {\n        segment.isSelected = true;\n    }\n};\n\n/**\n * @internal\n */\nexport const generalProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const processor = isBlockElement(element) ? generalBlockProcessor : generalSegmentProcessor;\n\n    processor(group, element, context);\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { blockProcessor } from './blockProcessor';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { createParagraphDecorator } from '../../modelApi/creators/createParagraphDecorator';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ContentModelSegmentFormat, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const headingProcessor: ElementProcessor<HTMLHeadingElement> = (group, element, context) => {\n    stackFormat(\n        context,\n        { segment: 'shallowCloneForBlock', paragraph: 'shallowClone', blockDecorator: 'empty' },\n        () => {\n            const segmentFormat: ContentModelSegmentFormat = {};\n\n            parseFormat(element, context.formatParsers.segmentOnBlock, segmentFormat, context);\n\n            // These formats are already declared on heading element, no need to keep them in context.\n            // And we should not duplicate them in context, either. Because when we want to turn off heading,\n            // inner text should not keep those text format from heading.\n            getObjectKeys(segmentFormat).forEach(key => {\n                delete context.segmentFormat[key];\n            });\n\n            context.blockDecorator = createParagraphDecorator(element.tagName, segmentFormat);\n\n            blockProcessor(group, element, context);\n        }\n    );\n\n    addBlock(group, createParagraph(true /*isImplicit*/, context.blockFormat));\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { createDivider } from '../../modelApi/creators/createDivider';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const hrProcessor: ElementProcessor<HTMLHRElement> = (group, element, context) => {\n    stackFormat(\n        context,\n        {\n            paragraph: 'shallowClone',\n        },\n        () => {\n            parseFormat(element, context.formatParsers.divider, context.blockFormat, context);\n\n            const hr = createDivider('hr', context.blockFormat);\n\n            if (element.size) {\n                hr.size = element.size;\n            }\n\n            if (context.isInSelection) {\n                hr.isSelected = true;\n            }\n\n            addBlock(group, hr);\n        }\n    );\n};\n","import { addDecorators } from '../../modelApi/common/addDecorators';\nimport { addSegment } from '../../modelApi/common/addSegment';\nimport { createImage } from '../../modelApi/creators/createImage';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ContentModelImageFormat, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const imageProcessor: ElementProcessor<HTMLImageElement> = (group, element, context) => {\n    stackFormat(context, { segment: 'shallowClone' }, () => {\n        const imageFormat: ContentModelImageFormat = context.segmentFormat;\n\n        // Use getAttribute('src') instead of retrieving src directly, in case the src has port and may be stripped by browser\n        const src = element.getAttribute('src') ?? '';\n\n        parseFormat(element, context.formatParsers.segment, imageFormat, context);\n        parseFormat(element, context.formatParsers.image, imageFormat, context);\n        parseFormat(element, context.formatParsers.block, context.blockFormat, context);\n\n        const image = createImage(src, imageFormat);\n        const alt = element.alt;\n        const title = element.title;\n\n        parseFormat(element, context.formatParsers.dataset, image.dataset, context);\n        addDecorators(image, context);\n\n        if (alt) {\n            image.alt = alt;\n        }\n        if (title) {\n            image.title = title;\n        }\n        if (context.isInSelection) {\n            image.isSelected = true;\n        }\n        if (context.selection?.type == 'image' && context.selection.image == element) {\n            image.isSelectedAsImageSelection = true;\n            image.isSelected = true;\n        }\n\n        const paragraph = addSegment(group, image);\n        context.domIndexer?.onSegment(element, paragraph, [image]);\n    });\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { blockProcessor } from './blockProcessor';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { formatContainerProcessor } from './formatContainerProcessor';\nimport { getDefaultStyle } from '../utils/getDefaultStyle';\nimport { isBlockElement } from '../utils/isBlockElement';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelSegmentFormat,\n    DomToModelContext,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\nconst FormatContainerTriggerStyles: (keyof CSSStyleDeclaration)[] = [\n    'marginBottom',\n    'marginTop',\n    'paddingBottom',\n    'paddingTop',\n    'paddingLeft',\n    'paddingRight',\n    'borderTopWidth',\n    'borderBottomWidth',\n    'borderLeftWidth',\n    'borderRightWidth',\n    'width',\n    'height',\n    'maxWidth',\n    'maxHeight',\n    'minWidth',\n    'minHeight',\n];\nconst ByPassFormatContainerTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'A'];\nconst SegmentDecoratorTags = ['A', 'CODE'];\n\n/**\n * @internal\n */\nexport const knownElementProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    const isBlock = isBlockElement(element);\n\n    if (\n        (isBlock || element.style.display == 'inline-block') && // For inline-block here, we will also check if it should be represented as Format Container\n        shouldUseFormatContainer(element, context)\n    ) {\n        formatContainerProcessor(group, element, context);\n    } else if (isBlock) {\n        const decorator = context.blockDecorator.tagName ? context.blockDecorator : undefined;\n        const isSegmentDecorator = SegmentDecoratorTags.indexOf(element.tagName) >= 0;\n\n        stackFormat(context, { segment: 'shallowCloneForBlock', paragraph: 'shallowClone' }, () => {\n            const segmentFormat: ContentModelSegmentFormat = {};\n\n            parseFormat(element, context.formatParsers.segmentOnBlock, segmentFormat, context);\n            Object.assign(context.segmentFormat, segmentFormat);\n\n            blockProcessor(group, element, context, segmentFormat);\n        });\n\n        if (isBlock && !isSegmentDecorator) {\n            addBlock(\n                group,\n                createParagraph(\n                    true /*isImplicit*/,\n                    context.blockFormat,\n                    undefined /*segmentFormat*/,\n                    decorator\n                )\n            );\n        }\n    } else {\n        stackFormat(\n            context,\n            {\n                segment: 'shallowClone',\n                paragraph: 'shallowClone',\n                link: 'cloneFormat',\n            },\n            () => {\n                parseFormat(element, context.formatParsers.segment, context.segmentFormat, context);\n\n                if (context.link.format.href && element.tagName != 'A') {\n                    parseFormat(\n                        element,\n                        context.formatParsers.segmentUnderLink,\n                        context.link.format,\n                        context\n                    );\n                }\n\n                context.elementProcessors.child(group, element, context);\n            }\n        );\n    }\n};\n\nfunction shouldUseFormatContainer(element: HTMLElement, context: DomToModelContext) {\n    // For those tags that we know we should not use format container, just return false\n    if (ByPassFormatContainerTags.indexOf(element.tagName) >= 0) {\n        return false;\n    }\n\n    const style = element.style;\n    const defaultStyle = getDefaultStyle(element);\n\n    const bgcolor = style.getPropertyValue('background-color');\n\n    // For block element with background, we need to use format container\n    if (bgcolor && bgcolor != 'transparent') {\n        return true;\n    }\n\n    // For block element with positive value of border width or top/bottom margin/padding,\n    // we need to use format container\n    if (\n        FormatContainerTriggerStyles.some(\n            key => parseInt((style[key] as string) || (defaultStyle[key] as string) || '') > 0\n        )\n    ) {\n        return true;\n    }\n\n    // For margin left/right with value \"auto\", we need to use format container\n    if (style.marginLeft == 'auto' || style.marginRight == 'auto') {\n        return true;\n    }\n\n    // For element with \"align\" attribute, we need to use format container\n    if (element.getAttribute('align')) {\n        return true;\n    }\n\n    return false;\n}\n","import { knownElementProcessor } from './knownElementProcessor';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const linkProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    if (element.hasAttribute('href')) {\n        stackFormat(context, { link: 'linkDefault' }, () => {\n            parseFormat(element, context.formatParsers.link, context.link.format, context);\n            parseFormat(element, context.formatParsers.dataset, context.link.dataset, context);\n\n            knownElementProcessor(group, element, context);\n        });\n    } else {\n        // A tag without href, can be treated as normal SPAN tag\n        knownElementProcessor(group, element, context);\n    }\n};\n","import { createListItem } from '../../modelApi/creators/createListItem';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listItemProcessor: ElementProcessor<HTMLLIElement> = (group, element, context) => {\n    const { listFormat } = context;\n\n    if (listFormat.listParent && listFormat.levels.length > 0) {\n        stackFormat(\n            context,\n            {\n                segment: 'shallowCloneForBlock',\n            },\n            () => {\n                parseFormat(\n                    element,\n                    context.formatParsers.segmentOnBlock,\n                    context.segmentFormat,\n                    context\n                );\n\n                const listItem = createListItem(listFormat.levels, context.segmentFormat);\n                parseFormat(\n                    element,\n                    context.formatParsers.listItemElement,\n                    listItem.format,\n                    context\n                );\n\n                listFormat.listParent!.blocks.push(listItem);\n\n                parseFormat(\n                    element,\n                    context.formatParsers.listItemThread,\n                    listItem.levels[listItem.levels.length - 1].format,\n                    context\n                );\n\n                context.elementProcessors.child(listItem, element, context);\n\n                const firstChild = listItem.blocks[0];\n\n                if (\n                    listItem.blocks.length == 1 &&\n                    firstChild.blockType == 'Paragraph' &&\n                    firstChild.isImplicit\n                ) {\n                    Object.assign(listItem.format, firstChild.format);\n                    firstChild.format = {};\n                }\n            }\n        );\n    } else {\n        const currentBlocks = listFormat.listParent?.blocks;\n        const lastItem = currentBlocks?.[currentBlocks?.length - 1];\n\n        context.elementProcessors['*'](\n            lastItem?.blockType == 'BlockGroup' ? lastItem : group,\n            element,\n            context\n        );\n    }\n};\n","import { createListLevel } from '../../modelApi/creators/createListLevel';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ContentModelListLevel, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listProcessor: ElementProcessor<HTMLOListElement | HTMLUListElement> = (\n    group,\n    element,\n    context\n) => {\n    stackFormat(\n        context,\n        {\n            segment: 'shallowCloneForBlock',\n            paragraph: 'shallowCloneForGroup',\n        },\n        () => {\n            const level: ContentModelListLevel = createListLevel(\n                element.tagName as 'OL' | 'UL',\n                context.blockFormat\n            );\n            const { listFormat } = context;\n\n            parseFormat(element, context.formatParsers.dataset, level.dataset, context);\n            parseFormat(element, context.formatParsers.listLevelThread, level.format, context);\n            parseFormat(element, context.formatParsers.listLevel, level.format, context);\n            parseFormat(element, context.formatParsers.segment, context.segmentFormat, context);\n\n            const originalListParent = listFormat.listParent;\n\n            listFormat.listParent = listFormat.listParent || group;\n            listFormat.levels.push(level);\n\n            try {\n                context.elementProcessors.child(group, element, context);\n            } finally {\n                listFormat.levels.pop();\n                listFormat.listParent = originalListParent;\n            }\n        }\n    );\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { blockProcessor } from './blockProcessor';\nimport { createParagraph } from '../../modelApi/creators/createParagraph';\nimport { createParagraphDecorator } from '../../modelApi/creators/createParagraphDecorator';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type { ContentModelSegmentFormat, ElementProcessor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const pProcessor: ElementProcessor<HTMLElement> = (group, element, context) => {\n    stackFormat(\n        context,\n        { blockDecorator: 'empty', segment: 'shallowCloneForBlock', paragraph: 'shallowClone' },\n        () => {\n            context.blockDecorator = createParagraphDecorator(element.tagName);\n\n            const segmentFormat: ContentModelSegmentFormat = {};\n\n            parseFormat(element, context.formatParsers.segmentOnBlock, segmentFormat, context);\n            Object.assign(context.segmentFormat, segmentFormat);\n\n            blockProcessor(group, element, context, segmentFormat);\n        }\n    );\n\n    addBlock(group, createParagraph(true /*isImplicit*/, context.blockFormat));\n};\n","import { addBlock } from '../../modelApi/common/addBlock';\nimport { createTable } from '../../modelApi/creators/createTable';\nimport { createTableCell } from '../../modelApi/creators/createTableCell';\nimport { getBoundingClientRect } from '../utils/getBoundingClientRect';\nimport { isElementOfType } from '../../domUtils/isElementOfType';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport { parseFormat } from '../utils/parseFormat';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelTableCellFormat,\n    DatasetFormat,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\n/**\n * Content Model Element Processor for table\n *\n * For Table with merged/splitted cells, HTML uses colSpan and rowSpan attributes to specify how it should be rendered.\n * To make it easier to edit a table, we will use a different way to describe table.\n *\n * 1. For a m * n table (m rows, n columns), we always create a m * n array for the cells.\n * 2. For a regular table cell, it is mapped to one item of this array\n * 3. For a merged/splitted table cell, it will has colSpan/rowSpan value. We also created TableCell model for those spanned\n * cells, and use \"spanLeft\" and \"spanAbove\" to mark its state\n * 4. When edit table, we always edit on this mapped m * n array because it always has an item for each cell\n * 5. When write back to DOM, we create TD/TH elements for those non-spanned cells, and mark its colSpan/rowSpan value according\n * its neighbour cell's spanLeft/spanAbove attribute\n * @param group The parent block group\n * @param parent Parent DOM node to process\n * @param context DOM to Content Model context\n */\nexport const tableProcessor: ElementProcessor<HTMLTableElement> = (\n    group,\n    tableElement,\n    context\n) => {\n    stackFormat(\n        context,\n        { segment: 'shallowCloneForBlock', paragraph: 'shallowCloneForGroup' },\n        () => {\n            parseFormat(tableElement, context.formatParsers.block, context.blockFormat, context);\n\n            const table = createTable(tableElement.rows.length, context.blockFormat);\n            const tableSelection = context.selection?.type == 'table' ? context.selection : null;\n            const selectedTable = tableSelection?.table;\n            const hasTableSelection = selectedTable == tableElement;\n\n            if (context.allowCacheElement) {\n                table.cachedElement = tableElement;\n            }\n\n            context.domIndexer?.onTable(tableElement, table);\n\n            parseFormat(tableElement, context.formatParsers.table, table.format, context);\n            parseFormat(tableElement, context.formatParsers.tableBorder, table.format, context);\n            parseFormat(\n                tableElement,\n                context.formatParsers.segmentOnBlock,\n                context.segmentFormat,\n                context\n            );\n            parseFormat(tableElement, context.formatParsers.dataset, table.dataset, context);\n            addBlock(group, table);\n\n            const columnPositions: number[] = [0];\n            const rowPositions: number[] = [0];\n            const zoomScale = context.zoomScale || 1;\n\n            for (let row = 0; row < tableElement.rows.length; row++) {\n                const tr = tableElement.rows[row];\n                const tableRow = table.rows[row];\n\n                const tbody = tr.parentNode;\n\n                if (\n                    isNodeOfType(tbody, 'ELEMENT_NODE') &&\n                    (isElementOfType(tbody, 'tbody') ||\n                        isElementOfType(tbody, 'thead') ||\n                        isElementOfType(tbody, 'tfoot'))\n                ) {\n                    parseFormat(tbody, context.formatParsers.tableRow, tableRow.format, context);\n                } else if (context.allowCacheElement) {\n                    tableRow.cachedElement = tr;\n                }\n\n                parseFormat(tr, context.formatParsers.tableRow, tableRow.format, context);\n\n                stackFormat(context, { paragraph: 'shallowClone', segment: 'shallowClone' }, () => {\n                    const parent = tr.parentElement;\n                    const parentTag = parent?.tagName;\n\n                    if (\n                        parent &&\n                        (parentTag == 'TBODY' || parentTag == 'THEAD' || parentTag == 'TFOOT')\n                    ) {\n                        // If there is TBODY around TR, retrieve format from TBODY first, in case some format are declared there\n                        parseFormat(\n                            parent,\n                            context.formatParsers.block,\n                            context.blockFormat,\n                            context\n                        );\n                        parseFormat(\n                            parent,\n                            context.formatParsers.segmentOnBlock,\n                            context.segmentFormat,\n                            context\n                        );\n                    }\n\n                    parseFormat(tr, context.formatParsers.block, context.blockFormat, context);\n                    parseFormat(\n                        tr,\n                        context.formatParsers.segmentOnBlock,\n                        context.segmentFormat,\n                        context\n                    );\n\n                    for (\n                        let sourceCol = 0, targetCol = 0;\n                        sourceCol < tr.cells.length;\n                        sourceCol++\n                    ) {\n                        for (; tableRow.cells[targetCol]; targetCol++) {}\n\n                        const td = tr.cells[sourceCol];\n                        const hasSelectionBeforeCell = context.isInSelection;\n                        const colEnd = targetCol + td.colSpan;\n                        const rowEnd = row + td.rowSpan;\n                        const needCalcWidth = columnPositions[colEnd] === undefined;\n                        const needCalcHeight = rowPositions[rowEnd] === undefined;\n\n                        if (needCalcWidth || needCalcHeight) {\n                            const rect = getBoundingClientRect(td);\n\n                            if (rect.width > 0 || rect.height > 0) {\n                                if (needCalcWidth) {\n                                    columnPositions[colEnd] =\n                                        columnPositions[targetCol] + rect.width / zoomScale;\n                                }\n\n                                if (needCalcHeight) {\n                                    rowPositions[rowEnd] =\n                                        rowPositions[row] + rect.height / zoomScale;\n                                }\n                            }\n                        }\n\n                        stackFormat(\n                            context,\n                            { paragraph: 'shallowClone', segment: 'shallowClone' },\n                            () => {\n                                parseFormat(\n                                    td,\n                                    context.formatParsers.block,\n                                    context.blockFormat,\n                                    context\n                                );\n                                parseFormat(\n                                    td,\n                                    context.formatParsers.segmentOnTableCell,\n                                    context.segmentFormat,\n                                    context\n                                );\n\n                                const cellFormat: ContentModelTableCellFormat = {\n                                    ...context.blockFormat,\n                                };\n                                const dataset: DatasetFormat = {};\n\n                                parseFormat(\n                                    td,\n                                    context.formatParsers.tableCell,\n                                    cellFormat,\n                                    context\n                                );\n                                parseFormat(\n                                    td,\n                                    context.formatParsers.tableBorder,\n                                    cellFormat,\n                                    context\n                                );\n                                parseFormat(td, context.formatParsers.dataset, dataset, context);\n\n                                for (\n                                    let colSpan = 1;\n                                    colSpan <= td.colSpan;\n                                    colSpan++, targetCol++\n                                ) {\n                                    for (let rowSpan = 1; rowSpan <= td.rowSpan; rowSpan++) {\n                                        const hasTd = colSpan == 1 && rowSpan == 1;\n                                        const cell = createTableCell(\n                                            colSpan > 1,\n                                            rowSpan > 1,\n                                            td.tagName == 'TH',\n                                            cellFormat\n                                        );\n\n                                        cell.dataset = { ...dataset };\n\n                                        const spannedRow = table.rows[row + rowSpan - 1];\n\n                                        if (spannedRow) {\n                                            spannedRow.cells[targetCol] = cell;\n                                        }\n\n                                        if (hasTd) {\n                                            if (context.allowCacheElement) {\n                                                cell.cachedElement = td;\n                                            }\n\n                                            const { listParent, levels } = context.listFormat;\n\n                                            context.listFormat.listParent = undefined;\n                                            context.listFormat.levels = [];\n\n                                            try {\n                                                context.elementProcessors.child(cell, td, context);\n                                            } finally {\n                                                context.listFormat.listParent = listParent;\n                                                context.listFormat.levels = levels;\n                                            }\n                                        }\n\n                                        const hasSelectionAfterCell = context.isInSelection;\n\n                                        if (\n                                            (hasSelectionBeforeCell && hasSelectionAfterCell) ||\n                                            (hasTableSelection &&\n                                                tableSelection &&\n                                                row >= tableSelection.firstRow &&\n                                                row <= tableSelection.lastRow &&\n                                                targetCol >= tableSelection.firstColumn &&\n                                                targetCol <= tableSelection.lastColumn)\n                                        ) {\n                                            cell.isSelected = true;\n                                        }\n                                    }\n                                }\n                            }\n                        );\n                    }\n                });\n\n                for (let col = 0; col < tableRow.cells.length; col++) {\n                    if (!tableRow.cells[col]) {\n                        tableRow.cells[col] = createTableCell(\n                            false,\n                            false,\n                            false,\n                            context.blockFormat\n                        );\n                    }\n                }\n            }\n\n            table.widths = calcSizes(columnPositions);\n\n            const heights = calcSizes(rowPositions);\n\n            table.rows.forEach((row, i) => {\n                if (heights[i] > 0) {\n                    row.height = heights[i];\n                }\n            });\n        }\n    );\n};\n\nfunction calcSizes(positions: number[]): number[] {\n    const result: number[] = [];\n    let lastPos = positions[positions.length - 1];\n\n    for (let i = positions.length - 2; i >= 0; i--) {\n        if (positions[i] === undefined) {\n            result[i] = 0;\n        } else {\n            result[i] = lastPos - positions[i];\n            lastPos = positions[i];\n        }\n    }\n\n    return result;\n}\n","import { addDecorators } from '../../modelApi/common/addDecorators';\nimport { addSegment } from '../../modelApi/common/addSegment';\nimport { addSelectionMarker } from '../utils/addSelectionMarker';\nimport { createText } from '../../modelApi/creators/createText';\nimport { ensureParagraph } from '../../modelApi/common/ensureParagraph';\nimport { getRegularSelectionOffsets } from '../utils/getRegularSelectionOffsets';\nimport { hasSpacesOnly } from '../../modelApi/common/hasSpacesOnly';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelParagraph,\n    ContentModelText,\n    DomToModelContext,\n    ElementProcessor,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const textProcessor: ElementProcessor<Text> = (\n    group: ContentModelBlockGroup,\n    textNode: Text,\n    context: DomToModelContext\n) => {\n    let txt = textNode.nodeValue || '';\n    const offsets = getRegularSelectionOffsets(context, textNode);\n    const txtStartOffset = offsets[0];\n    let txtEndOffset = offsets[1];\n    const segments: (ContentModelText | undefined)[] = [];\n    const paragraph = ensureParagraph(group, context.blockFormat);\n\n    if (txtStartOffset >= 0) {\n        const subText = txt.substring(0, txtStartOffset);\n        segments.push(addTextSegment(group, subText, paragraph, context));\n        context.isInSelection = true;\n\n        addSelectionMarker(group, context);\n\n        txt = txt.substring(txtStartOffset);\n        txtEndOffset -= txtStartOffset;\n    }\n\n    if (txtEndOffset >= 0) {\n        const subText = txt.substring(0, txtEndOffset);\n        segments.push(addTextSegment(group, subText, paragraph, context));\n\n        if (\n            context.selection &&\n            (context.selection.type != 'range' || !context.selection.range.collapsed)\n        ) {\n            addSelectionMarker(group, context);\n        }\n\n        context.isInSelection = false;\n        txt = txt.substring(txtEndOffset);\n    }\n\n    segments.push(addTextSegment(group, txt, paragraph, context));\n    context.domIndexer?.onSegment(\n        textNode,\n        paragraph,\n        segments.filter((x): x is ContentModelText => !!x)\n    );\n};\n\n// When we see these values of white-space style, need to preserve spaces and line-breaks and let browser handle it for us.\nconst WhiteSpaceValuesNeedToHandle = ['pre', 'pre-wrap', 'pre-line', 'break-spaces'];\n\nfunction addTextSegment(\n    group: ContentModelBlockGroup,\n    text: string,\n    paragraph: ContentModelParagraph,\n    context: DomToModelContext\n): ContentModelText | undefined {\n    let textModel: ContentModelText | undefined;\n\n    if (text) {\n        if (\n            !hasSpacesOnly(text) ||\n            (paragraph?.segments.length ?? 0) > 0 ||\n            WhiteSpaceValuesNeedToHandle.indexOf(paragraph?.format.whiteSpace || '') >= 0\n        ) {\n            textModel = createText(text, context.segmentFormat);\n\n            if (context.isInSelection) {\n                textModel.isSelected = true;\n            }\n\n            addDecorators(textModel, context);\n\n            addSegment(group, textModel, context.blockFormat);\n        }\n    }\n\n    return textModel;\n}\n","import { addDecorators } from '../../modelApi/common/addDecorators';\nimport { addSegment } from '../../modelApi/common/addSegment';\nimport { createSelectionMarker } from '../../modelApi/creators/createSelectionMarker';\nimport type { ContentModelBlockGroup, DomToModelContext } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function addSelectionMarker(group: ContentModelBlockGroup, context: DomToModelContext) {\n    const segmentFormat = {\n        ...context.defaultFormat,\n        ...context.segmentFormat,\n    };\n    const marker = createSelectionMarker(segmentFormat);\n\n    addDecorators(marker, context);\n\n    addSegment(group, marker, context.blockFormat, segmentFormat);\n}\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport type { ContentModelFormatBase } from 'roosterjs-content-model-types';\n\n/**\n * Check if the two given formats object are equal. This is a check to value but not to reference\n * @param f1 The first format object to check\n * @param f2 The second format object to check\n */\nexport function areSameFormats<T extends ContentModelFormatBase>(f1: T, f2: T) {\n    if (f1 == f2) {\n        return true;\n    } else {\n        const keys1 = getObjectKeys(f1);\n        const keys2 = getObjectKeys(f2);\n\n        return keys1.length == keys2.length && keys1.every(key => f1[key] == f2[key]);\n    }\n}\n","/**\n * @internal\n */\nexport function getBoundingClientRect(element: Element): DOMRect {\n    return element.getBoundingClientRect();\n}\n","import { defaultHTMLStyleMap } from '../../config/defaultHTMLStyleMap';\nimport type { DefaultStyleMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Get default CSS style of given element\n * @param element The element to get default style from\n * @returns A valid CSS style object\n */\nexport function getDefaultStyle(element: HTMLElement): Partial<CSSStyleDeclaration> {\n    const tag = element.tagName.toLowerCase() as keyof DefaultStyleMap;\n\n    return defaultHTMLStyleMap[tag] || {};\n}\n","import type { DomToModelContext } from 'roosterjs-content-model-types';\n\n/**\n * Get offset numbers of a regular (range based) selection.\n * If the selection start/end position is not in the given node, it will return -1 for the related value\n * @param context DOM to Content Model context used for retrieve the selection\n * @param currentContainer The container node to check\n * @returns a tuple of start and end offsets. -1 means selection is not directly under the given node\n */\nexport function getRegularSelectionOffsets(\n    context: DomToModelContext,\n    currentContainer: Node\n): [number, number] {\n    const range = context.selection?.type == 'range' ? context.selection.range : null;\n\n    const startOffset = range?.startContainer == currentContainer ? range.startOffset : -1;\n    const endOffset = range?.endContainer == currentContainer ? range.endOffset! : -1;\n\n    return [startOffset, endOffset];\n}\n","import { getDefaultStyle } from './getDefaultStyle';\n\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table', 'table-cell', 'flex'];\n\n/**\n * Check if the given element will be layout as a block\n * @param element The element to check\n * @param context The context of DOM to Content Model conversion\n */\nexport function isBlockElement(element: HTMLElement): boolean {\n    const display = element.style.display || getDefaultStyle(element).display || '';\n\n    return BLOCK_DISPLAY_STYLES.indexOf(display) >= 0;\n}\n","import { getDefaultStyle } from './getDefaultStyle';\nimport type {\n    ContentModelFormatBase,\n    DomToModelContext,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\n/**\n * Parse formats of the given HTML element using specified format parsers\n * @param element The element to parse format from\n * @param parsers The parses we are using to parse format\n * @param format The format object to hold result format\n * @param context DOM to Content Model context\n */\nexport function parseFormat<T extends ContentModelFormatBase>(\n    element: HTMLElement,\n    parsers: (FormatParser<T> | null)[],\n    format: T,\n    context: DomToModelContext\n) {\n    const defaultStyle = getDefaultStyle(element);\n\n    parsers.forEach(parser => {\n        parser?.(format, element, context, defaultStyle);\n    });\n}\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelCode,\n    ContentModelFormatBase,\n    ContentModelLink,\n    ContentModelParagraphDecorator,\n    ContentModelSegmentFormat,\n    DomToModelContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport interface StackFormatOptions {\n    segment?: 'shallowClone' | 'shallowCloneForBlock' | 'empty';\n    paragraph?: 'shallowClone' | 'shallowCloneForGroup' | 'empty';\n    blockDecorator?: 'empty';\n    link?: 'linkDefault' | 'cloneFormat' | 'empty';\n    code?: 'codeDefault' | 'empty';\n}\n\n// Some styles, such as background color, won't be inherited by block element if it was originally\n// declared from an inline element. So we need to skip them.\n// e.g.\n// <span style=\"background-color: red\">\n//   line 1       <---------------------------- in red here\n//   <div>line 2</div>  <---------------------- not in red here\n// </span>\nconst SkippedStylesForBlock: (keyof ContentModelSegmentFormat)[] = ['backgroundColor'];\nconst SkippedStylesForTable: (keyof ContentModelBlockFormat)[] = [\n    'marginLeft',\n    'marginRight',\n    'paddingLeft',\n    'paddingRight',\n];\n\n/**\n * @internal\n */\nexport function stackFormat(\n    context: DomToModelContext,\n    options: StackFormatOptions,\n    callback: () => void\n) {\n    const {\n        segmentFormat,\n        blockFormat,\n        link: linkFormat,\n        code: codeFormat,\n        blockDecorator: decoratorFormat,\n    } = context;\n    const { segment, paragraph, link, code, blockDecorator } = options;\n\n    try {\n        context.segmentFormat = stackFormatInternal(segmentFormat, segment);\n        context.blockFormat = stackFormatInternal(blockFormat, paragraph);\n        context.link = stackLinkInternal(linkFormat, link);\n        context.code = stackCodeInternal(codeFormat, code);\n        context.blockDecorator = stackDecoratorInternal(decoratorFormat, blockDecorator);\n\n        callback();\n    } finally {\n        context.segmentFormat = segmentFormat;\n        context.blockFormat = blockFormat;\n        context.link = linkFormat;\n        context.code = codeFormat;\n        context.blockDecorator = decoratorFormat;\n    }\n}\n\nfunction stackLinkInternal(\n    linkFormat: ContentModelLink,\n    link?: 'linkDefault' | 'cloneFormat' | 'empty'\n) {\n    switch (link) {\n        case 'linkDefault':\n            return {\n                format: {\n                    underline: true,\n                },\n                dataset: {},\n            };\n\n        case 'empty':\n            return {\n                format: {},\n                dataset: {},\n            };\n\n        case 'cloneFormat':\n        default:\n            return {\n                dataset: linkFormat.dataset,\n                format: { ...linkFormat.format },\n            };\n    }\n}\n\nfunction stackCodeInternal(codeFormat: ContentModelCode, code?: 'codeDefault' | 'empty') {\n    switch (code) {\n        case 'codeDefault':\n            return {\n                format: {\n                    fontFamily: 'monospace',\n                },\n            };\n        case 'empty':\n            return {\n                format: {},\n            };\n        default:\n            return codeFormat;\n    }\n}\n\nfunction stackDecoratorInternal(\n    format: ContentModelParagraphDecorator,\n    decorator?: 'decoratorDefault' | 'empty'\n) {\n    switch (decorator) {\n        case 'empty':\n            return {\n                format: {},\n                tagName: '',\n            };\n        default:\n            return format;\n    }\n}\n\nfunction stackFormatInternal<T extends ContentModelFormatBase>(\n    format: T,\n    processType?: 'shallowClone' | 'shallowCloneForBlock' | 'shallowCloneForGroup' | 'empty'\n): T | {} {\n    switch (processType) {\n        case 'empty':\n            return {};\n\n        case undefined:\n            return format;\n\n        default:\n            const result = { ...format };\n\n            getObjectKeys(format).forEach(key => {\n                if (\n                    (processType == 'shallowCloneForBlock' &&\n                        SkippedStylesForBlock.indexOf(key as keyof ContentModelSegmentFormat) >=\n                            0) ||\n                    (processType == 'shallowCloneForGroup' &&\n                        SkippedStylesForTable.indexOf(key as keyof ContentModelBlockFormat) >= 0)\n                ) {\n                    delete result[key];\n                }\n            });\n\n            return result;\n    }\n}\n","import toArray from './toArray';\nimport { isElementOfType } from './isElementOfType';\nimport { isNodeOfType } from './isNodeOfType';\nimport type { ContentModelEntityFormat } from 'roosterjs-content-model-types';\n\nconst ENTITY_INFO_NAME = '_Entity';\nconst ENTITY_TYPE_PREFIX = '_EType_';\nconst ENTITY_ID_PREFIX = '_EId_';\nconst ENTITY_READONLY_PREFIX = '_EReadonly_';\nconst ZERO_WIDTH_SPACE = '\\u200B';\nconst DELIMITER_BEFORE = 'entityDelimiterBefore';\nconst DELIMITER_AFTER = 'entityDelimiterAfter';\n\n/**\n * Check if the given DOM Node is an entity wrapper element\n */\nexport function isEntityElement(node: Node): boolean {\n    return isNodeOfType(node, 'ELEMENT_NODE') && node.classList.contains(ENTITY_INFO_NAME);\n}\n\n/**\n * Get all entity wrapper elements under the given root element\n * @param root The root element to query from\n * @returns An array of entity wrapper elements\n */\nexport function getAllEntityWrappers(root: HTMLElement): HTMLElement[] {\n    return toArray(root.querySelectorAll('.' + ENTITY_INFO_NAME)) as HTMLElement[];\n}\n\n/**\n * Parse entity class names from entity wrapper element\n * @param className Class names of entity\n * @param format The output entity format object\n */\nexport function parseEntityClassName(\n    className: string,\n    format: ContentModelEntityFormat\n): boolean | undefined {\n    if (className == ENTITY_INFO_NAME) {\n        return true;\n    } else if (className.indexOf(ENTITY_TYPE_PREFIX) == 0) {\n        format.entityType = className.substring(ENTITY_TYPE_PREFIX.length);\n    } else if (className.indexOf(ENTITY_ID_PREFIX) == 0) {\n        format.id = className.substring(ENTITY_ID_PREFIX.length);\n    } else if (className.indexOf(ENTITY_READONLY_PREFIX) == 0) {\n        format.isReadonly = className.substring(ENTITY_READONLY_PREFIX.length) == '1';\n    }\n}\n\n/**\n * Generate Entity class names for an entity wrapper\n * @param format The source entity format object\n * @returns A combined CSS class name string for entity wrapper\n */\nexport function generateEntityClassNames(format: ContentModelEntityFormat): string {\n    return format.isFakeEntity\n        ? ''\n        : `${ENTITY_INFO_NAME} ${ENTITY_TYPE_PREFIX}${format.entityType ?? ''} ${\n              format.id ? `${ENTITY_ID_PREFIX}${format.id} ` : ''\n          }${ENTITY_READONLY_PREFIX}${format.isReadonly ? '1' : '0'}`;\n}\n\n/**\n * @internal\n */\nexport function isEntityDelimiter(element: HTMLElement): boolean {\n    return (\n        isElementOfType(element, 'span') &&\n        (element.classList.contains(DELIMITER_AFTER) ||\n            element.classList.contains(DELIMITER_BEFORE)) &&\n        element.textContent === ZERO_WIDTH_SPACE\n    );\n}\n\n/**\n * Adds delimiters to the element provided. If the delimiters already exists, will not be added\n * @param element the node to add the delimiters\n */\nexport function addDelimiters(doc: Document, element: HTMLElement): HTMLElement[] {\n    let [delimiterAfter, delimiterBefore] = getDelimiters(element);\n\n    if (!delimiterAfter) {\n        delimiterAfter = insertDelimiter(doc, element, true /*isAfter*/);\n    }\n\n    if (!delimiterBefore) {\n        delimiterBefore = insertDelimiter(doc, element, false /*isAfter*/);\n    }\n\n    return [delimiterAfter, delimiterBefore];\n}\n\nfunction getDelimiters(entityWrapper: HTMLElement): (HTMLElement | undefined)[] {\n    const result: (HTMLElement | undefined)[] = [];\n    const { nextElementSibling, previousElementSibling } = entityWrapper;\n    result.push(\n        isDelimiter(nextElementSibling, DELIMITER_AFTER),\n        isDelimiter(previousElementSibling, DELIMITER_BEFORE)\n    );\n\n    return result;\n}\n\nfunction isDelimiter(el: Element | null, className: string): HTMLElement | undefined {\n    return el?.classList.contains(className) && el.textContent == ZERO_WIDTH_SPACE\n        ? (el as HTMLElement)\n        : undefined;\n}\n\nfunction insertDelimiter(doc: Document, element: Element, isAfter: boolean) {\n    const span = doc.createElement('span');\n\n    span.className = isAfter ? DELIMITER_AFTER : DELIMITER_BEFORE;\n    span.appendChild(doc.createTextNode(ZERO_WIDTH_SPACE));\n    element.parentNode?.insertBefore(span, isAfter ? element.nextSibling : element);\n\n    return span;\n}\n\n/**\n * Allowed CSS selector for entity, used by HtmlSanitizer.\n * TODO: Revisit paste logic and check if we can remove HtmlSanitizer\n */\nexport const AllowedEntityClasses: ReadonlyArray<string> = [\n    '^' + ENTITY_INFO_NAME + '$',\n    '^' + ENTITY_ID_PREFIX,\n    '^' + ENTITY_TYPE_PREFIX,\n    '^' + ENTITY_READONLY_PREFIX,\n    '^' + DELIMITER_BEFORE + '$',\n    '^' + DELIMITER_AFTER + '$',\n];\n","/**\n * Provide a strong-typed version of Object.keys()\n * @param obj The source object\n * @returns Array of keys\n */\nexport function getObjectKeys<T extends string | number | symbol>(\n    obj: Record<T, any> | Partial<Record<T, any>>\n): T[] {\n    return Object.keys(obj) as T[];\n}\n","/**\n * Check if the given element is of the type that we are checking according to its tag name\n * @param element The element to check\n * @param tag The HTML tag name to check\n * @returns True if the element has the given tag, otherwise false\n */\nexport function isElementOfType<Tag extends keyof HTMLElementTagNameMap>(\n    element: HTMLElement,\n    tag: Tag\n): element is HTMLElementTagNameMap[Tag] {\n    return element?.tagName?.toLocaleLowerCase() == tag;\n}\n","/**\n * A type map from node type number to its type declaration. This is used by utility function isNodeOfType()\n */\nexport interface NodeTypeMap {\n    /**\n     * Attribute node\n     */\n    ATTRIBUTE_NODE: Attr;\n\n    /**\n     * Comment node\n     */\n    COMMENT_NODE: Comment;\n\n    /**\n     * DocumentFragment node\n     */\n    DOCUMENT_FRAGMENT_NODE: DocumentFragment;\n\n    /**\n     * Document node\n     */\n    DOCUMENT_NODE: Document;\n\n    /**\n     * DocumentType node\n     */\n    DOCUMENT_TYPE_NODE: DocumentType;\n\n    /**\n     * HTMLElement node\n     */\n    ELEMENT_NODE: HTMLElement;\n\n    /**\n     * ProcessingInstruction node\n     */\n    PROCESSING_INSTRUCTION_NODE: ProcessingInstruction;\n\n    /**\n     * Text node\n     */\n    TEXT_NODE: Text;\n}\n\n/**\n * Type checker for Node. Return true if it of the specified node type\n * @param node The node to check\n * @param expectedType The type to check\n */\nexport function isNodeOfType<T extends keyof NodeTypeMap>(\n    node: Node | null | undefined,\n    expectedType: T\n): node is NodeTypeMap[T] {\n    return !!node && node.nodeType == Node[expectedType];\n}\n","import { validate } from './validate';\nimport type { ContentModelWithDataset, Definition } from 'roosterjs-content-model-types';\n\nconst EditingInfoDatasetName = 'editingInfo';\n\n/**\n * Update metadata of the given model\n * @param model The model to update metadata to\n * @param callback A callback function to update metadata\n * @param definition @optional Metadata definition used for verify the metadata object\n * @returns The metadata object if any, or null\n */\nexport function updateMetadata<T>(\n    model: ContentModelWithDataset<T>,\n    callback?: (metadata: T | null) => T | null,\n    definition?: Definition<T>\n): T | null {\n    const metadataString = model.dataset[EditingInfoDatasetName];\n    let obj: T | null = null;\n\n    try {\n        obj = JSON.parse(metadataString) as T;\n    } catch {}\n\n    if (definition && !validate(obj, definition)) {\n        obj = null;\n    }\n\n    if (callback) {\n        obj = callback(obj);\n\n        if (!obj) {\n            delete model.dataset[EditingInfoDatasetName];\n        } else if (!definition || validate(obj, definition)) {\n            model.dataset[EditingInfoDatasetName] = JSON.stringify(obj);\n        }\n    }\n\n    return obj;\n}\n\n/**\n * Check if the given model has metadata\n * @param model The content model to check\n */\nexport function hasMetadata<T>(model: ContentModelWithDataset<T> | HTMLElement): boolean {\n    return !!model.dataset[EditingInfoDatasetName];\n}\n","import { getObjectKeys } from '../getObjectKeys';\nimport type { Definition } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Validate the given object with a type definition object\n * @param input The object to validate\n * @param def The type definition object used for validation\n * @returns True if the object passed the validation, otherwise false\n */\nexport function validate<T>(input: any, def: Definition<T>): input is T {\n    let result = false;\n    if ((def.isOptional && typeof input === 'undefined') || (def.allowNull && input === null)) {\n        result = true;\n    } else if (\n        (!def.isOptional && typeof input === 'undefined') ||\n        (!def.allowNull && input === null)\n    ) {\n        return false;\n    } else {\n        switch (def.type) {\n            case 'string':\n                result =\n                    typeof input === 'string' &&\n                    (typeof def.value === 'undefined' || input === def.value);\n                break;\n\n            case 'number':\n                result =\n                    typeof input === 'number' &&\n                    (typeof def.value === 'undefined' || areSameNumbers(def.value, input)) &&\n                    (typeof def.minValue === 'undefined' || input >= def.minValue) &&\n                    (typeof def.maxValue === 'undefined' || input <= def.maxValue);\n                break;\n\n            case 'boolean':\n                result =\n                    typeof input === 'boolean' &&\n                    (typeof def.value === 'undefined' || input === def.value);\n                break;\n\n            case 'array':\n                result =\n                    Array.isArray(input) &&\n                    (typeof def.minLength === 'undefined' || input.length >= def.minLength) &&\n                    (typeof def.maxLength === 'undefined' || input.length <= def.maxLength) &&\n                    input.every(x => validate(x, def.itemDef));\n                break;\n\n            case 'object':\n                result =\n                    typeof input === 'object' &&\n                    getObjectKeys(def.propertyDef).every(x =>\n                        validate(input[x], def.propertyDef[x])\n                    );\n                break;\n        }\n    }\n\n    return result;\n}\n\nfunction areSameNumbers(n1: number, n2: number) {\n    return Math.abs(n1 - n2) < 1e-3;\n}\n","/**\n * Replace all child nodes of the given target node to the child nodes of source node.\n * @param target Target node, all child nodes of this node will be removed if keepExistingChildren is not set to true\n * @param source (Optional) source node, all child nodes of this node will be move to target node\n * @param keepExistingChildren (Optional) When set to true, all existing child nodes of target will be kept\n */\nexport function moveChildNodes(target: Node, source?: Node, keepExistingChildren?: boolean) {\n    if (!target) {\n        return;\n    }\n\n    while (!keepExistingChildren && target.firstChild) {\n        target.removeChild(target.firstChild);\n    }\n\n    while (source?.firstChild) {\n        target.appendChild(source.firstChild);\n    }\n}\n\n/**\n * Wrap all child nodes of the given parent element using a new element with the given tag name\n * @param parent The parent element\n * @param tagName The tag name of new wrapper\n * @returns New wrapper element\n */\nexport function wrapAllChildNodes<T extends keyof HTMLElementTagNameMap>(\n    parent: HTMLElement,\n    tagName: T\n): HTMLElementTagNameMap[T] {\n    const newElement = parent.ownerDocument.createElement(tagName);\n\n    moveChildNodes(newElement, parent);\n    parent.appendChild(newElement);\n\n    return newElement;\n}\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: DataTransferItemList): DataTransferItem[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport default function toArray<T>(array: readonly T[]): T[];\n\nexport default function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","/**\n * @internal\n * Removes the node and keep all children in place, return the parentNode where the children are attached\n * @param node the node to remove\n */\nexport function unwrap(node: Node): Node | null {\n    // Unwrap requires a parentNode\n    const parentNode = node ? node.parentNode : null;\n\n    if (!parentNode) {\n        return null;\n    }\n\n    while (node.firstChild) {\n        parentNode.insertBefore(node.firstChild, node);\n    }\n\n    parentNode.removeChild(node);\n    return parentNode;\n}\n","/**\n * Wrap the given node with a new element, put the wrapper node under the parent of the first node\n * and return the wrapper element.\n * @param doc Parent document object\n * @param node The node to wrap\n * @param wrapperTag The tag of wrapper HTML element\n * @returns The wrapper element\n */\nexport function wrap<T extends keyof HTMLElementTagNameMap>(\n    doc: Document,\n    node: Node,\n    wrapperTag: T\n): HTMLElementTagNameMap[T] {\n    const wrapper = doc.createElement(wrapperTag);\n    node.parentNode?.insertBefore(wrapper, node);\n    wrapper.appendChild(node);\n\n    return wrapper;\n}\n","import type { DirectionFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const directionFormatHandler: FormatHandler<DirectionFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        const dir = element.style.direction || element.dir || defaultStyle.direction;\n\n        if (dir) {\n            format.direction = dir == 'rtl' ? 'rtl' : 'ltr';\n        }\n    },\n    apply: (format, element) => {\n        if (format.direction) {\n            element.style.direction = format.direction;\n        }\n    },\n};\n","import type { DisplayFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const displayFormatHandler: FormatHandler<DisplayFormat> = {\n    parse: (format, element) => {\n        const display = element.style.display;\n\n        if (display) {\n            format.display = display;\n        }\n    },\n    apply: (format, element) => {\n        if (format.display) {\n            element.style.display = format.display;\n        }\n    },\n};\n","import { calcAlign, ResultMap } from '../utils/dir';\nimport { directionFormatHandler } from './directionFormatHandler';\nimport type {\n    DirectionFormat,\n    HtmlAlignFormat,\n    TextAlignFormat,\n} from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const htmlAlignFormatHandler: FormatHandler<\n    DirectionFormat & HtmlAlignFormat & TextAlignFormat\n> = {\n    parse: (format, element, context, defaultStyle) => {\n        directionFormatHandler.parse(format, element, context, defaultStyle);\n\n        const htmlAlign = element.getAttribute('align');\n\n        if (htmlAlign) {\n            format.htmlAlign = calcAlign(htmlAlign, format.direction);\n            delete format.textAlign;\n            delete context.blockFormat.textAlign;\n        }\n    },\n    apply: (format, element) => {\n        const dir: 'ltr' | 'rtl' = format.direction == 'rtl' ? 'rtl' : 'ltr';\n\n        if (format.htmlAlign) {\n            element.setAttribute('align', ResultMap[format.htmlAlign][dir]);\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { LineHeightFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const lineHeightFormatHandler: FormatHandler<LineHeightFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const lineHeight = element.style.lineHeight || defaultStyle.lineHeight;\n\n        if (lineHeight && lineHeight != 'inherit') {\n            format.lineHeight = lineHeight;\n        }\n    },\n    apply: (format, element) => {\n        if (format.lineHeight) {\n            element.style.lineHeight = format.lineHeight;\n        }\n    },\n};\n","import { parseValueWithUnit } from '../utils/parseValueWithUnit';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { MarginFormat } from 'roosterjs-content-model-types';\n\nconst MarginKeys: (keyof MarginFormat & keyof CSSStyleDeclaration)[] = [\n    'marginTop',\n    'marginRight',\n    'marginBottom',\n    'marginLeft',\n];\n\n/**\n * @internal\n */\nexport const marginFormatHandler: FormatHandler<MarginFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        MarginKeys.forEach(key => {\n            const value = element.style[key] || defaultStyle[key];\n\n            if (value) {\n                switch (key) {\n                    case 'marginTop':\n                    case 'marginBottom':\n                        format[key] = value;\n                        break;\n\n                    case 'marginLeft':\n                    case 'marginRight':\n                        format[key] = format[key]\n                            ? parseValueWithUnit(format[key] || '', element) +\n                              parseValueWithUnit(value, element) +\n                              'px'\n                            : value;\n                        break;\n                }\n            }\n        });\n\n        const marginBlockStart = element.style.marginBlockStart || defaultStyle.marginBlockStart;\n        const marginTop = element.style.marginTop || defaultStyle.marginTop;\n        if (marginBlockStart && !marginTop) {\n            format.marginBlockStart = parseValueWithUnit(marginBlockStart) + 'px';\n        }\n\n        const marginBlockEnd = element.style.marginBlockEnd || defaultStyle.marginBlockEnd;\n        const marginBottom = element.style.marginBottom || defaultStyle.marginBottom;\n        if (marginBlockEnd && !marginBottom) {\n            format.marginBlockEnd = parseValueWithUnit(marginBlockEnd) + 'px';\n        }\n    },\n    apply: (format, element, context) => {\n        MarginKeys.forEach(key => {\n            const value = format[key];\n\n            if (value != context.implicitFormat[key]) {\n                element.style[key] = value || '0';\n            }\n        });\n\n        if (format.marginBlockStart && !format.marginTop) {\n            element.style.marginBlockStart = format.marginBlockStart;\n        }\n\n        if (format.marginBlockEnd && !format.marginBottom) {\n            element.style.marginBlockEnd = format.marginBlockEnd;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { PaddingFormat } from 'roosterjs-content-model-types';\n\nconst PaddingKeys: (keyof PaddingFormat & keyof CSSStyleDeclaration)[] = [\n    'paddingTop',\n    'paddingRight',\n    'paddingBottom',\n    'paddingLeft',\n];\n\n/**\n * @internal\n */\nexport const paddingFormatHandler: FormatHandler<PaddingFormat> = {\n    parse: (format, element) => {\n        PaddingKeys.forEach(key => {\n            const value = element.style[key];\n\n            if (value) {\n                format[key] = value;\n            }\n        });\n    },\n    apply: (format, element) => {\n        PaddingKeys.forEach(key => {\n            const value = format[key];\n            if (value) {\n                element.style[key] = value;\n            }\n        });\n    },\n};\n","import { calcAlign, ResultMap } from '../utils/dir';\nimport { directionFormatHandler } from './directionFormatHandler';\nimport type { DirectionFormat, TextAlignFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const textAlignFormatHandler: FormatHandler<DirectionFormat & TextAlignFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        directionFormatHandler.parse(format, element, context, defaultStyle);\n\n        let textAlign = element.style.textAlign || defaultStyle.textAlign;\n\n        if (\n            element.tagName == 'LI' &&\n            element.parentElement?.style.display === 'flex' &&\n            element.parentElement.style.flexDirection === 'column' &&\n            element.style.alignSelf\n        ) {\n            // For LI element with flex style applied, we use its \"align-self\" style value instead since LI has a different implementation for align\n            textAlign = element.style.alignSelf;\n        }\n\n        if (textAlign) {\n            format.textAlign = calcAlign(textAlign, format.direction);\n        }\n    },\n    apply: (format, element) => {\n        const dir: 'ltr' | 'rtl' = format.direction == 'rtl' ? 'rtl' : 'ltr';\n\n        if (format.textAlign) {\n            const parent = element.parentElement;\n            const parentTag = parent?.tagName;\n\n            if (element.tagName == 'LI' && parent && (parentTag == 'OL' || parentTag == 'UL')) {\n                element.style.alignSelf = format.textAlign;\n                element.parentElement.style.flexDirection = 'column';\n                element.parentElement.style.display = 'flex';\n            } else {\n                element.style.textAlign = ResultMap[format.textAlign][dir];\n            }\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { WhiteSpaceFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const whiteSpaceFormatHandler: FormatHandler<WhiteSpaceFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        const whiteSpace = element.style.whiteSpace || defaultStyle.whiteSpace;\n\n        if (whiteSpace) {\n            format.whiteSpace = whiteSpace;\n        }\n    },\n    apply: (format, element, context) => {\n        const whiteSpace = context.implicitFormat.whiteSpace;\n        if (format.whiteSpace != whiteSpace) {\n            element.style.whiteSpace = format.whiteSpace || 'normal';\n        }\n    },\n};\n","import { getColor, setColor } from '../utils/color';\nimport type { BackgroundColorFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const backgroundColorFormatHandler: FormatHandler<BackgroundColorFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const backgroundColor =\n            getColor(\n                element,\n                true /*isBackground*/,\n                context.darkColorHandler,\n                !!context.isDarkMode\n            ) || defaultStyle.backgroundColor;\n\n        if (backgroundColor) {\n            format.backgroundColor = backgroundColor;\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.backgroundColor) {\n            setColor(\n                element,\n                format.backgroundColor,\n                true /*isBackground*/,\n                context.darkColorHandler,\n                !!context.isDarkMode\n            );\n        }\n    },\n};\n","import type { BorderBoxFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const borderBoxFormatHandler: FormatHandler<BorderBoxFormat> = {\n    parse: (format, element) => {\n        if (element.style?.boxSizing == 'border-box') {\n            format.useBorderBox = true;\n        }\n    },\n    apply: (format, element) => {\n        if (format.useBorderBox) {\n            element.style.boxSizing = 'border-box';\n        }\n    },\n};\n","import type { BorderFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * Keys of border items\n */\nexport const BorderKeys: (keyof BorderFormat & keyof CSSStyleDeclaration)[] = [\n    'borderTop',\n    'borderRight',\n    'borderBottom',\n    'borderLeft',\n    'borderRadius',\n];\n\n/**\n * @internal\n */\nexport const borderFormatHandler: FormatHandler<BorderFormat> = {\n    parse: (format, element) => {\n        BorderKeys.forEach(key => {\n            const value = element.style[key];\n\n            if (value) {\n                format[key] = value == 'none' ? '' : value;\n            }\n        });\n    },\n    apply: (format, element) => {\n        BorderKeys.forEach(key => {\n            const value = format[key];\n\n            if (value) {\n                element.style[key] = value;\n            }\n        });\n    },\n};\n","import type { BoxShadowFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const boxShadowFormatHandler: FormatHandler<BoxShadowFormat> = {\n    parse: (format, element) => {\n        if (element.style?.boxShadow) {\n            format.boxShadow = element.style.boxShadow;\n        }\n    },\n    apply: (format, element) => {\n        if (format.boxShadow) {\n            element.style.boxShadow = format.boxShadow;\n        }\n    },\n};\n","import { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport type { DatasetFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const datasetFormatHandler: FormatHandler<DatasetFormat> = {\n    parse: (format, element) => {\n        const dataset = element.dataset;\n\n        getObjectKeys(dataset).forEach(key => {\n            format[key] = dataset[key] || '';\n        });\n    },\n\n    apply: (format, element) => {\n        getObjectKeys(format).forEach(key => {\n            element.dataset[key] = format[key];\n        });\n    },\n};\n","import type { FloatFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const floatFormatHandler: FormatHandler<FloatFormat> = {\n    parse: (format, element) => {\n        const float = element.style.float || element.getAttribute('align');\n\n        if (float) {\n            format.float = float;\n        }\n    },\n    apply: (format, element) => {\n        if (format.float) {\n            element.style.float = format.float;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { IdFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const idFormatHandler: FormatHandler<IdFormat> = {\n    parse: (format, element) => {\n        if (element.id) {\n            format.id = element.id;\n        }\n    },\n    apply: (format, element) => {\n        if (format.id) {\n            element.id = format.id;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { SizeFormat } from 'roosterjs-content-model-types';\n\nconst PercentageRegex = /[\\d\\.]+%/;\n\n/**\n * @internal\n */\nexport const sizeFormatHandler: FormatHandler<SizeFormat> = {\n    parse: (format, element, context) => {\n        const width = element.style.width || tryParseSize(element, 'width');\n        const height = element.style.height || tryParseSize(element, 'height');\n        const maxWidth = element.style.maxWidth;\n        const maxHeight = element.style.maxHeight;\n        const minWidth = element.style.minWidth;\n        const minHeight = element.style.minHeight;\n\n        if (width) {\n            format.width = width;\n        }\n        if (height) {\n            format.height = height;\n        }\n        if (maxWidth) {\n            format.maxWidth = maxWidth;\n        }\n        if (maxHeight) {\n            format.maxHeight = maxHeight;\n        }\n        if (minWidth) {\n            format.minWidth = minWidth;\n        }\n        if (minHeight) {\n            format.minHeight = minHeight;\n        }\n    },\n    apply: (format, element) => {\n        if (format.width) {\n            element.style.width = format.width;\n        }\n        if (format.height) {\n            element.style.height = format.height;\n        }\n        if (format.maxWidth) {\n            element.style.maxWidth = format.maxWidth;\n        }\n        if (format.maxHeight) {\n            element.style.maxHeight = format.maxHeight;\n        }\n        if (format.minWidth) {\n            element.style.minWidth = format.minWidth;\n        }\n        if (format.minHeight) {\n            element.style.minHeight = format.minHeight;\n        }\n    },\n};\n\nfunction tryParseSize(element: HTMLElement, attrName: 'width' | 'height'): string | undefined {\n    const attrValue = element.getAttribute(attrName);\n    const value = parseInt(attrValue || '');\n\n    return attrValue && PercentageRegex.test(attrValue)\n        ? attrValue\n        : Number.isNaN(value)\n        ? undefined\n        : value + 'px';\n}\n","import type { FormatHandler } from '../FormatHandler';\nimport type { VerticalAlignFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const verticalAlignFormatHandler: FormatHandler<VerticalAlignFormat> = {\n    parse: (format, element) => {\n        const align = element.style.verticalAlign || element.getAttribute('valign');\n\n        switch (align) {\n            case 'baseline':\n            case 'initial':\n            case 'super':\n            case 'sub':\n            case 'text-top':\n            case 'text-bottom':\n            case 'top':\n                format.verticalAlign = 'top';\n                break;\n\n            case 'bottom':\n                format.verticalAlign = 'bottom';\n                break;\n\n            case 'middle':\n                format.verticalAlign = 'middle';\n                break;\n        }\n    },\n    apply: (format, element) => {\n        if (format.verticalAlign) {\n            element.style.verticalAlign = format.verticalAlign;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { WordBreakFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const wordBreakFormatHandler: FormatHandler<WordBreakFormat> = {\n    parse: (format, element, _, defaultStyle) => {\n        const wordBreak = element.style.wordBreak || defaultStyle.wordBreak;\n\n        if (wordBreak) {\n            format.wordBreak = wordBreak;\n        }\n    },\n    apply: (format, element) => {\n        if (format.wordBreak) {\n            element.style.wordBreak = format.wordBreak;\n        }\n    },\n};\n","import { backgroundColorFormatHandler } from './common/backgroundColorFormatHandler';\nimport { boldFormatHandler } from './segment/boldFormatHandler';\nimport { borderBoxFormatHandler } from './common/borderBoxFormatHandler';\nimport { borderFormatHandler } from './common/borderFormatHandler';\nimport { boxShadowFormatHandler } from './common/boxShadowFormatHandler';\nimport { datasetFormatHandler } from './common/datasetFormatHandler';\nimport { directionFormatHandler } from './block/directionFormatHandler';\nimport { displayFormatHandler } from './block/displayFormatHandler';\nimport { entityFormatHandler } from './entity/entityFormatHandler';\nimport { floatFormatHandler } from './common/floatFormatHandler';\nimport { fontFamilyFormatHandler } from './segment/fontFamilyFormatHandler';\nimport { fontSizeFormatHandler } from './segment/fontSizeFormatHandler';\nimport { getObjectKeys } from '../domUtils/getObjectKeys';\nimport { htmlAlignFormatHandler } from './block/htmlAlignFormatHandler';\nimport { idFormatHandler } from './common/idFormatHandler';\nimport { italicFormatHandler } from './segment/italicFormatHandler';\nimport { letterSpacingFormatHandler } from './segment/letterSpacingFormatHandler';\nimport { lineHeightFormatHandler } from './block/lineHeightFormatHandler';\nimport { linkFormatHandler } from './segment/linkFormatHandler';\nimport { listItemThreadFormatHandler } from './list/listItemThreadFormatHandler';\nimport { listLevelThreadFormatHandler } from './list/listLevelThreadFormatHandler';\nimport { listStyleFormatHandler } from './list/listStyleFormatHandler';\nimport { marginFormatHandler } from './block/marginFormatHandler';\nimport { paddingFormatHandler } from './block/paddingFormatHandler';\nimport { sizeFormatHandler } from './common/sizeFormatHandler';\nimport { strikeFormatHandler } from './segment/strikeFormatHandler';\nimport { superOrSubScriptFormatHandler } from './segment/superOrSubScriptFormatHandler';\nimport { tableLayoutFormatHandler } from './table/tableLayoutFormatHandler';\nimport { tableSpacingFormatHandler } from './table/tableSpacingFormatHandler';\nimport { textAlignFormatHandler } from './block/textAlignFormatHandler';\nimport { textColorFormatHandler } from './segment/textColorFormatHandler';\nimport { textColorOnTableCellFormatHandler } from './table/textColorOnTableCellFormatHandler';\nimport { underlineFormatHandler } from './segment/underlineFormatHandler';\nimport { verticalAlignFormatHandler } from './common/verticalAlignFormatHandler';\nimport { whiteSpaceFormatHandler } from './block/whiteSpaceFormatHandler';\nimport { wordBreakFormatHandler } from './common/wordBreakFormatHandler';\nimport type { FormatHandler } from './FormatHandler';\nimport type {\n    ContentModelFormatMap,\n    FormatApplier,\n    FormatAppliers,\n    FormatHandlerTypeMap,\n    FormatKey,\n    FormatParser,\n    FormatParsers,\n} from 'roosterjs-content-model-types';\n\ntype FormatHandlers = {\n    [Key in FormatKey]: FormatHandler<FormatHandlerTypeMap[Key]>;\n};\n\nconst defaultFormatHandlerMap: FormatHandlers = {\n    backgroundColor: backgroundColorFormatHandler,\n    bold: boldFormatHandler,\n    border: borderFormatHandler,\n    borderBox: borderBoxFormatHandler,\n    boxShadow: boxShadowFormatHandler,\n    dataset: datasetFormatHandler,\n    direction: directionFormatHandler,\n    display: displayFormatHandler,\n    float: floatFormatHandler,\n    fontFamily: fontFamilyFormatHandler,\n    fontSize: fontSizeFormatHandler,\n    entity: entityFormatHandler,\n    htmlAlign: htmlAlignFormatHandler,\n    id: idFormatHandler,\n    italic: italicFormatHandler,\n    letterSpacing: letterSpacingFormatHandler,\n    lineHeight: lineHeightFormatHandler,\n    link: linkFormatHandler,\n    listItemThread: listItemThreadFormatHandler,\n    listLevelThread: listLevelThreadFormatHandler,\n    listStyle: listStyleFormatHandler,\n    margin: marginFormatHandler,\n    padding: paddingFormatHandler,\n    size: sizeFormatHandler,\n    strike: strikeFormatHandler,\n    superOrSubScript: superOrSubScriptFormatHandler,\n    tableLayout: tableLayoutFormatHandler,\n    tableSpacing: tableSpacingFormatHandler,\n    textAlign: textAlignFormatHandler,\n    textColor: textColorFormatHandler,\n    textColorOnTableCell: textColorOnTableCellFormatHandler,\n    underline: underlineFormatHandler,\n    verticalAlign: verticalAlignFormatHandler,\n    whiteSpace: whiteSpaceFormatHandler,\n    wordBreak: wordBreakFormatHandler,\n};\n\nconst styleBasedSegmentFormats: (keyof FormatHandlerTypeMap)[] = [\n    'letterSpacing',\n    'fontFamily',\n    'fontSize',\n];\n\nconst elementBasedSegmentFormats: (keyof FormatHandlerTypeMap)[] = [\n    'strike',\n    'underline',\n    'superOrSubScript',\n    'italic',\n    'bold',\n];\nconst sharedBlockFormats: (keyof FormatHandlerTypeMap)[] = [\n    'direction',\n    'textAlign',\n    'lineHeight',\n    'whiteSpace',\n];\nconst sharedContainerFormats: (keyof FormatHandlerTypeMap)[] = [\n    'backgroundColor',\n    'margin',\n    'padding',\n    'border',\n];\n\n/**\n * @internal\n */\nexport const defaultFormatKeysPerCategory: {\n    [key in keyof ContentModelFormatMap]: (keyof FormatHandlerTypeMap)[];\n} = {\n    block: sharedBlockFormats,\n    listItemThread: ['listItemThread'],\n    listLevelThread: ['listLevelThread'],\n    listItemElement: [\n        ...sharedBlockFormats,\n        'direction',\n        'textAlign',\n        'lineHeight',\n        'margin',\n        'listStyle',\n    ],\n    listLevel: ['direction', 'textAlign', 'margin', 'padding', 'listStyle', 'backgroundColor'],\n    styleBasedSegment: [...styleBasedSegmentFormats, 'textColor', 'backgroundColor', 'lineHeight'],\n    elementBasedSegment: elementBasedSegmentFormats,\n    segment: [\n        ...styleBasedSegmentFormats,\n        ...elementBasedSegmentFormats,\n        'textColor',\n        'backgroundColor',\n        'lineHeight',\n    ],\n    segmentOnBlock: [...styleBasedSegmentFormats, ...elementBasedSegmentFormats, 'textColor'],\n    segmentOnTableCell: [\n        ...styleBasedSegmentFormats,\n        ...elementBasedSegmentFormats,\n        'textColorOnTableCell',\n    ],\n    tableCell: [\n        'border',\n        'backgroundColor',\n        'padding',\n        'verticalAlign',\n        'wordBreak',\n        'textColor',\n        'htmlAlign',\n        'size',\n    ],\n    tableRow: ['backgroundColor'],\n    table: [\n        'id',\n        'border',\n        'backgroundColor',\n        'display',\n        'htmlAlign',\n        'margin',\n        'size',\n        'tableLayout',\n    ],\n    tableBorder: ['borderBox', 'tableSpacing'],\n    tableCellBorder: ['borderBox'],\n    image: [\n        'id',\n        'size',\n        'margin',\n        'padding',\n        'borderBox',\n        'border',\n        'boxShadow',\n        'display',\n        'float',\n        'verticalAlign',\n    ],\n    link: [\n        'link',\n        'textColor',\n        'underline',\n        'display',\n        'margin',\n        'padding',\n        'backgroundColor',\n        'border',\n        'size',\n        'textAlign',\n    ],\n    segmentUnderLink: ['textColor'],\n    code: ['fontFamily', 'display'],\n    dataset: ['dataset'],\n    divider: [...sharedBlockFormats, ...sharedContainerFormats, 'display', 'size', 'htmlAlign'],\n    container: [...sharedContainerFormats, 'htmlAlign', 'size', 'display'],\n    entity: ['entity'],\n};\n\n/**\n * @internal\n */\nexport const defaultFormatParsers: FormatParsers = getObjectKeys(defaultFormatHandlerMap).reduce(\n    (result, key) => {\n        result[key] = defaultFormatHandlerMap[key].parse as FormatParser<any>;\n        return result;\n    },\n    <FormatParsers>{}\n);\n\n/**\n * @internal\n */\nexport const defaultFormatAppliers: FormatAppliers = getObjectKeys(defaultFormatHandlerMap).reduce(\n    (result, key) => {\n        result[key] = defaultFormatHandlerMap[key].apply as FormatApplier<any>;\n        return result;\n    },\n    <FormatAppliers>{}\n);\n","import { generateEntityClassNames, parseEntityClassName } from '../../domUtils/entityUtils';\nimport type { EntityInfoFormat, IdFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const entityFormatHandler: FormatHandler<EntityInfoFormat & IdFormat> = {\n    parse: (format, element) => {\n        let isEntity = false;\n\n        element.classList.forEach(name => {\n            isEntity = parseEntityClassName(name, format) || isEntity;\n        });\n\n        if (!isEntity) {\n            format.isFakeEntity = true;\n            format.isReadonly = !element.isContentEditable;\n        }\n    },\n\n    apply: (format, element) => {\n        if (!format.isFakeEntity) {\n            element.className = generateEntityClassNames(format);\n        }\n\n        if (format.isReadonly) {\n            element.contentEditable = 'false';\n        } else {\n            element.removeAttribute('contenteditable');\n        }\n    },\n};\n","import { isElementOfType } from '../../domUtils/isElementOfType';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { ListThreadFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listItemThreadFormatHandler: FormatHandler<ListThreadFormat> = {\n    parse: (format, element, context, defaultStyles) => {\n        const { listFormat } = context;\n        const depth = listFormat.levels.length;\n        const display = element.style.display || defaultStyles.display;\n\n        if (display && display != 'list-item') {\n            format.displayForDummyItem = display;\n        } else if (isLiUnderOl(element) && depth > 0) {\n            listFormat.threadItemCounts[depth - 1]++;\n            listFormat.threadItemCounts.splice(depth);\n            listFormat.levels.forEach(level => {\n                // Delete restart number so next list item doesn't need to have this value.\n                // Then it will be treated as a continuous list item to the previous one\n                delete level.format.startNumberOverride;\n            });\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.displayForDummyItem) {\n            element.style.display = format.displayForDummyItem;\n        } else if (isLiUnderOl(element)) {\n            const { listFormat } = context;\n            const { threadItemCounts } = listFormat;\n            const index = listFormat.nodeStack.length - 2; // The first one is always the parent of list, then minus another 1 to convert length to index\n\n            if (index >= 0) {\n                threadItemCounts.splice(index + 1);\n                threadItemCounts[index] = (threadItemCounts[index] ?? 0) + 1;\n            }\n        }\n    },\n};\n\nfunction isLiUnderOl(element: HTMLElement) {\n    return (\n        isElementOfType(element, 'li') &&\n        isNodeOfType(element.parentNode, 'ELEMENT_NODE') &&\n        isElementOfType(element.parentNode, 'ol')\n    );\n}\n","import { isElementOfType } from '../../domUtils/isElementOfType';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { ListThreadFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listLevelThreadFormatHandler: FormatHandler<ListThreadFormat> = {\n    parse: (format, element, context) => {\n        if (isElementOfType(element, 'ol')) {\n            const { listFormat } = context;\n            const { threadItemCounts, levels } = listFormat;\n            const depth = levels.length;\n\n            if (\n                typeof threadItemCounts[depth] === 'number' &&\n                element.start != threadItemCounts[depth] + 1\n            ) {\n                format.startNumberOverride = element.start;\n            }\n\n            threadItemCounts[depth] = element.start - 1;\n        }\n    },\n    apply: (format, element, context) => {\n        const {\n            listFormat: { threadItemCounts, nodeStack },\n        } = context;\n\n        // The first one is always the parent of list, and minus another one to convert length to index\n        // This format applier needs to be executed after new list level is pushed into node stack\n        const depth = nodeStack.length - 2;\n\n        if (depth >= 0 && isElementOfType(element, 'ol')) {\n            const startNumber = format.startNumberOverride;\n\n            if (typeof startNumber === 'number') {\n                threadItemCounts[depth] = startNumber - 1;\n            } else if (typeof threadItemCounts[depth] != 'number') {\n                threadItemCounts[depth] = 0;\n            }\n\n            threadItemCounts.splice(depth + 1);\n            element.start = threadItemCounts[depth] + 1;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { ListStyleFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const listStyleFormatHandler: FormatHandler<ListStyleFormat> = {\n    parse: (format, element) => {\n        const listStylePosition = element.style.listStylePosition;\n        const listStyleType = element.style.listStyleType;\n\n        if (listStylePosition) {\n            format.listStylePosition = listStylePosition;\n        }\n\n        if (listStyleType) {\n            format.listStyleType = listStyleType;\n        }\n    },\n    apply: (format, element) => {\n        if (format.listStylePosition) {\n            element.style.listStylePosition = format.listStylePosition;\n        }\n\n        if (format.listStyleType) {\n            element.style.listStyleType = format.listStyleType;\n        }\n    },\n};\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { BoldFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const boldFormatHandler: FormatHandler<BoldFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const fontWeight = element.style.fontWeight || defaultStyle.fontWeight;\n\n        if (fontWeight) {\n            format.fontWeight = fontWeight;\n        }\n    },\n    apply: (format, element, context) => {\n        if (typeof format.fontWeight === 'undefined') {\n            return;\n        }\n\n        const blockFontWeight = context.implicitFormat.fontWeight;\n\n        if (\n            (blockFontWeight && blockFontWeight != format.fontWeight) ||\n            (!blockFontWeight && format.fontWeight && format.fontWeight != 'normal')\n        ) {\n            if (format.fontWeight == 'bold') {\n                wrapAllChildNodes(element, 'b');\n            } else {\n                element.style.fontWeight = format.fontWeight || 'normal';\n            }\n        }\n    },\n};\n","import type { FontFamilyFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const fontFamilyFormatHandler: FormatHandler<FontFamilyFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const fontFamily = element.style.fontFamily || defaultStyle.fontFamily;\n\n        if (fontFamily && fontFamily != 'inherit') {\n            format.fontFamily = fontFamily;\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.fontFamily && format.fontFamily != context.implicitFormat.fontFamily) {\n            element.style.fontFamily = format.fontFamily;\n        }\n    },\n};\n","import { isSuperOrSubScript } from './superOrSubScriptFormatHandler';\nimport { parseValueWithUnit } from '../utils/parseValueWithUnit';\nimport type { FontSizeFormat } from 'roosterjs-content-model-types';\nimport type { FormatHandler } from '../FormatHandler';\n\n/**\n * @internal\n */\nexport const fontSizeFormatHandler: FormatHandler<FontSizeFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const fontSize = element.style.fontSize || defaultStyle.fontSize;\n        const verticalAlign = element.style.verticalAlign || defaultStyle.verticalAlign;\n\n        // when font size is 'smaller' and the style is for superscript/subscript,\n        // the font size will be handled by superOrSubScript handler\n        if (fontSize && !isSuperOrSubScript(fontSize, verticalAlign) && fontSize != 'inherit') {\n            if (element.style.fontSize) {\n                format.fontSize = normalizeFontSize(fontSize, context.segmentFormat.fontSize);\n            } else if (defaultStyle.fontSize) {\n                format.fontSize = fontSize;\n            }\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.fontSize && format.fontSize != context.implicitFormat.fontSize) {\n            element.style.fontSize = format.fontSize;\n        }\n    },\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\nconst KnownFontSizes: Record<string, string> = {\n    'xx-small': '6.75pt',\n    'x-small': '7.5pt',\n    small: '9.75pt',\n    medium: '12pt',\n    large: '13.5pt',\n    'x-large': '18pt',\n    'xx-large': '24pt',\n    'xxx-large': '36pt',\n};\n\nfunction normalizeFontSize(fontSize: string, contextFont: string | undefined): string | undefined {\n    const knownFontSize = KnownFontSizes[fontSize];\n\n    if (knownFontSize) {\n        return knownFontSize;\n    } else if (\n        fontSize == 'smaller' ||\n        fontSize == 'larger' ||\n        fontSize.endsWith('em') ||\n        fontSize.endsWith('%')\n    ) {\n        if (!contextFont) {\n            return undefined;\n        } else {\n            const existingFontSize = parseValueWithUnit(contextFont, undefined /*element*/, 'px');\n\n            if (existingFontSize) {\n                switch (fontSize) {\n                    case 'smaller':\n                        return Math.round((existingFontSize * 500) / 6) / 100 + 'px';\n                    case 'larger':\n                        return Math.round((existingFontSize * 600) / 5) / 100 + 'px';\n                    default:\n                        return parseValueWithUnit(fontSize, existingFontSize, 'px') + 'px';\n                }\n            }\n        }\n    } else if (fontSize == 'inherit' || fontSize == 'revert' || fontSize == 'unset') {\n        return undefined;\n    } else {\n        return fontSize;\n    }\n}\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { ItalicFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const italicFormatHandler: FormatHandler<ItalicFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const fontStyle = element.style.fontStyle || defaultStyle.fontStyle;\n\n        if (fontStyle == 'italic' || fontStyle == 'oblique') {\n            format.italic = true;\n        } else if (fontStyle == 'initial' || fontStyle == 'normal') {\n            format.italic = false;\n        }\n    },\n    apply: (format, element, context) => {\n        if (typeof format.italic === 'undefined') {\n            return;\n        }\n\n        const implicitItalic = context.implicitFormat.italic;\n\n        if (!!implicitItalic != !!format.italic) {\n            if (format.italic) {\n                wrapAllChildNodes(element, 'i');\n            } else {\n                element.style.fontStyle = 'normal';\n            }\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { LetterSpacingFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const letterSpacingFormatHandler: FormatHandler<LetterSpacingFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const letterSpacing = element.style.letterSpacing || defaultStyle.letterSpacing;\n\n        if (letterSpacing) {\n            format.letterSpacing = letterSpacing;\n        }\n    },\n    apply: (format, element, context) => {\n        if (format.letterSpacing) {\n            element.style.letterSpacing = format.letterSpacing;\n        }\n    },\n};\n","import { isElementOfType } from '../../domUtils/isElementOfType';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { LinkFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const linkFormatHandler: FormatHandler<LinkFormat> = {\n    parse: (format, element) => {\n        if (isElementOfType(element, 'a')) {\n            const name = element.name;\n            const href = element.getAttribute('href'); // Use getAttribute to get original HREF but not the resolved absolute url\n            const target = element.target;\n            const rel = element.rel;\n            const id = element.id;\n            const className = element.className;\n            const title = element.title;\n\n            if (name) {\n                format.name = name;\n            }\n\n            if (href) {\n                format.href = href;\n            }\n\n            if (target) {\n                format.target = target;\n            }\n\n            if (id) {\n                format.anchorId = id;\n            }\n\n            if (rel) {\n                format.relationship = rel;\n            }\n\n            if (title) {\n                format.anchorTitle = title;\n            }\n\n            if (className) {\n                format.anchorClass = className;\n            }\n        }\n    },\n    apply: (format, element) => {\n        if (isElementOfType(element, 'a') && format.href) {\n            element.href = format.href;\n\n            if (format.name) {\n                element.name = format.name;\n            }\n\n            if (format.target) {\n                element.target = format.target;\n            }\n\n            if (format.anchorId) {\n                element.id = format.anchorId;\n            }\n\n            if (format.anchorClass) {\n                element.className = format.anchorClass;\n            }\n\n            if (format.anchorTitle) {\n                element.title = format.anchorTitle;\n            }\n\n            if (format.relationship) {\n                element.rel = format.relationship;\n            }\n        }\n    },\n};\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { StrikeFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const strikeFormatHandler: FormatHandler<StrikeFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const textDecoration = element.style.textDecoration || defaultStyle.textDecoration;\n\n        if (textDecoration?.indexOf('line-through')! >= 0) {\n            format.strikethrough = true;\n        }\n    },\n    apply: (format, element) => {\n        if (format.strikethrough) {\n            wrapAllChildNodes(element, 's');\n        }\n    },\n};\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { SuperOrSubScriptFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const superOrSubScriptFormatHandler: FormatHandler<SuperOrSubScriptFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const verticalAlign = element.style.verticalAlign || defaultStyle.verticalAlign;\n        const fontSize = element.style.fontSize || defaultStyle.fontSize;\n\n        if (isSuperOrSubScript(fontSize, verticalAlign)) {\n            format.superOrSubScriptSequence = (format.superOrSubScriptSequence || '')\n                .split(' ')\n                .concat(verticalAlign)\n                .join(' ')\n                .trim();\n        }\n    },\n    apply: (format, element) => {\n        if (format.superOrSubScriptSequence) {\n            format.superOrSubScriptSequence\n                .split(' ')\n                .reverse()\n                .forEach(value => {\n                    const tagName = value == 'super' ? 'sup' : value == 'sub' ? 'sub' : null;\n\n                    if (tagName) {\n                        wrapAllChildNodes(element, tagName);\n                    }\n                });\n        }\n    },\n};\n\n/**\n * @internal\n */\nexport function isSuperOrSubScript(\n    fontSize: string | undefined,\n    verticalAlign: string | undefined\n): verticalAlign is 'sub' | 'super' {\n    return fontSize == 'smaller' && (verticalAlign == 'sub' || verticalAlign == 'super');\n}\n","import { getColor, setColor } from '../utils/color';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { TextColorFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const textColorFormatHandler: FormatHandler<TextColorFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const textColor =\n            getColor(\n                element,\n                false /*isBackground*/,\n                context.darkColorHandler,\n                !!context.isDarkMode\n            ) || defaultStyle.color;\n\n        if (textColor && textColor != 'inherit') {\n            format.textColor = textColor;\n        }\n    },\n    apply: (format, element, context) => {\n        const implicitColor = context.implicitFormat.textColor;\n\n        if (format.textColor && format.textColor != implicitColor) {\n            setColor(\n                element,\n                format.textColor,\n                false /*isBackground*/,\n                context.darkColorHandler,\n                !!context.isDarkMode\n            );\n        }\n    },\n};\n","import { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type { FormatHandler } from '../FormatHandler';\nimport type { UnderlineFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const underlineFormatHandler: FormatHandler<UnderlineFormat> = {\n    parse: (format, element, context, defaultStyle) => {\n        const textDecoration = element.style.textDecoration || defaultStyle.textDecoration;\n\n        if (textDecoration?.indexOf('underline')! >= 0) {\n            format.underline = true;\n        } else if (element.tagName == 'A' && textDecoration == 'none') {\n            format.underline = false;\n        }\n    },\n    apply: (format, element, context) => {\n        if (typeof format.underline === 'undefined') {\n            return;\n        }\n\n        const blockUnderline = context.implicitFormat.underline;\n\n        if (!!blockUnderline != !!format.underline) {\n            if (format.underline) {\n                wrapAllChildNodes(element, 'u');\n            } else {\n                element.style.textDecoration = 'none';\n            }\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { TableLayoutFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const tableLayoutFormatHandler: FormatHandler<TableLayoutFormat> = {\n    parse: (format, element) => {\n        const tableLayout = element.style.tableLayout;\n        if (tableLayout && tableLayout != 'inherit') {\n            format.tableLayout = tableLayout;\n        }\n    },\n    apply: (format, element) => {\n        if (format.tableLayout) {\n            element.style.tableLayout = format.tableLayout;\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { SpacingFormat } from 'roosterjs-content-model-types';\n\nconst BorderCollapsed = 'collapse';\n\n/**\n * @internal\n */\nexport const tableSpacingFormatHandler: FormatHandler<SpacingFormat> = {\n    parse: (format, element) => {\n        if (element.style.borderCollapse == BorderCollapsed) {\n            format.borderCollapse = true;\n        }\n    },\n    apply: (format, element) => {\n        if (format.borderCollapse) {\n            element.style.borderCollapse = BorderCollapsed;\n            element.style.borderSpacing = '0';\n            element.style.boxSizing = 'border-box';\n        }\n    },\n};\n","import type { FormatHandler } from '../FormatHandler';\nimport type { TextColorFormat } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const textColorOnTableCellFormatHandler: FormatHandler<TextColorFormat> = {\n    parse: (format, element) => {\n        if (element.style.color) {\n            // Delete color from format since text color on TD/TH will be handled by separate code\n            // and text color on segment format context need to be reset so that it will not inherit\n            // value outer container\n            delete format.textColor;\n        }\n    },\n    apply: () => {},\n};\n","import type { ColorManager } from 'roosterjs-content-model-types';\n\n/**\n * List of deprecated colors\n */\nexport const DeprecatedColors: string[] = [\n    'inactiveborder',\n    'activeborder',\n    'inactivecaptiontext',\n    'inactivecaption',\n    'activecaption',\n    'appworkspace',\n    'infobackground',\n    'background',\n    'buttonhighlight',\n    'buttonshadow',\n    'captiontext',\n    'infotext',\n    'menutext',\n    'menu',\n    'scrollbar',\n    'threeddarkshadow',\n    'threedface',\n    'threedhighlight',\n    'threedlightshadow',\n    'threedfhadow',\n    'windowtext',\n    'windowframe',\n    'window',\n];\n\n/**\n * Get color from given HTML element\n * @param element The element to get color from\n * @param isBackground True to get background color, false to get text color\n * @param darkColorHandler The dark color handler object to help manager dark mode color\n * @param isDarkMode Whether element is in dark mode now\n */\nexport function getColor(\n    element: HTMLElement,\n    isBackground: boolean,\n    darkColorHandler: ColorManager | undefined,\n    isDarkMode: boolean\n): string | undefined {\n    let color =\n        (isBackground ? element.style.backgroundColor : element.style.color) ||\n        element.getAttribute(isBackground ? 'bgcolor' : 'color') ||\n        undefined;\n\n    if (color && DeprecatedColors.indexOf(color) > -1) {\n        color = undefined;\n    }\n\n    if (darkColorHandler) {\n        color = darkColorHandler.parseColorValue(color, isDarkMode).lightModeColor;\n    }\n\n    return color;\n}\n\n/**\n * Set color to given HTML element\n * @param element The element to set color to\n * @param lightModeColor The color to set, always pass in color in light mode\n * @param isBackground True to set background color, false to set text color\n * @param darkColorHandler The dark color handler object to help manager dark mode color\n * @param isDarkMode Whether element is in dark mode now\n */\nexport function setColor(\n    element: HTMLElement,\n    lightModeColor: string,\n    isBackground: boolean,\n    darkColorHandler: ColorManager | undefined,\n    isDarkMode: boolean\n) {\n    const effectiveColor = darkColorHandler\n        ? darkColorHandler.registerColor(lightModeColor, isDarkMode)\n        : lightModeColor;\n\n    if (isBackground) {\n        element.style.backgroundColor = effectiveColor;\n    } else {\n        element.style.color = effectiveColor;\n    }\n}\n","/**\n * @internal\n */\nexport const ResultMap = {\n    start: {\n        ltr: 'left',\n        rtl: 'right',\n    },\n    center: {\n        ltr: 'center',\n        rtl: 'center',\n    },\n    end: {\n        ltr: 'right',\n        rtl: 'left',\n    },\n    initial: {\n        ltr: 'initial',\n        rtl: 'initial',\n    },\n    justify: {\n        ltr: 'justify',\n        rtl: 'justify',\n    },\n};\n\n/**\n * @internal\n */\nexport function calcAlign(align: string, dir?: 'ltr' | 'rtl') {\n    switch (align) {\n        case 'center':\n            return 'center';\n\n        case 'left':\n            return dir == 'rtl' ? 'end' : 'start';\n\n        case 'right':\n            return dir == 'rtl' ? 'start' : 'end';\n\n        case 'start':\n        case 'end':\n            return align;\n\n        case 'justify':\n        case 'initial':\n            return align;\n\n        default:\n            return undefined;\n    }\n}\n","const MarginValueRegex = /(-?\\d+(\\.\\d+)?)([a-z]+|%)/;\n\n/**\n * Parse unit value with its unit\n * @param value The source value to parse\n * @param currentSizePxOrElement The source element which has this unit value, or current font size (in px) from context.\n * @param resultUnit Unit for result, can be px or pt. @default px\n */\nexport function parseValueWithUnit(\n    value: string = '',\n    currentSizePxOrElement?: number | HTMLElement,\n    resultUnit: 'px' | 'pt' = 'px'\n): number {\n    const match = MarginValueRegex.exec(value);\n    let result = 0;\n\n    if (match) {\n        const [_, numStr, __, unit] = match;\n        const num = parseFloat(numStr);\n\n        switch (unit) {\n            case 'px':\n                result = num;\n                break;\n            case 'pt':\n                result = ptToPx(num);\n                break;\n            case 'em':\n                result = getFontSize(currentSizePxOrElement) * num;\n                break;\n            case 'ex':\n                result = (getFontSize(currentSizePxOrElement) * num) / 2;\n                break;\n            case '%':\n                result = (getFontSize(currentSizePxOrElement) * num) / 100;\n                break;\n            default:\n                // TODO: Support more unit if need\n                break;\n        }\n    }\n\n    if (result > 0 && resultUnit == 'pt') {\n        result = pxToPt(result);\n    }\n\n    return result;\n}\n\nfunction getFontSize(currentSizeOrElement?: number | HTMLElement): number {\n    if (typeof currentSizeOrElement === 'undefined') {\n        return 0;\n    } else if (typeof currentSizeOrElement === 'number') {\n        return currentSizeOrElement;\n    } else {\n        const styleInPt =\n            currentSizeOrElement.ownerDocument.defaultView?.getComputedStyle(currentSizeOrElement)\n                .fontSize ?? '';\n        const floatInPt = parseFloat(styleInPt);\n        const floatInPx = ptToPx(floatInPt);\n\n        return floatInPx;\n    }\n}\n\nfunction ptToPx(pt: number): number {\n    return Math.round((pt * 4000) / 3) / 1000;\n}\n\nfunction pxToPt(px: number) {\n    return Math.round((px * 3000) / 4) / 1000;\n}\n","export { domToContentModel } from './domToModel/domToContentModel';\nexport { contentModelToDom } from './modelToDom/contentModelToDom';\n\nexport {\n    childProcessor,\n    handleRegularSelection,\n    processChildNode,\n} from './domToModel/processors/childProcessor';\nexport { entityProcessor } from './domToModel/processors/entityProcessor';\nexport { tableProcessor } from './domToModel/processors/tableProcessor';\nexport { getRegularSelectionOffsets } from './domToModel/utils/getRegularSelectionOffsets';\nexport { parseFormat } from './domToModel/utils/parseFormat';\nexport { areSameFormats } from './domToModel/utils/areSameFormats';\nexport { isBlockElement } from './domToModel/utils/isBlockElement';\n\nexport { updateMetadata, hasMetadata } from './domUtils/metadata/updateMetadata';\nexport { isNodeOfType, NodeTypeMap } from './domUtils/isNodeOfType';\nexport { isElementOfType } from './domUtils/isElementOfType';\nexport { getObjectKeys } from './domUtils/getObjectKeys';\nexport { default as toArray } from './domUtils/toArray';\nexport { moveChildNodes, wrapAllChildNodes } from './domUtils/moveChildNodes';\nexport { wrap } from './domUtils/wrap';\nexport {\n    AllowedEntityClasses,\n    isEntityElement,\n    getAllEntityWrappers,\n    parseEntityClassName,\n    generateEntityClassNames,\n    addDelimiters,\n} from './domUtils/entityUtils';\n\nexport { createBr } from './modelApi/creators/createBr';\nexport { createListItem } from './modelApi/creators/createListItem';\nexport { createFormatContainer } from './modelApi/creators/createFormatContainer';\nexport { createParagraph } from './modelApi/creators/createParagraph';\nexport { createSelectionMarker } from './modelApi/creators/createSelectionMarker';\nexport { createTable } from './modelApi/creators/createTable';\nexport { createTableCell } from './modelApi/creators/createTableCell';\nexport { createText } from './modelApi/creators/createText';\nexport { createImage } from './modelApi/creators/createImage';\nexport { createContentModelDocument } from './modelApi/creators/createContentModelDocument';\nexport { createParagraphDecorator } from './modelApi/creators/createParagraphDecorator';\nexport { createGeneralSegment } from './modelApi/creators/createGeneralSegment';\nexport { createGeneralBlock } from './modelApi/creators/createGeneralBlock';\nexport { createEntity } from './modelApi/creators/createEntity';\nexport { createDivider } from './modelApi/creators/createDivider';\nexport { createListLevel } from './modelApi/creators/createListLevel';\n\nexport { addBlock } from './modelApi/common/addBlock';\nexport { addCode } from './modelApi/common/addDecorators';\nexport { addLink } from './modelApi/common/addDecorators';\n\nexport { normalizeContentModel } from './modelApi/common/normalizeContentModel';\nexport { isGeneralSegment } from './modelApi/common/isGeneralSegment';\nexport { unwrapBlock } from './modelApi/common/unwrapBlock';\nexport { addSegment } from './modelApi/common/addSegment';\nexport { isWhiteSpacePreserved } from './modelApi/common/isWhiteSpacePreserved';\nexport { normalizeSingleSegment } from './modelApi/common/normalizeSegment';\nexport { applySegmentFormatToElement } from './modelApi/common/applySegmentFormatToElement';\n\nexport { setParagraphNotImplicit } from './modelApi/block/setParagraphNotImplicit';\n\nexport { parseValueWithUnit } from './formatHandlers/utils/parseValueWithUnit';\nexport { BorderKeys } from './formatHandlers/common/borderFormatHandler';\nexport { DeprecatedColors, getColor, setColor } from './formatHandlers/utils/color';\n\nexport {\n    createDomToModelContext,\n    createDomToModelContextWithConfig,\n    createDomToModelConfig,\n} from './domToModel/context/createDomToModelContext';\nexport {\n    createModelToDomContext,\n    createModelToDomContextWithConfig,\n    createModelToDomConfig,\n} from './modelToDom/context/createModelToDomContext';\n","import type { ContentModelBlock } from 'roosterjs-content-model-types';\n\n/**\n * For a given block, if it is a paragraph, set it to be not-implicit\n * @param block The block to check\n */\nexport function setParagraphNotImplicit(block: ContentModelBlock) {\n    if (block.blockType == 'Paragraph' && block.isImplicit) {\n        block.isImplicit = false;\n    }\n}\n","import type { ContentModelBlock, ContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * Add a given block to block group\n * @param group The block group to add block into\n * @param block The block to add\n */\nexport function addBlock(group: ContentModelBlockGroup, block: ContentModelBlock) {\n    group.blocks.push(block);\n}\n","import type {\n    ContentModelCode,\n    ContentModelLink,\n    ContentModelSegment,\n    DomToModelDecoratorContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function addLink(segment: ContentModelSegment, link: ContentModelLink) {\n    if (link.format.href) {\n        segment.link = {\n            format: { ...link.format },\n            dataset: { ...link.dataset },\n        };\n    }\n}\n\n/**\n * Add a code decorator into segment if any\n * @param segment The segment to add decorator to\n * @param code The code decorator to add\n */\nexport function addCode(segment: ContentModelSegment, code: ContentModelCode) {\n    if (code.format.fontFamily) {\n        segment.code = {\n            format: { ...code.format },\n        };\n    }\n}\n\n/**\n * @internal\n */\nexport function addDecorators(segment: ContentModelSegment, context: DomToModelDecoratorContext) {\n    addLink(segment, context.link);\n    addCode(segment, context.code);\n}\n","import { ensureParagraph } from './ensureParagraph';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelBlockGroup,\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Add a given segment into a paragraph from its parent group. If the last block of the given group is not paragraph, create a new paragraph.\n * @param group The parent block group of the paragraph to add segment into\n * @param newSegment The segment to add\n * @param blockFormat The block format used for creating a new paragraph when need\n * @returns The parent paragraph where the segment is added to\n */\nexport function addSegment(\n    group: ContentModelBlockGroup,\n    newSegment: ContentModelSegment,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat\n): ContentModelParagraph {\n    const paragraph = ensureParagraph(group, blockFormat, segmentFormat);\n    const lastSegment = paragraph.segments[paragraph.segments.length - 1];\n\n    if (newSegment.segmentType == 'SelectionMarker') {\n        if (!lastSegment || !lastSegment.isSelected) {\n            paragraph.segments.push(newSegment);\n        }\n    } else {\n        if (newSegment.isSelected && lastSegment?.segmentType == 'SelectionMarker') {\n            paragraph.segments.pop();\n        }\n\n        paragraph.segments.push(newSegment);\n    }\n\n    return paragraph;\n}\n","import { applyFormat } from '../../modelToDom/utils/applyFormat';\nimport { createModelToDomContext } from '../../modelToDom/context/createModelToDomContext';\nimport type { ContentModelSegmentFormat } from 'roosterjs-content-model-types';\n\n/**\n * Format an existing HTML element using Segment Format\n * @param element The element to format\n * @param format The format to apply\n */\nexport function applySegmentFormatToElement(\n    element: HTMLElement,\n    format: ContentModelSegmentFormat\n) {\n    const context = createModelToDomContext();\n    applyFormat(element, context.formatAppliers.segment, format, context);\n}\n","import { addBlock } from './addBlock';\nimport { createParagraph } from '../creators/createParagraph';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelBlockGroup,\n    ContentModelParagraph,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Ensure there is a Paragraph that can insert segments in a Content Model Block Group\n * @param group The parent block group of the target paragraph\n * @param blockFormat Format of the paragraph. This is only used if we need to create a new paragraph\n */\nexport function ensureParagraph(\n    group: ContentModelBlockGroup,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat\n): ContentModelParagraph {\n    const lastBlock = group.blocks[group.blocks.length - 1];\n\n    if (lastBlock?.blockType == 'Paragraph') {\n        return lastBlock;\n    } else {\n        const paragraph = createParagraph(true, blockFormat, segmentFormat);\n        addBlock(group, paragraph);\n\n        return paragraph;\n    }\n}\n","// A regex to match text that only has space and CR\n// We use real space char \" \" (\\u0020) here but not \"\\s\" since \"\\s\" will also match \"&nbsp;\" (\\u00A0) which is something we need to keep\nconst SPACE_TEXT_REGEX = /^[\\r\\n\\t ]*$/;\n\n/**\n * @internal\n * Check if the given string only has space, including line breaks.\n * @param txt The string to check\n */\nexport function hasSpacesOnly(txt: string): boolean {\n    return SPACE_TEXT_REGEX.test(txt);\n}\n","import type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function isBlockEmpty(block: ContentModelBlock): boolean {\n    switch (block.blockType) {\n        case 'Paragraph':\n            return block.segments.length == 0;\n\n        case 'Table':\n            return block.rows.every(row => row.cells.length == 0);\n\n        case 'BlockGroup':\n            return isBlockGroupEmpty(block);\n\n        case 'Entity':\n            return false;\n\n        default:\n            return false;\n    }\n}\n\n/**\n * @internal\n */\nexport function isBlockGroupEmpty(group: ContentModelBlockGroup): boolean {\n    switch (group.blockGroupType) {\n        case 'FormatContainer':\n            // Format Container of DIV is a container for style, so we always treat it as not empty\n            return group.tagName == 'div' ? false : group.blocks.every(isBlockEmpty);\n\n        case 'ListItem':\n            return group.blocks.every(isBlockEmpty);\n\n        case 'Document':\n        case 'General':\n        case 'TableCell':\n            return false;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * @internal\n */\nexport function isSegmentEmpty(segment: ContentModelSegment): boolean {\n    switch (segment.segmentType) {\n        case 'Text':\n            return !segment.text;\n\n        case 'Image':\n            return !segment.src;\n\n        default:\n            return false;\n    }\n}\n\n/**\n * @internal\n */\nexport function isEmpty(\n    model: ContentModelBlock | ContentModelBlockGroup | ContentModelSegment\n): boolean {\n    if (isBlockGroup(model)) {\n        return isBlockGroupEmpty(model);\n    } else if (isBlock(model)) {\n        return isBlockEmpty(model);\n    } else if (isSegment(model)) {\n        return isSegmentEmpty(model);\n    }\n\n    return false;\n}\n\nfunction isSegment(\n    model: ContentModelBlock | ContentModelBlockGroup | ContentModelSegment\n): model is ContentModelSegment {\n    return typeof (<ContentModelSegment>model).segmentType === 'string';\n}\n\nfunction isBlock(\n    model: ContentModelBlock | ContentModelBlockGroup | ContentModelSegment\n): model is ContentModelBlock {\n    return typeof (<ContentModelBlock>model).blockType === 'string';\n}\n\nfunction isBlockGroup(\n    model: ContentModelBlock | ContentModelBlockGroup | ContentModelSegment\n): model is ContentModelBlockGroup {\n    return typeof (<ContentModelBlockGroup>model).blockGroupType === 'string';\n}\n","import type {\n    ContentModelBlockGroup,\n    ContentModelGeneralSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * Check if the given block group is a general segment\n * @param group The group to check\n */\nexport function isGeneralSegment(\n    group: ContentModelBlockGroup | ContentModelGeneralSegment\n): group is ContentModelGeneralSegment {\n    return (\n        group.blockGroupType == 'General' &&\n        (<ContentModelGeneralSegment>group).segmentType == 'General'\n    );\n}\n","import type { ContentModelParagraph } from 'roosterjs-content-model-types';\n\n// According to https://developer.mozilla.org/en-US/docs/Web/CSS/white-space, these style values will need to preserve white spaces\nconst WHITESPACE_PRE_VALUES = ['pre', 'pre-wrap', 'break-spaces'];\n\n/**\n * Check if we have white-space to be preserved for a given paragraph\n * @param paragraph The paragraph to check\n */\nexport function isWhiteSpacePreserved(paragraph: ContentModelParagraph): boolean {\n    return (\n        (paragraph.format.whiteSpace &&\n            WHITESPACE_PRE_VALUES.indexOf(paragraph.format.whiteSpace) >= 0) ||\n        false\n    );\n}\n","import { isBlockEmpty } from './isEmpty';\nimport { normalizeParagraph } from './normalizeParagraph';\nimport { unwrapBlock } from './unwrapBlock';\nimport type { ContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * For a given content model, normalize it to make the model be consistent.\n * This process includes:\n * - For a list item without any list level, unwrap the list item\n * - For a paragraph, make sure it has BR at the end if it is an empty paragraph\n * - For text segments under paragraph, make sure its space values are correct (use nbsp to replace space when necessary)\n * - For an empty block, remove it\n * @param group The root level block group of content model to normalize\n */\nexport function normalizeContentModel(group: ContentModelBlockGroup) {\n    for (let i = group.blocks.length - 1; i >= 0; i--) {\n        const block = group.blocks[i];\n\n        switch (block.blockType) {\n            case 'BlockGroup':\n                if (block.blockGroupType == 'ListItem' && block.levels.length == 0) {\n                    i += block.blocks.length;\n                    unwrapBlock(group, block);\n                } else {\n                    normalizeContentModel(block);\n                }\n                break;\n            case 'Paragraph':\n                normalizeParagraph(block);\n                break;\n            case 'Table':\n                for (let r = 0; r < block.rows.length; r++) {\n                    for (let c = 0; c < block.rows[r].cells.length; c++) {\n                        if (block.rows[r].cells[c]) {\n                            normalizeContentModel(block.rows[r].cells[c]);\n                        }\n                    }\n                }\n                break;\n        }\n\n        if (isBlockEmpty(block)) {\n            group.blocks.splice(i, 1);\n        }\n    }\n}\n","import { areSameFormats } from '../../domToModel/utils/areSameFormats';\nimport { createBr } from '../creators/createBr';\nimport { isSegmentEmpty } from './isEmpty';\nimport { isWhiteSpacePreserved } from './isWhiteSpacePreserved';\nimport { normalizeAllSegments } from './normalizeSegment';\nimport type { ContentModelParagraph } from 'roosterjs-content-model-types';\n/**\n * @internal\n */\nexport function normalizeParagraph(paragraph: ContentModelParagraph) {\n    const segments = paragraph.segments;\n\n    if (!paragraph.isImplicit && segments.length > 0) {\n        const last = segments[segments.length - 1];\n        const secondLast = segments[segments.length - 2];\n\n        if (\n            last.segmentType == 'SelectionMarker' &&\n            (!secondLast || secondLast.segmentType == 'Br')\n        ) {\n            segments.push(createBr(last.format));\n        } else if (segments.length > 1 && segments[segments.length - 1].segmentType == 'Br') {\n            const noMarkerSegments = segments.filter(x => x.segmentType != 'SelectionMarker');\n\n            // When there is content with a <BR> tag at the end, we can remove the BR.\n            // But if there are more than one <BR> at the end, do not remove them.\n            if (\n                noMarkerSegments.length > 1 &&\n                noMarkerSegments[noMarkerSegments.length - 2].segmentType != 'Br'\n            ) {\n                segments.pop();\n            }\n        }\n    }\n\n    if (!isWhiteSpacePreserved(paragraph)) {\n        normalizeAllSegments(paragraph);\n    }\n\n    removeEmptyLinks(paragraph);\n\n    removeEmptySegments(paragraph);\n}\n\nfunction removeEmptySegments(block: ContentModelParagraph) {\n    for (let j = block.segments.length - 1; j >= 0; j--) {\n        if (isSegmentEmpty(block.segments[j])) {\n            block.segments.splice(j, 1);\n        }\n    }\n}\n\nfunction removeEmptyLinks(paragraph: ContentModelParagraph) {\n    const marker = paragraph.segments.find(x => x.segmentType == 'SelectionMarker');\n    if (marker) {\n        const markerIndex = paragraph.segments.indexOf(marker);\n        const prev = paragraph.segments[markerIndex - 1];\n        const next = paragraph.segments[markerIndex + 1];\n        if (\n            (prev &&\n                !prev.link &&\n                areSameFormats(prev.format, marker.format) &&\n                (!next || (!next.link && areSameFormats(next.format, marker.format))) &&\n                marker.link) ||\n            (!prev &&\n                marker.link &&\n                next &&\n                !next.link &&\n                areSameFormats(next.format, marker.format))\n        ) {\n            delete marker.link;\n        }\n    }\n}\n","import { hasSpacesOnly } from './hasSpacesOnly';\nimport type {\n    ContentModelParagraph,\n    ContentModelSegment,\n    ContentModelText,\n} from 'roosterjs-content-model-types';\n\nconst SPACE = '\\u0020';\nconst NONE_BREAK_SPACE = '\\u00A0';\nconst LEADING_SPACE_REGEX = /^\\u0020+/;\nconst TRAILING_SPACE_REGEX = /\\u0020+$/;\n\n/**\n * @internal\n */\nexport function normalizeAllSegments(paragraph: ContentModelParagraph) {\n    const context = resetNormalizeSegmentContext();\n\n    paragraph.segments.forEach(segment => {\n        normalizeSegment(segment, context);\n    });\n\n    normalizeTextSegments(context.textSegments, context.lastInlineSegment);\n    normalizeLastTextSegment(context.lastTextSegment, context.lastInlineSegment);\n}\n\n/**\n * Normalize a given segment, make sure its spaces are correctly represented by space and non-break space\n * @param segment The segment to normalize\n * @param ignoreTrailingSpaces Whether we should ignore the trailing space of the text segment @default false\n */\nexport function normalizeSingleSegment(\n    segment: ContentModelSegment,\n    ignoreTrailingSpaces: boolean = false\n) {\n    const context = resetNormalizeSegmentContext();\n\n    context.ignoreTrailingSpaces = ignoreTrailingSpaces;\n    normalizeSegment(segment, context);\n}\n\n/**\n * @internal Export for test only\n */\nexport interface NormalizeSegmentContext {\n    textSegments: ContentModelText[];\n    ignoreLeadingSpaces: boolean;\n    ignoreTrailingSpaces: boolean;\n    lastTextSegment: ContentModelText | undefined;\n    lastInlineSegment: ContentModelSegment | undefined;\n}\n\n/**\n * @internal Export for test only\n */\nexport function createNormalizeSegmentContext(): NormalizeSegmentContext {\n    return resetNormalizeSegmentContext();\n}\n\nfunction resetNormalizeSegmentContext(\n    context?: Partial<NormalizeSegmentContext>\n): NormalizeSegmentContext {\n    return Object.assign(context ?? {}, {\n        textSegments: [],\n        ignoreLeadingSpaces: true,\n        ignoreTrailingSpaces: true,\n        lastInlineSegment: undefined,\n        lastTextSegment: undefined,\n    });\n}\n\n/**\n * @internal Export for test only\n */\nexport function normalizeSegment(segment: ContentModelSegment, context: NormalizeSegmentContext) {\n    switch (segment.segmentType) {\n        case 'Br':\n            normalizeTextSegments(context.textSegments, context.lastInlineSegment);\n            normalizeLastTextSegment(context.lastTextSegment, context.lastInlineSegment);\n\n            // Line ends, reset all states\n            resetNormalizeSegmentContext(context);\n            break;\n\n        case 'Entity':\n        case 'General':\n        case 'Image':\n            // Here \"inline segment\" means a segment showing some content inline such as text, image, or other inline HTML elements\n            // BR will end current line, so it is not treated as \"inline\" here.\n            // We will do some normalization to the trailing spaces for non-inline-segments\n            context.lastInlineSegment = segment;\n            context.ignoreLeadingSpaces = false;\n            break;\n\n        case 'Text':\n            context.textSegments.push(segment);\n            context.lastInlineSegment = segment;\n            context.lastTextSegment = segment;\n\n            const first = segment.text.substring(0, 1);\n            const last = segment.text.substr(-1);\n\n            if (!hasSpacesOnly(segment.text)) {\n                if (first == SPACE) {\n                    // 1. Multiple leading space => single &nbsp; or empty (depends on if previous segment ends with space)\n                    segment.text = segment.text.replace(\n                        LEADING_SPACE_REGEX,\n                        context.ignoreLeadingSpaces ? '' : NONE_BREAK_SPACE\n                    );\n                }\n\n                if (last == SPACE) {\n                    // 2. Multiple trailing space => single space\n                    segment.text = segment.text.replace(\n                        TRAILING_SPACE_REGEX,\n                        context.ignoreTrailingSpaces ? SPACE : NONE_BREAK_SPACE\n                    );\n                }\n            }\n\n            context.ignoreLeadingSpaces = last == SPACE;\n\n            break;\n    }\n}\n\nfunction normalizeTextSegments(\n    segments: ContentModelText[],\n    lastInlineSegment: ContentModelSegment | undefined\n) {\n    segments.forEach(segment => {\n        // 3. Segment ends with &nbsp; replace it with space if the previous char is not space so that next segment can wrap\n        // Only do this for segments that is not the last one since the last space will be removed in step 4\n        if (segment != lastInlineSegment) {\n            const text = segment.text;\n\n            if (\n                text.substr(-1) == NONE_BREAK_SPACE &&\n                text.length > 1 &&\n                text.substr(-2, 1) != SPACE\n            ) {\n                segment.text = text.substring(0, text.length - 1) + SPACE;\n            }\n        }\n    });\n}\n\nfunction normalizeLastTextSegment(\n    segment: ContentModelText | undefined,\n    lastInlineSegment: ContentModelSegment | undefined\n) {\n    if (segment && segment == lastInlineSegment && segment?.text.substr(-1) == SPACE) {\n        // 4. last text segment of the paragraph, remove trailing space\n        segment.text = segment.text.replace(TRAILING_SPACE_REGEX, '');\n    }\n}\n","import { setParagraphNotImplicit } from '../block/setParagraphNotImplicit';\nimport type { ContentModelBlock, ContentModelBlockGroup } from 'roosterjs-content-model-types';\n\n/**\n * Unwrap a given block group, move its child blocks to be under its parent group\n * @param parent Parent block group of the unwrapping group\n * @param groupToUnwrap  The block group to unwrap\n */\nexport function unwrapBlock(\n    parent: ContentModelBlockGroup | null,\n    groupToUnwrap: ContentModelBlockGroup & ContentModelBlock\n) {\n    const index = parent?.blocks.indexOf(groupToUnwrap) ?? -1;\n\n    if (index >= 0) {\n        groupToUnwrap.blocks.forEach(setParagraphNotImplicit);\n\n        parent?.blocks.splice(index, 1, ...groupToUnwrap.blocks);\n    }\n}\n","import type { ContentModelBr, ContentModelSegmentFormat } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelBr model\n * @param format @optional The format of this model\n */\nexport function createBr(format?: ContentModelSegmentFormat): ContentModelBr {\n    return {\n        segmentType: 'Br',\n        format: format ? { ...format } : {},\n    };\n}\n","import type {\n    ContentModelDocument,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelDocument model\n * @param defaultFormat @optional Default format of this model\n */\nexport function createContentModelDocument(\n    defaultFormat?: ContentModelSegmentFormat\n): ContentModelDocument {\n    const result: ContentModelDocument = {\n        blockGroupType: 'Document',\n        blocks: [],\n    };\n\n    if (defaultFormat) {\n        result.format = defaultFormat;\n    }\n\n    return result;\n}\n","import type { ContentModelBlockFormat, ContentModelDivider } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelDivider model\n * @param tagName Tag name of this divider. Currently only hr and div are supported\n * @param format @optional The format of this model\n */\nexport function createDivider(\n    tagName: 'hr' | 'div',\n    format?: ContentModelBlockFormat\n): ContentModelDivider {\n    return {\n        blockType: 'Divider',\n        tagName,\n        format: format ? { ...format } : {},\n    };\n}\n","import type { ContentModelEntity, ContentModelSegmentFormat } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelEntity model\n * @param wrapper Wrapper element of this entity\n * @param isReadonly Whether this is a readonly entity @default true\n * @param segmentFormat @optional Segment format of this entity\n * @param type @optional Type of this entity\n * @param id @optional Id of this entity\n */\nexport function createEntity(\n    wrapper: HTMLElement,\n    isReadonly: boolean = true,\n    segmentFormat?: ContentModelSegmentFormat,\n    type?: string,\n    id?: string\n): ContentModelEntity {\n    return {\n        segmentType: 'Entity',\n        blockType: 'Entity',\n        format: { ...segmentFormat },\n        entityFormat: {\n            id,\n            entityType: type,\n            isReadonly,\n        },\n        wrapper,\n    };\n}\n","import type {\n    ContentModelFormatContainer,\n    ContentModelFormatContainerFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelFormatContainer model\n * @param tag Tag name of this format container, in lower case\n * @param format @optional The format of this model\n */\nexport function createFormatContainer(\n    tag: Lowercase<string>,\n    format?: ContentModelFormatContainerFormat\n): ContentModelFormatContainer {\n    return {\n        blockType: 'BlockGroup',\n        blockGroupType: 'FormatContainer',\n        tagName: tag,\n        blocks: [],\n        format: { ...(format || {}) },\n    };\n}\n","import type { ContentModelGeneralBlock } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelGeneralBlock model\n * @param element Original element of this model\n */\nexport function createGeneralBlock(element: HTMLElement): ContentModelGeneralBlock {\n    return {\n        blockType: 'BlockGroup',\n        blockGroupType: 'General',\n        element: element,\n        blocks: [],\n        format: {},\n    };\n}\n","import type {\n    ContentModelGeneralSegment,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelGeneralSegment model\n * @param element The original DOM element\n * @param format @optional The format of this model\n */\nexport function createGeneralSegment(\n    element: HTMLElement,\n    format?: ContentModelSegmentFormat\n): ContentModelGeneralSegment {\n    return {\n        blockType: 'BlockGroup',\n        blockGroupType: 'General',\n        segmentType: 'General',\n        format: format ? { ...format } : {},\n        blocks: [],\n        element: element,\n    };\n}\n","import type { ContentModelImage, ContentModelImageFormat } from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelImage model\n * @param src Image source\n * @param format @optional The format of this model\n */\nexport function createImage(src: string, format?: ContentModelImageFormat): ContentModelImage {\n    return {\n        segmentType: 'Image',\n        src: src,\n        format: format ? { ...format } : {},\n        dataset: {},\n    };\n}\n","import { createListLevel } from './createListLevel';\nimport { createSelectionMarker } from './createSelectionMarker';\nimport type {\n    ContentModelListItem,\n    ContentModelListLevel,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelListItem model\n * @param levels Existing list levels\n * @param format @optional The format of this model\n */\nexport function createListItem(\n    levels: ContentModelListLevel[],\n    format?: ContentModelSegmentFormat\n): ContentModelListItem {\n    return {\n        blockType: 'BlockGroup',\n        blockGroupType: 'ListItem',\n        blocks: [],\n        levels: levels\n            ? levels.map(level => createListLevel(level.listType, level.format, level.dataset))\n            : [],\n        formatHolder: createSelectionMarker(format),\n        format: {},\n    };\n}\n","import type {\n    ContentModelListItemLevelFormat,\n    ContentModelListLevel,\n    DatasetFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelListLevel model\n * @param listType Tag name of the list, either OL or UL\n * @param format @optional The format of this model\n * @param dataset @optional The dataset of this model\n */\nexport function createListLevel(\n    listType: 'OL' | 'UL',\n    format?: ContentModelListItemLevelFormat,\n    dataset?: DatasetFormat\n): ContentModelListLevel {\n    return {\n        listType,\n        format: { ...format },\n        dataset: { ...dataset },\n    };\n}\n","import type {\n    ContentModelBlockFormat,\n    ContentModelParagraph,\n    ContentModelParagraphDecorator,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelParagraph model\n * @param isImplicit @optional Whether this is an implicit paragraph. An implicit paragraph is a paragraph that will not render with DOM element container\n * @param blockFormat @optional Format of this paragraph\n * @param segmentFormat @optional Segment format applied to this block\n * @param decorator @optional Decorator of this paragraph\n */\nexport function createParagraph(\n    isImplicit?: boolean,\n    blockFormat?: ContentModelBlockFormat,\n    segmentFormat?: ContentModelSegmentFormat,\n    decorator?: ContentModelParagraphDecorator\n): ContentModelParagraph {\n    const result: ContentModelParagraph = {\n        blockType: 'Paragraph',\n        segments: [],\n        format: blockFormat ? { ...blockFormat } : {},\n    };\n\n    if (segmentFormat && Object.keys(segmentFormat).length > 0) {\n        result.segmentFormat = { ...segmentFormat };\n    }\n\n    if (isImplicit) {\n        result.isImplicit = true;\n    }\n\n    if (decorator) {\n        result.decorator = {\n            tagName: decorator.tagName,\n            format: { ...decorator.format },\n        };\n    }\n\n    return result;\n}\n","import type {\n    ContentModelParagraphDecorator,\n    ContentModelSegmentFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelParagraphDecorator model\n * @param tagName Tag name of this decorator\n * @param format @optional The format of this model\n */\nexport function createParagraphDecorator(\n    tagName: string,\n    format?: ContentModelSegmentFormat\n): ContentModelParagraphDecorator {\n    return {\n        tagName: tagName.toLocaleLowerCase(),\n        format: { ...(format || {}) },\n    };\n}\n","import type {\n    ContentModelSegmentFormat,\n    ContentModelSelectionMarker,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelSelectionMarker model\n * @param format @optional The format of this model\n */\nexport function createSelectionMarker(\n    format?: ContentModelSegmentFormat\n): ContentModelSelectionMarker {\n    return {\n        segmentType: 'SelectionMarker',\n        isSelected: true,\n        format: format ? { ...format } : {},\n    };\n}\n","import type {\n    ContentModelTable,\n    ContentModelTableFormat,\n    ContentModelTableRow,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelTable model\n * @param rowCount Count of rows of this table\n * @param format @optional The format of this model\n */\nexport function createTable(rowCount: number, format?: ContentModelTableFormat): ContentModelTable {\n    const rows: ContentModelTableRow[] = [];\n\n    for (let i = 0; i < rowCount; i++) {\n        rows.push({\n            height: 0,\n            format: {},\n            cells: [],\n        });\n    }\n\n    return {\n        blockType: 'Table',\n        rows,\n        format: { ...(format || {}) },\n        widths: [],\n        dataset: {},\n    };\n}\n","import type {\n    ContentModelTableCell,\n    ContentModelTableCellFormat,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelTableCell model\n * @param spanLeftOrColSpan @optional Whether this is a table cell merged with its left cell, or colspan number @default false\n * @param spanAboveOrRowSpan Whether this is a table cell merged with its upper cell, or rowSpan number @default false\n * @param isHeader @optional Whether this is a header cell @default false\n * @param format @optional The format of this model\n */\nexport function createTableCell(\n    spanLeftOrColSpan?: boolean | number,\n    spanAboveOrRowSpan?: boolean | number,\n    isHeader?: boolean,\n    format?: ContentModelTableCellFormat\n): ContentModelTableCell {\n    const spanLeft =\n        typeof spanLeftOrColSpan === 'number' ? spanLeftOrColSpan > 1 : !!spanLeftOrColSpan;\n    const spanAbove =\n        typeof spanAboveOrRowSpan === 'number' ? spanAboveOrRowSpan > 1 : !!spanAboveOrRowSpan;\n    return {\n        blockGroupType: 'TableCell',\n        blocks: [],\n        format: format ? { ...format } : {},\n        spanLeft,\n        spanAbove,\n        isHeader: !!isHeader,\n        dataset: {},\n    };\n}\n","import { addCode, addLink } from '../common/addDecorators';\nimport type {\n    ContentModelCode,\n    ContentModelLink,\n    ContentModelSegmentFormat,\n    ContentModelText,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create a ContentModelText model\n * @param text Text of this model\n * @param format @optional The format of this model\n * @param link @optional The link decorator\n * @param code @option The code decorator\n */\nexport function createText(\n    text: string,\n    format?: ContentModelSegmentFormat,\n    link?: ContentModelLink,\n    code?: ContentModelCode\n): ContentModelText {\n    const result: ContentModelText = {\n        segmentType: 'Text',\n        text: text,\n        format: format ? { ...format } : {},\n    };\n\n    if (link) {\n        addLink(result, link);\n    }\n\n    if (code) {\n        addCode(result, code);\n    }\n\n    return result;\n}\n","import toArray from '../domUtils/toArray';\nimport { isNodeOfType } from '../domUtils/isNodeOfType';\nimport type {\n    ContentModelDocument,\n    DOMSelection,\n    ModelToDomBlockAndSegmentNode,\n    ModelToDomContext,\n    OnNodeCreated,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create DOM tree fragment from Content Model document\n * @param doc Document object of the target DOM tree\n * @param root Target node that will become the container of new DOM tree.\n * When a DOM node with existing node is passed, it will be merged with content model so that unchanged blocks\n * won't be touched.\n * @param model The content model document to generate DOM tree from\n * @param context The context object for Content Model to DOM conversion\n * @param onNodeCreated Callback invoked when a DOM node is created\n * @returns The selection range created in DOM tree from this model, or null when there is no selection\n */\nexport function contentModelToDom(\n    doc: Document,\n    root: Node,\n    model: ContentModelDocument,\n    context: ModelToDomContext,\n    onNodeCreated?: OnNodeCreated\n): DOMSelection | null {\n    context.onNodeCreated = onNodeCreated;\n\n    context.modelHandlers.blockGroupChildren(doc, root, model, context);\n\n    const range = extractSelectionRange(doc, context);\n\n    root.normalize();\n\n    return range;\n}\n\nfunction extractSelectionRange(doc: Document, context: ModelToDomContext): DOMSelection | null {\n    const {\n        regularSelection: { start, end },\n        tableSelection,\n        imageSelection,\n    } = context;\n\n    let startPosition: { container: Node; offset: number } | undefined;\n    let endPosition: { container: Node; offset: number } | undefined;\n\n    if (imageSelection) {\n        return imageSelection;\n    } else if (\n        (startPosition = start && calcPosition(start)) &&\n        (endPosition = end && calcPosition(end))\n    ) {\n        const range = doc.createRange();\n\n        range.setStart(startPosition.container, startPosition.offset);\n        range.setEnd(endPosition.container, endPosition.offset);\n\n        return {\n            type: 'range',\n            range,\n        };\n    } else if (tableSelection) {\n        return tableSelection;\n    } else {\n        return null;\n    }\n}\n\nfunction calcPosition(\n    pos: ModelToDomBlockAndSegmentNode\n): { container: Node; offset: number } | undefined {\n    let result: { container: Node; offset: number } | undefined;\n\n    if (pos.block) {\n        if (!pos.segment) {\n            result = { container: pos.block, offset: 0 };\n        } else if (isNodeOfType(pos.segment, 'TEXT_NODE')) {\n            result = { container: pos.segment, offset: pos.segment.nodeValue?.length || 0 };\n        } else if (pos.segment.parentNode) {\n            result = {\n                container: pos.segment.parentNode,\n                offset:\n                    toArray(pos.segment.parentNode.childNodes as NodeListOf<Node>).indexOf(\n                        pos.segment\n                    ) + 1,\n            };\n        }\n    }\n\n    if (result && isNodeOfType(result.container, 'DOCUMENT_FRAGMENT_NODE')) {\n        const childNodes = result.container.childNodes;\n\n        if (childNodes.length > result.offset) {\n            result = { container: childNodes[result.offset], offset: 0 };\n        } else if (result.container.lastChild) {\n            const container = result.container.lastChild;\n            result = {\n                container,\n                offset: isNodeOfType(container, 'TEXT_NODE')\n                    ? container.nodeValue?.length ?? 0\n                    : container.childNodes.length,\n            };\n        } else {\n            result = undefined;\n        }\n    }\n\n    return result;\n}\n","import { defaultContentModelHandlers } from './defaultContentModelHandlers';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport {\n    defaultFormatAppliers,\n    defaultFormatKeysPerCategory,\n} from '../../formatHandlers/defaultFormatHandlers';\nimport type {\n    EditorContext,\n    FormatApplier,\n    FormatAppliers,\n    FormatAppliersPerCategory,\n    ModelToDomContext,\n    ModelToDomFormatContext,\n    ModelToDomOption,\n    ModelToDomSelectionContext,\n    ModelToDomSettings,\n} from 'roosterjs-content-model-types';\n\n/**\n * Create context object fro Content Model to DOM conversion\n * @param editorContext Context of editor\n * @param options Option array to customize the Model to DOM conversion behavior\n */\nexport function createModelToDomContext(\n    editorContext?: EditorContext,\n    ...options: (ModelToDomOption | undefined)[]\n): ModelToDomContext {\n    return createModelToDomContextWithConfig(createModelToDomConfig(options), editorContext);\n}\n\n/**\n * Create context object for Content Model to DOM conversion with an existing configure\n * @param config A full config object to define how to convert Content Model to DOM tree\n * @param editorContext Context of editor\n */\nexport function createModelToDomContextWithConfig(\n    config: ModelToDomSettings,\n    editorContext?: EditorContext\n) {\n    return Object.assign(\n        {},\n        editorContext,\n        createModelToDomSelectionContext(),\n        createModelToDomFormatContext(),\n        config\n    );\n}\n\nfunction createModelToDomSelectionContext(): ModelToDomSelectionContext {\n    return {\n        regularSelection: {\n            current: {\n                block: null,\n                segment: null,\n            },\n        },\n    };\n}\n\nfunction createModelToDomFormatContext(): ModelToDomFormatContext {\n    return {\n        listFormat: {\n            threadItemCounts: [],\n            nodeStack: [],\n        },\n        implicitFormat: {},\n    };\n}\n\n/**\n * Create Content Model to DOM Config object\n * @param options All customizations of DOM creation\n */\nexport function createModelToDomConfig(\n    options: (ModelToDomOption | undefined)[]\n): ModelToDomSettings {\n    return {\n        modelHandlers: Object.assign(\n            {},\n            defaultContentModelHandlers,\n            ...options.map(x => x?.modelHandlerOverride)\n        ),\n        formatAppliers: buildFormatAppliers(\n            options.map(x => x?.formatApplierOverride),\n            options.map(x => x?.additionalFormatAppliers)\n        ),\n        defaultModelHandlers: defaultContentModelHandlers,\n        defaultFormatAppliers,\n        metadataAppliers: Object.assign({}, ...options.map(x => x?.metadataAppliers)),\n    };\n}\n\n/**\n * @internal Export for test only\n * Build format appliers used by Content Model to DOM conversion\n */\nexport function buildFormatAppliers(\n    overrides: (Partial<FormatAppliers> | undefined)[] = [],\n    additionalAppliersArray: (Partial<FormatAppliersPerCategory> | undefined)[] = []\n): FormatAppliersPerCategory {\n    const combinedOverrides = Object.assign({}, ...overrides);\n\n    return getObjectKeys(defaultFormatKeysPerCategory).reduce((result, key) => {\n        const value = defaultFormatKeysPerCategory[key]\n            .map(\n                formatKey =>\n                    (combinedOverrides[formatKey] === undefined\n                        ? defaultFormatAppliers[formatKey]\n                        : combinedOverrides[formatKey]) as FormatApplier<any>\n            )\n            .concat(\n                ...additionalAppliersArray.map(\n                    appliers => (appliers?.[key] ?? []) as FormatApplier<any>[]\n                )\n            );\n\n        result[key] = value;\n\n        return result;\n    }, {} as FormatAppliersPerCategory);\n}\n","import { handleBlock } from '../handlers/handleBlock';\nimport { handleBlockGroupChildren } from '../handlers/handleBlockGroupChildren';\nimport { handleBr } from '../handlers/handleBr';\nimport { handleDivider } from '../handlers/handleDivider';\nimport { handleEntityBlock, handleEntitySegment } from '../handlers/handleEntity';\nimport { handleFormatContainer } from '../handlers/handleFormatContainer';\nimport { handleGeneralBlock, handleGeneralSegment } from '../handlers/handleGeneralModel';\nimport { handleImage } from '../handlers/handleImage';\nimport { handleList } from '../handlers/handleList';\nimport { handleListItem } from '../handlers/handleListItem';\nimport { handleParagraph } from '../handlers/handleParagraph';\nimport { handleSegment } from '../handlers/handleSegment';\nimport { handleSegmentDecorator } from '../handlers/handleSegmentDecorator';\nimport { handleTable } from '../handlers/handleTable';\nimport { handleText } from '../handlers/handleText';\nimport type { ContentModelHandlerMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const defaultContentModelHandlers: ContentModelHandlerMap = {\n    block: handleBlock,\n    blockGroupChildren: handleBlockGroupChildren,\n    br: handleBr,\n    entityBlock: handleEntityBlock,\n    entitySegment: handleEntitySegment,\n    generalBlock: handleGeneralBlock,\n    generalSegment: handleGeneralSegment,\n    divider: handleDivider,\n    image: handleImage,\n    list: handleList,\n    listItem: handleListItem,\n    paragraph: handleParagraph,\n    formatContainer: handleFormatContainer,\n    segment: handleSegment,\n    segmentDecorator: handleSegmentDecorator,\n    table: handleTable,\n    text: handleText,\n};\n","import type {\n    ContentModelBlock,\n    ContentModelBlockHandler,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleBlock: ContentModelBlockHandler<ContentModelBlock> = (\n    doc: Document,\n    parent: Node,\n    block: ContentModelBlock,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    const handlers = context.modelHandlers;\n\n    switch (block.blockType) {\n        case 'Table':\n            refNode = handlers.table(doc, parent, block, context, refNode);\n            break;\n        case 'Paragraph':\n            refNode = handlers.paragraph(doc, parent, block, context, refNode);\n            break;\n        case 'Entity':\n            refNode = handlers.entityBlock(doc, parent, block, context, refNode);\n            break;\n        case 'Divider':\n            refNode = handlers.divider(doc, parent, block, context, refNode);\n            break;\n        case 'BlockGroup':\n            switch (block.blockGroupType) {\n                case 'General':\n                    refNode = handlers.generalBlock(doc, parent, block, context, refNode);\n                    break;\n\n                case 'FormatContainer':\n                    refNode = handlers.formatContainer(doc, parent, block, context, refNode);\n                    break;\n\n                case 'ListItem':\n                    refNode = handlers.listItem(doc, parent, block, context, refNode);\n                    break;\n            }\n\n            break;\n    }\n\n    return refNode;\n};\n","import type {\n    ContentModelBlockGroup,\n    ContentModelHandler,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleBlockGroupChildren: ContentModelHandler<ContentModelBlockGroup> = (\n    doc: Document,\n    parent: Node,\n    group: ContentModelBlockGroup,\n    context: ModelToDomContext\n) => {\n    const { listFormat } = context;\n    const nodeStack = listFormat.nodeStack;\n    let refNode: Node | null = parent.firstChild;\n\n    try {\n        group.blocks.forEach((childBlock, index) => {\n            // When process list, we need a node stack.\n            // When there are two continuous lists, they should share the same stack\n            // so that list items with same type/threadId can be merged into the same list element\n            // In other cases, clear the stack so that two separate lists won't share the same list element\n            if (\n                index == 0 ||\n                childBlock.blockType != 'BlockGroup' ||\n                childBlock.blockGroupType != 'ListItem'\n            ) {\n                listFormat.nodeStack = [];\n            }\n\n            refNode = context.modelHandlers.block(doc, parent, childBlock, context, refNode);\n        });\n\n        // Remove all rest node if any since they don't appear in content model\n        while (refNode) {\n            const next = refNode.nextSibling;\n\n            refNode.parentNode?.removeChild(refNode);\n            refNode = next;\n        }\n    } finally {\n        listFormat.nodeStack = nodeStack;\n    }\n};\n","import { handleSegmentCommon } from '../utils/handleSegmentCommon';\nimport type { ContentModelBr, ContentModelSegmentHandler } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleBr: ContentModelSegmentHandler<ContentModelBr> = (\n    doc,\n    parent,\n    segment,\n    context,\n    segmentNodes\n) => {\n    const br = doc.createElement('br');\n    const element = doc.createElement('span');\n    element.appendChild(br);\n    parent.appendChild(element);\n\n    handleSegmentCommon(doc, br, element, segment, context, segmentNodes);\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { reuseCachedElement } from '../utils/reuseCachedElement';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelDivider,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleDivider: ContentModelBlockHandler<ContentModelDivider> = (\n    doc: Document,\n    parent: Node,\n    divider: ContentModelDivider,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    let element = context.allowCacheElement ? divider.cachedElement : undefined;\n\n    if (element) {\n        refNode = reuseCachedElement(parent, element, refNode);\n    } else {\n        element = doc.createElement(divider.tagName);\n\n        if (context.allowCacheElement) {\n            divider.cachedElement = element;\n        }\n\n        parent.insertBefore(element, refNode);\n\n        applyFormat(element, context.formatAppliers.divider, divider.format, context);\n\n        if (divider.size) {\n            element.setAttribute('size', divider.size);\n        }\n    }\n\n    context.onNodeCreated?.(divider, element);\n\n    return refNode;\n};\n","import { addDelimiters } from '../../domUtils/entityUtils';\nimport { applyFormat } from '../utils/applyFormat';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport { reuseCachedElement } from '../utils/reuseCachedElement';\nimport { wrap } from '../../domUtils/wrap';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelEntity,\n    ContentModelSegmentHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleEntityBlock: ContentModelBlockHandler<ContentModelEntity> = (\n    _,\n    parent,\n    entityModel,\n    context,\n    refNode\n) => {\n    const { entityFormat, wrapper } = entityModel;\n\n    applyFormat(wrapper, context.formatAppliers.entity, entityFormat, context);\n\n    refNode = reuseCachedElement(parent, wrapper, refNode);\n    context.onNodeCreated?.(entityModel, wrapper);\n\n    return refNode;\n};\n\n/**\n * @internal\n */\nexport const handleEntitySegment: ContentModelSegmentHandler<ContentModelEntity> = (\n    doc,\n    parent,\n    entityModel,\n    context,\n    newSegments\n) => {\n    const { entityFormat, wrapper, format } = entityModel;\n\n    parent.appendChild(wrapper);\n    newSegments?.push(wrapper);\n\n    if (getObjectKeys(format).length > 0) {\n        const span = wrap(doc, wrapper, 'span');\n\n        applyFormat(span, context.formatAppliers.segment, format, context);\n    }\n\n    applyFormat(wrapper, context.formatAppliers.entity, entityFormat, context);\n\n    if (context.addDelimiterForEntity && entityFormat.isReadonly) {\n        const [after, before] = addDelimiters(doc, wrapper);\n\n        newSegments?.push(after, before);\n        context.regularSelection.current.segment = after;\n    } else {\n        context.regularSelection.current.segment = wrapper;\n    }\n\n    context.onNodeCreated?.(entityModel, wrapper);\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { isBlockGroupEmpty } from '../../modelApi/common/isEmpty';\nimport { reuseCachedElement } from '../utils/reuseCachedElement';\nimport { stackFormat } from '../utils/stackFormat';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelBlockHandler,\n    ContentModelFormatContainer,\n    ContentModelSegmentFormat,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\nconst PreChildFormat: ContentModelSegmentFormat & ContentModelBlockFormat = {\n    fontFamily: 'monospace',\n    whiteSpace: 'pre',\n};\n\n/**\n * @internal\n */\nexport const handleFormatContainer: ContentModelBlockHandler<ContentModelFormatContainer> = (\n    doc: Document,\n    parent: Node,\n    container: ContentModelFormatContainer,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    let element = context.allowCacheElement ? container.cachedElement : undefined;\n\n    if (element) {\n        refNode = reuseCachedElement(parent, element, refNode);\n\n        context.modelHandlers.blockGroupChildren(doc, element, container, context);\n    } else if (!isBlockGroupEmpty(container)) {\n        const containerNode = doc.createElement(container.tagName);\n\n        if (context.allowCacheElement) {\n            container.cachedElement = containerNode;\n        }\n\n        parent.insertBefore(containerNode, refNode);\n\n        stackFormat(context, container.tagName, () => {\n            applyFormat(containerNode, context.formatAppliers.container, container.format, context);\n            applyFormat(\n                containerNode,\n                context.formatAppliers.segmentOnBlock,\n                container.format,\n                context\n            );\n\n            applyFormat(containerNode, context.formatAppliers.container, container.format, context);\n        });\n\n        if (container.tagName == 'pre') {\n            stackFormat(context, PreChildFormat, () => {\n                context.modelHandlers.blockGroupChildren(doc, containerNode, container, context);\n            });\n        } else {\n            context.modelHandlers.blockGroupChildren(doc, containerNode, container, context);\n        }\n\n        element = containerNode;\n    }\n\n    if (element) {\n        context.onNodeCreated?.(container, element);\n    }\n\n    return refNode;\n};\n","import { handleSegmentCommon } from '../utils/handleSegmentCommon';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport { reuseCachedElement } from '../utils/reuseCachedElement';\nimport { wrap } from '../../domUtils/wrap';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelGeneralBlock,\n    ContentModelGeneralSegment,\n    ContentModelSegmentHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleGeneralBlock: ContentModelBlockHandler<ContentModelGeneralBlock> = (\n    doc,\n    parent,\n    group,\n    context,\n    refNode\n) => {\n    let node: Node = group.element;\n\n    if (refNode && node.parentNode == parent) {\n        refNode = reuseCachedElement(parent, node, refNode);\n    } else {\n        node = node.cloneNode();\n        group.element = node as HTMLElement;\n\n        parent.insertBefore(node, refNode);\n    }\n\n    context.onNodeCreated?.(group, node);\n    context.modelHandlers.blockGroupChildren(doc, node, group, context);\n\n    return refNode;\n};\n\n/**\n * @internal\n */\nexport const handleGeneralSegment: ContentModelSegmentHandler<ContentModelGeneralSegment> = (\n    doc,\n    parent,\n    group,\n    context,\n    segmentNodes\n) => {\n    const node = group.element.cloneNode() as HTMLElement;\n    group.element = node;\n    parent.appendChild(node);\n\n    if (isNodeOfType(node, 'ELEMENT_NODE')) {\n        const element = wrap(doc, node, 'span');\n\n        handleSegmentCommon(doc, node, element, group, context, segmentNodes);\n        context.onNodeCreated?.(group, node);\n    }\n\n    context.modelHandlers.blockGroupChildren(doc, node, group, context);\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { handleSegmentCommon } from '../utils/handleSegmentCommon';\nimport { parseValueWithUnit } from '../../formatHandlers/utils/parseValueWithUnit';\nimport type { ContentModelImage, ContentModelSegmentHandler } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleImage: ContentModelSegmentHandler<ContentModelImage> = (\n    doc,\n    parent,\n    imageModel,\n    context,\n    segmentNodes\n) => {\n    const img = doc.createElement('img');\n    const element = document.createElement('span');\n\n    parent.appendChild(element);\n    element.appendChild(img);\n\n    img.src = imageModel.src;\n\n    if (imageModel.alt) {\n        img.alt = imageModel.alt;\n    }\n\n    if (imageModel.title) {\n        img.title = imageModel.title;\n    }\n\n    applyFormat(img, context.formatAppliers.image, imageModel.format, context);\n    applyFormat(img, context.formatAppliers.dataset, imageModel.dataset, context);\n\n    const { width, height } = imageModel.format;\n    const widthNum = width ? parseValueWithUnit(width) : 0;\n    const heightNum = height ? parseValueWithUnit(height) : 0;\n\n    if (widthNum > 0) {\n        img.width = widthNum;\n    }\n\n    if (heightNum > 0) {\n        img.height = heightNum;\n    }\n\n    if (imageModel.isSelectedAsImageSelection) {\n        context.imageSelection = {\n            type: 'image',\n            image: img,\n        };\n    }\n\n    handleSegmentCommon(doc, img, element, imageModel, context, segmentNodes);\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { applyMetadata } from '../utils/applyMetadata';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelListItem,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleList: ContentModelBlockHandler<ContentModelListItem> = (\n    doc: Document,\n    parent: Node,\n    listItem: ContentModelListItem,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    let layer = 0;\n    const { nodeStack } = context.listFormat;\n\n    if (nodeStack.length == 0) {\n        nodeStack.push({\n            node: parent,\n        });\n    }\n\n    // Skip existing list levels that has same properties so we can reuse them\n    for (; layer < listItem.levels.length && layer + 1 < nodeStack.length; layer++) {\n        const stackLevel = nodeStack[layer + 1];\n        const itemLevel = listItem.levels[layer];\n\n        if (\n            stackLevel.listType != itemLevel.listType ||\n            stackLevel.dataset?.editingInfo != itemLevel.dataset.editingInfo ||\n            (itemLevel.listType == 'OL' && typeof itemLevel.format.startNumberOverride === 'number')\n        ) {\n            break;\n        }\n    }\n\n    // Cut off remained list levels that we can't reuse\n    nodeStack.splice(layer + 1);\n\n    // Create new list levels that are after reused ones\n    for (; layer < listItem.levels.length; layer++) {\n        const level = listItem.levels[layer];\n        const newList = doc.createElement(level.listType || 'UL');\n        const lastParent = nodeStack[nodeStack.length - 1].node;\n\n        lastParent.insertBefore(newList, layer == 0 ? refNode : null);\n        nodeStack.push({ node: newList, ...level });\n\n        applyFormat(newList, context.formatAppliers.listLevelThread, level.format, context);\n\n        // Need to apply metadata after applying list level format since the list numbers value relies on the result of list thread handling\n        applyMetadata(level, context.metadataAppliers.listLevel, level.format, context);\n\n        // Need to apply listItemElement formats after applying metadata since the list numbers value relies on the result of metadata handling\n        applyFormat(newList, context.formatAppliers.listLevel, level.format, context);\n        applyFormat(newList, context.formatAppliers.dataset, level.dataset, context);\n\n        context.onNodeCreated?.(level, newList);\n    }\n\n    return refNode;\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { applyMetadata } from '../utils/applyMetadata';\nimport { setParagraphNotImplicit } from '../../modelApi/block/setParagraphNotImplicit';\nimport { unwrap } from '../../domUtils/unwrap';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelListItem,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleListItem: ContentModelBlockHandler<ContentModelListItem> = (\n    doc: Document,\n    parent: Node,\n    listItem: ContentModelListItem,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    refNode = context.modelHandlers.list(doc, parent, listItem, context, refNode);\n\n    const { nodeStack } = context.listFormat;\n\n    const listParent = nodeStack?.[nodeStack?.length - 1]?.node || parent;\n    const li = doc.createElement('li');\n    const level = listItem.levels[listItem.levels.length - 1];\n\n    // It is possible listParent is the same with parent param.\n    // This happens when outdent a list item to cause it has no list level\n    listParent.insertBefore(li, refNode?.parentNode == listParent ? refNode : null);\n\n    if (level) {\n        applyFormat(li, context.formatAppliers.segment, listItem.formatHolder.format, context);\n        applyFormat(li, context.formatAppliers.listItemThread, level.format, context);\n\n        // Need to apply metadata after applying listItem format since the list numbers value relies on the result of list thread handling\n        applyMetadata(level, context.metadataAppliers.listItem, listItem.format, context);\n\n        // Need to apply listItemElement formats after applying metadata since the list numbers value relies on the result of metadata handling\n        applyFormat(li, context.formatAppliers.listItemElement, listItem.format, context);\n\n        context.modelHandlers.blockGroupChildren(doc, li, listItem, context);\n    } else {\n        // There is no level for this list item, that means it should be moved out of the list\n        // For each paragraph, make it not implicit so it will have a DIV around it, to avoid more paragraphs connected together\n        listItem.blocks.forEach(setParagraphNotImplicit);\n\n        context.modelHandlers.blockGroupChildren(doc, li, listItem, context);\n\n        unwrap(li);\n    }\n\n    context.onNodeCreated?.(listItem, li);\n\n    return refNode;\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { getObjectKeys } from '../../domUtils/getObjectKeys';\nimport { optimize } from '../optimizers/optimize';\nimport { reuseCachedElement } from '../utils/reuseCachedElement';\nimport { stackFormat } from '../utils/stackFormat';\nimport { unwrap } from '../../domUtils/unwrap';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelParagraph,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\nconst DefaultParagraphTag = 'div';\n\n/**\n * @internal\n */\nexport const handleParagraph: ContentModelBlockHandler<ContentModelParagraph> = (\n    doc: Document,\n    parent: Node,\n    paragraph: ContentModelParagraph,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    let container = context.allowCacheElement ? paragraph.cachedElement : undefined;\n\n    if (container) {\n        refNode = reuseCachedElement(parent, container, refNode);\n    } else {\n        stackFormat(context, paragraph.decorator?.tagName || null, () => {\n            const needParagraphWrapper =\n                !paragraph.isImplicit ||\n                !!paragraph.decorator ||\n                (getObjectKeys(paragraph.format).length > 0 &&\n                    paragraph.segments.some(segment => segment.segmentType != 'SelectionMarker'));\n            const formatOnWrapper = needParagraphWrapper\n                ? {\n                      ...(paragraph.decorator?.format || {}),\n                      ...paragraph.segmentFormat,\n                  }\n                : {};\n\n            container = doc.createElement(paragraph.decorator?.tagName || DefaultParagraphTag);\n\n            parent.insertBefore(container, refNode);\n\n            context.regularSelection.current = {\n                block: needParagraphWrapper ? container : container.parentNode,\n                segment: null,\n            };\n\n            const handleSegments = () => {\n                const parent = container;\n\n                if (parent) {\n                    const firstSegment = paragraph.segments[0];\n\n                    if (firstSegment?.segmentType == 'SelectionMarker') {\n                        // Make sure there is a segment created before selection marker.\n                        // If selection marker is the first selected segment in a paragraph, create a dummy text node,\n                        // so after rewrite, the regularSelection object can have a valid segment object set to the text node.\n                        context.modelHandlers.text(\n                            doc,\n                            parent,\n                            {\n                                ...firstSegment,\n                                segmentType: 'Text',\n                                text: '',\n                            },\n                            context,\n                            []\n                        );\n                    }\n\n                    paragraph.segments.forEach(segment => {\n                        const newSegments: Node[] = [];\n                        context.modelHandlers.segment(doc, parent, segment, context, newSegments);\n\n                        newSegments.forEach(node => {\n                            context.domIndexer?.onSegment(node, paragraph, [segment]);\n                        });\n                    });\n                }\n            };\n\n            if (needParagraphWrapper) {\n                stackFormat(context, formatOnWrapper, handleSegments);\n\n                applyFormat(container, context.formatAppliers.block, paragraph.format, context);\n                applyFormat(container, context.formatAppliers.container, paragraph.format, context);\n                applyFormat(\n                    container,\n                    context.formatAppliers.segmentOnBlock,\n                    formatOnWrapper,\n                    context\n                );\n            } else {\n                handleSegments();\n            }\n\n            optimize(container);\n\n            // It is possible the next sibling node is changed during processing child segments\n            // e.g. When this paragraph is an implicit paragraph and it contains an inline entity segment\n            // The segment will be appended to container as child then the container will be removed\n            // since this paragraph it is implicit. In that case container.nextSibling will become original\n            // inline entity's next sibling. So reset refNode to its real next sibling (after change) here\n            // to make sure the value is correct.\n            refNode = container.nextSibling;\n\n            if (container) {\n                context.onNodeCreated?.(paragraph, container);\n                context.domIndexer?.onParagraph(container);\n            }\n\n            if (needParagraphWrapper) {\n                if (context.allowCacheElement) {\n                    paragraph.cachedElement = container;\n                }\n            } else {\n                unwrap(container);\n                container = undefined;\n            }\n        });\n    }\n\n    return refNode;\n};\n","import type {\n    ContentModelSegment,\n    ContentModelSegmentHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleSegment: ContentModelSegmentHandler<ContentModelSegment> = (\n    doc,\n    parent,\n    segment,\n    context,\n    segmentNodes\n) => {\n    const regularSelection = context.regularSelection;\n\n    // If start position is not set yet, and current segment is in selection, set start position\n    if (segment.isSelected && !regularSelection.start) {\n        regularSelection.start = {\n            ...regularSelection.current,\n        };\n    }\n\n    switch (segment.segmentType) {\n        case 'Text':\n            context.modelHandlers.text(doc, parent, segment, context, segmentNodes);\n            break;\n\n        case 'Br':\n            context.modelHandlers.br(doc, parent, segment, context, segmentNodes);\n            break;\n\n        case 'Image':\n            context.modelHandlers.image(doc, parent, segment, context, segmentNodes);\n            break;\n\n        case 'General':\n            context.modelHandlers.generalSegment(doc, parent, segment, context, segmentNodes);\n            break;\n\n        case 'Entity':\n            context.modelHandlers.entitySegment(doc, parent, segment, context, segmentNodes);\n            break;\n    }\n\n    // If end position is not set, or it is not finalized, and current segment is still in selection, set end position\n    // If there is other selection, we will overwrite regularSelection.end when we process that segment\n    if (segment.isSelected && regularSelection.start) {\n        regularSelection.end = {\n            ...regularSelection.current,\n        };\n    }\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { isNodeOfType } from '../../domUtils/isNodeOfType';\nimport { stackFormat } from '../utils/stackFormat';\nimport { wrapAllChildNodes } from '../../domUtils/moveChildNodes';\nimport type {\n    ContentModelSegment,\n    ContentModelSegmentHandler,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleSegmentDecorator: ContentModelSegmentHandler<ContentModelSegment> = (\n    _,\n    parent,\n    segment,\n    context,\n    segmentNodes\n) => {\n    const { code, link } = segment;\n\n    if (isNodeOfType(parent, 'ELEMENT_NODE')) {\n        if (link) {\n            stackFormat(context, 'a', () => {\n                const a = wrapAllChildNodes(parent, 'a');\n\n                applyFormat(a, context.formatAppliers.link, link.format, context);\n                applyFormat(a, context.formatAppliers.dataset, link.dataset, context);\n\n                segmentNodes?.push(a);\n                context.onNodeCreated?.(link, a);\n            });\n        }\n\n        if (code) {\n            stackFormat(context, 'code', () => {\n                const codeNode = wrapAllChildNodes(parent, 'code');\n\n                applyFormat(codeNode, context.formatAppliers.code, code.format, context);\n\n                segmentNodes?.push(codeNode);\n                context.onNodeCreated?.(code, codeNode);\n            });\n        }\n    }\n};\n","import { applyFormat } from '../utils/applyFormat';\nimport { hasMetadata } from '../../domUtils/metadata/updateMetadata';\nimport { isBlockEmpty } from '../../modelApi/common/isEmpty';\nimport { moveChildNodes } from '../../domUtils/moveChildNodes';\nimport { reuseCachedElement } from '../utils/reuseCachedElement';\nimport type {\n    ContentModelBlockHandler,\n    ContentModelTable,\n    ModelToDomContext,\n    TableSelection,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleTable: ContentModelBlockHandler<ContentModelTable> = (\n    doc: Document,\n    parent: Node,\n    table: ContentModelTable,\n    context: ModelToDomContext,\n    refNode: Node | null\n) => {\n    if (isBlockEmpty(table)) {\n        // Empty table, do not create TABLE element and just return\n        return refNode;\n    }\n\n    let tableNode = context.allowCacheElement ? table.cachedElement : undefined;\n\n    if (tableNode) {\n        refNode = reuseCachedElement(parent, tableNode, refNode);\n\n        moveChildNodes(tableNode);\n    } else {\n        tableNode = doc.createElement('table');\n\n        if (context.allowCacheElement) {\n            table.cachedElement = tableNode;\n        }\n\n        parent.insertBefore(tableNode, refNode);\n\n        applyFormat(tableNode, context.formatAppliers.block, table.format, context);\n        applyFormat(tableNode, context.formatAppliers.table, table.format, context);\n        applyFormat(tableNode, context.formatAppliers.tableBorder, table.format, context);\n        applyFormat(tableNode, context.formatAppliers.dataset, table.dataset, context);\n    }\n\n    context.onNodeCreated?.(table, tableNode);\n\n    const tbody = doc.createElement('tbody');\n    tableNode.appendChild(tbody);\n\n    for (let row = 0; row < table.rows.length; row++) {\n        const tableRow = table.rows[row];\n\n        if (tableRow.cells.length == 0) {\n            // Skip empty row\n            continue;\n        }\n\n        const tr = (context.allowCacheElement && tableRow.cachedElement) || doc.createElement('tr');\n        tbody.appendChild(tr);\n        moveChildNodes(tr);\n\n        if (!tableRow.cachedElement) {\n            if (context.allowCacheElement) {\n                tableRow.cachedElement = tr;\n            }\n\n            applyFormat(tr, context.formatAppliers.tableRow, tableRow.format, context);\n        }\n\n        context.onNodeCreated?.(tableRow, tr);\n\n        for (let col = 0; col < tableRow.cells.length; col++) {\n            const cell = tableRow.cells[col];\n\n            if (cell.isSelected) {\n                const tableSelection: TableSelection = context.tableSelection || {\n                    type: 'table',\n                    table: tableNode,\n                    firstColumn: col,\n                    lastColumn: col,\n                    firstRow: row,\n                    lastRow: row,\n                };\n\n                if (tableSelection.table == tableNode) {\n                    tableSelection.lastColumn = Math.max(tableSelection.lastColumn, col);\n                    tableSelection.lastRow = Math.max(tableSelection.lastRow, row);\n                }\n\n                context.tableSelection = tableSelection;\n            }\n\n            if (!cell.spanAbove && !cell.spanLeft) {\n                const td =\n                    (context.allowCacheElement && cell.cachedElement) ||\n                    doc.createElement(cell.isHeader ? 'th' : 'td');\n\n                tr.appendChild(td);\n\n                let rowSpan = 1;\n                let colSpan = 1;\n                let width = table.widths[col];\n                let height = tableRow.height;\n\n                for (; table.rows[row + rowSpan]?.cells[col]?.spanAbove; rowSpan++) {\n                    height += table.rows[row + rowSpan].height;\n                }\n                for (; tableRow.cells[col + colSpan]?.spanLeft; colSpan++) {\n                    width += table.widths[col + colSpan];\n                }\n\n                if (rowSpan > 1) {\n                    td.rowSpan = rowSpan;\n                }\n\n                if (colSpan > 1) {\n                    td.colSpan = colSpan;\n                }\n\n                if (!cell.cachedElement || (cell.format.useBorderBox && hasMetadata(table))) {\n                    if (width > 0 && !td.style.width) {\n                        td.style.width = width + 'px';\n                    }\n\n                    if (height > 0 && !td.style.height) {\n                        td.style.height = height + 'px';\n                    }\n                }\n\n                if (!cell.cachedElement) {\n                    if (context.allowCacheElement) {\n                        cell.cachedElement = td;\n                    }\n\n                    applyFormat(td, context.formatAppliers.block, cell.format, context);\n                    applyFormat(td, context.formatAppliers.tableCell, cell.format, context);\n                    applyFormat(td, context.formatAppliers.tableCellBorder, cell.format, context);\n                    applyFormat(td, context.formatAppliers.dataset, cell.dataset, context);\n                }\n\n                context.modelHandlers.blockGroupChildren(doc, td, cell, context);\n\n                context.onNodeCreated?.(cell, td);\n            }\n        }\n    }\n\n    context.domIndexer?.onTable(tableNode, table);\n\n    return refNode;\n};\n","import { handleSegmentCommon } from '../utils/handleSegmentCommon';\nimport type { ContentModelSegmentHandler, ContentModelText } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const handleText: ContentModelSegmentHandler<ContentModelText> = (\n    doc,\n    parent,\n    segment,\n    context,\n    segmentNodes\n) => {\n    const txt = doc.createTextNode(segment.text);\n    const element = doc.createElement('span');\n\n    parent.appendChild(element);\n    element.appendChild(txt);\n\n    handleSegmentCommon(doc, txt, element, segment, context, segmentNodes);\n};\n","import { isNodeOfType } from '../../domUtils/isNodeOfType';\n\nconst OptimizeTags = ['SPAN', 'B', 'EM', 'I', 'U', 'SUB', 'SUP', 'STRIKE', 'S', 'A', 'CODE'];\n\n/**\n * @internal\n */\nexport function mergeNode(root: Node) {\n    for (let child = root.firstChild; child; ) {\n        const next = child.nextSibling;\n\n        if (\n            next &&\n            isNodeOfType(child, 'ELEMENT_NODE') &&\n            isNodeOfType(next, 'ELEMENT_NODE') &&\n            child.tagName == next.tagName &&\n            OptimizeTags.indexOf(child.tagName) >= 0 &&\n            hasSameAttributes(child, next)\n        ) {\n            while (next.firstChild) {\n                child.appendChild(next.firstChild);\n            }\n\n            next.parentNode!.removeChild(next);\n        } else {\n            child = next;\n        }\n    }\n}\n\nfunction hasSameAttributes(element1: HTMLElement, element2: HTMLElement) {\n    const attr1 = element1.attributes;\n    const attr2 = element2.attributes;\n\n    if (attr1.length != attr2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < attr1.length; i++) {\n        if (attr1[i].name != attr2[i].name || attr1[i].value != attr2[i].value) {\n            return false;\n        }\n    }\n\n    return true;\n}\n","import { isEntityElement } from '../../domUtils/entityUtils';\nimport { mergeNode } from './mergeNode';\nimport { removeUnnecessarySpan } from './removeUnnecessarySpan';\n\n/**\n * @internal\n */\nexport function optimize(root: Node) {\n    /**\n     * Do no do any optimization to entity\n     */\n    if (isEntityElement(root)) {\n        return;\n    }\n\n    removeUnnecessarySpan(root);\n    mergeNode(root);\n\n    for (let child = root.firstChild; child; child = child.nextSibling) {\n        optimize(child);\n    }\n}\n","import { isNodeOfType } from '../../domUtils/isNodeOfType';\n\n/**\n * @internal\n */\nexport function removeUnnecessarySpan(root: Node) {\n    for (let child = root.firstChild; child; ) {\n        if (\n            isNodeOfType(child, 'ELEMENT_NODE') &&\n            child.tagName == 'SPAN' &&\n            child.attributes.length == 0\n        ) {\n            const node = child;\n            let refNode = child.nextSibling;\n            child = child.nextSibling;\n\n            while (node.lastChild) {\n                const newNode = node.lastChild;\n                root.insertBefore(newNode, refNode);\n                refNode = newNode;\n            }\n\n            root.removeChild(node);\n        } else {\n            child = child.nextSibling;\n        }\n    }\n}\n","import type {\n    ContentModelFormatBase,\n    FormatApplier,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Apply formats to the given HTML element using specified appliers\n * @param element The element to apply formats to\n * @param appliers The appliers we are using to apply formats\n * @param format The format object we get format info from\n * @param context Content Model to DOM context\n */\nexport function applyFormat<T extends ContentModelFormatBase>(\n    element: HTMLElement,\n    appliers: (FormatApplier<T> | null)[],\n    format: T,\n    context: ModelToDomContext\n) {\n    appliers.forEach(applier => {\n        applier?.(format, element, context);\n    });\n}\n","import { updateMetadata } from '../../domUtils/metadata/updateMetadata';\nimport type {\n    ContentModelFormatBase,\n    ContentModelWithDataset,\n    MetadataApplier,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function applyMetadata<TMetadata, TFormat extends ContentModelFormatBase>(\n    model: ContentModelWithDataset<TMetadata>,\n    applier: MetadataApplier<TMetadata, TFormat> | undefined,\n    format: TFormat,\n    context: ModelToDomContext\n) {\n    if (applier) {\n        updateMetadata(\n            model,\n            metadata => {\n                applier.applierFunction(metadata, format, context);\n                return metadata;\n            },\n            applier.metadataDefinition\n        );\n    }\n}\n","import { applyFormat } from './applyFormat';\nimport type { ContentModelSegment, ModelToDomContext } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function handleSegmentCommon(\n    doc: Document,\n    segmentNode: Node,\n    containerNode: HTMLElement,\n    segment: ContentModelSegment,\n    context: ModelToDomContext,\n    segmentNodes: Node[]\n) {\n    if (!segmentNode.firstChild) {\n        context.regularSelection.current.segment = segmentNode;\n    }\n\n    applyFormat(containerNode, context.formatAppliers.styleBasedSegment, segment.format, context);\n\n    segmentNodes?.push(segmentNode);\n    context.modelHandlers.segmentDecorator(doc, containerNode, segment, context, segmentNodes);\n\n    applyFormat(containerNode, context.formatAppliers.elementBasedSegment, segment.format, context);\n\n    context.onNodeCreated?.(segment, segmentNode);\n}\n","import { isEntityElement } from '../../domUtils/entityUtils';\n\n/**\n * @internal\n */\nexport function reuseCachedElement(parent: Node, element: Node, refNode: Node | null): Node | null {\n    if (element.parentNode == parent) {\n        // Remove nodes before the one we are hitting since they don't appear in Content Model at this position.\n        // But we don't want to touch entity since it would better to keep entity at its place unless it is removed\n        // In that case we will remove it after we have handled all other nodes\n        while (refNode && refNode != element && !isEntityElement(refNode)) {\n            const next = refNode.nextSibling;\n\n            refNode.parentNode?.removeChild(refNode);\n            refNode = next;\n        }\n\n        if (refNode && refNode == element) {\n            refNode = refNode.nextSibling;\n        } else {\n            parent.insertBefore(element, refNode);\n        }\n    } else {\n        parent.insertBefore(element, refNode);\n    }\n\n    return refNode;\n}\n\n/**\n * @internal\n */\nexport function removeNode(node: Node): Node | null {\n    const next = node.nextSibling;\n    node.parentNode?.removeChild(node);\n\n    return next;\n}\n","import { defaultContentModelFormatMap } from '../../config/defaultContentModelFormatMap';\nimport type {\n    ContentModelBlockFormat,\n    ContentModelSegmentFormat,\n    ModelToDomContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function stackFormat(\n    context: ModelToDomContext,\n    tagNameOrFormat: string | (ContentModelSegmentFormat & ContentModelBlockFormat) | null,\n    callback: () => void\n) {\n    const newFormat =\n        typeof tagNameOrFormat === 'string'\n            ? defaultContentModelFormatMap[tagNameOrFormat]\n            : tagNameOrFormat;\n\n    if (newFormat) {\n        const implicitFormat = context.implicitFormat;\n\n        try {\n            context.implicitFormat = {\n                ...implicitFormat,\n                ...newFormat,\n            };\n\n            callback();\n        } finally {\n            context.implicitFormat = implicitFormat;\n        }\n    } else {\n        callback();\n    }\n}\n","import { convertDomSelectionToMetadata } from '../editor/utils/selectionConverter';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport { Position } from 'roosterjs-editor-dom';\nimport type { EntityState, ContentChangedEvent } from 'roosterjs-editor-types';\nimport type { AddUndoSnapshot, StandaloneEditorCore } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\n * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.\n * @param core The StandaloneEditorCore object\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\n * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).\n * @param additionalData @optional parameter to provide additional data related to the ContentChanged Event.\n */\nexport const addUndoSnapshot: AddUndoSnapshot = (\n    core,\n    callback,\n    changeSource,\n    canUndoByBackspace,\n    additionalData\n) => {\n    const undoState = core.undo;\n    const isNested = undoState.isNested;\n    let data: any;\n\n    if (!isNested) {\n        undoState.isNested = true;\n\n        // When there is getEntityState, it means this is triggered by an entity change.\n        // So if HTML content is not changed (hasNewContent is false), no need to add another snapshot before change\n        if (core.undo.hasNewContent || !additionalData?.getEntityState || !callback) {\n            addUndoSnapshotInternal(core, canUndoByBackspace, additionalData?.getEntityState?.());\n        }\n    }\n\n    try {\n        if (callback) {\n            const selection = core.api.getDOMSelection(core);\n            const range = selection?.type == 'range' ? selection.range : null;\n            data = callback(\n                range && Position.getStart(range).normalize(),\n                range && Position.getEnd(range).normalize()\n            );\n\n            if (!isNested) {\n                const entityStates = additionalData?.getEntityState?.();\n                addUndoSnapshotInternal(core, false /*isAutoCompleteSnapshot*/, entityStates);\n            }\n        }\n    } finally {\n        if (!isNested) {\n            undoState.isNested = false;\n        }\n    }\n\n    if (callback && changeSource) {\n        const event: ContentChangedEvent = {\n            eventType: PluginEventType.ContentChanged,\n            source: changeSource,\n            data: data,\n            additionalData,\n        };\n        core.api.triggerEvent(core, event, true /*broadcast*/);\n    }\n\n    if (canUndoByBackspace) {\n        const selection = core.api.getDOMSelection(core);\n\n        if (selection?.type == 'range') {\n            core.undo.hasNewContent = false;\n            core.undo.posContainer = selection.range.startContainer;\n            core.undo.posOffset = selection.range.startOffset;\n        }\n    }\n};\n\nfunction addUndoSnapshotInternal(\n    core: StandaloneEditorCore,\n    canUndoByBackspace: boolean,\n    entityStates?: EntityState[]\n) {\n    if (!core.lifecycle.shadowEditFragment) {\n        const selection = core.api.getDOMSelection(core);\n        const metadata = convertDomSelectionToMetadata(core.contentDiv, selection);\n\n        if (metadata) {\n            metadata.isDarkMode = !!core.lifecycle.isDarkMode;\n        }\n\n        core.undo.snapshotsService.addSnapshot(\n            {\n                html: core.contentDiv.innerHTML,\n                metadata,\n                knownColors: core.darkColorHandler?.getKnownColorsCopy() || [],\n                entityStates,\n            },\n            canUndoByBackspace\n        );\n        core.undo.hasNewContent = false;\n    }\n}\n","import { getObjectKeys } from 'roosterjs-editor-dom';\nimport type { AttachDomEvent } from 'roosterjs-content-model-types';\nimport type {\n    DOMEventHandler,\n    DOMEventHandlerObject,\n    PluginDomEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Attach a DOM event to the editor content DIV\n * @param core The StandaloneEditorCore object\n * @param eventName The DOM event name\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\n */\nexport const attachDomEvent: AttachDomEvent = (core, eventMap) => {\n    const disposers = getObjectKeys(eventMap || {}).map(key => {\n        const { pluginEventType, beforeDispatch } = extractHandler(eventMap[key]);\n        const eventName = key as keyof HTMLElementEventMap;\n        const onEvent = (event: HTMLElementEventMap[typeof eventName]) => {\n            if (beforeDispatch) {\n                beforeDispatch(event);\n            }\n            if (pluginEventType != null) {\n                core.api.triggerEvent(\n                    core,\n                    <PluginDomEvent>{\n                        eventType: pluginEventType,\n                        rawEvent: event,\n                    },\n                    false /*broadcast*/\n                );\n            }\n        };\n\n        core.contentDiv.addEventListener(eventName, onEvent);\n\n        return () => {\n            core.contentDiv.removeEventListener(eventName, onEvent);\n        };\n    });\n    return () => disposers.forEach(disposers => disposers());\n};\n\nfunction extractHandler(handlerObj: DOMEventHandler): DOMEventHandlerObject {\n    let result: DOMEventHandlerObject = {\n        pluginEventType: null,\n        beforeDispatch: null,\n    };\n\n    if (typeof handlerObj === 'number') {\n        result.pluginEventType = handlerObj;\n    } else if (typeof handlerObj === 'function') {\n        result.beforeDispatch = handlerObj;\n    } else if (typeof handlerObj === 'object') {\n        result = handlerObj;\n    }\n    return result;\n}\n","import { addUndoSnapshot } from './addUndoSnapshot';\nimport { attachDomEvent } from './attachDomEvent';\nimport { ensureTypeInContainer } from './ensureTypeInContainer';\nimport { getContent } from './getContent';\nimport { getStyleBasedFormatState } from './getStyleBasedFormatState';\nimport { insertNode } from './insertNode';\nimport { restoreUndoSnapshot } from './restoreUndoSnapshot';\nimport { setContent } from './setContent';\nimport { transformColor } from './transformColor';\nimport { triggerEvent } from './triggerEvent';\nimport type { UnportedCoreApiMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const coreApiMap: UnportedCoreApiMap = {\n    attachDomEvent,\n    addUndoSnapshot,\n    ensureTypeInContainer,\n    getContent,\n    getStyleBasedFormatState,\n    insertNode,\n    restoreUndoSnapshot,\n    setContent,\n    transformColor,\n    triggerEvent,\n};\n","import { ContentPosition, KnownCreateElementDataIndex, PositionType } from 'roosterjs-editor-types';\nimport {\n    createElement,\n    createRange,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    isNodeEmpty,\n    Position,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\nimport type { EnsureTypeInContainer } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * When typing goes directly under content div, many things can go wrong\n * We fix it by wrapping it with a div and reposition cursor within the div\n */\nexport const ensureTypeInContainer: EnsureTypeInContainer = (core, position, keyboardEvent) => {\n    const table = findClosestElementAncestor(position.node, core.contentDiv, 'table');\n    let td: HTMLElement | null;\n\n    if (table && (td = table.querySelector('td,th'))) {\n        position = new Position(td, PositionType.Begin);\n    }\n    position = position.normalize();\n\n    const block = getBlockElementAtNode(core.contentDiv, position.node);\n    let formatNode: HTMLElement | null;\n\n    if (block) {\n        formatNode = block.collapseToSingleElement();\n        if (isNodeEmpty(formatNode, false /* trimContent */, true /* shouldCountBrAsVisible */)) {\n            const brEl = formatNode.ownerDocument.createElement('br');\n            formatNode.append(brEl);\n        }\n        // if the block is empty, apply default format\n        // Otherwise, leave it as it is as we don't want to change the style for existing data\n        // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\n        const shouldSetNodeStyles =\n            isNodeEmpty(formatNode) ||\n            (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));\n        formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\n    } else {\n        // Only reason we don't get the selection block is that we have an empty content div\n        // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\n        // The fix is to add a DIV wrapping, apply default format and move cursor over\n        formatNode = createElement(\n            KnownCreateElementDataIndex.EmptyLine,\n            core.contentDiv.ownerDocument\n        ) as HTMLElement;\n        core.api.insertNode(core, formatNode, {\n            position: ContentPosition.End,\n            updateCursor: false,\n            replaceSelection: false,\n            insertOnNewLine: false,\n        });\n\n        // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\n        position = new Position(formatNode, PositionType.Begin);\n    }\n\n    // If this is triggered by a keyboard event, let's select the new position\n    if (keyboardEvent) {\n        core.api.setDOMSelection(core, {\n            type: 'range',\n            range: createRange(new Position(position)),\n        });\n    }\n};\n\nfunction wasNodeJustCreatedByKeyboardEvent(event: KeyboardEvent, formatNode: HTMLElement) {\n    return (\n        safeInstanceOf(event.target, 'Node') &&\n        event.target.contains(formatNode) &&\n        event.key === formatNode.innerText\n    );\n}\n","import { ColorTransformDirection, GetContentMode, PluginEventType } from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getHtmlWithSelectionPath,\n    getSelectionPath,\n    getTextContent,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\nimport type { GetContent } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Get current editor content as HTML string\n * @param core The StandaloneEditorCore object\n * @param mode specify what kind of HTML content to retrieve\n * @returns HTML string representing current editor content\n */\nexport const getContent: GetContent = (core, mode): string => {\n    let content: string | null = '';\n    const triggerExtractContentEvent = mode == GetContentMode.CleanHTML;\n    const includeSelectionMarker = mode == GetContentMode.RawHTMLWithSelection;\n\n    // When there is fragment for shadow edit, always use the cached fragment as document since HTML node in editor\n    // has been changed by uncommitted shadow edit which should be ignored.\n    const root = core.lifecycle.shadowEditFragment || core.contentDiv;\n\n    if (mode == GetContentMode.PlainTextFast) {\n        content = root.textContent;\n    } else if (mode == GetContentMode.PlainText) {\n        content = getTextContent(root);\n    } else {\n        const clonedRoot = cloneNode(root);\n        clonedRoot.normalize();\n\n        const originalRange = core.api.getDOMSelection(core);\n        const path =\n            !includeSelectionMarker || core.lifecycle.shadowEditFragment\n                ? null\n                : originalRange?.type == 'range'\n                ? getSelectionPath(core.contentDiv, originalRange.range)\n                : null;\n        const range = path && createRange(clonedRoot, path.start, path.end);\n\n        core.api.transformColor(\n            core,\n            clonedRoot,\n            false /*includeSelf*/,\n            null /*callback*/,\n            ColorTransformDirection.DarkToLight,\n            true /*forceTransform*/,\n            core.lifecycle.isDarkMode\n        );\n\n        if (triggerExtractContentEvent) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.ExtractContentWithDom,\n                    clonedRoot,\n                },\n                true /*broadcast*/\n            );\n\n            content = clonedRoot.innerHTML;\n        } else if (range) {\n            // range is not null, which means we want to include a selection path in the content\n            content = getHtmlWithSelectionPath(clonedRoot, range);\n        } else {\n            content = clonedRoot.innerHTML;\n        }\n    }\n\n    return content ?? '';\n};\n\nfunction cloneNode(node: HTMLElement | DocumentFragment): HTMLElement {\n    let clonedNode: HTMLElement;\n    if (safeInstanceOf(node, 'DocumentFragment')) {\n        clonedNode = node.ownerDocument.createElement('div');\n        clonedNode.appendChild(node.cloneNode(true /*deep*/));\n    } else {\n        clonedNode = node.cloneNode(true /*deep*/) as HTMLElement;\n    }\n\n    return clonedNode;\n}\n","import { contains, getComputedStyles } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\nimport type { GetStyleBasedFormatState } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Get style based format state from current selection, including font name/size and colors\n * @param core The StandaloneEditorCore objects\n * @param node The node to get style from\n */\nexport const getStyleBasedFormatState: GetStyleBasedFormatState = (core, node) => {\n    if (!node) {\n        return {};\n    }\n\n    const styles = node\n        ? getComputedStyles(node, [\n              'font-family',\n              'font-size',\n              'color',\n              'background-color',\n              'line-height',\n              'margin-top',\n              'margin-bottom',\n              'text-align',\n              'direction',\n              'font-weight',\n          ])\n        : [];\n    const { contentDiv, darkColorHandler } = core;\n\n    let styleTextColor: string | undefined;\n    let styleBackColor: string | undefined;\n\n    while (\n        node &&\n        contains(contentDiv, node, true /*treatSameNodeAsContain*/) &&\n        !(styleTextColor && styleBackColor)\n    ) {\n        if (node.nodeType == NodeType.Element) {\n            const element = node as HTMLElement;\n\n            styleTextColor = styleTextColor || element.style.getPropertyValue('color');\n            styleBackColor = styleBackColor || element.style.getPropertyValue('background-color');\n        }\n        node = node.parentNode;\n    }\n\n    if (!core.lifecycle.isDarkMode && node == core.contentDiv) {\n        styleTextColor = styleTextColor || styles[2];\n        styleBackColor = styleBackColor || styles[3];\n    }\n\n    const textColor = darkColorHandler.parseColorValue(styleTextColor);\n    const backColor = darkColorHandler.parseColorValue(styleBackColor);\n\n    return {\n        fontName: styles[0],\n        fontSize: styles[1],\n        textColor: textColor.lightModeColor,\n        backgroundColor: backColor.lightModeColor,\n        textColors: textColor.darkModeColor\n            ? {\n                  lightModeColor: textColor.lightModeColor,\n                  darkModeColor: textColor.darkModeColor,\n              }\n            : undefined,\n        backgroundColors: backColor.darkModeColor\n            ? {\n                  lightModeColor: backColor.lightModeColor,\n                  darkModeColor: backColor.darkModeColor,\n              }\n            : undefined,\n        lineHeight: styles[4],\n        marginTop: styles[5],\n        marginBottom: styles[6],\n        textAlign: styles[7],\n        direction: styles[8],\n        fontWeight: styles[9],\n    };\n};\n","import type { BlockElement, InsertOption, NodePosition } from 'roosterjs-editor-types';\nimport {\n    ContentPosition,\n    ColorTransformDirection,\n    NodeType,\n    PositionType,\n    RegionType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getBlockElementAtNode,\n    getFirstLastBlockElement,\n    isBlockElement,\n    isVoidHtmlElement,\n    Position,\n    safeInstanceOf,\n    toArray,\n    wrap,\n    adjustInsertPosition,\n    getRegionsFromRange,\n    splitTextNode,\n    splitParentNode,\n} from 'roosterjs-editor-dom';\nimport type { InsertNode, StandaloneEditorCore } from 'roosterjs-content-model-types';\n\nfunction getInitialRange(\n    core: StandaloneEditorCore,\n    option: InsertOption\n): { range: Range | null; rangeToRestore: Range | null } {\n    // Selection start replaces based on the current selection.\n    // Range inserts based on a provided range.\n    // Both have the potential to use the current selection to restore cursor position\n    // So in both cases we need to store the selection state.\n    const selection = core.api.getDOMSelection(core);\n    let range = selection?.type == 'range' ? selection.range : null;\n    let rangeToRestore = null;\n    if (option.position == ContentPosition.Range) {\n        rangeToRestore = range;\n        range = option.range;\n    } else if (range) {\n        rangeToRestore = range.cloneRange();\n    }\n\n    return { range, rangeToRestore };\n}\n\n/**\n * @internal\n * Insert a DOM node into editor content\n * @param core The StandaloneEditorCore object. No op if null.\n * @param option An insert option object to specify how to insert the node\n */\nexport const insertNode: InsertNode = (\n    core: StandaloneEditorCore,\n    node: Node,\n    option: InsertOption | null\n) => {\n    option = option || {\n        position: ContentPosition.SelectionStart,\n        insertOnNewLine: false,\n        updateCursor: true,\n        replaceSelection: true,\n        insertToRegionRoot: false,\n    };\n    const contentDiv = core.contentDiv;\n\n    if (option.updateCursor) {\n        core.api.focus(core);\n    }\n\n    if (option.position == ContentPosition.Outside) {\n        contentDiv.parentNode?.insertBefore(node, contentDiv.nextSibling);\n        return true;\n    }\n\n    core.api.transformColor(\n        core,\n        node,\n        true /*includeSelf*/,\n        () => {\n            if (!option) {\n                return;\n            }\n            switch (option.position) {\n                case ContentPosition.Begin:\n                case ContentPosition.End: {\n                    const isBegin = option.position == ContentPosition.Begin;\n                    const block = getFirstLastBlockElement(contentDiv, isBegin);\n                    let insertedNode: Node | Node[] | undefined;\n                    if (block) {\n                        const refNode = isBegin ? block.getStartNode() : block.getEndNode();\n                        if (\n                            option.insertOnNewLine ||\n                            refNode.nodeType == NodeType.Text ||\n                            isVoidHtmlElement(refNode)\n                        ) {\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\n                                // because insertBefore() returns an empty DocumentFragment\n                                insertedNode = toArray(node.childNodes);\n                                refNode.parentNode?.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            } else {\n                                insertedNode = refNode.parentNode?.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            }\n                        } else {\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\n                            insertedNode = refNode.insertBefore(\n                                node,\n                                isBegin ? refNode.firstChild : null\n                            );\n                        }\n                    } else {\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\n                        insertedNode = contentDiv.appendChild(node);\n                    }\n\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine) {\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\n                            wrap(nodes);\n                        }\n                    }\n\n                    break;\n                }\n                case ContentPosition.DomEnd:\n                    // Use appendChild to insert the node at the end of the content div.\n                    const insertedNode = contentDiv.appendChild(node);\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\n                        wrap(insertedNode);\n                    }\n                    break;\n                case ContentPosition.Range:\n                case ContentPosition.SelectionStart:\n                    let { range, rangeToRestore } = getInitialRange(core, option);\n                    if (!range) {\n                        return;\n                    }\n\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\n                    if (option.replaceSelection && !range.collapsed) {\n                        range.deleteContents();\n                    }\n\n                    let pos: NodePosition = Position.getStart(range);\n                    let blockElement: BlockElement | null;\n\n                    if (option.insertOnNewLine && option.insertToRegionRoot) {\n                        pos = adjustInsertPositionRegionRoot(core, range, pos);\n                    } else if (\n                        option.insertOnNewLine &&\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\n                    ) {\n                        pos = adjustInsertPositionNewLine(blockElement, core, pos);\n                    } else {\n                        pos = adjustInsertPosition(contentDiv, node, pos, range);\n                    }\n\n                    const nodeForCursor =\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\n\n                    range = createRange(pos);\n                    range.insertNode(node);\n\n                    if (option.updateCursor && nodeForCursor) {\n                        rangeToRestore = createRange(\n                            new Position(nodeForCursor, PositionType.After).normalize()\n                        );\n                    }\n\n                    if (rangeToRestore) {\n                        core.api.setDOMSelection(core, {\n                            type: 'range',\n                            range: rangeToRestore,\n                        });\n                    }\n\n                    break;\n            }\n        },\n        ColorTransformDirection.LightToDark\n    );\n\n    return true;\n};\n\nfunction adjustInsertPositionRegionRoot(\n    core: StandaloneEditorCore,\n    range: Range,\n    position: NodePosition\n) {\n    const region = getRegionsFromRange(core.contentDiv, range, RegionType.Table)[0];\n    let node: Node | null = position.node;\n\n    if (region) {\n        if (node.nodeType == NodeType.Text && !position.isAtEnd) {\n            node = splitTextNode(node as Text, position.offset, true /*returnFirstPart*/);\n        }\n\n        if (node != region.rootNode) {\n            while (node && node.parentNode != region.rootNode) {\n                splitParentNode(node, false /*splitBefore*/);\n                node = node.parentNode;\n            }\n        }\n\n        if (node) {\n            position = new Position(node, PositionType.After);\n        }\n    }\n\n    return position;\n}\n\nfunction adjustInsertPositionNewLine(\n    blockElement: BlockElement,\n    core: StandaloneEditorCore,\n    pos: Position\n) {\n    let tempPos = new Position(blockElement.getEndNode(), PositionType.After);\n    if (safeInstanceOf(tempPos.node, 'HTMLTableRowElement')) {\n        const div = core.contentDiv.ownerDocument.createElement('div');\n        const range = createRange(pos);\n        range.insertNode(div);\n        tempPos = new Position(div, PositionType.Begin);\n    }\n    return tempPos;\n}\n","import { EntityOperation, PluginEventType } from 'roosterjs-editor-types';\nimport { getEntityFromElement, getEntitySelector, queryElements } from 'roosterjs-editor-dom';\nimport type { RestoreUndoSnapshot } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Restore an undo snapshot into editor\n * @param core The editor core object\n * @param step Steps to move, can be 0, positive or negative\n */\nexport const restoreUndoSnapshot: RestoreUndoSnapshot = (core, step) => {\n    if (core.undo.hasNewContent && step < 0) {\n        core.api.addUndoSnapshot(\n            core,\n            null /*callback*/,\n            null /*changeSource*/,\n            false /*canUndoByBackspace*/\n        );\n    }\n\n    const snapshot = core.undo.snapshotsService.move(step);\n\n    if (snapshot && snapshot.html != null) {\n        try {\n            core.undo.isRestoring = true;\n            core.api.setContent(\n                core,\n                snapshot.html,\n                true /*triggerContentChangedEvent*/,\n                snapshot.metadata ?? undefined\n            );\n\n            const darkColorHandler = core.darkColorHandler;\n            const isDarkModel = core.lifecycle.isDarkMode;\n\n            snapshot.knownColors.forEach(color => {\n                darkColorHandler.registerColor(\n                    color.lightModeColor,\n                    isDarkModel,\n                    color.darkModeColor\n                );\n            });\n\n            snapshot.entityStates?.forEach(entityState => {\n                const { type, id, state } = entityState;\n                const wrapper = queryElements(\n                    core.contentDiv,\n                    getEntitySelector(type, id)\n                )[0] as HTMLElement;\n                const entity = wrapper && getEntityFromElement(wrapper);\n\n                if (entity) {\n                    core.api.triggerEvent(\n                        core,\n                        {\n                            eventType: PluginEventType.EntityOperation,\n                            operation: EntityOperation.UpdateEntityState,\n                            entity: entity,\n                            state,\n                        },\n                        false\n                    );\n                }\n            });\n        } finally {\n            core.undo.isRestoring = false;\n        }\n    }\n};\n","import { ChangeSource, ColorTransformDirection, PluginEventType } from 'roosterjs-editor-types';\nimport { convertMetadataToDOMSelection } from '../editor/utils/selectionConverter';\nimport { extractContentMetadata, restoreContentWithEntityPlaceholder } from 'roosterjs-editor-dom';\nimport type { ContentMetadata } from 'roosterjs-editor-types';\nimport type { SetContent, StandaloneEditorCore } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n * if triggerContentChangedEvent is set to true\n * @param core The StandaloneEditorCore object\n * @param content HTML content to set in\n * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n * @param metadata @optional Metadata of the content that helps editor know the selection and color mode.\n * If not passed, we will treat content as in light mode without selection\n */\nexport const setContent: SetContent = (core, content, triggerContentChangedEvent, metadata) => {\n    let contentChanged = false;\n    if (core.contentDiv.innerHTML != content) {\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: PluginEventType.BeforeSetContent,\n                newContent: content,\n            },\n            true /*broadcast*/\n        );\n\n        const entities = core.entity.entityMap;\n        const html = content || '';\n        const body = new DOMParser().parseFromString(\n            core.trustedHTMLHandler?.(html) ?? html,\n            'text/html'\n        ).body;\n\n        restoreContentWithEntityPlaceholder(body, core.contentDiv, entities);\n\n        const metadataFromContent = extractContentMetadata(core.contentDiv);\n        metadata = metadata || metadataFromContent;\n        selectContentMetadata(core, metadata);\n        contentChanged = true;\n    }\n\n    const isDarkMode = core.lifecycle.isDarkMode;\n\n    if ((!metadata && isDarkMode) || (metadata && !!metadata.isDarkMode != !!isDarkMode)) {\n        core.api.transformColor(\n            core,\n            core.contentDiv,\n            false /*includeSelf*/,\n            null /*callback*/,\n            isDarkMode ? ColorTransformDirection.LightToDark : ColorTransformDirection.DarkToLight,\n            true /*forceTransform*/,\n            metadata?.isDarkMode\n        );\n        contentChanged = true;\n    }\n\n    if (triggerContentChangedEvent && contentChanged) {\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: PluginEventType.ContentChanged,\n                source: ChangeSource.SetContent,\n            },\n            false /*broadcast*/\n        );\n    }\n};\n\nfunction selectContentMetadata(core: StandaloneEditorCore, metadata: ContentMetadata | undefined) {\n    if (!core.lifecycle.shadowEditFragment && metadata) {\n        const selection = convertMetadataToDOMSelection(core.contentDiv, metadata);\n\n        if (selection) {\n            core.api.setDOMSelection(core, selection);\n        }\n    }\n}\n","import { ColorTransformDirection } from 'roosterjs-editor-types';\nimport type { TransformColor } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Edit and transform color of elements between light mode and dark mode\n * @param core The StandaloneEditorCore object\n * @param rootNode The root HTML elements to transform\n * @param includeSelf True to transform the root node as well, otherwise false\n * @param callback The callback function to invoke before do color transformation\n * @param direction To specify the transform direction, light to dark, or dark to light\n * @param forceTransform By default this function will only work when editor core is in dark mode.\n * Pass true to this value to force do color transformation even editor core is in light mode\n */\nexport const transformColor: TransformColor = (\n    core,\n    rootNode,\n    includeSelf,\n    callback,\n    direction,\n    forceTransform,\n    fromDarkMode = false\n) => {\n    const {\n        darkColorHandler,\n        lifecycle: { onExternalContentTransform },\n    } = core;\n    const toDarkMode = direction == ColorTransformDirection.LightToDark;\n    if (rootNode && (forceTransform || core.lifecycle.isDarkMode)) {\n        const transformer = onExternalContentTransform\n            ? (element: HTMLElement) => {\n                  onExternalContentTransform(element, fromDarkMode, toDarkMode, darkColorHandler);\n              }\n            : (element: HTMLElement) => {\n                  darkColorHandler.transformElementColor(element, fromDarkMode, toDarkMode);\n              };\n\n        iterateElements(rootNode, transformer, includeSelf);\n    }\n\n    callback?.();\n};\n\nfunction iterateElements(\n    root: Node,\n    transformer: (element: HTMLElement) => void,\n    includeSelf?: boolean\n) {\n    if (includeSelf && isHTMLElement(root)) {\n        transformer(root);\n    }\n\n    for (let child = root.firstChild; child; child = child.nextSibling) {\n        if (isHTMLElement(child)) {\n            transformer(child);\n        }\n\n        iterateElements(child, transformer);\n    }\n}\n\n// This is not a strict check, we just need to make sure this element has style so that we can set style to it\n// We don't use safeInstanceOf() here since this function will be called very frequently when extract html content\n// in dark mode, so we need to make sure this check is fast enough\nfunction isHTMLElement(node: Node): node is HTMLElement {\n    const htmlElement = <HTMLElement>node;\n    return node.nodeType == Node.ELEMENT_NODE && !!htmlElement.style;\n}\n","import { PluginEventType } from 'roosterjs-editor-types';\nimport type { TriggerEvent } from 'roosterjs-content-model-types';\nimport type { EditorPlugin, PluginEvent } from 'roosterjs-editor-types';\nimport type { CompatiblePluginEventType } from 'roosterjs-editor-types/lib/compatibleTypes';\n\nconst allowedEventsInShadowEdit: (PluginEventType | CompatiblePluginEventType)[] = [\n    PluginEventType.EditorReady,\n    PluginEventType.BeforeDispose,\n    PluginEventType.ExtractContentWithDom,\n    PluginEventType.ZoomChanged,\n];\n\n/**\n * @internal\n * Trigger a plugin event\n * @param core The StandaloneEditorCore object\n * @param pluginEvent The event object to trigger\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\n */\nexport const triggerEvent: TriggerEvent = (core, pluginEvent, broadcast) => {\n    if (\n        (!core.lifecycle.shadowEditFragment ||\n            allowedEventsInShadowEdit.indexOf(pluginEvent.eventType) >= 0) &&\n        (broadcast || !core.plugins.some(plugin => handledExclusively(pluginEvent, plugin)))\n    ) {\n        core.plugins.forEach(plugin => {\n            if (plugin.onPluginEvent) {\n                plugin.onPluginEvent(pluginEvent);\n            }\n        });\n    }\n};\n\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\n    if (plugin.onPluginEvent && plugin.willHandleEventExclusively?.(event)) {\n        plugin.onPluginEvent(event);\n        return true;\n    }\n\n    return false;\n}\n","import { isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\nimport { Keys, PluginEventType } from 'roosterjs-editor-types';\nimport type {\n    EditPluginState,\n    GenericContentEditFeature,\n    IEditor,\n    PluginEvent,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * Edit Component helps handle Content edit features\n */\nclass EditPlugin implements PluginWithState<EditPluginState> {\n    private editor: IEditor | null = null;\n    private state: EditPluginState;\n\n    /**\n     * Construct a new instance of EditPlugin\n     * @param options The editor options\n     */\n    constructor() {\n        this.state = {\n            features: {},\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Edit';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        let hasFunctionKey = false;\n        let features: GenericContentEditFeature<PluginEvent>[] | null = null;\n        let ctrlOrMeta = false;\n        const isKeyDownEvent = event.eventType == PluginEventType.KeyDown;\n\n        if (isKeyDownEvent) {\n            const rawEvent = event.rawEvent;\n            const range = this.editor?.getSelectionRange();\n\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\n            features =\n                this.state.features[rawEvent.which] ||\n                (range && !range.collapsed && this.state.features[Keys.RANGE]);\n        } else if (event.eventType == PluginEventType.ContentChanged) {\n            features = this.state.features[Keys.CONTENTCHANGED];\n        }\n\n        for (let i = 0; features && i < features?.length; i++) {\n            const feature = features[i];\n            if (\n                (feature.allowFunctionKeys || !hasFunctionKey) &&\n                this.editor &&\n                feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\n            ) {\n                feature.handleEvent(event, this.editor);\n                if (isKeyDownEvent) {\n                    event.handledByEditFeature = true;\n                }\n                break;\n            }\n        }\n    }\n}\n\n/**\n * @internal\n * Create a new instance of EditPlugin.\n */\nexport function createEditPlugin(): PluginWithState<EditPluginState> {\n    return new EditPlugin();\n}\n","import { convertDomSelectionToRangeEx } from '../editor/utils/selectionConverter';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type { ContentModelSelectionChangedEvent } from 'roosterjs-content-model-types';\nimport type { EditorPlugin, PluginEvent, SelectionChangedEvent } from 'roosterjs-editor-types';\n\n/**\n * Translate Standalone editor event type to legacy event type\n */\nclass EventTypeTranslatePlugin implements EditorPlugin {\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'EventTypeTranslate';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize() {}\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {}\n\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.SelectionChanged:\n                if (!event.selectionRangeEx && isContentModelSelectionChangedEvent(event)) {\n                    event.selectionRangeEx = convertDomSelectionToRangeEx(event.newSelection);\n                }\n                break;\n        }\n    }\n}\n\nfunction isContentModelSelectionChangedEvent(\n    event: SelectionChangedEvent\n): event is ContentModelSelectionChangedEvent {\n    return !!(event as ContentModelSelectionChangedEvent).newSelection;\n}\n\n/**\n * @internal\n * Create a new instance of EventTypeTranslatePlugin.\n */\nexport function createEventTypeTranslatePlugin(): EditorPlugin {\n    return new EventTypeTranslatePlugin();\n}\n","import { PluginEventType, SelectionRangeTypes } from 'roosterjs-editor-types';\nimport {\n    changeElementTag,\n    getTagOfNode,\n    moveChildNodes,\n    safeInstanceOf,\n    toArray,\n} from 'roosterjs-editor-dom';\nimport type { EditorPlugin, IEditor, PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * TODO: Rename this plugin since it is not only for table now\n *\n * NormalizeTable plugin makes sure each table in editor has TBODY/THEAD/TFOOT tag around TR tags\n *\n * When we retrieve HTML content using innerHTML, browser will always add TBODY around TR nodes if there is not.\n * This causes some issue when we restore the HTML content with selection path since the selection path is\n * deeply coupled with DOM structure. So we need to always make sure there is already TBODY tag whenever\n * new table is inserted, to make sure the selection path we created is correct.\n */\nclass NormalizeTablePlugin implements EditorPlugin {\n    private editor: IEditor | null = null;\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'NormalizeTable';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n            case PluginEventType.ContentChanged:\n                if (this.editor) {\n                    this.normalizeTables(this.editor.queryElements('table'));\n                }\n                break;\n\n            case PluginEventType.BeforePaste:\n                this.normalizeTables(toArray(event.fragment.querySelectorAll('table')));\n                break;\n\n            case PluginEventType.MouseDown:\n                this.normalizeTableFromEvent(event.rawEvent);\n                break;\n\n            case PluginEventType.KeyDown:\n                if (event.rawEvent.shiftKey) {\n                    this.normalizeTableFromEvent(event.rawEvent);\n                }\n                break;\n\n            case PluginEventType.ExtractContentWithDom:\n                normalizeListsForExport(event.clonedRoot);\n                break;\n        }\n    }\n\n    private normalizeTableFromEvent(event: KeyboardEvent | MouseEvent) {\n        const table = this.editor?.getElementAtCursor('table', event.target as Node);\n\n        if (table) {\n            this.normalizeTables([<HTMLTableElement>table]);\n        }\n    }\n\n    private normalizeTables(tables: HTMLTableElement[]) {\n        if (this.editor && tables.length > 0) {\n            const rangeEx = this.editor.getSelectionRangeEx();\n            const { startContainer, endContainer, startOffset, endOffset } =\n                (rangeEx?.type == SelectionRangeTypes.Normal && rangeEx.ranges[0]) || {};\n\n            const isChanged = normalizeTables(tables);\n\n            if (isChanged) {\n                if (\n                    startContainer &&\n                    endContainer &&\n                    typeof startOffset === 'number' &&\n                    typeof endOffset === 'number'\n                ) {\n                    this.editor.select(startContainer, startOffset, endContainer, endOffset);\n                } else if (\n                    rangeEx?.type == SelectionRangeTypes.TableSelection &&\n                    rangeEx.coordinates\n                ) {\n                    this.editor.select(rangeEx.table, rangeEx.coordinates);\n                }\n            }\n        }\n    }\n}\n\nfunction normalizeTables(tables: HTMLTableElement[]) {\n    let isDOMChanged = false;\n    tables.forEach(table => {\n        let tbody: HTMLTableSectionElement | null = null;\n\n        for (let child = table.firstChild; child; child = child.nextSibling) {\n            const tag = getTagOfNode(child);\n            switch (tag) {\n                case 'TR':\n                    if (!tbody) {\n                        tbody = table.ownerDocument.createElement('tbody');\n                        table.insertBefore(tbody, child);\n                    }\n\n                    tbody.appendChild(child);\n                    child = tbody;\n                    isDOMChanged = true;\n\n                    break;\n                case 'TBODY':\n                    if (tbody) {\n                        moveChildNodes(tbody, child, true /*keepExistingChildren*/);\n                        child.parentNode?.removeChild(child);\n                        child = tbody;\n                        isDOMChanged = true;\n                    } else {\n                        tbody = child as HTMLTableSectionElement;\n                    }\n                    break;\n                default:\n                    tbody = null;\n                    break;\n            }\n        }\n\n        const colgroups = table.querySelectorAll('colgroup');\n        const thead = table.querySelector('thead');\n        if (thead) {\n            colgroups.forEach(colgroup => {\n                if (!thead.contains(colgroup)) {\n                    thead.appendChild(colgroup);\n                }\n            });\n        }\n    });\n\n    return isDOMChanged;\n}\n\nfunction normalizeListsForExport(root: ParentNode) {\n    toArray(root.querySelectorAll('li')).forEach(li => {\n        const prevElement = li.previousSibling;\n\n        if (li.style.display == 'block' && safeInstanceOf(prevElement, 'HTMLLIElement')) {\n            li.style.removeProperty('display');\n\n            prevElement.appendChild(changeElementTag(li, 'div'));\n        }\n    });\n}\n\n/**\n * @internal\n * Create a new instance of NormalizeTablePlugin.\n */\nexport function createNormalizeTablePlugin(): EditorPlugin {\n    return new NormalizeTablePlugin();\n}\n","import { createEditPlugin } from './EditPlugin';\nimport { createEventTypeTranslatePlugin } from './EventTypeTranslatePlugin';\nimport { createNormalizeTablePlugin } from './NormalizeTablePlugin';\nimport type { UnportedCorePlugins } from '../publicTypes/ContentModelCorePlugins';\nimport type { UnportedCorePluginState } from 'roosterjs-content-model-types';\nimport type { ContentModelEditorOptions } from '../publicTypes/IContentModelEditor';\n\n/**\n * @internal\n * Create Core Plugins\n * @param options Editor options\n */\nexport function createCorePlugins(options: ContentModelEditorOptions): UnportedCorePlugins {\n    const map = options.corePluginOverride || {};\n\n    // The order matters, some plugin needs to be put before/after others to make sure event\n    // can be handled in right order\n    return {\n        eventTranslate: map.eventTranslate || createEventTypeTranslatePlugin(),\n        edit: map.edit || createEditPlugin(),\n        normalizeTable: map.normalizeTable || createNormalizeTablePlugin(),\n    };\n}\n\n/**\n * @internal\n * Get plugin state of core plugins\n * @param corePlugins ContentModelCorePlugins object\n */\nexport function getPluginState(corePlugins: UnportedCorePlugins): UnportedCorePluginState {\n    return {\n        edit: corePlugins.edit.getState(),\n    };\n}\n","import { buildRangeEx } from './utils/buildRangeEx';\nimport { createEditorCore } from './createEditorCore';\nimport { getObjectKeys } from 'roosterjs-content-model-dom';\nimport { getPendableFormatState } from './utils/getPendableFormatState';\nimport { isBold, paste } from 'roosterjs-content-model-core';\nimport {\n    ChangeSource,\n    ColorTransformDirection,\n    ContentPosition,\n    GetContentMode,\n    PluginEventType,\n    QueryScope,\n    RegionType,\n} from 'roosterjs-editor-types';\nimport type {\n    BlockElement,\n    ClipboardData,\n    ContentChangedData,\n    DOMEventHandler,\n    DarkColorHandler,\n    DefaultFormat,\n    EditorUndoState,\n    ExperimentalFeatures,\n    GenericContentEditFeature,\n    IContentTraverser,\n    IPositionContentSearcher,\n    InsertOption,\n    NodePosition,\n    PendableFormatState,\n    PluginEvent,\n    PluginEventData,\n    PluginEventFromType,\n    PositionType,\n    Rect,\n    Region,\n    SelectionPath,\n    SelectionRangeEx,\n    SizeTransformer,\n    StyleBasedFormatState,\n    TableSelection,\n    TrustedHTMLHandler,\n} from 'roosterjs-editor-types';\nimport {\n    convertDomSelectionToRangeEx,\n    convertRangeExToDomSelection,\n} from './utils/selectionConverter';\nimport type {\n    CompatibleChangeSource,\n    CompatibleColorTransformDirection,\n    CompatibleContentPosition,\n    CompatibleExperimentalFeatures,\n    CompatibleGetContentMode,\n    CompatiblePluginEventType,\n    CompatibleQueryScope,\n    CompatibleRegionType,\n} from 'roosterjs-editor-types/lib/compatibleTypes';\nimport {\n    ContentTraverser,\n    Position,\n    PositionContentSearcher,\n    cacheGetEventData,\n    collapseNodes,\n    contains,\n    deleteSelectedContent,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    getRegionsFromRange,\n    getSelectionPath,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    queryElements,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport type { ContentModelEditorCore } from '../publicTypes/ContentModelEditorCore';\nimport type {\n    ContentModelEditorOptions,\n    IContentModelEditor,\n} from '../publicTypes/IContentModelEditor';\nimport type {\n    ContentModelDocument,\n    ContentModelSegmentFormat,\n    DOMSelection,\n    DomToModelOption,\n    ModelToDomOption,\n    OnNodeCreated,\n    ContentModelFormatter,\n    FormatWithContentModelOptions,\n    EditorEnvironment,\n} from 'roosterjs-content-model-types';\n\n/**\n * Editor for Content Model.\n * (This class is still under development, and may still be changed in the future with some breaking changes)\n */\nexport class ContentModelEditor implements IContentModelEditor {\n    private core: ContentModelEditorCore | null = null;\n\n    /**\n     * Creates an instance of Editor\n     * @param contentDiv The DIV HTML element which will be the container element of editor\n     * @param options An optional options object to customize the editor\n     */\n    constructor(contentDiv: HTMLDivElement, options: ContentModelEditorOptions = {}) {\n        this.core = createEditorCore(contentDiv, options);\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\n    }\n\n    /**\n     * Create Content Model from DOM tree in this editor\n     * @param option The option to customize the behavior of DOM to Content Model conversion\n     */\n    createContentModel(\n        option?: DomToModelOption,\n        selectionOverride?: DOMSelection\n    ): ContentModelDocument {\n        const core = this.getCore();\n\n        return core.api.createContentModel(core, option, selectionOverride);\n    }\n\n    /**\n     * Set content with content model\n     * @param model The content model to set\n     * @param option Additional options to customize the behavior of Content Model to DOM conversion\n     * @param onNodeCreated An optional callback that will be called when a DOM node is created\n     */\n    setContentModel(\n        model: ContentModelDocument,\n        option?: ModelToDomOption,\n        onNodeCreated?: OnNodeCreated\n    ): DOMSelection | null {\n        const core = this.getCore();\n\n        return core.api.setContentModel(core, model, option, onNodeCreated);\n    }\n\n    /**\n     * Get current running environment, such as if editor is running on Mac\n     */\n    getEnvironment(): EditorEnvironment {\n        return this.getCore().environment;\n    }\n\n    /**\n     * Get current DOM selection\n     */\n    getDOMSelection(): DOMSelection | null {\n        const core = this.getCore();\n\n        return core.api.getDOMSelection(core);\n    }\n\n    /**\n     * Set DOMSelection into editor content.\n     * This is the replacement of IEditor.select.\n     * @param selection The selection to set\n     */\n    setDOMSelection(selection: DOMSelection | null) {\n        const core = this.getCore();\n\n        core.api.setDOMSelection(core, selection);\n    }\n\n    /**\n     * The general API to do format change with Content Model\n     * It will grab a Content Model for current editor content, and invoke a callback function\n     * to do format change. Then according to the return value, write back the modified content model into editor.\n     * If there is cached model, it will be used and updated.\n     * @param formatter Formatter function, see ContentModelFormatter\n     * @param options More options, see FormatWithContentModelOptions\n     */\n    formatContentModel(\n        formatter: ContentModelFormatter,\n        options?: FormatWithContentModelOptions\n    ): void {\n        const core = this.getCore();\n\n        core.api.formatContentModel(core, formatter, options);\n    }\n\n    /**\n     * Get pending format of editor if any, or return null\n     */\n    getPendingFormat(): ContentModelSegmentFormat | null {\n        return this.getCore().format.pendingFormat?.format ?? null;\n    }\n\n    /**\n     * Dispose this editor, dispose all plugins and custom data\n     */\n    dispose(): void {\n        const core = this.getCore();\n\n        for (let i = core.plugins.length - 1; i >= 0; i--) {\n            const plugin = core.plugins[i];\n\n            try {\n                plugin.dispose();\n            } catch (e) {\n                // Cache the error and pass it out, then keep going since dispose should always succeed\n                core.disposeErrorHandler?.(plugin, e as Error);\n            }\n        }\n\n        getObjectKeys(core.customData).forEach(key => {\n            const data = core.customData[key];\n\n            if (data && data.disposer) {\n                data.disposer(data.value);\n            }\n\n            delete core.customData[key];\n        });\n\n        core.darkColorHandler.reset();\n\n        this.core = null;\n    }\n\n    /**\n     * Get whether this editor is disposed\n     * @returns True if editor is disposed, otherwise false\n     */\n    isDisposed(): boolean {\n        return !this.core;\n    }\n\n    /**\n     * Insert node into editor\n     * @param node The node to insert\n     * @param option Insert options. Default value is:\n     *  position: ContentPosition.SelectionStart\n     *  updateCursor: true\n     *  replaceSelection: true\n     *  insertOnNewLine: false\n     * @returns true if node is inserted. Otherwise false\n     */\n    insertNode(node: Node, option?: InsertOption): boolean {\n        const core = this.getCore();\n        return node ? core.api.insertNode(core, node, option ?? null) : false;\n    }\n\n    /**\n     * Delete a node from editor content\n     * @param node The node to delete\n     * @returns true if node is deleted. Otherwise false\n     */\n    deleteNode(node: Node): boolean {\n        // Only remove the node when it falls within editor\n        if (node && this.contains(node) && node.parentNode) {\n            node.parentNode.removeChild(node);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Replace a node in editor content with another node\n     * @param existingNode The existing node to be replaced\n     * @param toNode node to replace to\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\n     * @returns true if node is replaced. Otherwise false\n     */\n    replaceNode(existingNode: Node, toNode: Node, transformColorForDarkMode?: boolean): boolean {\n        const core = this.getCore();\n        // Only replace the node when it falls within editor\n        if (this.contains(existingNode) && toNode) {\n            core.api.transformColor(\n                core,\n                transformColorForDarkMode ? toNode : null,\n                true /*includeSelf*/,\n                () => existingNode.parentNode?.replaceChild(toNode, existingNode),\n                ColorTransformDirection.LightToDark\n            );\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get BlockElement at given node\n     * @param node The node to create InlineElement\n     * @returns The BlockElement result\n     */\n    getBlockElementAtNode(node: Node): BlockElement | null {\n        return getBlockElementAtNode(this.getCore().contentDiv, node);\n    }\n\n    contains(arg: Node | Range | null): boolean {\n        if (!arg) {\n            return false;\n        }\n        return contains(this.getCore().contentDiv, <Node>arg);\n    }\n\n    queryElements(\n        selector: string,\n        scopeOrCallback:\n            | QueryScope\n            | CompatibleQueryScope\n            | ((node: Node) => any) = QueryScope.Body,\n        callback?: (node: Node) => any\n    ) {\n        const core = this.getCore();\n        const result: HTMLElement[] = [];\n        const scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\n\n        const selectionEx = scope == QueryScope.Body ? null : this.getSelectionRangeEx();\n        if (selectionEx) {\n            selectionEx.ranges.forEach(range => {\n                result.push(...queryElements(core.contentDiv, selector, callback, scope, range));\n            });\n        } else {\n            return queryElements(core.contentDiv, selector, callback, scope, undefined /* range */);\n        }\n\n        return result;\n    }\n\n    /**\n     * Collapse nodes within the given start and end nodes to their common ancestor node,\n     * split parent nodes if necessary\n     * @param start The start node\n     * @param end The end node\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\n     * and the returned nodes will be all nodes from start through end after splitting\n     * False to disallow split parent\n     * @returns When canSplitParent is true, returns all node from start through end after splitting,\n     * otherwise just return start and end\n     */\n    collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\n        return collapseNodes(this.getCore().contentDiv, start, end, canSplitParent);\n    }\n\n    //#endregion\n\n    //#region Content API\n\n    /**\n     * Check whether the editor contains any visible content\n     * @param trim Whether trim the content string before check. Default is false\n     * @returns True if there's no visible content, otherwise false\n     */\n    isEmpty(trim?: boolean): boolean {\n        return isNodeEmpty(this.getCore().contentDiv, trim);\n    }\n\n    /**\n     * Get current editor content as HTML string\n     * @param mode specify what kind of HTML content to retrieve\n     * @returns HTML string representing current editor content\n     */\n    getContent(mode: GetContentMode | CompatibleGetContentMode = GetContentMode.CleanHTML): string {\n        const core = this.getCore();\n        return core.api.getContent(core, mode);\n    }\n\n    /**\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n     * @param content HTML content to set in\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n     */\n    setContent(content: string, triggerContentChangedEvent: boolean = true) {\n        const core = this.getCore();\n        core.api.setContent(core, content, triggerContentChangedEvent);\n    }\n\n    /**\n     * Insert HTML content into editor\n     * @param HTML content to insert\n     * @param option Insert options. Default value is:\n     *  position: ContentPosition.SelectionStart\n     *  updateCursor: true\n     *  replaceSelection: true\n     *  insertOnNewLine: false\n     */\n    insertContent(content: string, option?: InsertOption) {\n        if (content) {\n            const doc = this.getDocument();\n            const body = new DOMParser().parseFromString(\n                this.getCore().trustedHTMLHandler(content),\n                'text/html'\n            )?.body;\n            let allNodes = body?.childNodes ? toArray(body.childNodes) : [];\n\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\n            // separately to show up on its own line\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\n                allNodes = [wrap(allNodes)];\n            }\n\n            const fragment = doc.createDocumentFragment();\n            allNodes.forEach(node => fragment.appendChild(node));\n\n            this.insertNode(fragment, option);\n        }\n    }\n\n    /**\n     * Delete selected content\n     */\n    deleteSelectedContent(): NodePosition | null {\n        const range = this.getSelectionRange();\n        if (range && !range.collapsed) {\n            return deleteSelectedContent(this.getCore().contentDiv, range);\n        }\n        return null;\n    }\n\n    /**\n     * Paste into editor using a clipboardData object\n     * @param clipboardData Clipboard data retrieved from clipboard\n     * @param pasteAsText Force pasting as plain text. Default value is false\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\n     * false to keep original format.  Default value is false. When pasteAsText is true, this parameter is ignored\n     * @param pasteAsImage: When set to true, if the clipboardData contains a imageDataUri will paste the image to the editor\n     */\n    paste(\n        clipboardData: ClipboardData,\n        pasteAsText: boolean = false,\n        applyCurrentFormat: boolean = false,\n        pasteAsImage: boolean = false\n    ) {\n        paste(\n            this,\n            clipboardData,\n            pasteAsText\n                ? 'asPlainText'\n                : applyCurrentFormat\n                ? 'mergeFormat'\n                : pasteAsImage\n                ? 'asImage'\n                : 'normal'\n        );\n    }\n\n    //#endregion\n\n    //#region Focus and Selection\n\n    /**\n     * Get current selection range from Editor.\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\n     * Default value is true\n     * @returns current selection range, or null if editor never got focus before\n     */\n    getSelectionRange(tryGetFromCache: boolean = true): Range | null {\n        const selection = this.getDOMSelection();\n\n        return selection?.type == 'range' ? selection.range : null;\n    }\n\n    /**\n     * Get current selection range from Editor.\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\n     * Default value is true\n     * @returns current selection range, or null if editor never got focus before\n     */\n    getSelectionRangeEx(): SelectionRangeEx {\n        const selection = this.getDOMSelection();\n\n        return convertDomSelectionToRangeEx(selection);\n    }\n\n    /**\n     * Get current selection in a serializable format\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\n     * @returns current selection path, or null if editor never got focus before\n     */\n    getSelectionPath(): SelectionPath | null {\n        const range = this.getSelectionRange();\n        return range && getSelectionPath(this.getCore().contentDiv, range);\n    }\n\n    /**\n     * Check if focus is in editor now\n     * @returns true if focus is in editor, otherwise false\n     */\n    hasFocus(): boolean {\n        const core = this.getCore();\n        return core.api.hasFocus(core);\n    }\n\n    /**\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\n     */\n    focus() {\n        const core = this.getCore();\n        core.api.focus(core);\n    }\n\n    select(\n        arg1: Range | SelectionRangeEx | NodePosition | Node | SelectionPath | null,\n        arg2?: NodePosition | number | PositionType | TableSelection | null,\n        arg3?: Node,\n        arg4?: number | PositionType\n    ): boolean {\n        const core = this.getCore();\n        const rangeEx = buildRangeEx(core, arg1, arg2, arg3, arg4);\n        const selection = convertRangeExToDomSelection(rangeEx);\n\n        this.setDOMSelection(selection);\n        return true;\n    }\n\n    /**\n     * Get current focused position. Return null if editor doesn't have focus at this time.\n     */\n    getFocusedPosition(): NodePosition | null {\n        const sel = this.getDocument().defaultView?.getSelection();\n        if (sel?.focusNode && this.contains(sel.focusNode)) {\n            return new Position(sel.focusNode, sel.focusOffset);\n        }\n\n        const range = this.getSelectionRange();\n        if (range) {\n            return Position.getStart(range);\n        }\n\n        return null;\n    }\n\n    /**\n     * Get an HTML element from current cursor position.\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\n     * or its parent node (if current node is a Text node).\n     * When expectedTags is specified, return value is the first ancestor of current node which has\n     * one of the expected tags.\n     * If no element found within editor by the given tag, return null.\n     * @param selector Optional, an HTML selector to find HTML element with.\n     * @param startFrom Start search from this node. If not specified, start from current focused position\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\n     * If it is not cached before, query from DOM and cache the result into the event object\n     */\n    getElementAtCursor(\n        selector?: string,\n        startFrom?: Node,\n        event?: PluginEvent\n    ): HTMLElement | null {\n        event = startFrom ? undefined : event; // Only use cache when startFrom is not specified, for different start position can have different result\n\n        return (\n            cacheGetEventData(event ?? null, 'GET_ELEMENT_AT_CURSOR_' + selector, () => {\n                if (!startFrom) {\n                    const position = this.getFocusedPosition();\n                    startFrom = position?.node;\n                }\n                return (\n                    startFrom &&\n                    findClosestElementAncestor(startFrom, this.getCore().contentDiv, selector)\n                );\n            }) ?? null\n        );\n    }\n\n    /**\n     * Check if this position is at beginning of the editor.\n     * This will return true if all nodes between the beginning of target node and the position are empty.\n     * @param position The position to check\n     * @returns True if position is at beginning of the editor, otherwise false\n     */\n    isPositionAtBeginning(position: NodePosition): boolean {\n        return isPositionAtBeginningOf(position, this.getCore().contentDiv);\n    }\n\n    /**\n     * Get impacted regions from selection\n     */\n    getSelectedRegions(type: RegionType | CompatibleRegionType = RegionType.Table): Region[] {\n        const selection = this.getSelectionRangeEx();\n        const result: Region[] = [];\n        const contentDiv = this.getCore().contentDiv;\n        selection.ranges.forEach(range => {\n            result.push(...(range ? getRegionsFromRange(contentDiv, range, type) : []));\n        });\n        return result.filter((value, index, self) => {\n            return self.indexOf(value) === index;\n        });\n    }\n\n    //#endregion\n\n    //#region EVENT API\n\n    addDomEventHandler(\n        nameOrMap: string | Record<string, DOMEventHandler>,\n        handler?: DOMEventHandler\n    ): () => void {\n        const eventsToMap = typeof nameOrMap == 'string' ? { [nameOrMap]: handler! } : nameOrMap;\n        const core = this.getCore();\n        return core.api.attachDomEvent(core, eventsToMap);\n    }\n\n    /**\n     * Trigger an event to be dispatched to all plugins\n     * @param eventType Type of the event\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\n     * the result of this function provides a chance to read the modified result\n     */\n    triggerPluginEvent<T extends PluginEventType | CompatiblePluginEventType>(\n        eventType: T,\n        data: PluginEventData<T>,\n        broadcast: boolean = false\n    ): PluginEventFromType<T> {\n        const core = this.getCore();\n        const event = ({\n            eventType,\n            ...data,\n        } as any) as PluginEventFromType<T>;\n        core.api.triggerEvent(core, event, broadcast);\n\n        return event;\n    }\n\n    /**\n     * Trigger a ContentChangedEvent\n     * @param source Source of this event, by default is 'SetContent'\n     * @param data additional data for this event\n     */\n    triggerContentChangedEvent(\n        source: ChangeSource | CompatibleChangeSource | string = ChangeSource.SetContent,\n        data?: any\n    ) {\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\n            source,\n            data,\n        });\n    }\n\n    //#endregion\n\n    //#region Undo API\n\n    /**\n     * Undo last edit operation\n     */\n    undo() {\n        this.focus();\n        const core = this.getCore();\n        core.api.restoreUndoSnapshot(core, -1 /*step*/);\n    }\n\n    /**\n     * Redo next edit operation\n     */\n    redo() {\n        this.focus();\n        const core = this.getCore();\n        core.api.restoreUndoSnapshot(core, 1 /*step*/);\n    }\n\n    /**\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\n     * ContentChangedEvent with given change source.\n     * If this function is called nested, undo snapshot will only be added in the outside one\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\n     * the data field in ContentChangedEvent if changeSource is not null.\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\n     * a ContentChangedEvent will be fired with change source equal to this value\n     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).\n     */\n    addUndoSnapshot(\n        callback?: (start: NodePosition | null, end: NodePosition | null) => any,\n        changeSource?: ChangeSource | CompatibleChangeSource | string,\n        canUndoByBackspace?: boolean,\n        additionalData?: ContentChangedData\n    ) {\n        const core = this.getCore();\n        core.api.addUndoSnapshot(\n            core,\n            callback ?? null,\n            changeSource ?? null,\n            canUndoByBackspace ?? false,\n            additionalData\n        );\n    }\n\n    /**\n     * Whether there is an available undo/redo snapshot\n     */\n    getUndoState(): EditorUndoState {\n        const { hasNewContent, snapshotsService } = this.getCore().undo;\n        return {\n            canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),\n            canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),\n        };\n    }\n\n    //#endregion\n\n    //#region Misc\n\n    /**\n     * Get document which contains this editor\n     * @returns The HTML document which contains this editor\n     */\n    getDocument(): Document {\n        return this.getCore().contentDiv.ownerDocument;\n    }\n\n    /**\n     * Get the scroll container of the editor\n     */\n    getScrollContainer(): HTMLElement {\n        return this.getCore().domEvent.scrollContainer;\n    }\n\n    /**\n     * Get custom data related to this editor\n     * @param key Key of the custom data\n     * @param getter Getter function. If custom data for the given key doesn't exist,\n     * call this function to get one and store it if it is specified. Otherwise return undefined\n     * @param disposer An optional disposer function to dispose this custom data when\n     * dispose editor.\n     */\n    getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\n        const core = this.getCore();\n        return (core.customData[key] = core.customData[key] || {\n            value: getter ? getter() : undefined,\n            disposer,\n        }).value as T;\n    }\n\n    /**\n     * Check if editor is in IME input sequence\n     * @returns True if editor is in IME input sequence, otherwise false\n     */\n    isInIME(): boolean {\n        return this.getCore().domEvent.isInIME;\n    }\n\n    /**\n     * Get default format of this editor\n     * @returns Default format object of this editor\n     */\n    getDefaultFormat(): DefaultFormat {\n        const format = this.getCore().format.defaultFormat;\n\n        return {\n            bold: isBold(format.fontWeight),\n            italic: format.italic,\n            underline: format.underline,\n            fontFamily: format.fontFamily,\n            fontSize: format.fontSize,\n            textColor: format.textColor,\n            backgroundColor: format.backgroundColor,\n        };\n    }\n\n    /**\n     * Get a content traverser for the whole editor\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\n     */\n    getBodyTraverser(startNode?: Node): IContentTraverser {\n        return ContentTraverser.createBodyTraverser(this.getCore().contentDiv, startNode);\n    }\n\n    /**\n     * Get a content traverser for current selection\n     * @returns A content traverser, or null if editor never got focus before\n     */\n    getSelectionTraverser(range?: Range): IContentTraverser | null {\n        range = range ?? this.getSelectionRange() ?? undefined;\n        return range\n            ? ContentTraverser.createSelectionTraverser(this.getCore().contentDiv, range)\n            : null;\n    }\n\n    /**\n     * Get a content traverser for current block element start from specified position\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\n     * @returns A content traverser, or null if editor never got focus before\n     */\n    getBlockTraverser(\n        startFrom: ContentPosition | CompatibleContentPosition = ContentPosition.SelectionStart\n    ): IContentTraverser | null {\n        const range = this.getSelectionRange();\n        return range\n            ? ContentTraverser.createBlockTraverser(this.getCore().contentDiv, range, startFrom)\n            : null;\n    }\n\n    /**\n     * Get a text traverser of current selection\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\n     * If it is not cached before, query from DOM and cache the result into the event object\n     * @returns A content traverser, or null if editor never got focus before\n     */\n    getContentSearcherOfCursor(event?: PluginEvent): IPositionContentSearcher | null {\n        return cacheGetEventData(event ?? null, 'ContentSearcher', () => {\n            const range = this.getSelectionRange();\n            return (\n                range &&\n                new PositionContentSearcher(this.getCore().contentDiv, Position.getStart(range))\n            );\n        });\n    }\n\n    /**\n     * Run a callback function asynchronously\n     * @param callback The callback function to run\n     * @returns a function to cancel this async run\n     */\n    runAsync(callback: (editor: IContentModelEditor) => void) {\n        const win = this.getCore().contentDiv.ownerDocument.defaultView || window;\n        const handle = win.requestAnimationFrame(() => {\n            if (!this.isDisposed() && callback) {\n                callback(this);\n            }\n        });\n\n        return () => {\n            win.cancelAnimationFrame(handle);\n        };\n    }\n\n    /**\n     * Set DOM attribute of editor content DIV\n     * @param name Name of the attribute\n     * @param value Value of the attribute\n     */\n    setEditorDomAttribute(name: string, value: string | null) {\n        if (value === null) {\n            this.getCore().contentDiv.removeAttribute(name);\n        } else {\n            this.getCore().contentDiv.setAttribute(name, value);\n        }\n    }\n\n    /**\n     * Get DOM attribute of editor content DIV, null if there is no such attribute.\n     * @param name Name of the attribute\n     */\n    getEditorDomAttribute(name: string): string | null {\n        return this.getCore().contentDiv.getAttribute(name);\n    }\n\n    /**\n     * @deprecated Use getVisibleViewport() instead.\n     *\n     * Get current relative distance from top-left corner of the given element to top-left corner of editor content DIV.\n     * @param element The element to calculate from. If the given element is not in editor, return value will be null\n     * @param addScroll When pass true, The return value will also add scrollLeft and scrollTop if any. So the value\n     * may be different than what user is seeing from the view. When pass false, scroll position will be ignored.\n     * @returns An [x, y] array which contains the left and top distances, or null if the given element is not in editor.\n     */\n    getRelativeDistanceToEditor(element: HTMLElement, addScroll?: boolean): number[] | null {\n        if (this.contains(element)) {\n            const contentDiv = this.getCore().contentDiv;\n            const editorRect = contentDiv.getBoundingClientRect();\n            const elementRect = element.getBoundingClientRect();\n\n            if (editorRect && elementRect) {\n                let x = elementRect.left - editorRect?.left;\n                let y = elementRect.top - editorRect?.top;\n\n                if (addScroll) {\n                    x += contentDiv.scrollLeft;\n                    y += contentDiv.scrollTop;\n                }\n\n                return [x, y];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Add a Content Edit feature.\n     * @param feature The feature to add\n     */\n    addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\n        const core = this.getCore();\n        feature?.keys.forEach(key => {\n            const array = core.edit.features[key] || [];\n            array.push(feature);\n            core.edit.features[key] = array;\n        });\n    }\n\n    /**\n     * Remove a Content Edit feature.\n     * @param feature The feature to remove\n     */\n    removeContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\n        const core = this.getCore();\n        feature?.keys.forEach(key => {\n            const featureSet = core.edit.features[key];\n            const index = featureSet?.indexOf(feature) ?? -1;\n            if (index >= 0) {\n                core.edit.features[key].splice(index, 1);\n                if (core.edit.features[key].length < 1) {\n                    delete core.edit.features[key];\n                }\n            }\n        });\n    }\n\n    /**\n     * Get style based format state from current selection, including font name/size and colors\n     */\n    getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\n        if (!node) {\n            const range = this.getSelectionRange();\n            node = (range && Position.getStart(range).normalize().node) ?? undefined;\n        }\n        const core = this.getCore();\n        return core.api.getStyleBasedFormatState(core, node ?? null);\n    }\n\n    /**\n     * Get the pendable format such as underline and bold\n     * @param forceGetStateFromDOM If set to true, will force get the format state from DOM tree.\n     * @returns The pending format state\n     */\n    getPendableFormatState(forceGetStateFromDOM: boolean = false): PendableFormatState {\n        const core = this.getCore();\n        return getPendableFormatState(core);\n    }\n\n    /**\n     * Ensure user will type into a container element rather than into the editor content DIV directly\n     * @param position The position that user is about to type to\n     * @param keyboardEvent Optional keyboard event object\n     */\n    ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent) {\n        const core = this.getCore();\n        core.api.ensureTypeInContainer(core, position, keyboardEvent);\n    }\n\n    //#endregion\n\n    //#region Dark mode APIs\n\n    /**\n     * Set the dark mode state and transforms the content to match the new state.\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\n     */\n    setDarkModeState(nextDarkMode?: boolean) {\n        const isDarkMode = this.isDarkMode();\n\n        if (isDarkMode == !!nextDarkMode) {\n            return;\n        }\n        const core = this.getCore();\n\n        core.api.transformColor(\n            core,\n            core.contentDiv,\n            false /*includeSelf*/,\n            null /*callback*/,\n            nextDarkMode\n                ? ColorTransformDirection.LightToDark\n                : ColorTransformDirection.DarkToLight,\n            true /*forceTransform*/,\n            isDarkMode\n        );\n\n        this.triggerContentChangedEvent(\n            nextDarkMode ? ChangeSource.SwitchToDarkMode : ChangeSource.SwitchToLightMode\n        );\n    }\n\n    /**\n     * Check if the editor is in dark mode\n     * @returns True if the editor is in dark mode, otherwise false\n     */\n    isDarkMode(): boolean {\n        return this.getCore().lifecycle.isDarkMode;\n    }\n\n    /**\n     * Transform the given node and all its child nodes to dark mode color if editor is in dark mode\n     * @param node The node to transform\n     * @param direction The transform direction. @default ColorTransformDirection.LightToDark\n     */\n    transformToDarkColor(\n        node: Node,\n        direction:\n            | ColorTransformDirection\n            | CompatibleColorTransformDirection = ColorTransformDirection.LightToDark\n    ) {\n        const core = this.getCore();\n        core.api.transformColor(core, node, true /*includeSelf*/, null /*callback*/, direction);\n    }\n\n    /**\n     * Get a darkColorHandler object for this editor.\n     */\n    getDarkColorHandler(): DarkColorHandler {\n        return this.getCore().darkColorHandler;\n    }\n\n    /**\n     * Make the editor in \"Shadow Edit\" mode.\n     * In Shadow Edit mode, all format change will finally be ignored.\n     * This can be used for building a live preview feature for format button, to allow user\n     * see format result without really apply it.\n     * This function can be called repeated. If editor is already in shadow edit mode, we can still\n     * use this function to do more shadow edit operation.\n     */\n    startShadowEdit() {\n        const core = this.getCore();\n        core.api.switchShadowEdit(core, true /*isOn*/);\n    }\n\n    /**\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\n     */\n    stopShadowEdit() {\n        const core = this.getCore();\n        core.api.switchShadowEdit(core, false /*isOn*/);\n    }\n\n    /**\n     * Check if editor is in Shadow Edit mode\n     */\n    isInShadowEdit() {\n        return !!this.getCore().lifecycle.shadowEditFragment;\n    }\n\n    /**\n     * Check if the given experimental feature is enabled\n     * @param feature The feature to check\n     */\n    isFeatureEnabled(feature: ExperimentalFeatures | CompatibleExperimentalFeatures): boolean {\n        return this.getCore().experimentalFeatures.indexOf(feature) >= 0;\n    }\n\n    /**\n     * Get a function to convert HTML string to trusted HTML string.\n     * By default it will just return the input HTML directly. To override this behavior,\n     * pass your own trusted HTML handler to EditorOptions.trustedHTMLHandler\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types\n     */\n    getTrustedHTMLHandler(): TrustedHTMLHandler {\n        return this.getCore().trustedHTMLHandler;\n    }\n\n    /**\n     * @deprecated Use getZoomScale() instead\n     */\n    getSizeTransformer(): SizeTransformer {\n        return this.getCore().sizeTransformer;\n    }\n\n    /**\n     * Get current zoom scale, default value is 1\n     * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale\n     * to let editor behave correctly especially for those mouse drag/drop behaviors\n     * @returns current zoom scale number\n     */\n    getZoomScale(): number {\n        return this.getCore().zoomScale;\n    }\n\n    /**\n     * Set current zoom scale, default value is 1\n     * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale\n     * to let editor behave correctly especially for those mouse drag/drop behaviors\n     * @param scale The new scale number to set. It should be positive number and no greater than 10, otherwise it will be ignored.\n     */\n    setZoomScale(scale: number): void {\n        const core = this.getCore();\n        if (scale > 0 && scale <= 10) {\n            const oldValue = core.zoomScale;\n            core.zoomScale = scale;\n\n            if (oldValue != scale) {\n                this.triggerPluginEvent(\n                    PluginEventType.ZoomChanged,\n                    {\n                        oldZoomScale: oldValue,\n                        newZoomScale: scale,\n                    },\n                    true /*broadcast*/\n                );\n            }\n        }\n    }\n\n    /**\n     * Retrieves the rect of the visible viewport of the editor.\n     */\n    getVisibleViewport(): Rect | null {\n        const core = this.getCore();\n\n        return core.api.getVisibleViewport(core);\n    }\n\n    /**\n     * @returns the current ContentModelEditorCore object\n     * @throws a standard Error if there's no core object\n     */\n    private getCore(): ContentModelEditorCore {\n        if (!this.core) {\n            throw new Error('Editor is already disposed');\n        }\n        return this.core;\n    }\n}\n","import { coreApiMap } from '../coreApi/coreApiMap';\nimport { createCorePlugins, getPluginState } from '../corePlugins/createCorePlugins';\nimport { createModelFromHtml, createStandaloneEditorCore } from 'roosterjs-content-model-core';\nimport type { ContentModelEditorCore } from '../publicTypes/ContentModelEditorCore';\nimport type { ContentModelEditorOptions } from '../publicTypes/IContentModelEditor';\nimport type { EditorPlugin } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Create a new instance of Content Model Editor Core\n * @param contentDiv The DIV HTML element which will be the container element of editor\n * @param options An optional options object to customize the editor\n */\nexport function createEditorCore(\n    contentDiv: HTMLDivElement,\n    options: ContentModelEditorOptions\n): ContentModelEditorCore {\n    const corePlugins = createCorePlugins(options);\n    const pluginState = getPluginState(corePlugins);\n    const additionalPlugins: EditorPlugin[] = [\n        corePlugins.eventTranslate,\n        corePlugins.edit,\n        ...(options.plugins ?? []),\n        corePlugins.normalizeTable,\n    ].filter(x => !!x);\n\n    const zoomScale: number = (options.zoomScale ?? -1) > 0 ? options.zoomScale! : 1;\n    const initContent = options.initialContent ?? contentDiv.innerHTML;\n\n    if (initContent && !options.initialModel) {\n        options.initialModel = createModelFromHtml(\n            initContent,\n            options.defaultDomToModelOptions,\n            options.trustedHTMLHandler,\n            options.defaultSegmentFormat\n        );\n    }\n\n    const standaloneEditorCore = createStandaloneEditorCore(\n        contentDiv,\n        options,\n        coreApiMap,\n        pluginState,\n        additionalPlugins\n    );\n\n    const core: ContentModelEditorCore = {\n        ...standaloneEditorCore,\n        ...pluginState,\n        zoomScale: zoomScale,\n        sizeTransformer: (size: number) => size / zoomScale,\n        disposeErrorHandler: options.disposeErrorHandler,\n        customData: {},\n        experimentalFeatures: options.experimentalFeatures ?? [],\n    };\n\n    return core;\n}\n","import type { IContentModelEditor } from '../publicTypes/IContentModelEditor';\nimport type { IEditor } from 'roosterjs-editor-types';\n\n/**\n * Check if the given editor object is Content Model editor\n * @param editor The editor to check\n * @returns True if the given editor is Content Model editor, otherwise false\n */\nexport function isContentModelEditor(editor: IEditor): editor is IContentModelEditor {\n    const contentModelEditor = editor as IContentModelEditor;\n\n    return !!contentModelEditor.createContentModel;\n}\n","import { createRange, safeInstanceOf } from 'roosterjs-editor-dom';\nimport { SelectionRangeTypes } from 'roosterjs-editor-types';\nimport type { ContentModelEditorCore } from '../../publicTypes/ContentModelEditorCore';\nimport type {\n    NodePosition,\n    PositionType,\n    SelectionPath,\n    SelectionRangeEx,\n    TableSelection,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport function buildRangeEx(\n    core: ContentModelEditorCore,\n    arg1: Range | SelectionRangeEx | NodePosition | Node | SelectionPath | null,\n    arg2?: NodePosition | number | PositionType | TableSelection | null,\n    arg3?: Node,\n    arg4?: number | PositionType\n): SelectionRangeEx {\n    let rangeEx: SelectionRangeEx | null = null;\n\n    if (isSelectionRangeEx(arg1)) {\n        rangeEx = arg1;\n    } else if (safeInstanceOf(arg1, 'HTMLTableElement') && isTableSelectionOrNull(arg2)) {\n        rangeEx = {\n            type: SelectionRangeTypes.TableSelection,\n            ranges: [],\n            areAllCollapsed: false,\n            table: arg1,\n            coordinates: arg2 ?? undefined,\n        };\n    } else if (safeInstanceOf(arg1, 'HTMLImageElement') && typeof arg2 == 'undefined') {\n        rangeEx = {\n            type: SelectionRangeTypes.ImageSelection,\n            ranges: [],\n            areAllCollapsed: false,\n            image: arg1,\n        };\n    } else {\n        const range = !arg1\n            ? null\n            : safeInstanceOf(arg1, 'Range')\n            ? arg1\n            : isSelectionPath(arg1)\n            ? createRange(core.contentDiv, arg1.start, arg1.end)\n            : isNodePosition(arg1) || safeInstanceOf(arg1, 'Node')\n            ? createRange(\n                  <Node>arg1,\n                  <number | PositionType>arg2,\n                  <Node>arg3,\n                  <number | PositionType>arg4\n              )\n            : null;\n\n        rangeEx = range\n            ? {\n                  type: SelectionRangeTypes.Normal,\n                  ranges: [range],\n                  areAllCollapsed: range.collapsed,\n              }\n            : {\n                  type: SelectionRangeTypes.Normal,\n                  ranges: [],\n                  areAllCollapsed: true,\n              };\n    }\n\n    return rangeEx;\n}\n\nfunction isSelectionRangeEx(obj: any): obj is SelectionRangeEx {\n    const rangeEx = obj as SelectionRangeEx;\n    return (\n        rangeEx &&\n        typeof rangeEx == 'object' &&\n        typeof rangeEx.type == 'number' &&\n        Array.isArray(rangeEx.ranges)\n    );\n}\n\nfunction isTableSelectionOrNull(obj: any): obj is TableSelection | null {\n    const selection = obj as TableSelection | null;\n\n    return (\n        selection === null ||\n        (selection &&\n            typeof selection == 'object' &&\n            typeof selection.firstCell == 'object' &&\n            typeof selection.lastCell == 'object')\n    );\n}\n\nfunction isSelectionPath(obj: any): obj is SelectionPath {\n    const path = obj as SelectionPath;\n\n    return path && typeof path == 'object' && Array.isArray(path.start) && Array.isArray(path.end);\n}\n\nfunction isNodePosition(obj: any): obj is NodePosition {\n    const pos = obj as NodePosition;\n\n    return (\n        pos &&\n        typeof pos == 'object' &&\n        typeof pos.node == 'object' &&\n        typeof pos.offset == 'number'\n    );\n}\n","import { contains, getObjectKeys, getTagOfNode, Position } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\nimport type { PendableFormatNames } from 'roosterjs-editor-dom';\nimport type { NodePosition, PendableFormatState } from 'roosterjs-editor-types';\nimport type { StandaloneEditorCore } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * @param core The StandaloneEditorCore object\n * @param forceGetStateFromDOM If set to true, will force get the format state from DOM tree.\n * @returns The cached format state if it exists. If the cached position do not exist, search for pendable elements in the DOM tree and return the pendable format state.\n */\nexport function getPendableFormatState(core: StandaloneEditorCore): PendableFormatState {\n    const selection = core.api.getDOMSelection(core);\n    const range = selection?.type == 'range' ? selection.range : null;\n    const currentPosition = range && Position.getStart(range).normalize();\n\n    return currentPosition ? queryCommandStateFromDOM(core, currentPosition) : {};\n}\n\nconst PendableStyleCheckers: Record<\n    PendableFormatNames,\n    (tagName: string, style: CSSStyleDeclaration) => boolean\n> = {\n    isBold: (tag, style) =>\n        tag == 'B' ||\n        tag == 'STRONG' ||\n        tag == 'H1' ||\n        tag == 'H2' ||\n        tag == 'H3' ||\n        tag == 'H4' ||\n        tag == 'H5' ||\n        tag == 'H6' ||\n        parseInt(style.fontWeight) >= 700 ||\n        ['bold', 'bolder'].indexOf(style.fontWeight) >= 0,\n    isUnderline: (tag, style) => tag == 'U' || style.textDecoration.indexOf('underline') >= 0,\n    isItalic: (tag, style) => tag == 'I' || tag == 'EM' || style.fontStyle === 'italic',\n    isSubscript: (tag, style) => tag == 'SUB' || style.verticalAlign === 'sub',\n    isSuperscript: (tag, style) => tag == 'SUP' || style.verticalAlign === 'super',\n    isStrikeThrough: (tag, style) =>\n        tag == 'S' || tag == 'STRIKE' || style.textDecoration.indexOf('line-through') >= 0,\n};\n\n/**\n * CssFalsyCheckers checks for non pendable format that might overlay a pendable format, then it can prevent getPendableFormatState return falsy pendable format states.\n */\n\nconst CssFalsyCheckers: Record<PendableFormatNames, (style: CSSStyleDeclaration) => boolean> = {\n    isBold: style =>\n        (style.fontWeight !== '' && parseInt(style.fontWeight) < 700) ||\n        style.fontWeight === 'normal',\n    isUnderline: style =>\n        style.textDecoration !== '' && style.textDecoration.indexOf('underline') < 0,\n    isItalic: style => style.fontStyle !== '' && style.fontStyle !== 'italic',\n    isSubscript: style => style.verticalAlign !== '' && style.verticalAlign !== 'sub',\n    isSuperscript: style => style.verticalAlign !== '' && style.verticalAlign !== 'super',\n    isStrikeThrough: style =>\n        style.textDecoration !== '' && style.textDecoration.indexOf('line-through') < 0,\n};\n\nfunction queryCommandStateFromDOM(\n    core: StandaloneEditorCore,\n    currentPosition: NodePosition\n): PendableFormatState {\n    let node: Node | null = currentPosition.node;\n    const formatState: PendableFormatState = {};\n    const pendableKeys: PendableFormatNames[] = [];\n    while (node && contains(core.contentDiv, node)) {\n        const tag = getTagOfNode(node);\n        const style = node.nodeType == NodeType.Element && (node as HTMLElement).style;\n        if (tag && style) {\n            getObjectKeys(PendableStyleCheckers).forEach(key => {\n                if (!(pendableKeys.indexOf(key) >= 0)) {\n                    formatState[key] = formatState[key] || PendableStyleCheckers[key](tag, style);\n                    if (CssFalsyCheckers[key](style)) {\n                        pendableKeys.push(key);\n                    }\n                }\n            });\n        }\n        node = node.parentNode;\n    }\n    return formatState;\n}\n","import { createRange, getSelectionPath, queryElements } from 'roosterjs-editor-dom';\nimport { createTableRanges } from 'roosterjs-content-model-core';\nimport { SelectionRangeTypes } from 'roosterjs-editor-types';\nimport type { DOMSelection } from 'roosterjs-content-model-types';\nimport type { ContentMetadata, SelectionRangeEx } from 'roosterjs-editor-types';\n\n// In theory, all functions below are not necessary. We keep these functions here only for compatibility with old IEditor interface\n\n/**\n * @internal\n */\nexport function convertRangeExToDomSelection(\n    rangeEx: SelectionRangeEx | null\n): DOMSelection | null {\n    switch (rangeEx?.type) {\n        case SelectionRangeTypes.ImageSelection:\n            return {\n                type: 'image',\n                image: rangeEx.image,\n            };\n\n        case SelectionRangeTypes.Normal:\n            return rangeEx.ranges.length > 0\n                ? {\n                      type: 'range',\n                      range: rangeEx.ranges[0],\n                  }\n                : null;\n\n        case SelectionRangeTypes.TableSelection:\n            return rangeEx.coordinates\n                ? {\n                      type: 'table',\n                      table: rangeEx.table,\n                      firstColumn: rangeEx.coordinates.firstCell.x,\n                      firstRow: rangeEx.coordinates.firstCell.y,\n                      lastColumn: rangeEx.coordinates.lastCell.x,\n                      lastRow: rangeEx.coordinates.lastCell.y,\n                  }\n                : null;\n\n        default:\n            return null;\n    }\n}\n\n/**\n * @internal\n */\nexport function convertDomSelectionToRangeEx(selection: DOMSelection | null): SelectionRangeEx {\n    switch (selection?.type) {\n        case 'image':\n            return {\n                type: SelectionRangeTypes.ImageSelection,\n                image: selection.image,\n                areAllCollapsed: false,\n                ranges: [createRange(selection.image)],\n            };\n\n        case 'range':\n            return {\n                type: SelectionRangeTypes.Normal,\n                ranges: [selection.range],\n                areAllCollapsed: selection.range.collapsed,\n            };\n\n        case 'table':\n            return {\n                type: SelectionRangeTypes.TableSelection,\n                ranges: createTableRanges(selection),\n                areAllCollapsed: false,\n                table: selection.table,\n                coordinates: {\n                    firstCell: { x: selection.firstColumn, y: selection.firstRow },\n                    lastCell: { x: selection.lastColumn, y: selection.lastRow },\n                },\n            };\n\n        default:\n            return {\n                type: SelectionRangeTypes.Normal,\n                ranges: [],\n                areAllCollapsed: true,\n            };\n    }\n}\n\n/**\n * @internal\n */\nexport function convertDomSelectionToMetadata(\n    contentDiv: HTMLElement,\n    selection: DOMSelection | null\n): ContentMetadata | null {\n    switch (selection?.type) {\n        case 'table':\n            return {\n                type: SelectionRangeTypes.TableSelection,\n                tableId: selection.table.id,\n                firstCell: {\n                    x: selection.firstColumn,\n                    y: selection.firstRow,\n                },\n                lastCell: {\n                    x: selection.lastColumn,\n                    y: selection.lastRow,\n                },\n                isDarkMode: false,\n            };\n        case 'image':\n            return {\n                type: SelectionRangeTypes.ImageSelection,\n                imageId: selection.image.id,\n                isDarkMode: false,\n            };\n        case 'range':\n            return {\n                type: SelectionRangeTypes.Normal,\n                isDarkMode: false,\n                start: [],\n                end: [],\n                ...(getSelectionPath(contentDiv, selection.range) || {}),\n            };\n        default:\n            return null;\n    }\n}\n\n/**\n * @internal\n */\nexport function convertMetadataToDOMSelection(\n    contentDiv: HTMLElement,\n    metadata: ContentMetadata | undefined\n): DOMSelection | null {\n    switch (metadata?.type) {\n        case SelectionRangeTypes.Normal:\n            return {\n                type: 'range',\n                range: createRange(contentDiv, metadata.start, metadata.end),\n            };\n        case SelectionRangeTypes.TableSelection:\n            const table = queryElements(contentDiv, '#' + metadata.tableId)[0] as HTMLTableElement;\n\n            return table\n                ? {\n                      type: 'table',\n                      table: table,\n                      firstColumn: metadata.firstCell.x,\n                      firstRow: metadata.firstCell.y,\n                      lastColumn: metadata.lastCell.x,\n                      lastRow: metadata.lastCell.y,\n                  }\n                : null;\n        case SelectionRangeTypes.ImageSelection:\n            const image = queryElements(contentDiv, '#' + metadata.imageId)[0] as HTMLImageElement;\n\n            return image\n                ? {\n                      type: 'image',\n                      image: image,\n                  }\n                : null;\n\n        default:\n            return null;\n    }\n}\n","export { ContentModelEditorCore } from './publicTypes/ContentModelEditorCore';\nexport { IContentModelEditor, ContentModelEditorOptions } from './publicTypes/IContentModelEditor';\nexport {\n    ContentModelCorePlugins,\n    UnportedCorePlugins,\n} from './publicTypes/ContentModelCorePlugins';\n\nexport { ContentModelEditor } from './editor/ContentModelEditor';\nexport { isContentModelEditor } from './editor/isContentModelEditor';\n","import { keyboardDelete } from './keyboardDelete';\nimport { keyboardInput } from './keyboardInput';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type { IContentModelEditor } from 'roosterjs-content-model-editor';\nimport type {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginKeyDownEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * ContentModel edit plugins helps editor to do editing operation on top of content model.\n * This includes:\n * 1. Delete Key\n * 2. Backspace Key\n */\nexport class ContentModelEditPlugin implements EditorPlugin {\n    private editor: IContentModelEditor | null = null;\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'ContentModelEdit';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        // TODO: Later we may need a different interface for Content Model editor plugin\n        this.editor = editor as IContentModelEditor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case PluginEventType.KeyDown:\n                    this.handleKeyDownEvent(this.editor, event);\n                    break;\n            }\n        }\n    }\n\n    private handleKeyDownEvent(editor: IContentModelEditor, event: PluginKeyDownEvent) {\n        const rawEvent = event.rawEvent;\n\n        if (!rawEvent.defaultPrevented && !event.handledByEditFeature) {\n            // TODO: Consider use ContentEditFeature and need to hide other conflict features that are not based on Content Model\n            switch (rawEvent.key) {\n                case 'Backspace':\n                case 'Delete':\n                    // Use our API to handle BACKSPACE/DELETE key.\n                    // No need to clear cache here since if we rely on browser's behavior, there will be Input event and its handler will reconcile cache\n                    keyboardDelete(editor, rawEvent);\n                    break;\n\n                case 'Enter':\n                default:\n                    keyboardInput(editor, rawEvent);\n                    break;\n            }\n        }\n    }\n}\n","import { deleteSegment } from 'roosterjs-content-model-core';\nimport type { DeleteSelectionStep } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const deleteAllSegmentBefore: DeleteSelectionStep = context => {\n    const { paragraph, marker } = context.insertPoint;\n    const index = paragraph.segments.indexOf(marker);\n\n    for (let i = index - 1; i >= 0; i--) {\n        const segment = paragraph.segments[i];\n\n        segment.isSelected = true;\n\n        if (deleteSegment(paragraph, segment, context.formatContext)) {\n            context.deleteResult = 'range';\n        }\n    }\n};\n","import { deleteBlock, deleteSegment } from 'roosterjs-content-model-core';\nimport { getLeafSiblingBlock } from '../utils/getLeafSiblingBlock';\nimport { setParagraphNotImplicit } from 'roosterjs-content-model-dom';\nimport type { BlockAndPath } from '../utils/getLeafSiblingBlock';\nimport type { ContentModelSegment, DeleteSelectionStep } from 'roosterjs-content-model-types';\n\nfunction getDeleteCollapsedSelection(direction: 'forward' | 'backward'): DeleteSelectionStep {\n    return context => {\n        const isForward = direction == 'forward';\n        const { paragraph, marker, path, tableContext } = context.insertPoint;\n        const segments = paragraph.segments;\n\n        fixupBr(segments);\n\n        const index = segments.indexOf(marker) + (isForward ? 1 : -1);\n        const segmentToDelete = segments[index];\n        let blockToDelete: BlockAndPath | null;\n\n        if (segmentToDelete) {\n            if (deleteSegment(paragraph, segmentToDelete, context.formatContext, direction)) {\n                context.deleteResult = 'singleChar';\n\n                // It is possible that we have deleted everything from this paragraph, so we need to mark it as not implicit\n                // to avoid losing its format. See https://github.com/microsoft/roosterjs/issues/1953\n                setParagraphNotImplicit(paragraph);\n            }\n        } else if ((blockToDelete = getLeafSiblingBlock(path, paragraph, isForward))) {\n            const { block, path, siblingSegment } = blockToDelete;\n\n            if (block.blockType == 'Paragraph') {\n                if (siblingSegment) {\n                    // When selection is under general segment, need to check if it has a sibling sibling, and delete from it\n                    if (deleteSegment(block, siblingSegment, context.formatContext, direction)) {\n                        context.deleteResult = 'range';\n                    }\n                } else {\n                    if (isForward) {\n                        context.lastParagraph = block;\n                    } else {\n                        if (block.segments[block.segments.length - 1]?.segmentType == 'Br') {\n                            block.segments.pop();\n                        }\n\n                        context.insertPoint = {\n                            marker,\n                            paragraph: block,\n                            path,\n                            tableContext,\n                        };\n                        context.lastParagraph = paragraph;\n                        delete block.cachedElement;\n                    }\n\n                    context.deleteResult = 'range';\n                }\n\n                // When go across table, getLeafSiblingBlock will return null, when we are here, we must be in the same table context\n                context.lastTableContext = tableContext;\n            } else {\n                if (\n                    deleteBlock(\n                        path[0].blocks,\n                        block,\n                        undefined /*replacement*/,\n                        context.formatContext,\n                        direction\n                    )\n                ) {\n                    context.deleteResult = 'range';\n                }\n            }\n        } else {\n            // We have nothing to delete, in this case we don't want browser handle it as well.\n            // Because when Backspace on an empty document, it will also delete the only DIV and SPAN element, causes\n            // editor is really empty. We don't want that happen. So the handling should stop here.\n            context.deleteResult = 'nothingToDelete';\n        }\n    };\n}\n\n/**\n * If the last segment is BR, remove it for now. We may add it back later when normalize model.\n * So that if this is an empty paragraph, it will start to delete next block\n */\nfunction fixupBr(segments: ContentModelSegment[]) {\n    if (segments[segments.length - 1]?.segmentType == 'Br') {\n        const segmentsWithoutBr = segments.filter(x => x.segmentType != 'SelectionMarker');\n\n        if (segmentsWithoutBr[segmentsWithoutBr.length - 2]?.segmentType != 'Br') {\n            segments.pop();\n        }\n    }\n}\n\n/**\n * @internal if we didn't delete anything, and we want to delete forward, now perform it\n */\nexport const forwardDeleteCollapsedSelection = getDeleteCollapsedSelection('forward');\n\n/**\n * @internal if we didn't delete anything, and we want to delete backward, now perform it\n */\nexport const backwardDeleteCollapsedSelection = getDeleteCollapsedSelection('backward');\n","import { isPunctuation, isSpace, normalizeText } from 'roosterjs-content-model-core';\nimport { isWhiteSpacePreserved } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelParagraph,\n    DeleteSelectionContext,\n    DeleteSelectionStep,\n} from 'roosterjs-content-model-types';\n\nconst enum DeleteWordState {\n    Start,\n    Punctuation,\n    Text,\n    NonText,\n    Space,\n    End,\n}\n\ninterface CharInfo {\n    text: boolean;\n    space: boolean;\n    punctuation: boolean;\n}\n\nfunction getDeleteWordSelection(direction: 'forward' | 'backward'): DeleteSelectionStep {\n    return context => {\n        const { marker, paragraph } = context.insertPoint;\n        const startIndex = paragraph.segments.indexOf(marker);\n        const deleteNext = direction == 'forward';\n\n        const iterator = iterateSegments(paragraph, startIndex, deleteNext, context);\n        let curr = iterator.next();\n\n        for (let state = DeleteWordState.Start; state != DeleteWordState.End && !curr.done; ) {\n            const { punctuation, space, text } = curr.value;\n\n            // This is a state machine of how to delete a whole word together with space and punctuations.\n            // For a full state machine chart, see\n            // Forward delete: https://github.com/microsoft/roosterjs/blob/master/assets/design-charts/ForwardDeleteWord.png\n            // Backward delete: https://github.com/microsoft/roosterjs/blob/master/assets/design-charts/BackwardDeleteWord.png\n            switch (state) {\n                case DeleteWordState.Start:\n                    state = space\n                        ? DeleteWordState.Space\n                        : punctuation\n                        ? DeleteWordState.Punctuation\n                        : DeleteWordState.Text;\n                    curr = iterator.next(true /*delete*/);\n                    break;\n\n                case DeleteWordState.Punctuation:\n                    if (deleteNext && space) {\n                        state = DeleteWordState.NonText;\n                        curr = iterator.next(true /*delete*/);\n                    } else if (punctuation) {\n                        curr = iterator.next(true /*delete*/);\n                    } else {\n                        state = DeleteWordState.End;\n                    }\n                    break;\n\n                case DeleteWordState.Text:\n                    if (deleteNext && space) {\n                        state = DeleteWordState.NonText;\n                        curr = iterator.next(true /*delete*/);\n                    } else if (text) {\n                        curr = iterator.next(true /*delete*/);\n                    } else {\n                        state = DeleteWordState.End;\n                    }\n                    break;\n\n                case DeleteWordState.NonText:\n                    if (punctuation || !space) {\n                        state = DeleteWordState.End;\n                    } else {\n                        curr = iterator.next(true /*delete*/);\n                    }\n                    break;\n\n                case DeleteWordState.Space:\n                    if (space) {\n                        curr = iterator.next(true /*delete*/);\n                    } else if (punctuation) {\n                        state = deleteNext ? DeleteWordState.NonText : DeleteWordState.Punctuation;\n                        curr = iterator.next(true /*delete*/);\n                    } else {\n                        state = deleteNext ? DeleteWordState.End : DeleteWordState.Text;\n                    }\n                    break;\n            }\n        }\n    };\n}\n\nfunction* iterateSegments(\n    paragraph: ContentModelParagraph,\n    markerIndex: number,\n    forward: boolean,\n    context: DeleteSelectionContext\n): Generator<CharInfo, null, boolean> {\n    const step = forward ? 1 : -1;\n    const segments = paragraph.segments;\n    const preserveWhiteSpace = isWhiteSpacePreserved(paragraph);\n\n    for (let i = markerIndex + step; i >= 0 && i < segments.length; i += step) {\n        const segment = segments[i];\n\n        switch (segment.segmentType) {\n            case 'Text':\n                for (\n                    let j = forward ? 0 : segment.text.length - 1;\n                    j >= 0 && j < segment.text.length;\n                    j += step\n                ) {\n                    const c = segment.text[j];\n                    const punctuation = isPunctuation(c);\n                    const space = isSpace(c);\n                    const text = !punctuation && !space;\n\n                    if (yield { punctuation, space, text }) {\n                        let newText = segment.text;\n\n                        newText = newText.substring(0, j) + newText.substring(j + 1);\n\n                        if (!preserveWhiteSpace) {\n                            newText = normalizeText(newText, forward);\n                        }\n\n                        context.deleteResult = 'range';\n\n                        if (newText) {\n                            segment.text = newText;\n\n                            if (step > 0) {\n                                j -= step;\n                            }\n                        } else {\n                            segments.splice(i, 1);\n\n                            if (step > 0) {\n                                i -= step;\n                            }\n\n                            break;\n                        }\n                    }\n                }\n                break;\n\n            case 'Image':\n                if (\n                    yield { punctuation: true, space: false, text: false } // Treat image as punctuation since they have the same behavior.\n                ) {\n                    segments.splice(i, 1);\n\n                    if (step > 0) {\n                        i -= step;\n                    }\n\n                    context.deleteResult = 'range';\n                }\n                break;\n\n            case 'SelectionMarker':\n                break;\n\n            default:\n                return null;\n        }\n    }\n\n    return null;\n}\n\n/**\n * @internal\n */\nexport const forwardDeleteWordSelection = getDeleteWordSelection('forward');\n\n/**\n * @internal\n */\nexport const backwardDeleteWordSelection = getDeleteWordSelection('backward');\n","import { normalizeContentModel } from 'roosterjs-content-model-dom';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport type { IContentModelEditor } from 'roosterjs-content-model-editor';\nimport type {\n    ContentModelDocument,\n    DeleteResult,\n    FormatWithContentModelContext,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * @return True means content is changed, so need to rewrite content model to editor. Otherwise false\n */\nexport function handleKeyboardEventResult(\n    editor: IContentModelEditor,\n    model: ContentModelDocument,\n    rawEvent: KeyboardEvent,\n    result: DeleteResult,\n    context: FormatWithContentModelContext\n): boolean {\n    context.skipUndoSnapshot = true;\n    context.clearModelCache = false;\n\n    switch (result) {\n        case 'notDeleted':\n            // We have not delete anything, we will let browser handle this event, so that current cached model may be invalid\n            context.clearModelCache = true;\n\n            // Return false here since we didn't do any change to Content Model, so no need to rewrite with Content Model\n            return false;\n\n        case 'nothingToDelete':\n            // We known there is nothing to delete, no need to let browser keep handling the event\n            rawEvent.preventDefault();\n            return false;\n\n        case 'range':\n        case 'singleChar':\n            // We have deleted what we need from content model, no need to let browser keep handling the event\n            rawEvent.preventDefault();\n            normalizeContentModel(model);\n\n            if (result == 'range') {\n                // A range is about to be deleted, so add an undo snapshot immediately\n                context.skipUndoSnapshot = false;\n            }\n\n            // Trigger an event to let plugins know the content is about to be changed by Content Model keyboard editing.\n            // So plugins can do proper handling. e.g. UndoPlugin can decide whether take a snapshot before this change happens.\n            editor.triggerPluginEvent(PluginEventType.BeforeKeyboardEditing, {\n                rawEvent,\n            });\n\n            return true;\n    }\n}\n\n/**\n * @internal\n */\nexport function shouldDeleteWord(rawEvent: KeyboardEvent, isMac: boolean) {\n    return (\n        (isMac && rawEvent.altKey && !rawEvent.metaKey) ||\n        (!isMac && rawEvent.ctrlKey && !rawEvent.altKey)\n    );\n}\n\n/**\n * @internal\n */\nexport function shouldDeleteAllSegmentsBefore(rawEvent: KeyboardEvent) {\n    return rawEvent.metaKey && !rawEvent.altKey;\n}\n","import { ChangeSource, deleteSelection, isModifierKey } from 'roosterjs-content-model-core';\nimport { deleteAllSegmentBefore } from './deleteSteps/deleteAllSegmentBefore';\nimport { isNodeOfType } from 'roosterjs-content-model-dom';\nimport {\n    handleKeyboardEventResult,\n    shouldDeleteAllSegmentsBefore,\n    shouldDeleteWord,\n} from './handleKeyboardEventCommon';\nimport {\n    backwardDeleteWordSelection,\n    forwardDeleteWordSelection,\n} from './deleteSteps/deleteWordSelection';\nimport {\n    backwardDeleteCollapsedSelection,\n    forwardDeleteCollapsedSelection,\n} from './deleteSteps/deleteCollapsedSelection';\nimport type { IContentModelEditor } from 'roosterjs-content-model-editor';\nimport type { DOMSelection, DeleteSelectionStep } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n * Do keyboard event handling for DELETE/BACKSPACE key\n * @param editor The Content Model Editor\n * @param rawEvent DOM keyboard event\n */\nexport function keyboardDelete(editor: IContentModelEditor, rawEvent: KeyboardEvent) {\n    const selection = editor.getDOMSelection();\n\n    if (shouldDeleteWithContentModel(selection, rawEvent)) {\n        editor.formatContentModel(\n            (model, context) => {\n                const result = deleteSelection(\n                    model,\n                    getDeleteSteps(rawEvent, !!editor.getEnvironment().isMac),\n                    context\n                ).deleteResult;\n\n                return handleKeyboardEventResult(editor, model, rawEvent, result, context);\n            },\n            {\n                rawEvent,\n                changeSource: ChangeSource.Keyboard,\n                getChangeData: () => rawEvent.which,\n                apiName: rawEvent.key == 'Delete' ? 'handleDeleteKey' : 'handleBackspaceKey',\n            }\n        );\n\n        return true;\n    }\n}\n\nfunction getDeleteSteps(rawEvent: KeyboardEvent, isMac: boolean): (DeleteSelectionStep | null)[] {\n    const isForward = rawEvent.key == 'Delete';\n    const deleteAllSegmentBeforeStep =\n        shouldDeleteAllSegmentsBefore(rawEvent) && !isForward ? deleteAllSegmentBefore : null;\n    const deleteWordSelection = shouldDeleteWord(rawEvent, isMac)\n        ? isForward\n            ? forwardDeleteWordSelection\n            : backwardDeleteWordSelection\n        : null;\n    const deleteCollapsedSelection = isForward\n        ? forwardDeleteCollapsedSelection\n        : backwardDeleteCollapsedSelection;\n    return [deleteAllSegmentBeforeStep, deleteWordSelection, deleteCollapsedSelection];\n}\n\nfunction shouldDeleteWithContentModel(selection: DOMSelection | null, rawEvent: KeyboardEvent) {\n    if (!selection) {\n        return false; // Nothing to delete\n    } else if (selection.type != 'range' || !selection.range.collapsed) {\n        return true; // Selection is not collapsed, need to delete all selections\n    } else {\n        const range = selection.range;\n\n        // When selection is collapsed and is in middle of text node, no need to use Content Model to delete\n        return !(\n            isNodeOfType(range.startContainer, 'TEXT_NODE') &&\n            !isModifierKey(rawEvent) &&\n            (canDeleteBefore(rawEvent, range) || canDeleteAfter(rawEvent, range))\n        );\n    }\n}\n\nfunction canDeleteBefore(rawEvent: KeyboardEvent, range: Range) {\n    return rawEvent.key == 'Backspace' && range.startOffset > 1;\n}\n\nfunction canDeleteAfter(rawEvent: KeyboardEvent, range: Range) {\n    return (\n        rawEvent.key == 'Delete' &&\n        range.startOffset < (range.startContainer.nodeValue?.length ?? 0) - 1\n    );\n}\n","import { deleteSelection, isModifierKey } from 'roosterjs-content-model-core';\nimport { normalizeContentModel } from 'roosterjs-content-model-dom';\nimport type { IContentModelEditor } from 'roosterjs-content-model-editor';\nimport type { DOMSelection } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function keyboardInput(editor: IContentModelEditor, rawEvent: KeyboardEvent) {\n    const selection = editor.getDOMSelection();\n\n    if (shouldInputWithContentModel(selection, rawEvent)) {\n        editor.addUndoSnapshot();\n\n        editor.formatContentModel(\n            (model, context) => {\n                const result = deleteSelection(model, [], context);\n\n                // We have deleted selection then we will let browser to handle the input.\n                // With this combined operation, we don't wan to mass up the cached model so clear it\n                context.clearModelCache = true;\n\n                // Skip undo snapshot here and add undo snapshot before the operation so that we don't add another undo snapshot in middle of this replace operation\n                context.skipUndoSnapshot = true;\n\n                if (result.deleteResult == 'range') {\n                    // We have deleted something, next input should inherit the segment format from deleted content, so set pending format here\n                    context.newPendingFormat = result.insertPoint?.marker.format;\n\n                    normalizeContentModel(model);\n\n                    // Do not preventDefault since we still want browser to handle the final input for now\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            {\n                rawEvent,\n            }\n        );\n\n        return true;\n    }\n}\n\nfunction shouldInputWithContentModel(selection: DOMSelection | null, rawEvent: KeyboardEvent) {\n    if (!selection) {\n        return false; // Nothing to delete\n    } else if (\n        !isModifierKey(rawEvent) &&\n        (rawEvent.key == 'Enter' || rawEvent.key == 'Space' || rawEvent.key.length == 1)\n    ) {\n        return selection.type != 'range' || !selection.range.collapsed; // TODO: Also handle Enter key even selection is collapsed\n    } else {\n        return false;\n    }\n}\n","import { isGeneralSegment } from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlock,\n    ContentModelBlockGroup,\n    ContentModelParagraph,\n    ContentModelSegment,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport type BlockAndPath = {\n    /**\n     * The sibling block\n     */\n    block: ContentModelBlock;\n\n    /**\n     * Path of this sibling block\n     */\n    path: ContentModelBlockGroup[];\n\n    /**\n     * If the input block is under a general segment, it is possible there are sibling segments under the same paragraph.\n     * Use this property to return the sibling sibling under the same paragraph\n     */\n    siblingSegment?: ContentModelSegment;\n};\n\n/**\n * @internal\n */\nexport function getLeafSiblingBlock(\n    path: ContentModelBlockGroup[],\n    block: ContentModelBlock,\n    isNext: boolean\n): BlockAndPath | null {\n    const newPath = [...path];\n\n    while (newPath.length > 0) {\n        const group = newPath[0];\n        const index = group.blocks.indexOf(block);\n\n        if (index < 0) {\n            break;\n        }\n\n        let nextBlock = group.blocks[index + (isNext ? 1 : -1)];\n\n        if (nextBlock) {\n            while (nextBlock.blockType == 'BlockGroup') {\n                const child = nextBlock.blocks[isNext ? 0 : nextBlock.blocks.length - 1];\n\n                if (!child) {\n                    return { block: nextBlock, path: newPath };\n                } else if (child.blockType != 'BlockGroup') {\n                    newPath.unshift(nextBlock);\n                    return { block: child, path: newPath };\n                } else {\n                    newPath.unshift(nextBlock);\n                    nextBlock = child;\n                }\n            }\n\n            return { block: nextBlock, path: newPath };\n        } else if (isGeneralSegment(group)) {\n            // For general segment, we need to check if there is sibling segment under the same paragraph\n            // First let's find the parent paragraph of this segment\n            newPath.shift();\n\n            let segmentIndex = -1;\n            const segment = group;\n            const para = newPath[0]?.blocks.find(\n                x => x.blockType == 'Paragraph' && (segmentIndex = x.segments.indexOf(segment)) >= 0\n            ) as ContentModelParagraph;\n\n            if (para) {\n                // Now we have found the parent paragraph, so let's check if it has a sibling segment\n                const siblingSegment = para.segments[segmentIndex + (isNext ? 1 : -1)];\n\n                if (siblingSegment) {\n                    // Return this block, path and segment since we have found it\n                    return { block: para, path: newPath, siblingSegment };\n                } else {\n                    // No sibling segment, let's keep go upper level\n                    block = para;\n                }\n            } else {\n                // Parent sibling is not found (in theory this should never happen), just return null\n                break;\n            }\n        } else if (group.blockGroupType != 'Document' && group.blockGroupType != 'TableCell') {\n            newPath.shift();\n            block = group;\n        } else {\n            break;\n        }\n    }\n\n    return null;\n}\n","import { isCharacterValue } from 'roosterjs-content-model-core';\nimport {\n    addDelimiters,\n    isBlockElement,\n    isEntityElement,\n    isNodeOfType,\n} from 'roosterjs-content-model-dom';\nimport {\n    DelimiterClasses,\n    Keys,\n    NodeType,\n    PluginEventType,\n    PositionType,\n    SelectionRangeTypes,\n} from 'roosterjs-editor-types';\nimport {\n    Position,\n    createRange,\n    getDelimiterFromElement,\n    getEntityFromElement,\n    getEntitySelector,\n    matchesSelector,\n    splitTextNode,\n} from 'roosterjs-editor-dom';\nimport type {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginKeyDownEvent,\n} from 'roosterjs-editor-types';\nimport type { IContentModelEditor } from 'roosterjs-content-model-editor';\n\nconst DELIMITER_SELECTOR =\n    '.' + DelimiterClasses.DELIMITER_AFTER + ',.' + DelimiterClasses.DELIMITER_BEFORE;\nconst ZERO_WIDTH_SPACE = '\\u200B';\nconst INLINE_ENTITY_SELECTOR = 'span' + getEntitySelector();\n\n/**\n * Entity delimiter plugin helps maintain delimiter elements around an entity so that user can put focus before/after an entity\n */\nexport class EntityDelimiterPlugin implements EditorPlugin {\n    private editor: IContentModelEditor | null = null;\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'EntityDelimiter';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor as IContentModelEditor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (this.editor) {\n            switch (event.eventType) {\n                case PluginEventType.ContentChanged:\n                case PluginEventType.EditorReady:\n                    normalizeDelimitersInEditor(this.editor);\n                    break;\n\n                case PluginEventType.BeforePaste:\n                    const { fragment } = event;\n                    addDelimitersIfNeeded(fragment.querySelectorAll(INLINE_ENTITY_SELECTOR));\n\n                    break;\n\n                case PluginEventType.ExtractContentWithDom:\n                case PluginEventType.BeforeCutCopy:\n                    event.clonedRoot.querySelectorAll(DELIMITER_SELECTOR).forEach(node => {\n                        if (getDelimiterFromElement(node)) {\n                            removeNode(node);\n                        } else {\n                            removeDelimiterAttr(node);\n                        }\n                    });\n                    break;\n\n                case PluginEventType.KeyDown:\n                    handleKeyDownEvent(this.editor, event);\n                    break;\n            }\n        }\n    }\n}\n\nfunction preventTypeInDelimiter(delimiter: HTMLElement) {\n    delimiter.normalize();\n    const textNode = delimiter.firstChild as Node;\n    const index = textNode.nodeValue?.indexOf(ZERO_WIDTH_SPACE) ?? -1;\n    if (index >= 0) {\n        splitTextNode(<Text>textNode, index == 0 ? 1 : index, false /* returnFirstPart */);\n        let nodeToMove: Node | undefined;\n        delimiter.childNodes.forEach(node => {\n            if (node.nodeValue !== ZERO_WIDTH_SPACE) {\n                nodeToMove = node;\n            }\n        });\n        if (nodeToMove) {\n            delimiter.parentElement?.insertBefore(\n                nodeToMove,\n                delimiter.className == DelimiterClasses.DELIMITER_BEFORE\n                    ? delimiter\n                    : delimiter.nextSibling\n            );\n            const selection = nodeToMove.ownerDocument?.getSelection();\n\n            if (selection) {\n                selection.setPosition(\n                    nodeToMove,\n                    new Position(nodeToMove, PositionType.End).offset\n                );\n            }\n        }\n    }\n}\n\n/**\n * @internal\n */\nexport function normalizeDelimitersInEditor(editor: IEditor) {\n    removeInvalidDelimiters(editor.queryElements(DELIMITER_SELECTOR));\n    addDelimitersIfNeeded(editor.queryElements(INLINE_ENTITY_SELECTOR));\n}\n\nfunction addDelimitersIfNeeded(nodes: Element[] | NodeListOf<Element>) {\n    nodes.forEach(node => {\n        if (\n            isNodeOfType(node, 'ELEMENT_NODE') &&\n            isEntityElement(node) &&\n            !node.isContentEditable\n        ) {\n            addDelimiters(node.ownerDocument, node as HTMLElement);\n        }\n    });\n}\n\nfunction removeNode(el: Node | undefined | null) {\n    el?.parentElement?.removeChild(el);\n}\n\nfunction removeInvalidDelimiters(nodes: Element[] | NodeListOf<Element>) {\n    nodes.forEach(node => {\n        if (getDelimiterFromElement(node)) {\n            const sibling = node.classList.contains(DelimiterClasses.DELIMITER_BEFORE)\n                ? node.nextElementSibling\n                : node.previousElementSibling;\n            if (!(isNodeOfType(sibling, 'ELEMENT_NODE') && getEntityFromElement(sibling))) {\n                removeNode(node);\n            }\n        } else {\n            removeDelimiterAttr(node);\n        }\n    });\n}\n\nfunction removeDelimiterAttr(node: Element | undefined | null, checkEntity: boolean = true) {\n    if (!node) {\n        return;\n    }\n\n    const isAfter = node.classList.contains(DelimiterClasses.DELIMITER_AFTER);\n    const entitySibling = isAfter ? node.previousElementSibling : node.nextElementSibling;\n    if (checkEntity && entitySibling && isEntityElement(entitySibling)) {\n        return;\n    }\n\n    node.classList.remove(DelimiterClasses.DELIMITER_AFTER, DelimiterClasses.DELIMITER_BEFORE);\n\n    node.normalize();\n    node.childNodes.forEach(cn => {\n        const index = cn.textContent?.indexOf(ZERO_WIDTH_SPACE) ?? -1;\n        if (index >= 0) {\n            createRange(cn, index, cn, index + 1)?.deleteContents();\n        }\n    });\n}\n\nfunction handleCollapsedEnter(editor: IEditor, delimiter: HTMLElement) {\n    const isAfter = delimiter.classList.contains(DelimiterClasses.DELIMITER_AFTER);\n    const entity = !isAfter ? delimiter.nextSibling : delimiter.previousSibling;\n    const block = getBlock(editor, delimiter);\n\n    editor.runAsync(() => {\n        if (!block) {\n            return;\n        }\n        const blockToCheck = isAfter ? block.nextSibling : block.previousSibling;\n        if (blockToCheck && isNodeOfType(blockToCheck, 'ELEMENT_NODE')) {\n            const delimiters = blockToCheck.querySelectorAll(DELIMITER_SELECTOR);\n            // Check if the last or first delimiter still contain the delimiter class and remove it.\n            const delimiterToCheck = delimiters.item(isAfter ? 0 : delimiters.length - 1);\n            removeDelimiterAttr(delimiterToCheck);\n        }\n\n        if (entity && isEntityElement(entity)) {\n            const entityElement = entity as HTMLElement;\n            const { nextElementSibling, previousElementSibling } = entityElement;\n            [nextElementSibling, previousElementSibling].forEach(el => {\n                // Check if after Enter the ZWS got removed but we still have a element with the class\n                // Remove the attributes of the element if it is invalid now.\n                if (el && matchesSelector(el, DELIMITER_SELECTOR) && !getDelimiterFromElement(el)) {\n                    removeDelimiterAttr(el, false /* checkEntity */);\n                }\n            });\n\n            // Add delimiters to the entity if needed because on Enter we can sometimes lose the ZWS of the element.\n            addDelimiters(entityElement.ownerDocument, entityElement);\n        }\n    });\n}\n\nconst getPosition = (container: HTMLElement | null) => {\n    if (container && getDelimiterFromElement(container)) {\n        const isAfter = container.classList.contains(DelimiterClasses.DELIMITER_AFTER);\n        return new Position(container, isAfter ? PositionType.After : PositionType.Before);\n    }\n    return undefined;\n};\n\nfunction getBlock(editor: IEditor, element: Node | undefined) {\n    if (!element) {\n        return undefined;\n    }\n\n    let block = editor.getBlockElementAtNode(element)?.getStartNode();\n\n    while (block && (!isNodeOfType(block, 'ELEMENT_NODE') || !isBlockElement(block))) {\n        block = editor.contains(block.parentElement) ? block.parentElement! : undefined;\n    }\n\n    return block;\n}\n\nfunction handleSelectionNotCollapsed(editor: IEditor, range: Range, event: KeyboardEvent) {\n    const { startContainer, endContainer, startOffset, endOffset } = range;\n\n    const startElement = editor.getElementAtCursor(DELIMITER_SELECTOR, startContainer);\n    const endElement = editor.getElementAtCursor(DELIMITER_SELECTOR, endContainer);\n\n    const startUpdate = getPosition(startElement);\n    const endUpdate = getPosition(endElement);\n\n    if (startUpdate || endUpdate) {\n        editor.select(\n            startUpdate ?? new Position(startContainer, startOffset),\n            endUpdate ?? new Position(endContainer, endOffset)\n        );\n    }\n    editor.runAsync(aEditor => {\n        const delimiter = aEditor.getElementAtCursor(DELIMITER_SELECTOR);\n        if (delimiter) {\n            preventTypeInDelimiter(delimiter);\n            if (event.which === Keys.ENTER) {\n                removeDelimiterAttr(delimiter);\n            }\n        }\n    });\n}\n\nfunction handleKeyDownEvent(editor: IEditor, event: PluginKeyDownEvent) {\n    const range = editor.getSelectionRangeEx();\n    const { rawEvent } = event;\n    if (range.type != SelectionRangeTypes.Normal) {\n        return;\n    }\n\n    if (range.areAllCollapsed && (isCharacterValue(rawEvent) || rawEvent.which === Keys.ENTER)) {\n        const position = editor.getFocusedPosition()?.normalize();\n        if (!position) {\n            return;\n        }\n\n        const { element, node } = position;\n        const refNode = element == node ? element.childNodes.item(position.offset) : element;\n\n        const delimiter = editor.getElementAtCursor(DELIMITER_SELECTOR, refNode);\n        if (!delimiter) {\n            return;\n        }\n\n        if (rawEvent.which === Keys.ENTER) {\n            handleCollapsedEnter(editor, delimiter);\n        } else if (delimiter.firstChild?.nodeType == NodeType.Text) {\n            editor.runAsync(() => preventTypeInDelimiter(delimiter));\n        }\n    } else if (!range.areAllCollapsed && !rawEvent.shiftKey && rawEvent.which != Keys.SHIFT) {\n        const currentRange = range.ranges[0];\n        if (!currentRange) {\n            return;\n        }\n        handleSelectionNotCollapsed(editor, currentRange, rawEvent);\n    }\n}\n","export { ContentModelPastePlugin } from './paste/ContentModelPastePlugin';\nexport { ContentModelEditPlugin } from './edit/ContentModelEditPlugin';\nexport { EntityDelimiterPlugin } from './entityDelimiter/EntityDelimiterPlugin';\n","import addParser from './utils/addParser';\nimport { BorderKeys } from 'roosterjs-content-model-dom';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\nimport { deprecatedBorderColorParser } from './utils/deprecatedColorParser';\nimport { getPasteSource } from './pasteSourceValidations/getPasteSource';\nimport { parseLink } from './utils/linkParser';\nimport { PastePropertyNames } from './pasteSourceValidations/constants';\nimport { PasteType as OldPasteType, PluginEventType } from 'roosterjs-editor-types';\nimport { processPastedContentFromExcel } from './Excel/processPastedContentFromExcel';\nimport { processPastedContentFromPowerPoint } from './PowerPoint/processPastedContentFromPowerPoint';\nimport { processPastedContentFromWordDesktop } from './WordDesktop/processPastedContentFromWordDesktop';\nimport { processPastedContentWacComponents } from './WacComponents/processPastedContentWacComponents';\nimport type { IContentModelEditor } from 'roosterjs-content-model-editor';\nimport type {\n    BorderFormat,\n    ContentModelBeforePasteEvent,\n    ContentModelBlockFormat,\n    ContentModelTableCellFormat,\n    FormatParser,\n    PasteType,\n} from 'roosterjs-content-model-types';\nimport type {\n    EditorPlugin,\n    HtmlSanitizerOptions,\n    IEditor,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\n// Map old PasteType to new PasteType\n// TODO: We can remove this once we have standalone editor\nconst PasteTypeMap: Record<OldPasteType, PasteType> = {\n    [OldPasteType.AsImage]: 'asImage',\n    [OldPasteType.AsPlainText]: 'asPlainText',\n    [OldPasteType.MergeFormat]: 'mergeFormat',\n    [OldPasteType.Normal]: 'normal',\n};\n\n/**\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\n * 1. Content copied from Word\n * 2. Content copied from Excel\n * 3. Content copied from Word Online or OneNote Online\n * 4. Content copied from Power Point\n * (This class is still under development, and may still be changed in the future with some breaking changes)\n */\nexport class ContentModelPastePlugin implements EditorPlugin {\n    private editor: IContentModelEditor | null = null;\n\n    /**\n     * Construct a new instance of Paste class\n     * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN\n     * @param allowExcelNoBorderTable Allow table copied from Excel without border\n     */\n    constructor(\n        private unknownTagReplacement: string = 'SPAN',\n        private allowExcelNoBorderTable?: boolean\n    ) {}\n\n    /**\n     * Get name of this plugin\n     */\n    getName() {\n        return 'ContentModelPaste';\n    }\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize(editor: IEditor) {\n        // TODO: Later we may need a different interface for Content Model editor plugin\n        this.editor = editor as IContentModelEditor;\n    }\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (!this.editor || event.eventType != PluginEventType.BeforePaste) {\n            return;\n        }\n\n        const ev = event as ContentModelBeforePasteEvent;\n\n        if (!ev.domToModelOption) {\n            return;\n        }\n\n        const pasteSource = getPasteSource(ev, false);\n        const pasteType = PasteTypeMap[ev.pasteType];\n\n        switch (pasteSource) {\n            case 'wordDesktop':\n                processPastedContentFromWordDesktop(ev);\n                break;\n            case 'wacComponents':\n                processPastedContentWacComponents(ev);\n                break;\n            case 'excelOnline':\n            case 'excelDesktop':\n                if (pasteType === 'normal' || pasteType === 'mergeFormat') {\n                    // Handle HTML copied from Excel\n                    processPastedContentFromExcel(\n                        ev,\n                        this.editor.getTrustedHTMLHandler(),\n                        this.allowExcelNoBorderTable\n                    );\n                }\n                break;\n            case 'googleSheets':\n                ev.sanitizingOption.additionalTagReplacements[\n                    PastePropertyNames.GOOGLE_SHEET_NODE_NAME\n                ] = '*';\n                break;\n            case 'powerPointDesktop':\n                processPastedContentFromPowerPoint(ev, this.editor.getTrustedHTMLHandler());\n                break;\n        }\n\n        addParser(ev.domToModelOption, 'link', parseLink);\n        addParser(ev.domToModelOption, 'tableCell', deprecatedBorderColorParser);\n        addParser(ev.domToModelOption, 'tableCell', tableBorderParser);\n        addParser(ev.domToModelOption, 'table', deprecatedBorderColorParser);\n        sanitizeBlockStyles(ev.sanitizingOption);\n\n        if (pasteType === 'mergeFormat') {\n            addParser(ev.domToModelOption, 'block', blockElementParser);\n            addParser(ev.domToModelOption, 'listLevel', blockElementParser);\n        }\n\n        ev.sanitizingOption.unknownTagReplacement = this.unknownTagReplacement;\n    }\n}\n\n/**\n * For block elements that have background color style, remove the background color when user selects the merge current format\n * paste option\n */\nconst blockElementParser: FormatParser<ContentModelBlockFormat> = (\n    format: ContentModelBlockFormat,\n    element: HTMLElement\n) => {\n    if (element.style.backgroundColor) {\n        delete format.backgroundColor;\n    }\n};\n\nfunction sanitizeBlockStyles(sanitizingOption: Required<HtmlSanitizerOptions>) {\n    chainSanitizerCallback(sanitizingOption.cssStyleCallbacks, 'display', (value: string) => {\n        return value != 'flex'; // return whether we keep the style\n    });\n}\n\nconst ElementBorderKeys = new Map<\n    keyof BorderFormat,\n    {\n        c: keyof CSSStyleDeclaration;\n        s: keyof CSSStyleDeclaration;\n        w: keyof CSSStyleDeclaration;\n    }\n>([\n    ['borderTop', { w: 'borderTopWidth', s: 'borderTopStyle', c: 'borderTopColor' }],\n    ['borderRight', { w: 'borderRightWidth', s: 'borderRightStyle', c: 'borderRightColor' }],\n    ['borderBottom', { w: 'borderBottomWidth', s: 'borderBottomStyle', c: 'borderBottomColor' }],\n    ['borderLeft', { w: 'borderLeftWidth', s: 'borderLeftStyle', c: 'borderLeftColor' }],\n]);\n\nfunction tableBorderParser(format: ContentModelTableCellFormat, element: HTMLElement): void {\n    BorderKeys.forEach(key => {\n        if (!format[key]) {\n            const styleSet = ElementBorderKeys.get(key);\n            if (\n                styleSet &&\n                element.style[styleSet.w] &&\n                element.style[styleSet.s] &&\n                !element.style[styleSet.c]\n            ) {\n                format[key] = `${element.style[styleSet.w]} ${element.style[styleSet.s]}`;\n            }\n        }\n    });\n}\n","import addParser from '../utils/addParser';\nimport { isNodeOfType, moveChildNodes } from 'roosterjs-content-model-dom';\nimport { setProcessor } from '../utils/setProcessor';\nimport type { TrustedHTMLHandler } from 'roosterjs-editor-types';\nimport type { ContentModelBeforePasteEvent } from 'roosterjs-content-model-types';\n\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\n\n/**\n * @internal\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\n * @param event The BeforePaste event\n */\n\nexport function processPastedContentFromExcel(\n    event: ContentModelBeforePasteEvent,\n    trustedHTMLHandler: TrustedHTMLHandler,\n    allowExcelNoBorderTable?: boolean\n) {\n    const { fragment, htmlBefore, clipboardData } = event;\n    const html = clipboardData.html ? excelHandler(clipboardData.html, htmlBefore) : undefined;\n\n    if (html && clipboardData.html != html) {\n        const doc = new DOMParser().parseFromString(trustedHTMLHandler(html), 'text/html');\n        moveChildNodes(fragment, doc?.body);\n    }\n\n    // For Excel Online\n    const firstChild = fragment.firstChild;\n    if (\n        isNodeOfType(firstChild, 'ELEMENT_NODE') &&\n        firstChild.tagName == 'div' &&\n        firstChild.firstChild\n    ) {\n        const tableFound = Array.from(firstChild.childNodes).every((child: Node) => {\n            // Tables pasted from Excel Online should be of the format: 0 to N META tags and 1 TABLE tag\n            const tagName = isNodeOfType(child, 'ELEMENT_NODE') && child.tagName;\n\n            return tagName == 'META'\n                ? true\n                : tagName == 'TABLE'\n                ? child == firstChild.lastChild\n                : false;\n        });\n\n        // Extract Table from Div\n        if (tableFound && firstChild.lastChild) {\n            event.fragment.replaceChildren(firstChild.lastChild);\n        }\n    }\n\n    addParser(event.domToModelOption, 'tableCell', (format, element) => {\n        if (!allowExcelNoBorderTable && element.style.borderStyle === 'none') {\n            format.borderBottom = DEFAULT_BORDER_STYLE;\n            format.borderLeft = DEFAULT_BORDER_STYLE;\n            format.borderRight = DEFAULT_BORDER_STYLE;\n            format.borderTop = DEFAULT_BORDER_STYLE;\n        }\n    });\n\n    setProcessor(event.domToModelOption, 'child', (group, element, context) => {\n        const segmentFormat = { ...context.segmentFormat };\n        if (group.blockGroupType === 'TableCell' && group.format.textColor) {\n            context.segmentFormat.textColor = group.format.textColor;\n        }\n\n        context.defaultElementProcessors.child(group, element, context);\n\n        if (group.blockGroupType === 'TableCell' && group.format.textColor) {\n            context.segmentFormat = segmentFormat;\n            delete group.format.textColor;\n        }\n    });\n}\n\n/**\n * @internal Export for test only\n * @param html Source html\n */\n\nexport function excelHandler(html: string, htmlBefore: string): string {\n    if (html.match(LAST_TD_END_REGEX)) {\n        const trMatch = htmlBefore.match(LAST_TR_REGEX);\n        const tr = trMatch ? trMatch[0] : '<TR>';\n        html = tr + html + '</TR>';\n    }\n    if (html.match(LAST_TR_END_REGEX)) {\n        const tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\n        const table = tableMatch ? tableMatch[0] : '<TABLE>';\n        html = table + html + '</TABLE>';\n    }\n\n    return html;\n}\n","import { moveChildNodes } from 'roosterjs-content-model-dom';\nimport type { BeforePasteEvent, TrustedHTMLHandler } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Convert pasted content from PowerPoint\n * @param event The BeforePaste event\n */\n\nexport function processPastedContentFromPowerPoint(\n    event: BeforePasteEvent,\n    trustedHTMLHandler: TrustedHTMLHandler\n) {\n    const { fragment, clipboardData } = event;\n\n    if (clipboardData.html && !clipboardData.text && clipboardData.image) {\n        // It is possible that PowerPoint copied both image and HTML but not plain text.\n        // We always prefer HTML if any.\n        const doc = new DOMParser().parseFromString(\n            trustedHTMLHandler(clipboardData.html),\n            'text/html'\n        );\n\n        moveChildNodes(fragment, doc?.body);\n    }\n}\n","import addParser from '../utils/addParser';\nimport { setProcessor } from '../utils/setProcessor';\nimport type {\n    ContentModelBeforePasteEvent,\n    ContentModelBlockFormat,\n    ContentModelBlockGroup,\n    ContentModelListItemLevelFormat,\n    ContentModelSegmentFormat,\n    DomToModelContext,\n    ElementProcessor,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\nconst WAC_IDENTIFY_SELECTOR =\n    'ul[class^=\"BulletListStyle\"]>.OutlineElement,ol[class^=\"NumberListStyle\"]>.OutlineElement,span.WACImageContainer,span.WACImageBorder';\nconst LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\n\nconst PARAGRAPH = 'Paragraph';\nconst TABLE_CONTAINER = 'TableContainer';\n\nconst TEMP_ELEMENTS_CLASSES = [\n    'TableInsertRowGapBlank',\n    'TableColumnResizeHandle',\n    'TableCellTopBorderHandle',\n    'TableCellLeftBorderHandle',\n    'TableHoverColumnHandle',\n    'TableHoverRowHandle',\n    'ListMarkerWrappingSpan',\n];\n\nconst CLASSES_TO_KEEP = [\n    'OutlineElement',\n    'NumberListStyle',\n    'WACImageContainer',\n    'ListContainerWrapper',\n    'BulletListStyle',\n    ...TEMP_ELEMENTS_CLASSES,\n    'TableCellContent',\n    PARAGRAPH,\n    'WACImageContainer',\n    'WACImageBorder',\n    TABLE_CONTAINER,\n    'LineBreakBlob',\n];\n\nconst LIST_ELEMENT_TAGS = ['UL', 'OL', 'LI'];\nconst LIST_ELEMENT_SELECTOR = LIST_ELEMENT_TAGS.join(',');\n\n/**\n * Wac components do not use sub and super tags, instead only add vertical align to a span.\n * This parser normalize the content for content model\n */\nconst wacSubSuperParser: FormatParser<ContentModelSegmentFormat> = (\n    format: ContentModelSegmentFormat,\n    element: HTMLElement\n): void => {\n    const verticalAlign = element.style.verticalAlign;\n    if (verticalAlign === 'super') {\n        format.superOrSubScriptSequence = 'super';\n    }\n    if (verticalAlign === 'sub') {\n        format.superOrSubScriptSequence = 'sub';\n    }\n};\n\n/**\n * This processor does:\n * 1) Remove the display and margin of the element.\n * 2) When an element should be ignored but should handle the child elements call the default child processor.\n * 3) Removes the End of Paragraph element to avoid empty lines, we should only remove this if the previous element of the EOP is an EmptyTextRun\n * 4) Finally call the default processor.\n * @returns\n */\nconst wacElementProcessor: ElementProcessor<HTMLElement> = (\n    group: ContentModelBlockGroup,\n    element: HTMLElement,\n    context: DomToModelContext\n): void => {\n    const elementTag = element.tagName;\n\n    if (element.matches(WAC_IDENTIFY_SELECTOR)) {\n        element.style.removeProperty('display');\n        element.style.removeProperty('margin');\n    }\n\n    if (element.classList.contains(LIST_CONTAINER_ELEMENT_CLASS_NAME)) {\n        context.elementProcessors.child(group, element, context);\n        return;\n    }\n\n    if (TEMP_ELEMENTS_CLASSES.some(className => element.classList.contains(className))) {\n        return;\n    } else if (shouldClearListContext(elementTag, element, context)) {\n        const { listFormat } = context;\n        listFormat.levels = [];\n        listFormat.listParent = undefined;\n    }\n\n    context.defaultElementProcessors.element(group, element, context);\n};\n\n/**\n * This processor calls the default list processor and then sets the correct list level and list bullet.\n */\nconst wacLiElementProcessor: ElementProcessor<HTMLLIElement> = (\n    group: ContentModelBlockGroup,\n    element: HTMLLIElement,\n    context: DomToModelContext\n): void => {\n    context.defaultElementProcessors.li?.(group, element, context);\n    const { listFormat } = context;\n    const listParent = listFormat.listParent;\n    if (listParent) {\n        const lastblock = listParent.blocks[listParent.blocks.length - 1];\n        if (\n            lastblock.blockType == 'BlockGroup' &&\n            lastblock.blockGroupType == 'ListItem' &&\n            context.listFormat.listParent !== lastblock\n        ) {\n            const currentLevel = lastblock.levels[lastblock.levels.length - 1];\n\n            // Get item level from 'data-aria-level' attribute\n            const level = parseInt(element.getAttribute('data-aria-level') ?? '');\n            if (level > 0) {\n                if (level > lastblock.levels.length) {\n                    while (level != lastblock.levels.length) {\n                        lastblock.levels.push(currentLevel);\n                    }\n                } else {\n                    lastblock.levels.splice(level, lastblock.levels.length - 1);\n                    lastblock.levels[level - 1] = currentLevel;\n                }\n            }\n        }\n    }\n};\n\n/**\n * This parsers does:\n * 1) Sets the display for dummy item to undefined when the current style is block.\n * 2) Removes the Margin Left\n */\nconst wacListItemParser: FormatParser<ContentModelListItemLevelFormat> = (\n    format: ContentModelListItemLevelFormat,\n    element: HTMLElement\n): void => {\n    if (element.style.display === 'block') {\n        format.displayForDummyItem = undefined;\n    }\n\n    format.marginLeft = undefined;\n};\n\n/**\n * Wac usually adds padding to lists which is unwanted so remove it.\n */\nconst wacListLevelParser: FormatParser<ContentModelListItemLevelFormat> = (\n    format: ContentModelListItemLevelFormat\n): void => {\n    format.marginLeft = undefined;\n    format.paddingLeft = undefined;\n};\n\n/**\n * This function returns whether we need to clear the list format.\n * Word Online wraps lists inside divs to have this structure:\n *\n *  <div class='ListContainerWrapper'>\n *      <ol>...</ol>\n *  </div>\n *  <div>\n *      <p>...</p>\n *  <div>\n *  <div class='ListContainerWrapper'>\n *      <ol>...</ol>\n *  </div>\n *\n *  So if a elements is not contained inside of a list we should clear the list context to prevent normal text to be\n *  transformed into list\n *  For the above scenario, if we do not clear the format, the content inside of the second div would be transformed to a list too.\n */\nfunction shouldClearListContext(\n    elementTag: string,\n    element: HTMLElement,\n    context: DomToModelContext\n) {\n    return (\n        context.listFormat.levels.length > 0 &&\n        LIST_ELEMENT_TAGS.every(tag => tag != elementTag) &&\n        !element.closest(LIST_ELEMENT_SELECTOR)\n    );\n}\n\n/**\n * @internal\n * Convert pasted content from Office Online\n * Once it is known that the document is from WAC\n * We need to remove the display property and margin from all the list item\n * @param ev ContentModelBeforePasteEvent\n */\nexport function processPastedContentWacComponents(ev: ContentModelBeforePasteEvent) {\n    addParser(ev.domToModelOption, 'segment', wacSubSuperParser);\n    addParser(ev.domToModelOption, 'listItemThread', wacListItemParser);\n    addParser(ev.domToModelOption, 'listLevel', wacListLevelParser);\n    addParser(ev.domToModelOption, 'container', wacBlockParser);\n\n    setProcessor(ev.domToModelOption, 'element', wacElementProcessor);\n    setProcessor(ev.domToModelOption, 'li', wacLiElementProcessor);\n    setProcessor(ev.domToModelOption, 'ol', wacListProcessor);\n    setProcessor(ev.domToModelOption, 'ul', wacListProcessor);\n    ev.sanitizingOption.additionalAllowedCssClasses.push(...CLASSES_TO_KEEP);\n}\n\n/**\n * List items from word have this format when using List items:\n * @example\n        <div>\n           <ol></ol>\n        </div>\n        <div>\n           <ol></ol>\n        </div>\n        <div>\n           <ol></ol>\n        </div>\n *  Due to this the div between each of the lists we need to restore the list context to use the previous list,\n *  otherwise it could create a new list instead under the same list element\n */\nconst wacListProcessor: ElementProcessor<HTMLOListElement | HTMLUListElement> = (\n    group: ContentModelBlockGroup,\n    element: HTMLOListElement | HTMLUListElement,\n    context: DomToModelContext\n): void => {\n    const lastBlock = group.blocks[group.blocks.length - 1];\n    const isWrappedInContainer = element.closest(`.${LIST_CONTAINER_ELEMENT_CLASS_NAME}`);\n    if (\n        isWrappedInContainer?.previousElementSibling?.classList.contains(\n            LIST_CONTAINER_ELEMENT_CLASS_NAME\n        )\n    ) {\n        if (lastBlock?.blockType === 'BlockGroup' && lastBlock.blockGroupType == 'ListItem') {\n            context.listFormat = {\n                threadItemCounts: [],\n                levels: lastBlock.levels,\n                listParent: group,\n            };\n        }\n    }\n    if (element.tagName.toUpperCase() === 'OL') {\n        context.defaultElementProcessors.ol?.(group, element as HTMLOListElement, context);\n    } else {\n        context.defaultElementProcessors.ul?.(group, element as HTMLUListElement, context);\n    }\n};\n\nconst wacBlockParser: FormatParser<ContentModelBlockFormat> = (\n    format: ContentModelBlockFormat,\n    element: HTMLElement\n) => {\n    if (element.classList.contains(TABLE_CONTAINER) && element.style.marginLeft.startsWith('-')) {\n        delete format.marginLeft;\n    }\n};\n","import addParser from '../utils/addParser';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\nimport { getStyles } from '../utils/getStyles';\nimport { moveChildNodes } from 'roosterjs-content-model-dom';\nimport { processWordComments } from './processWordComments';\nimport { processWordList } from './processWordLists';\nimport { setProcessor } from '../utils/setProcessor';\nimport type {\n    ContentModelBeforePasteEvent,\n    ContentModelBlockFormat,\n    ContentModelListItemFormat,\n    ContentModelListItemLevelFormat,\n    DomToModelContext,\n    ElementProcessor,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\nconst PERCENTAGE_REGEX = /%/;\nconst DEFAULT_BROWSER_LINE_HEIGHT_PERCENTAGE = 120;\n\n/**\n * @internal\n * Handles Pasted content when source is Word Desktop\n * @param ev ContentModelBeforePasteEvent\n */\nexport function processPastedContentFromWordDesktop(ev: ContentModelBeforePasteEvent) {\n    setProcessor(ev.domToModelOption, 'element', wordDesktopElementProcessor);\n    addParser(ev.domToModelOption, 'block', removeNonValidLineHeight);\n    addParser(ev.domToModelOption, 'listLevel', listLevelParser);\n    addParser(ev.domToModelOption, 'listItemElement', listItemElementParser);\n\n    // Remove \"border:none\" for image to fix image resize behavior\n    // We found a problem that when paste an image with \"border:none\" then the resize border will be\n    // displayed incorrectly when resize it. So we need to drop this style\n    chainSanitizerCallback(\n        ev.sanitizingOption.cssStyleCallbacks,\n        'border',\n        (value, element) => element.tagName != 'IMG' || value != 'none'\n    );\n\n    // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\n    chainSanitizerCallback(ev.sanitizingOption.elementCallbacks, 'O:P', element => {\n        moveChildNodes(element);\n        element.appendChild(element.ownerDocument.createTextNode('\\u00A0')); // &nbsp;\n        return true;\n    });\n}\n\n/**\n * @internal\n * Exported only for unit test\n */\nexport const wordDesktopElementProcessor: ElementProcessor<HTMLElement> = (\n    group,\n    element,\n    context\n) => {\n    const styles = getStyles(element);\n    // Process Word Lists or Word Commands, otherwise use the default processor on this element.\n    if (\n        !(processWordList(styles, group, element, context) || processWordComments(styles, element))\n    ) {\n        context.defaultElementProcessors.element(group, element, context);\n    }\n};\n\nfunction removeNonValidLineHeight(\n    format: ContentModelBlockFormat,\n    element: HTMLElement,\n    context: DomToModelContext,\n    defaultStyle: Readonly<Partial<CSSStyleDeclaration>>\n): void {\n    //If the line height is less than the browser default line height, line between the text is going to be too narrow\n    let parsedLineHeight: number;\n    if (\n        PERCENTAGE_REGEX.test(element.style.lineHeight) &&\n        !isNaN((parsedLineHeight = parseInt(element.style.lineHeight))) &&\n        parsedLineHeight < DEFAULT_BROWSER_LINE_HEIGHT_PERCENTAGE\n    ) {\n        format.lineHeight = defaultStyle.lineHeight;\n    }\n}\n\nfunction listLevelParser(\n    format: ContentModelListItemLevelFormat,\n    element: HTMLElement,\n    context: DomToModelContext,\n    defaultStyle: Readonly<Partial<CSSStyleDeclaration>>\n): void {\n    if (element.style.marginLeft != '') {\n        format.marginLeft = defaultStyle.marginLeft;\n    }\n\n    format.marginBottom = undefined;\n}\n\nconst listItemElementParser: FormatParser<ContentModelListItemFormat> = (\n    format: ContentModelListItemFormat,\n    element: HTMLElement\n): void => {\n    if (element.style.marginLeft) {\n        format.marginLeft = undefined;\n    }\n    if (element.style.marginRight) {\n        format.marginRight = undefined;\n    }\n};\n","import { isElementOfType } from 'roosterjs-content-model-dom';\n\nconst MSO_COMMENT_ANCHOR_HREF_REGEX = /#_msocom_/;\nconst MSO_SPECIAL_CHARACTER = 'mso-special-character';\nconst MSO_SPECIAL_CHARACTER_COMMENT = 'comment';\nconst MSO_ELEMENT = 'mso-element';\nconst MSO_ELEMENT_COMMENT_LIST = 'comment-list';\n\n/**\n * @internal\n * Check whether the element contain Word attributes related to comments and if it does we should no process\n * this element.\n * @returns\n */\nexport function processWordComments(styles: Record<string, string>, element: HTMLElement) {\n    return (\n        styles[MSO_SPECIAL_CHARACTER] == MSO_SPECIAL_CHARACTER_COMMENT ||\n        (isElementOfType(element, 'a') && MSO_COMMENT_ANCHOR_HREF_REGEX.test(element.href)) ||\n        styles[MSO_ELEMENT] == MSO_ELEMENT_COMMENT_LIST\n    );\n}\n","import { getStyles } from '../utils/getStyles';\nimport {\n    addBlock,\n    createListItem,\n    createListLevel,\n    isNodeOfType,\n    parseFormat,\n} from 'roosterjs-content-model-dom';\nimport type {\n    ContentModelBlockGroup,\n    ContentModelListItemLevelFormat,\n    ContentModelListLevel,\n    DomToModelContext,\n    DomToModelListFormat,\n    FormatParser,\n} from 'roosterjs-content-model-types';\n\n/** Word list metadata style name */\nconst MSO_LIST = 'mso-list';\nconst MSO_LIST_IGNORE = 'ignore';\nconst LOOKUP_DEPTH = 5;\nconst WORD_FIRST_LIST = 'l0';\n\ninterface WordDesktopListFormat extends DomToModelListFormat {\n    wordLevel?: number | '';\n    wordList?: string;\n    wordKnownLevels?: Map<string, ContentModelListLevel[]>;\n}\n\n/**\n * @internal\n * @param styles\n * @param group\n * @param element\n * @param context\n * @returns\n */\nexport function processWordList(\n    styles: Record<string, string>,\n    group: ContentModelBlockGroup,\n    element: HTMLElement,\n    context: DomToModelContext\n) {\n    const listFormat = context.listFormat as WordDesktopListFormat;\n    if (!listFormat.wordKnownLevels) {\n        listFormat.wordKnownLevels = new Map<string, ContentModelListLevel[]>();\n    }\n    const wordListStyle = styles[MSO_LIST] || '';\n\n    // If the element contains Ignore style, do not process it,\n    // Usually this element contains the fake bullet used in Word Desktop.\n    if (wordListStyle.toLowerCase() === MSO_LIST_IGNORE) {\n        return true;\n    }\n\n    const listProps = wordListStyle.split(' ');\n    // Try get the list metadata from word, which follows this format: l1 level1 lfo2\n    // If we are able to get the level property means we can process this element to be a list\n    listFormat.wordLevel = listProps[1] && parseInt(listProps[1].substr('level'.length));\n\n    listFormat.wordList = listProps[0] || WORD_FIRST_LIST;\n    if (listFormat.levels.length == 0) {\n        listFormat.levels = listFormat.wordKnownLevels.get(listFormat.wordList) || [];\n    }\n\n    if (wordListStyle && group && typeof listFormat.wordLevel === 'number') {\n        const { wordLevel } = listFormat;\n        // Retrieve the Fake bullet on the element and also the list type\n        const fakeBullet = getFakeBulletText(element);\n        const listType = getFakeBulletTagName(fakeBullet);\n\n        // Create the new level of the list item and parse the format\n        const newLevel: ContentModelListLevel = createListLevel(listType);\n        parseFormat(element, context.formatParsers.listLevel, newLevel.format, context);\n\n        // If the list format is in a different level, update the array so we get the new item\n        // To be in the same level as the provided level metadata.\n        if (wordLevel > listFormat.levels.length) {\n            while (wordLevel != listFormat.levels.length) {\n                listFormat.levels.push(newLevel);\n            }\n        } else {\n            listFormat.levels.splice(wordLevel, listFormat.levels.length - 1);\n            listFormat.levels[wordLevel - 1] = newLevel;\n        }\n\n        listFormat.listParent = group;\n\n        processAsListItem(listFormat, context, element, group, fakeBullet);\n\n        if (\n            listFormat.levels.length > 0 &&\n            listFormat.wordKnownLevels.get(listFormat.wordList) != listFormat.levels\n        ) {\n            listFormat.wordKnownLevels.set(listFormat.wordList, [...listFormat.levels]);\n        }\n        return true;\n    }\n\n    return false;\n}\n\nfunction processAsListItem(\n    listFormat: WordDesktopListFormat,\n    context: DomToModelContext,\n    element: HTMLElement,\n    group: ContentModelBlockGroup,\n    fakeBullet: string\n) {\n    const listItem = createListItem(listFormat.levels, context.segmentFormat);\n    const lastLevel = listItem.levels[listItem.levels.length - 1];\n\n    parseFormat(element, context.formatParsers.segmentOnBlock, context.segmentFormat, context);\n    parseFormat(element, context.formatParsers.listItemElement, listItem.format, context);\n\n    if (lastLevel?.listType == 'OL') {\n        parseFormat(\n            element,\n            [startNumberOverrideParser(fakeBullet)],\n            listItem.levels[listItem.levels.length - 1].format,\n            context\n        );\n    }\n\n    context.elementProcessors.child(listItem, element, context);\n    addBlock(group, listItem);\n}\n\nfunction startNumberOverrideParser(\n    fakeBullet: string\n): FormatParser<ContentModelListItemLevelFormat> | null {\n    return (format, _, context) => {\n        const {\n            wordKnownLevels,\n            wordLevel,\n            wordList,\n        } = context.listFormat as WordDesktopListFormat;\n        if (typeof wordLevel === 'number' && wordList) {\n            const start = parseInt(fakeBullet);\n            if (start != undefined && !isNaN(start) && !wordKnownLevels?.has(wordList)) {\n                format.startNumberOverride = start;\n            }\n        }\n    };\n}\n\n/**\n * Check whether the string is a fake bullet from word Desktop\n */\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): 'UL' | 'OL' {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels?: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = '';\n    levels = levels || LOOKUP_DEPTH;\n    let child: Node | null = node.firstChild;\n    while (!result && child) {\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent?.trim() ?? '';\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (isNodeOfType(child, 'ELEMENT_NODE') && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (isNodeOfType(node, 'ELEMENT_NODE')) {\n        const listAttribute = getStyles(node as HTMLElement)[MSO_LIST];\n        if (\n            listAttribute &&\n            listAttribute.length > 0 &&\n            listAttribute.trim().toLowerCase() == MSO_LIST_IGNORE\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","import type { GetSourceFunction } from './getPasteSource';\n\nconst WORD_ONLINE_TABLE_TEMP_ELEMENT_CLASSES = [\n    'TableInsertRowGapBlank',\n    'TableColumnResizeHandle',\n    'TableCellTopBorderHandle',\n    'TableCellLeftBorderHandle',\n    'TableHoverColumnHandle',\n    'TableHoverRowHandle',\n];\n\nconst WAC_IDENTIFY_SELECTOR =\n    'ul[class^=\"BulletListStyle\"]>.OutlineElement,ol[class^=\"NumberListStyle\"]>.OutlineElement,span.WACImageContainer,' +\n    WORD_ONLINE_TABLE_TEMP_ELEMENT_CLASSES.map(c => `table div[class^=\"${c}\"]`).join(',');\n\n/**\n * @internal\n * Check whether the fragment provided contain Wac Elements\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const documentContainWacElements: GetSourceFunction = props => {\n    const { fragment } = props;\n    return !!fragment.querySelector(WAC_IDENTIFY_SELECTOR);\n};\n","import { documentContainWacElements } from './documentContainWacElements';\nimport { isExcelDesktopDocument } from './isExcelDesktopDocument';\nimport { isExcelOnlineDocument } from './isExcelOnlineDocument';\nimport { isGoogleSheetDocument } from './isGoogleSheetDocument';\nimport { isPowerPointDesktopDocument } from './isPowerPointDesktopDocument';\nimport { isWordDesktopDocument } from './isWordDesktopDocument';\nimport { shouldConvertToSingleImage } from './shouldConvertToSingleImage';\nimport type { BeforePasteEvent, ClipboardData } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport type GetSourceInputParams = {\n    htmlAttributes: Record<string, string>;\n    fragment: DocumentFragment;\n    shouldConvertSingleImage: boolean;\n    clipboardData: ClipboardData;\n};\n\n/**\n * @internal\n * Represent the types of sources to handle in the Paste Plugin\n */\nexport type KnownPasteSourceType =\n    | 'wordDesktop'\n    | 'excelDesktop'\n    | 'excelOnline'\n    | 'powerPointDesktop'\n    | 'googleSheets'\n    | 'wacComponents'\n    | 'default'\n    | 'singleImage';\n\n/**\n * @internal\n */\nexport type GetSourceFunction = (props: GetSourceInputParams) => boolean;\n\nconst getSourceFunctions = new Map<KnownPasteSourceType, GetSourceFunction>([\n    ['wordDesktop', isWordDesktopDocument],\n    ['excelDesktop', isExcelDesktopDocument],\n    ['excelOnline', isExcelOnlineDocument],\n    ['powerPointDesktop', isPowerPointDesktopDocument],\n    ['wacComponents', documentContainWacElements],\n    ['googleSheets', isGoogleSheetDocument],\n    ['singleImage', shouldConvertToSingleImage],\n]);\n\n/**\n * @internal\n * This function tries to get the source of the Pasted content\n * @param event the before paste event\n * @param shouldConvertSingleImage Whether convert single image is enabled.\n * @returns The Type of pasted content, if no type found will return {KnownSourceType.Default}\n */\nexport function getPasteSource(\n    event: BeforePasteEvent,\n    shouldConvertSingleImage: boolean\n): KnownPasteSourceType {\n    const { htmlAttributes, clipboardData, fragment } = event;\n\n    let result: KnownPasteSourceType | null = null;\n    const param: GetSourceInputParams = {\n        htmlAttributes,\n        fragment,\n        shouldConvertSingleImage,\n        clipboardData,\n    };\n\n    getSourceFunctions.forEach((func, key) => {\n        if (!result && func(param)) {\n            result = key;\n        }\n    });\n\n    return result ?? 'default';\n}\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getPasteSource';\n\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\n\n/**\n * @internal\n * Checks whether the Array provided contains strings that identify Excel Desktop documents\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isExcelDesktopDocument: GetSourceFunction = props => {\n    const { htmlAttributes } = props;\n    // The presence of this attribute confirms its origin from Excel Desktop\n    return htmlAttributes[PastePropertyNames.EXCEL_DESKTOP_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE;\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getPasteSource';\n\n// Excel Desktop also has this attribute\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\n\n/**\n * @internal\n * Checks whether the Array provided contains strings that identify Excel Online documents\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isExcelOnlineDocument: GetSourceFunction = props => {\n    const { htmlAttributes } = props;\n    // The presence of Excel.Sheet confirms its origin from Excel, the absence of EXCEL_DESKTOP_ATTRIBUTE_NAME confirms it is from the Online version\n    return (\n        htmlAttributes[PastePropertyNames.PROG_ID_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE &&\n        htmlAttributes[PastePropertyNames.EXCEL_DESKTOP_ATTRIBUTE_NAME] == undefined\n    );\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getPasteSource';\n\n/**\n * @internal\n * Checks whether the fragment provided contain elements from Google sheets\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isGoogleSheetDocument: GetSourceFunction = props => {\n    const { fragment } = props;\n    return !!fragment.querySelector(PastePropertyNames.GOOGLE_SHEET_NODE_NAME);\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getPasteSource';\n\nconst POWERPOINT_ATTRIBUTE_VALUE = 'PowerPoint.Slide';\n\n/**\n * @internal\n * Checks whether the Array provided contains strings that identify Power Point Desktop documents\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isPowerPointDesktopDocument: GetSourceFunction = props => {\n    return props.htmlAttributes[PastePropertyNames.PROG_ID_NAME] == POWERPOINT_ATTRIBUTE_VALUE;\n};\n","import { PastePropertyNames } from './constants';\nimport type { GetSourceFunction } from './getPasteSource';\n\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\nconst WORD_PROG_ID = 'Word.Document';\n\n/**\n * @internal\n * Checks whether the Array provided contains strings that identify Word Desktop documents\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const isWordDesktopDocument: GetSourceFunction = props => {\n    const { htmlAttributes } = props;\n    return (\n        htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE ||\n        htmlAttributes[PastePropertyNames.PROG_ID_NAME] == WORD_PROG_ID\n    );\n};\n","import type { GetSourceFunction } from './getPasteSource';\n\n/**\n * @internal\n * Checks whether the fragment only contains a single image to paste\n * and the editor have the ConvertSingleImageBody Experimental feature\n * @param props Properties related to the PasteEvent\n * @returns\n */\nexport const shouldConvertToSingleImage: GetSourceFunction = props => {\n    const { shouldConvertSingleImage, clipboardData } = props;\n    return (\n        shouldConvertSingleImage &&\n        clipboardData.htmlFirstLevelChildTags?.length == 1 &&\n        clipboardData.htmlFirstLevelChildTags[0] == 'IMG'\n    );\n};\n","import type {\n    ContentModelFormatMap,\n    DomToModelOption,\n    FormatParser,\n    FormatParsersPerCategory,\n} from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport default function addParser<TKey extends keyof FormatParsersPerCategory>(\n    domToModelOption: DomToModelOption,\n    entry: TKey,\n    additionalFormatParsers: FormatParser<ContentModelFormatMap[TKey]>\n) {\n    if (!domToModelOption.additionalFormatParsers) {\n        domToModelOption.additionalFormatParsers = {};\n    }\n    if (!domToModelOption.additionalFormatParsers[entry]) {\n        domToModelOption.additionalFormatParsers[entry] = [];\n    }\n\n    domToModelOption.additionalFormatParsers[entry]?.push(additionalFormatParsers);\n}\n","import { BorderKeys, DeprecatedColors } from 'roosterjs-content-model-dom';\nimport type { BorderFormat, FormatParser } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport const deprecatedBorderColorParser: FormatParser<BorderFormat> = (\n    format: BorderFormat\n): void => {\n    BorderKeys.forEach(key => {\n        const value = format[key];\n        let color: string = '';\n        if (\n            value &&\n            DeprecatedColors.some(dColor => value.indexOf(dColor) > -1 && (color = dColor))\n        ) {\n            const newValue = value.replace(color, '').trimRight();\n            format[key] = newValue;\n        }\n    });\n};\n","/**\n * @internal\n * Get CSS styles of a given element in name-value pair format\n * @param element The element to get styles from\n */\nexport function getStyles(element: HTMLElement): Record<string, string> {\n    const result: Record<string, string> = {};\n    const style = element?.getAttribute('style') || '';\n    style.split(';').forEach(pair => {\n        const valueIndex = pair.indexOf(':');\n        const name = pair.slice(0, valueIndex);\n        const value = pair.slice(valueIndex + 1);\n        if (name && value) {\n            result[name.trim()] = value.trim();\n        }\n    });\n    return result;\n}\n","import { isElementOfType } from 'roosterjs-content-model-dom';\nimport type { ContentModelHyperLinkFormat, FormatParser } from 'roosterjs-content-model-types';\n\nconst SUPPORTED_PROTOCOLS = ['http:', 'https:', 'notes:', 'mailto:', 'onenote:'];\nconst INVALID_LINKS_REGEX = /^file:\\/\\/\\/[a-zA-Z\\/]/i;\n\n/**\n * @internal\n */\nexport const parseLink: FormatParser<ContentModelHyperLinkFormat> = (format, element) => {\n    if (!isElementOfType(element, 'a')) {\n        return;\n    }\n\n    let url: URL | undefined;\n    try {\n        url = new URL(element.href);\n    } catch {\n        url = undefined;\n    }\n\n    if (\n        (url && SUPPORTED_PROTOCOLS.indexOf(url.protocol) === -1) ||\n        INVALID_LINKS_REGEX.test(element.href)\n    ) {\n        element.removeAttribute('href');\n        format.href = '';\n    }\n};\n","import type { DomToModelOption, ElementProcessorMap } from 'roosterjs-content-model-types';\n\n/**\n * @internal\n */\nexport function setProcessor<TKey extends keyof ElementProcessorMap>(\n    domToModelOption: DomToModelOption,\n    entry: TKey,\n    processorOverride: Partial<ElementProcessorMap>[TKey]\n) {\n    if (!domToModelOption.processorOverride) {\n        domToModelOption.processorOverride = {};\n    }\n\n    domToModelOption.processorOverride[entry] = processorOverride;\n}\n","import { ContentModelEditor } from 'roosterjs-content-model-editor';\nimport {\n    ContentModelEditPlugin,\n    ContentModelPastePlugin,\n    EntityDelimiterPlugin,\n} from 'roosterjs-content-model-plugins';\nimport type { EditorPlugin } from 'roosterjs-editor-types';\nimport type {\n    ContentModelEditorOptions,\n    IContentModelEditor,\n} from 'roosterjs-content-model-editor';\n\n/**\n * Create a Content Model Editor using the given options\n * @param contentDiv The html div element needed for creating the editor\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\n * ContentEdit, HyperLink and Paste, user don't need to add those.\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\n * @returns The ContentModelEditor instance\n */\nexport function createContentModelEditor(\n    contentDiv: HTMLDivElement,\n    additionalPlugins?: EditorPlugin[],\n    initialContent?: string\n): IContentModelEditor {\n    const plugins = additionalPlugins ? [...additionalPlugins] : [];\n    plugins.push(\n        new ContentModelPastePlugin(),\n        new ContentModelEditPlugin(),\n        new EntityDelimiterPlugin()\n    );\n\n    const options: ContentModelEditorOptions = {\n        plugins: plugins,\n        initialContent: initialContent,\n        defaultSegmentFormat: {\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\n            fontSize: '11pt',\n            textColor: '#000000',\n        },\n    };\n    return new ContentModelEditor(contentDiv, options);\n}\n","export { createContentModelEditor } from './createContentModelEditor';\nexport * from 'roosterjs-content-model-types';\nexport * from 'roosterjs-content-model-dom';\nexport * from 'roosterjs-content-model-core';\nexport * from 'roosterjs-content-model-api';\nexport * from 'roosterjs-content-model-editor';\nexport * from 'roosterjs-content-model-plugins';\n","module.exports = roosterjs;","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(2594);\n"],"names":["default","ResultMap","left","ltr","rtl","center","right","TableAlignMap","model","alignment","paragraphOrListItemOrTable","getOperationalBlocks","forEach","block","newAligment","format","direction","blockType","alignTable","textAlign","length","internalSetDirection","marginLeft","paddingLeft","setProperty","marginRight","paddingRight","key","value","isBlockGroupOfType","findListItemsInSameThread","item","levels","level","blocks","indentation","paragraphOrListItem","isIndent","lastLevel","newLevel","createListLevel","listType","startNumberOverride","push","pop","isRtl","originalValue","parseValueWithUnit","newValue","Math","ceil","floor","max","isQuote","tagName","paragraphOfQuote","every","blockAndParent","parent","unwrapBlock","createFormatContainer","target","current","areSameFormats","canMergeQuote","wrapBlockStep1","wrapBlockStep2","clearContainerFormat","path","containerPathIndex","getClosestAncestorBlockGroupIndex","container","containerIndex","indexOf","blockIndex","newContainer","splice","clearListFormat","listItem","clearBlockFormat","index","decorator","blocksToClear","segmentsToClear","tablesToClear","iterateSelections","tableContext","segments","colIndex","rowIndex","isWholeTableSelected","cell","rows","cells","isSelected","updateTableCellMetadata","isHeader","useBorderBox","find","x","clearTableCellFormat","includeListFormatHolder","marker","filter","segmentType","isOnlySelectionMarkerSelected","adjustWordSelection","some","isWholeBlockSelected","i","defaultSegmentFormat","link","textColor","code","clearSegmentsFormat","table","borderCollapse","updateTableMetadata","applyTableFormat","undefined","createTablesFormat","mergeValue","isFirst","pendingFormat","formatState","firstTableContext","firstBlock","px","isFirstImage","isFirstSegment","result","listItemIndex","retrieveStructureFormat","isMultilineSelection","paragraph","headingLevel","parseInt","substring","validHeadingLevel","marginBottom","marginTop","retrieveParagraphFormat","segment","extractedBorder","borderColor","borderWidth","borderStyle","modelFormat","Object","assign","italic","underline","fontWeight","mergedFormat","superOrSubscript","superOrSubScriptSequence","split","isBold","strikethrough","letterSpacing","fontFamily","fontSize","backgroundColor","lineHeight","retrieveSegmentFormat","canUnlink","canAddImageAltText","extractBorderValues","color","width","style","imageFormat","boxShadow","borderRadius","canMergeTableCell","tableFormat","isInTable","tableHasHeader","row","retrieveTableFormat","round","parseFloat","step1Result","blockToWrap","creator","canMerge","prevBlock","wrapper","createAndAdd","setParagraphNotImplicit","addBlock","unshift","nextBlock","file","callback","FileReader","onload","onerror","readAsDataURL","entityModel","position","isBlock","focusAfterEntity","context","blockParent","deleteResult","deleteSelection","insertPoint","normalizeContentModel","pathIndex","child","directChild","blockGroupType","childIndex","blocksToInsert","nextParagraph","createParagraph","createBr","createSelectionMarker","setSelection","image","border","borderFormat","borderLeft","borderTop","borderBottom","borderRight","findListItems","group","pushNullIfNecessary","last","areListTypesCompatible","listItems","currentIndex","compareToIndex","currentLevels","compareToLevels","currentLevel","hasStartNumberOverride","levelLength","slice","currentItem","items","isOrderedList","filterListItems","shouldIgnoreBlock","paragraphOrListItems","alreadyInExpectedType","existingListItems","hasIgnoredParagraphBefore","itemIndex","segmentFormat","newListItem","createListItem","marginBlockEnd","marginBlockStart","isImplicit","firstMatcher","siblingMatcher","first","paragraphs","getSelectedParagraphs","changed","p","findIndex","findDelimiter","moveRightward","word","text","offset","char","isPunctuation","isSpace","splitTextSegment","textSegment","found","newSegmentLeft","createText","newSegmentRight","markerBlock","_","__","tempSegments","markerSelectionIndex","currentSegment","selection","firstCol","addSegment","operation","cachedElement","TextAlignValueMap","alignCellLeft","alignCellCenter","alignCellRight","VerticalAlignValueMap","alignCellTop","alignCellMiddle","alignCellBottom","alignTableCellInternal","sel","getSelectedCells","firstRow","lastRow","lastCol","verticalAlign","metadata","vAlignOverride","noSpanAbove","spanAbove","noSpanLeft","spanLeft","noDifferentBelowSpan","map","spanCount","getBelowSpanCount","a","noDifferentRightSpan","col","getRightSpanCount","columns","createTable","createTableCell","cellInNextCol","widths","collapseTableSelection","cellInNextRow","createEmptyParagraph","newPara","br","firstCell","shift","hasSelection","insertLeft","insertAbove","sourceRow","height","canMergeCells","mergingColIndex","newSelectedCol","mergingRowIndex","newSelectedRow","newCell","dataset","newWidth","belowRow","belowCell","newHeight","newRow","editor","focus","formatContentModel","setModelAlignment","apiName","setModelDirection","HeaderFontSizes","h1","h2","h3","h4","h5","h6","formatParagraphWithContentModel","para","tag","setModelIndentation","newPendingFormat","createParagraphDecorator","spacing","toString","DefaultQuoteFormat","BuildInQuoteFormat","quoteFormat","fullQuoteFormat","toggleModelBlockQuote","type","options","contentNode","wrapperDisplay","skipUndoSnapshot","getDocument","createElement","display","appendChild","createEntity","insertEntityModel","newEntities","selectionOverride","changeSource","ChangeSource","InsertEntity","getChangeData","id","isReadonly","clearModelFormat","reducedModelChildProcessor","nodeStack","selectionRootNode","getSelectionRootNode","root","startNode","node","contains","isNodeOfType","parentNode","createNodeStack","stackChild","getRegularSelectionOffsets","nodeStartOffset","nodeEndOffset","firstChild","nextSibling","getChildIndex","handleRegularSelection","processChildNode","defaultElementProcessors","getPendingFormat","createContentModel","processorOverride","getUndoState","isDarkMode","zoomScale","getZoomScale","retrieveModelFormatState","adjustSegmentSelection","ref","getDOMSelection","readFile","dataUrl","isDisposed","originalSrc","updateImageMetadata","src","previousSrc","alt","triggerPluginEvent","newSrc","insertImageWithSrc","createImage","doc","createContentModelDocument","mergeModel","mergeFormat","imageFileOrSrc","altText","margin","url","href","getSelectedSegments","firstSegment","join","URI_REGEX","MAILTO_REGEX","FTP_REGEX","anchorTitle","displayText","sanitizer","HtmlSanitizer","document","sanitize","getAttribute","checkXss","trim","matchLink","normalizedUrl","prefix","search","applyLinkPrefix","originalText","createLink","addLink","originalUrl","CreateLink","onNodeCreated","modelElement","isChanged","getFirstSelectedListItem","updateListMetadata","setListType","newFormat","formatSegmentWithContentModel","capitalization","language","toLocaleLowerCase","toLocaleUpperCase","wordArray","charAt","regex","RegExp","replace","match","FONT_SIZES","change","sizeInPt","newSize","pt","changeBase","fontSizes","min","getNewFontSize","setFontSizeInternal","changeFontSizeInternal","lastParagraph","lastSegmentIndex","fontName","isTurningOn","DefaultCode","addCode","applyBorderFormat","positions","pos","borderOverride","tableModel","getFirstSelectedTable","perimeter","Top","Bottom","Left","Right","operations","allBorders","leftBorder","rightBorder","topBorder","bottomBorder","singleCol","singleRow","modifyPerimeter","alignTableCellHorizontally","alignTableCellVertically","deleteTableColumn","deleteTableRow","deleteTable","insertTableRow","insertTableColumn","mergeTableRow","mergeTableCells","mergeTableColumn","splitTableCellHorizontally","splitTableCellVertically","ensureFocusableParagraphForTable","normalizeTable","hasMetadata","keepCellShade","insertPosition","createTableStructure","setTableCellBackgroundColor","setStyleCallback","toggleStyleCallback","segmentHasStyleCallback","includingFormatHolder","afterFormatCallback","segmentAndParagraphs","getSelectedSegmentsAndParagraphs","isCollapsedSelection","formatsAndSegments","isTurningOff","BulletListType","Min","Disc","Dash","Square","ShortArrow","LongArrow","UnfilledArrow","Hyphen","DoubleLongArrow","Circle","Max","AutoLink","Format","ImageResize","Paste","SetContent","Cut","Drop","SwitchToDarkMode","SwitchToLightMode","ListChain","Keyboard","NumberingListType","Decimal","DecimalDash","DecimalParenthesis","DecimalDoubleParenthesis","LowerAlpha","LowerAlphaParenthesis","LowerAlphaDoubleParenthesis","LowerAlphaDash","UpperAlpha","UpperAlphaParenthesis","UpperAlphaDoubleParenthesis","UpperAlphaDash","LowerRoman","LowerRomanParenthesis","LowerRomanDoubleParenthesis","LowerRomanDash","UpperRoman","UpperRomanParenthesis","UpperRomanDoubleParenthesis","UpperRomanDash","TableBorderFormat","Default","ListWithSideBorders","NoHeaderBorders","NoSideBorders","FirstColumnHeaderExternal","EspecialType1","EspecialType2","EspecialType3","Clear","core","option","cachedModel","cache","lifecycle","shadowEditFragment","cloneModel","includeCachedElement","api","editorContext","createEditorContext","domToModelContext","createDomToModelContext","defaultDomToModelOptions","createDomToModelContextWithConfig","defaultDomToModelConfig","domToContentModel","contentDiv","internalCreateContentModel","cachedSelection","darkColorHandler","defaultFormat","addDelimiterForEntity","allowCacheElement","domIndexer","element","ownerDocument","defaultView","getComputedStyle","isRootRtl","checkRootRtl","originalWidth","getBoundingClientRect","visualWidth","offsetWidth","checkZoomScale","hasFocus","setDOMSelection","handlePendingFormat","range","collapsed","posContainer","startContainer","posOffset","startOffset","formatter","rawEvent","deletedEntities","newImages","writeBack","viewport","getVisibleViewport","maxWidth","handleImages","setContentModel","addUndoSnapshot","formatApiName","eventData","eventType","contentModel","clearModelCache","source","data","additionalData","changedEntities","entity","concat","entry","triggerEvent","getSelection","rangeCount","getRangeAt","commonAncestorContainer","getNewSelection","scrollContainer","domEvent","elements","additionalRects","rects","top","bottom","rect","r","getIntersectedRect","activeElement","modelToDomContext","createModelToDomContext","defaultModelToDomOptions","createModelToDomContextWithConfig","defaultModelToDomConfig","contentModelToDom","ignoreSelection","setRangeSelection","createRange","selectNode","collapse","addRangeToSelection","addUniqueId","idPrefix","querySelectorAll","skipSelectionChangedEvent","skipReselectOnFocus","sheet","selectionStyleNode","selectionRules","rootSelector","buildImageCSS","imageSelectionBorderColor","firstColumn","lastColumn","parseTableCells","selectors","cont","indexes","toArray","childNodes","el","start","end","tdCount","midElement","ind","middleElSelector","currentRow","cellIndex","selector","handleTableSelected","cssRules","currentRules","buildTableCss","deleteRule","insertRule","newSelection","selectionRangeEx","switchShadowEdit","editorCore","isOn","fragment","createDocumentFragment","clonedRoot","cloneNode","moveChildNodes","selectionPath","onNativeSelectionChange","updateCachedModel","this","state","cacheModel","contentModelDomIndexer","getName","initialize","addEventListener","dispose","removeEventListener","getState","onPluginEvent","event","shouldClearCache","invalidateCache","isInShadowEdit","forceUpdate","newRangeEx","areSameSelection","reconcileSelection","defaultPrevented","isCharacterValue","ContentModelCachePlugin","disposer","onPaste","clipboardData","isClipboardEvent","dataTransfer","preventDefault","extractClipboardItems","allowedCustomPasteType","then","paste","addDomEventHandler","e","copy","onCutCopy","cut","isCut","pasteModel","transformToDarkColor","getTempDiv","selectionForCopy","newRange","tempDiv","querySelector","elementToSelect","parentElement","childElementCount","domSelectionToRange","runAsync","cleanUpAndRestoreSelection","div","getCustomData","overflow","userSelect","contentEditable","body","removeChild","isElementOfType","wrap","isContentEditable","removeAttribute","ContentModelCopyPastePlugin","hasDefaultFormat","getObjectKeys","getEnvironment","isAndroid","isComposing","isInIME","checkAndApplyPendingFormat","isCursorMovingKey","clearPendingFormat","applyDefaultFormat","canApplyPendingFormat","applyPendingFormat","ContentModelFormatPlugin","onDragStart","dragEvent","getElementAtCursor","onDrop","onScroll","onKeyboardEvent","which","stopPropagation","onInputEvent","onMouseDown","mouseUpEventListerAdded","onMouseUp","mouseDownX","pageX","mouseDownY","pageY","removeMouseUpEventListener","isClicking","onContextMenuEvent","allItems","searcher","getContentSearcherOfCursor","elementBeforeCursor","getInlineElementBefore","eventTargetNode","button","getContainerNode","contextMenuProviders","provider","getContextMenuItems","plugins","isContextMenuProvider","eventHandlers","keypress","getEventHandler","keydown","keyup","mousedown","contextmenu","compositionstart","compositionend","dragstart","drop","input","pluginEventType","beforeDispatch","DOMEventPlugin","ENTITY_ID_REGEX","EntityOperationMap","newEntity","overwrite","removeFromEnd","removeFromStart","replaceTemporaryContent","updateEntityState","click","entityMap","handleMouseUpEvent","handleContentChangedEvent","handleExtractContentWithDomEvent","isEntityElement","cmEvent","modifiedEntities","getChangedEntities","entityStates","entityType","isFakeEntity","entityFormat","ensureUniqueId","className","generateEntityClassNames","eventResult","canPersist","shouldPersist","mapEntry","isDeleted","entityState","findAllEntities","classList","name","parseEntityClassName","getAllEntityWrappers","exec","baseId","substr","newId","num","EntityPlugin","ContentEditableAttributeName","initializer","onInitialNodeCreated","initialModel","createInitModel","adjustColor","doNotAdjustEditorColor","adjustContainerColor","inDarkMode","onExternalContentTransform","getDarkColorHandler","setColor","LifecyclePlugin","onFocus","onBlur","onKeyDownDocument","onMouseDownDocument","styleNode","head","env","isSafari","blur","getClickingImage","selectImage","selectBeforeImage","isModifierKey","shiftKey","setStart","SelectionPlugin","Backspace","Delete","Enter","snapshotsService","undoSnapshotService","createUndoSnapshotsService","isRestoring","hasNewContent","isNested","lastKeyPress","willHandleEventExclusively","ctrlKey","canUndoAutoComplete","undoState","canUndo","canRedo","onKeyDown","onKeyPress","clearRedoForInput","onContentChanged","onBeforeKeyboardEditing","evt","altKey","undo","isCtrlOrMetaPressed","metaKey","clearRedo","isMac","UndoPlugin","createContentModelCachePlugin","createContentModelFormatPlugin","copyPaste","createContentModelCopyPastePlugin","createDOMEventPlugin","createLifecyclePlugin","createEntityPlugin","createSelectionPlugin","createUndoPlugin","removeAllRanges","addRange","getNewPendingFormat","markerFormat","isBlockElement","blockCount","previousBlock","previousSegment","subStr","newText","sel1","sel2","r1","r2","endContainer","endOffset","isIndexedSegment","__roosterjsContentModel","Array","isArray","onSegment","segmentNode","reconcileNodeSelection","reconcileTextSelection","insertMarker","lastChild","isAfter","formatSegment","textNode","selectable","newSegments","txt","nodeValue","textSegments","middle","newLast","firstIndex","lastIndex","onParagraph","paragraphElement","previousText","onTable","tableElement","tableRows","oldSelection","marker1","marker2","entities","ColorAttributeEnum","VARIABLE_REGEX","ColorAttributeName","getDarkColor","knownColors","getKnownColorsCopy","values","registerColor","lightModeColor","darkModeColor","colorKey","parsedColor","parseColorValue","reset","removeProperty","isInDarkMode","startsWith","findLightColorFromDarkColor","darkColor","rgbSearch","parseColor","rgbCurrent","transformElementColor","fromDarkMode","toDarkMode","names","getPropertyValue","DarkColorHandlerImpl","snapshots","totalSize","autoCompleteIndex","maxSize","canMove","step","newIndex","move","addSnapshot","snapshot","isAutoCompleteSnapshot","currentSnapshot","isSameSnapshot","html","getSnapshotLength","removeCount","removedSize","UndoSnapshotsServiceImpl","defaultTrustHtmlHandler","getDarkColorFallback","unportedCoreApiMap","unportedCorePluginState","tempPlugins","userAgent","corePlugins","createStandaloneEditorCorePlugins","standaloneCoreApiMap","coreApiOverride","originalApi","environment","window","navigator","appVersion","test","trustedHTMLHandler","createStandaloneEditorDefaultSettings","getPluginState","tablePreProcessor","metadataAppliers","listItemMetadataApplier","listLevel","listLevelMetadataApplier","createDomToModelConfig","createModelToDomConfig","get","createModelFromHtml","deleteSegment","deleteBlock","combineBorderValue","normalizeText","createTableRanges","createStandaloneEditorCore","isOptional","minValue","maxValue","allowNull","itemDef","minLength","maxLength","propertyDef","NumberDefinition","createNumberDefinition","ImageMetadataFormatDefinition","createObjectDefinition","widthPx","heightPx","leftPercent","rightPercent","topPercent","bottomPercent","angleRad","createStringDefinition","naturalHeight","naturalWidth","updateMetadata","DefaultOrderedListStyles","DefaultUnorderedListStyles","OrderedMapPlaceholderRegex","RomanValues","M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I","OrderedMap","UnorderedMap","convertDecimalsToAlpha","decimal","isLowerCase","alpha","String","fromCharCode","toLowerCase","convertDecimalsToRoman","romanValue","timesRomanCharAppear","repeat","listMetadataDefinition","orderedStyleType","unorderedStyleType","shouldApplyToItem","listStyleType","getRawListStyleType","depth","metadataDefinition","applierFunction","template","listNumber","listFormat","threadItemCounts","list","TableCellMetadataFormatDefinition","bgColorOverride","createBooleanDefinition","NullStringDefinition","BooleanDefinition","TableFormatDefinition","topBorderColor","bottomBorderColor","verticalBorderColor","hasHeaderRow","headerRowColor","hasFirstColumn","hasBandedColumns","hasBandedRows","bgColorEven","bgColorOdd","tableBorderFormat","DeleteSelectionIteratingOptions","contentUnderSelectedTableCell","contentUnderSelectedGeneralElement","createInsertPoint","formatContext","insertMarkerIndex","lastTableContext","isForward","array","deleteLength","deleteState","processor","selectionRoot","isInSelection","shouldUseTableProcessor","tableProcessor","entityProcessor","BorderStyles","BorderSizeRegex","combinedBorder","v","CursorMovingKeys","Set","isCtrlKey","isAltKey","isMetaKey","has","SPACES_REGEX","charCodeAt","trs","tr","sourceCol","targetCol","td","colSpan","rowSpan","cloneModelWithFormat","cloneModelWithDataset","cloneBlockBase","cloneBlockGroupBase","handleCachedElement","zeroFontSize","cloneFormatContainer","cloneGeneralBlock","formatHolder","cloneSelectionMarker","cloneListLevel","cloneListItem","divider","cloneDivider","cloneEntity","newParagraph","cloneSegmentBase","general","cloneGeneralSegment","title","isSelectedAsImageSelection","cloneSegment","cloneParagraph","from","cloneTableCell","cloneTableRow","cloneTable","cloneBlock","newSegment","Error","newModel","DOMParser","parseFromString","blockGroupTypes","stopTypes","boldStyle","HeadingTags","mergeParagraph","markerPosition","mergeToCurrentParagraph","splitParagraph","segmentIndex","sourceKeys","mergeTable","newTable","j","k","leftCell","aboveCell","oldCell","newMarker","insertBlock","mergeList","newList","listParent","newParaFormat","paraIndex","applyDefaultFormatOption","mergeSegmentFormat","targetformat","sourceFormat","PasteTypeMap","asImage","asPlainText","normal","EmptySegmentFormat","mergePasteContent","applyCurrentFormat","customizedMerge","shouldMergeTable","pasteType","originalFormat","snapshotBeforePaste","setContent","getContent","createDefaultHtmlSanitizerOptions","additionalAllowedCssClasses","AllowedEntityClasses","cssStyleCallbacks","sanitizingOption","htmlBefore","htmlAfter","htmlAttributes","domToModelOption","createBeforePasteEventData","currentFormat","rawHtml","imageDataUri","getTrustedHTMLHandler","retrieveMetadataFromClipboard","handleImagePaste","handleTextPaste","formatContainer","applySegmentFormatToElement","pluginEvent","sanitizePasteContent","triggerPluginEventAndCreatePasteFragment","selections","collectSelections","deepFirst","findSequence","removeUnmeaningfulSelections","groupIndex","checkFirstParagraph","allSegments","resultPath","blockToDelete","replacement","segmentToDelete","preserveWhiteSpace","isWhiteSpacePreserved","isBackward","normalizeSingleSegment","normalizePreviousSegment","deleteSingleChar","additionalSteps","deleteExpandedSelection","isValidDeleteSelectionContext","mergeParagraphAfterDelete","internalIterateSelections","treatAllAsSelect","hasSelectedSegment","hasUnselectedSegment","newPath","handleGeneralContent","handleGeneralElement","setSelectionToBlockGroup","handleSelection","isGeneralSegment","setIsSelected","findCell","currentCell","setSelectionToTable","segmentsToDelete","setSelectionToSegment","setSelectionToBlock","DEFAULT_FORMAT","effectiveMetadata","metaOverrides","removeCellShade","overrides","bgColorOverrides","vAlignOverrides","borderOverrides","updateOverrides","clearCache","transparentBorderMatrix","BorderFormatters","alwaysUseTransparent","BorderKeys","getBorderStyleFromColor","formatCells","setBorderColor","setFirstColumnFormat","setHeaderRowFormat","getTableCellWidth","tryMoveBlocks","targetCell","sourceCell","s","White","Black","shouldRemoveColor","cellBackgroundColor","lightness","calculateLightness","colorValues","red","green","blue","isColorOverride","applyToSegments","setAdaptiveCellColor","removeAdaptiveCellColor","HEX3_REGEX","HEX6_REGEX","RGB_REGEX","RGBA_REGEX","defaultContentModelFormatMap","blockquote","pre","whiteSpace","blockElement","defaultHTMLStyleMap","address","article","aside","b","dd","dl","dt","em","fontStyle","fieldset","figcaption","figure","footer","form","header","hr","li","main","nav","ol","textDecoration","section","strike","strong","sub","sup","boxSizing","th","u","ul","config","blockFormat","blockDecorator","elementProcessors","defaultProcessorMap","formatParsers","buildFormatParsers","formatParserOverride","additionalFormatParsers","defaultFormatParsers","additionalParsersArray","combinedOverrides","defaultFormatKeysPerCategory","reduce","formatKey","parsers","linkProcessor","knownElementProcessor","brProcessor","codeProcessor","font","fontProcessor","img","imageProcessor","headingProcessor","hrProcessor","listItemProcessor","listProcessor","pProcessor","formatContainerProcessor","span","generalProcessor","textProcessor","elementProcessor","childProcessor","delimiter","delimiterProcessor","SegmentDecoratorTags","isSegmentDecorator","parseFormat","ContextStyles","addSelectionMarker","stackFormat","tryGetProcessorForEntity","isEntityDelimiter","tryGetProcessorForDelimiter","isBlockEntity","FontSizes","size","intSize","Number","isNaN","segmentOnBlock","getDefaultStyle","shouldFallbackToParagraph","generalBlockProcessor","createGeneralBlock","isSelectedBefore","generalSegmentProcessor","createGeneralSegment","addDecorators","blockProcessor","createDivider","FormatContainerTriggerStyles","ByPassFormatContainerTags","defaultStyle","bgcolor","shouldUseFormatContainer","segmentUnderLink","hasAttribute","listItemElement","listItemThread","currentBlocks","lastItem","listLevelThread","originalListParent","calcSizes","lastPos","tableSelection","hasTableSelection","tableBorder","columnPositions","rowPositions","tableRow","tbody","parentTag","hasSelectionBeforeCell","colEnd","rowEnd","needCalcWidth","needCalcHeight","segmentOnTableCell","cellFormat","tableCell","hasTd","spannedRow","hasSelectionAfterCell","heights","offsets","txtStartOffset","txtEndOffset","ensureParagraph","subText","addTextSegment","WhiteSpaceValuesNeedToHandle","textModel","hasSpacesOnly","f1","f2","keys1","keys2","currentContainer","BLOCK_DISPLAY_STYLES","parser","SkippedStylesForBlock","SkippedStylesForTable","stackFormatInternal","processType","linkFormat","codeFormat","decoratorFormat","stackLinkInternal","stackCodeInternal","ENTITY_INFO_NAME","ENTITY_TYPE_PREFIX","ENTITY_ID_PREFIX","ENTITY_READONLY_PREFIX","DELIMITER_BEFORE","DELIMITER_AFTER","isDelimiter","textContent","insertDelimiter","createTextNode","insertBefore","entityWrapper","nextElementSibling","previousElementSibling","delimiterAfter","delimiterBefore","obj","keys","expectedType","nodeType","Node","EditingInfoDatasetName","definition","metadataString","JSON","parse","validate","stringify","def","n1","n2","abs","keepExistingChildren","newElement","collection","call","wrapperTag","directionFormatHandler","dir","apply","displayFormatHandler","htmlAlignFormatHandler","htmlAlign","calcAlign","setAttribute","lineHeightFormatHandler","MarginKeys","marginFormatHandler","implicitFormat","PaddingKeys","paddingFormatHandler","textAlignFormatHandler","flexDirection","alignSelf","whiteSpaceFormatHandler","backgroundColorFormatHandler","getColor","borderBoxFormatHandler","borderFormatHandler","boxShadowFormatHandler","datasetFormatHandler","floatFormatHandler","float","idFormatHandler","PercentageRegex","tryParseSize","attrName","attrValue","sizeFormatHandler","maxHeight","minWidth","minHeight","verticalAlignFormatHandler","wordBreakFormatHandler","wordBreak","defaultFormatHandlerMap","bold","boldFormatHandler","borderBox","fontFamilyFormatHandler","fontSizeFormatHandler","entityFormatHandler","italicFormatHandler","letterSpacingFormatHandler","linkFormatHandler","listItemThreadFormatHandler","listLevelThreadFormatHandler","listStyle","listStyleFormatHandler","padding","strikeFormatHandler","superOrSubScript","superOrSubScriptFormatHandler","tableLayout","tableLayoutFormatHandler","tableSpacing","tableSpacingFormatHandler","textColorFormatHandler","textColorOnTableCell","textColorOnTableCellFormatHandler","underlineFormatHandler","styleBasedSegmentFormats","elementBasedSegmentFormats","sharedBlockFormats","sharedContainerFormats","styleBasedSegment","elementBasedSegment","tableCellBorder","defaultFormatAppliers","isEntity","isLiUnderOl","defaultStyles","displayForDummyItem","startNumber","listStylePosition","blockFontWeight","wrapAllChildNodes","isSuperOrSubScript","contextFont","knownFontSize","KnownFontSizes","endsWith","existingFontSize","normalizeFontSize","small","medium","large","rel","anchorId","relationship","anchorClass","reverse","implicitColor","BorderCollapsed","borderSpacing","DeprecatedColors","isBackground","effectiveColor","initial","justify","align","MarginValueRegex","getFontSize","currentSizeOrElement","styleInPt","ptToPx","currentSizePxOrElement","resultUnit","numStr","unit","addDelimiters","lastSegment","applyFormat","formatAppliers","lastBlock","SPACE_TEXT_REGEX","isBlockEmpty","isBlockGroupEmpty","isSegmentEmpty","isBlockGroup","isSegment","WHITESPACE_PRE_VALUES","normalizeParagraph","c","secondLast","noMarkerSegments","normalizeAllSegments","markerIndex","prev","next","removeEmptyLinks","removeEmptySegments","SPACE","NONE_BREAK_SPACE","LEADING_SPACE_REGEX","TRAILING_SPACE_REGEX","resetNormalizeSegmentContext","ignoreLeadingSpaces","ignoreTrailingSpaces","lastInlineSegment","lastTextSegment","normalizeSegment","normalizeTextSegments","normalizeLastTextSegment","groupToUnwrap","rowCount","spanLeftOrColSpan","spanAboveOrRowSpan","calcPosition","modelHandlers","blockGroupChildren","startPosition","endPosition","imageSelection","setEnd","extractSelectionRange","normalize","regularSelection","defaultContentModelHandlers","modelHandlerOverride","buildFormatAppliers","formatApplierOverride","additionalFormatAppliers","defaultModelHandlers","additionalAppliersArray","appliers","handleBlock","handleBlockGroupChildren","handleBr","entityBlock","handleEntityBlock","entitySegment","handleEntitySegment","generalBlock","handleGeneralBlock","generalSegment","handleGeneralSegment","handleDivider","handleImage","handleList","handleListItem","handleParagraph","handleFormatContainer","handleSegment","segmentDecorator","handleSegmentDecorator","handleTable","handleText","refNode","handlers","childBlock","segmentNodes","handleSegmentCommon","reuseCachedElement","after","before","PreChildFormat","imageModel","widthNum","heightNum","layer","stackLevel","itemLevel","editingInfo","applyMetadata","unwrap","needParagraphWrapper","formatOnWrapper","handleSegments","optimize","codeNode","tableNode","OptimizeTags","hasSameAttributes","element1","element2","attr1","attributes","attr2","removeUnnecessarySpan","mergeNode","newNode","applier","containerNode","tagNameOrFormat","addUndoSnapshotInternal","canUndoByBackspace","convertDomSelectionToMetadata","innerHTML","getEntityState","Position","getStart","getEnd","attachDomEvent","eventMap","disposers","handlerObj","eventName","onEvent","coreApiMap","ensureTypeInContainer","getStyleBasedFormatState","insertNode","restoreUndoSnapshot","transformColor","keyboardEvent","findClosestElementAncestor","formatNode","getBlockElementAtNode","collapseToSingleElement","isNodeEmpty","brEl","append","shouldSetNodeStyles","safeInstanceOf","innerText","wasNodeJustCreatedByKeyboardEvent","updateCursor","replaceSelection","insertOnNewLine","mode","clonedNode","content","triggerExtractContentEvent","includeSelectionMarker","getTextContent","originalRange","getSelectionPath","getHtmlWithSelectionPath","styleTextColor","styleBackColor","styles","getComputedStyles","backColor","textColors","backgroundColors","insertToRegionRoot","isBegin","getFirstLastBlockElement","getStartNode","getEndNode","isVoidHtmlElement","nodes","insertedNode","rangeToRestore","cloneRange","getInitialRange","deleteContents","region","getRegionsFromRange","isAtEnd","splitTextNode","rootNode","splitParentNode","adjustInsertPositionRegionRoot","tempPos","adjustInsertPositionNewLine","adjustInsertPosition","nodeForCursor","queryElements","getEntitySelector","getEntityFromElement","triggerContentChangedEvent","contentChanged","newContent","restoreContentWithEntityPlaceholder","metadataFromContent","extractContentMetadata","convertMetadataToDOMSelection","selectContentMetadata","iterateElements","transformer","includeSelf","isHTMLElement","htmlElement","ELEMENT_NODE","forceTransform","allowedEventsInShadowEdit","broadcast","plugin","handledExclusively","features","hasFunctionKey","ctrlOrMeta","isKeyDownEvent","getSelectionRange","feature","allowFunctionKeys","shouldHandleEvent","handleEvent","handledByEditFeature","EditPlugin","isContentModelSelectionChangedEvent","convertDomSelectionToRangeEx","EventTypeTranslatePlugin","normalizeTables","normalizeTableFromEvent","prevElement","previousSibling","changeElementTag","tables","rangeEx","getSelectionRangeEx","ranges","isDOMChanged","getTagOfNode","colgroups","thead","colgroup","select","coordinates","NormalizeTablePlugin","corePluginOverride","eventTranslate","createEventTypeTranslatePlugin","edit","createEditPlugin","createNormalizeTablePlugin","createEditorCore","getCore","disposeErrorHandler","customData","deleteNode","replaceNode","existingNode","toNode","transformColorForDarkMode","replaceChild","arg","scopeOrCallback","scope","Function","selectionEx","collapseNodes","canSplitParent","isEmpty","insertContent","allNodes","deleteSelectedContent","pasteAsText","pasteAsImage","tryGetFromCache","arg1","arg2","arg3","arg4","buildRangeEx","convertRangeExToDomSelection","getFocusedPosition","focusNode","focusOffset","startFrom","cacheGetEventData","isPositionAtBeginning","isPositionAtBeginningOf","getSelectedRegions","self","nameOrMap","handler","eventsToMap","redo","getScrollContainer","getter","getDefaultFormat","getBodyTraverser","ContentTraverser","createBodyTraverser","getSelectionTraverser","createSelectionTraverser","getBlockTraverser","createBlockTraverser","PositionContentSearcher","win","handle","requestAnimationFrame","cancelAnimationFrame","setEditorDomAttribute","getEditorDomAttribute","getRelativeDistanceToEditor","addScroll","editorRect","elementRect","y","scrollLeft","scrollTop","addContentEditFeature","removeContentEditFeature","featureSet","getPendableFormatState","forceGetStateFromDOM","setDarkModeState","nextDarkMode","startShadowEdit","stopShadowEdit","isFeatureEnabled","experimentalFeatures","getSizeTransformer","sizeTransformer","setZoomScale","scale","oldValue","oldZoomScale","newZoomScale","ContentModelEditor","createCorePlugins","pluginState","additionalPlugins","initContent","initialContent","standaloneEditorCore","isSelectionRangeEx","lastCell","areAllCollapsed","isNodePosition","currentPosition","pendableKeys","PendableStyleCheckers","CssFalsyCheckers","queryCommandStateFromDOM","isUnderline","isItalic","isSubscript","isSuperscript","isStrikeThrough","tableId","imageId","isContentModelEditor","handleKeyDownEvent","keyboardDelete","keyboardInput","ContentModelEditPlugin","deleteAllSegmentBefore","getDeleteCollapsedSelection","segmentsWithoutBr","fixupBr","getLeafSiblingBlock","siblingSegment","forwardDeleteCollapsedSelection","backwardDeleteCollapsedSelection","DeleteWordState","getDeleteWordSelection","startIndex","deleteNext","iterator","forward","punctuation","space","iterateSegments","curr","done","forwardDeleteWordSelection","backwardDeleteWordSelection","canDeleteBefore","canDeleteAfter","shouldDeleteWithContentModel","shouldDeleteAllSegmentsBefore","shouldDeleteWord","getDeleteSteps","handleKeyboardEventResult","shouldInputWithContentModel","isNext","DELIMITER_SELECTOR","ZERO_WIDTH_SPACE","INLINE_ENTITY_SELECTOR","normalizeDelimitersInEditor","addDelimitersIfNeeded","getDelimiterFromElement","removeNode","removeDelimiterAttr","getBlock","blockToCheck","delimiters","entityElement","matchesSelector","handleCollapsedEnter","preventTypeInDelimiter","currentRange","startElement","endElement","startUpdate","getPosition","endUpdate","aEditor","handleSelectionNotCollapsed","setPosition","sibling","checkEntity","entitySibling","remove","cn","EntityDelimiterPlugin","ContentModelPastePlugin","unknownTagReplacement","allowExcelNoBorderTable","ev","pasteSource","getPasteSource","processPastedContentFromWordDesktop","processPastedContentWacComponents","processPastedContentFromExcel","additionalTagReplacements","processPastedContentFromPowerPoint","parseLink","deprecatedBorderColorParser","tableBorderParser","chainSanitizerCallback","blockElementParser","ElementBorderKeys","Map","w","styleSet","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","DEFAULT_BORDER_STYLE","excelHandler","trMatch","tableMatch","replaceChildren","setProcessor","LIST_CONTAINER_ELEMENT_CLASS_NAME","TABLE_CONTAINER","TEMP_ELEMENTS_CLASSES","CLASSES_TO_KEEP","LIST_ELEMENT_TAGS","LIST_ELEMENT_SELECTOR","wacSubSuperParser","wacElementProcessor","elementTag","matches","closest","shouldClearListContext","wacLiElementProcessor","lastblock","wacListItemParser","wacListLevelParser","wacBlockParser","wacListProcessor","isWrappedInContainer","toUpperCase","PERCENTAGE_REGEX","removeNonValidLineHeight","parsedLineHeight","listLevelParser","wordDesktopElementProcessor","listItemElementParser","elementCallbacks","getStyles","processWordList","processWordComments","MSO_COMMENT_ANCHOR_HREF_REGEX","MSO_LIST","MSO_LIST_IGNORE","startNumberOverrideParser","fakeBullet","wordKnownLevels","wordLevel","wordList","getFakeBulletText","isIgnoreNode","listAttribute","wordListStyle","listProps","isFakeBullet","getFakeBulletTagName","processAsListItem","set","WAC_IDENTIFY_SELECTOR","documentContainWacElements","props","getSourceFunctions","isWordDesktopDocument","isExcelDesktopDocument","isExcelOnlineDocument","isPowerPointDesktopDocument","isGoogleSheetDocument","shouldConvertToSingleImage","shouldConvertSingleImage","param","func","htmlFirstLevelChildTags","dColor","trimRight","pair","valueIndex","SUPPORTED_PROTOCOLS","INVALID_LINKS_REGEX","URL","protocol","createContentModelEditor","module","exports","roosterjs","extendStatics","d","setPrototypeOf","__proto__","prototype","hasOwnProperty","__extends","TypeError","constructor","create","__assign","t","n","arguments","__rest","getOwnPropertySymbols","propertyIsEnumerable","__decorate","decorators","desc","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","__esDecorate","ctor","descriptorIn","contextIn","initializers","extraInitializers","accept","f","kind","descriptor","access","addInitializer","init","__runInitializers","thisArg","useValue","__propKey","__setFunctionName","description","configurable","__metadata","metadataKey","metadataValue","__awaiter","_arguments","P","generator","Promise","resolve","reject","fulfilled","rejected","__generator","g","label","sent","trys","ops","verb","Symbol","op","__createBinding","o","m","k2","__esModule","writable","enumerable","__exportStar","__values","__read","ar","error","__spread","__spreadArrays","il","jl","__spreadArray","to","pack","l","__await","__asyncGenerator","asyncIterator","q","resume","fulfill","settle","__asyncDelegator","__asyncValues","__makeTemplateObject","cooked","raw","__setModuleDefault","__importStar","mod","__importDefault","__classPrivateFieldGet","receiver","__classPrivateFieldSet","__classPrivateFieldIn","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","prop","toStringTag","__webpack_exports__"],"sourceRoot":""}