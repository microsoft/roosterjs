// Type definitions for roosterjs (Version 6.10.2)
// Generated by dts tool from roosterjs
// Project: https://github.com/Microsoft/roosterjs

declare namespace roosterjs {
    /**
     * Create an editor instance with most common options
     * @param contentDiv The html div element needed for creating the editor
     * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are
     * DefalutShortcut, HyperLink, Paste, and ContentEdit, user don't need to add those.
     * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.
     * @returns The editor instance
     */
    function createEditor(contentDiv: HTMLDivElement, additionalPlugins?: EditorPlugin[], initialContent?: string): Editor;

    const enum Alignment {
        Left = 0,
        Center = 1,
        Right = 2,
    }

    interface BlockElement {
        getTextContent: () => string;
        getStartNode: () => Node;
        getEndNode: () => Node;
        getContentNodes: () => Node[];
        getFirstInlineElement: () => InlineElement;
        getLastInlineElement: () => InlineElement;
        getInlineElements: () => InlineElement[];
        equals: (blockElement: BlockElement) => boolean;
        isAfter: (blockElement: BlockElement) => boolean;
        isInBlock: (inlineElement: InlineElement) => boolean;
        contains: (node: Node) => boolean;
    }

    interface ContentChangedEvent extends PluginEvent {
        source: ChangeSource | string;
        data?: any;
    }

    const enum ChangeSource {
        AutoBullet = "AutoBullet",
        AutoLink = "AutoLink",
        CreateLink = "CreateLink",
        Format = "Format",
        ImageResize = "ImageResize",
        Paste = "Paste",
        SetContent = "SetContent",
        Undo = "Undo",
    }

    /**
     * The position. Mostly used for content insertion and traversing
     * On insertion, we will need to specify where we want the content to be placed (begin, end, selection or outside)
     * On content traversing, we will need to specify the start position of traversing
     */
    const enum ContentPosition {
        /**
         * Begin of the container
         */
        Begin = 0,
        /**
         * End of the container
         */
        End = 1,
        /**
         * Selection start
         */
        SelectionStart = 2,
        /**
         * Outside of editor
         */
        Outside = 3,
    }

    const enum ContentScope {
        Block = 0,
        Selection = 1,
        Body = 2,
    }

    interface DefaultFormat {
        fontFamily?: string;
        fontSize?: string;
        textColor?: string;
        backgroundColor?: string;
        bold?: boolean;
        italic?: boolean;
        underline?: boolean;
    }

    const enum Direction {
        LeftToRight = 0,
        RightToLeft = 1,
    }

    const enum DocumentPosition {
        Same = 0,
        Disconnected = 1,
        Preceding = 2,
        Following = 4,
        Contains = 8,
        ContainedBy = 16,
        ImplementationSpecific = 32,
    }

    interface EditorPoint {
        containerNode: Node;
        offset: NodeBoundary | number;
    }

    const enum NodeBoundary {
        Begin = 0,
        End = 1,
    }

    interface ExtractContentEvent extends PluginEvent {
        content: string;
    }

    interface FormatState {
        fontName?: string;
        fontSize?: string;
        isBold?: boolean;
        isItalic?: boolean;
        isUnderline?: boolean;
        backgroundColor?: string;
        textColor?: string;
        isBullet?: boolean;
        isNumbering?: boolean;
        isStrikeThrough?: boolean;
        isBlockQuote?: boolean;
        isSubscript?: boolean;
        isSuperscript?: boolean;
        canUnlink?: boolean;
        canAddImageAltText?: boolean;
        canUndo?: boolean;
        canRedo?: boolean;
        headerLevel?: number;
    }

    const enum Indentation {
        Increase = 0,
        Decrease = 1,
    }

    interface InlineElement {
        getTextContent: () => string;
        getContainerNode: () => Node;
        getParentBlock: () => BlockElement;
        getStartPoint: () => EditorPoint;
        getEndPoint: () => EditorPoint;
        isAfter: (inlineElement: InlineElement) => boolean;
        contains: (editorPoint: EditorPoint) => boolean;
        applyStyle: (styler: (node: Node) => void, fromPoint?: EditorPoint, toPoint?: EditorPoint) => void;
    }

    interface InsertOption {
        position: ContentPosition;
        updateCursor: boolean;
        replaceSelection: boolean;
        insertOnNewLine: boolean;
    }

    interface LinkData {
        scheme: string;
        originalUrl: string;
        normalizedUrl: string;
    }

    const enum ListState {
        None = 0,
        Bullets = 1,
        Numbering = 2,
    }

    /**
     * Table format
     */
    interface TableFormat {
        /**
         * Background color for even rows
         */
        bgColorEven: string;
        /**
         * Background color for odd rows
         */
        bgColorOdd: string;
        /**
         * Top border color for each row
         */
        topBorderColor: string;
        /**
         * Bottom border color for each row
         */
        bottomBorderColor: string;
        /**
         * Vertical border color for each row
         */
        verticalBorderColor: string;
    }

    const enum TableOperation {
        /**
         * Insert a row above current row
         */
        InsertAbove = 0,
        /**
         * Insert a row below current row
         */
        InsertBelow = 1,
        /**
         * Insert a column on the left of current column
         */
        InsertLeft = 2,
        /**
         * Insert a column on the right of current column
         */
        InsertRight = 3,
        /**
         * Delete the whole table
         */
        DeleteTable = 4,
        /**
         * Delete current column
         */
        DeleteColumn = 5,
        /**
         * Delete current row
         */
        DeleteRow = 6,
        /**
         * Merge current row with the row above
         */
        MergeAbove = 7,
        /**
         * Merge current row with the row below
         */
        MergeBelow = 8,
        /**
         * Merge current column with the column on the left
         */
        MergeLeft = 9,
        /**
         * Merge current column with the column on the right
         */
        MergeRight = 10,
        /**
         * Split current table cell horizontally
         */
        SplitHorizontally = 11,
        /**
         * Split current table cell vertically
         */
        SplitVertically = 12,
    }

    const enum NodeType {
        Element = 1,
        Text = 3,
        ProcessingInstruction = 7,
        Comment = 8,
        Document = 9,
        DocumentType = 10,
        DocumentFragment = 11,
    }

    interface PluginDomEvent extends PluginEvent {
        rawEvent: Event;
    }

    interface PluginEvent {
        eventType: PluginEventType;
        eventDataCache?: {
            [key: string]: any;
        };
    }

    /**
     * Editor plugin event type
     */
    const enum PluginEventType {
        /**
         * HTML KeyDown event
         */
        KeyDown = 0,
        /**
         * HTML KeyPress event
         */
        KeyPress = 1,
        /**
         * HTML KeyUp event
         */
        KeyUp = 2,
        /**
         * HTML CompositionEnd event
         */
        CompositionEnd = 3,
        /**
         * HTML MouseDown event
         */
        MouseDown = 4,
        /**
         * HTML MouseUp event
         */
        MouseUp = 5,
        /**
         * Content changed event
         */
        ContentChanged = 6,
        /**
         * Extract Content event
         * This event is triggered when getContent() is called with triggerExtractContentEvent = true
         * Plugin can handle this event to remove the UI only markups to return clean HTML
         */
        ExtractContent = 7,
        /**
         * Before Paste event, provide a chance to change paste content
         */
        BeforePaste = 8,
        /**
         * Idle event, fired when user doesn't have any input for a time period (specified in EditorOptions)
         */
        Idle = 9,
    }

    interface Rect {
        top: number;
        bottom: number;
        left: number;
        right: number;
    }

    interface TraversingScoper {
        getStartBlockElement: () => BlockElement;
        getStartInlineElement: () => InlineElement;
        getInlineElementBeforeStart?: () => InlineElement;
        getInlineElementAfterStart?: () => InlineElement;
        isBlockInScope: (blockElement: BlockElement) => boolean;
        trimInlineElement: (inlineElement: InlineElement) => InlineElement;
    }

    interface ClipboardData {
        snapshotBeforePaste: string;
        originalFormat: DefaultFormat;
        types: string[];
        image: File;
        text: string;
        html: string;
        isHtmlFromTempDiv?: boolean;
    }

    interface BeforePasteEvent extends PluginEvent {
        clipboardData: ClipboardData;
        fragment: DocumentFragment;
        pasteOption: PasteOption;
    }

    /**
     * Paste option
     */
    const enum PasteOption {
        /**
         * Paste html with content type "text/html"
         */
        PasteHtml = 0,
        /**
         * Paste plain text with content type "text/plain"
         */
        PasteText = 1,
        /**
         * Paste image from clipboard with content type "image/*"
         */
        PasteImage = 2,
    }

    class NodeBlockElement implements BlockElement {
        private containerNode;
        private inlineElementFactory;
        private firstInline;
        private lastInline;
        constructor(containerNode: Node, inlineElementFactory: InlineElementFactory);
        getTextContent(): string;
        getStartNode(): Node;
        getEndNode(): Node;
        getContentNodes(): Node[];
        getFirstInlineElement(): InlineElement;
        getLastInlineElement(): InlineElement;
        getInlineElements(): InlineElement[];
        equals(blockElement: BlockElement): boolean;
        isAfter(blockElement: BlockElement): boolean;
        isInBlock(inlineElement: InlineElement): boolean;
        contains(node: Node): boolean;
    }

    class StartEndBlockElement implements BlockElement {
        private rootNode;
        private startNode;
        private endNode;
        private inlineElementFactory;
        private firstInline;
        private lastInline;
        constructor(rootNode: Node, startNode: Node, endNode: Node, inlineElementFactory: InlineElementFactory);
        getTextContent(): string;
        getContentNodes(): Node[];
        getStartNode(): Node;
        getEndNode(): Node;
        getFirstInlineElement(): InlineElement;
        getLastInlineElement(): InlineElement;
        getInlineElements(): InlineElement[];
        equals(blockElement: BlockElement): boolean;
        isAfter(blockElement: BlockElement): boolean;
        isInBlock(inlineElement: InlineElement): boolean;
        contains(node: Node): boolean;
    }

    function getBlockElementAtNode(rootNode: Node, node: Node, inlineElementFactory: InlineElementFactory): BlockElement;

    function getFirstBlockElement(rootNode: Node, inlineElementFactory: InlineElementFactory): BlockElement;

    function getLastBlockElement(rootNode: Node, inlineElementFactory: InlineElementFactory): BlockElement;

    function getNextBlockElement(rootNode: Node, blockElement: BlockElement, inlineElementFactory: InlineElementFactory): BlockElement;

    function getPreviousBlockElement(rootNode: Node, blockElement: BlockElement, inlineElementFactory: InlineElementFactory): BlockElement;

    function getFirstInlineElement(rootNode: Node, inlineElementFactory: InlineElementFactory): InlineElement;

    function getLastInlineElement(rootNode: Node, inlineElementFactory: InlineElementFactory): InlineElement;

    function getInlineElementAtNode(rootNode: Node, node: Node, inlineElementFactory: InlineElementFactory): InlineElement;

    function getNextInlineElement(rootNode: Node, inlineElement: InlineElement, inlineElementFactory: InlineElementFactory): InlineElement;

    function getPreviousInlineElement(rootNode: Node, inlineElement: InlineElement, inlineElementFactory: InlineElementFactory): InlineElement;

    function getInlineElementBeforePoint(rootNode: Node, position: EditorPoint, inlineElementFactory: InlineElementFactory): InlineElement;

    function getInlineElementAfterPoint(rootNode: Node, editorPoint: EditorPoint, inlineElementFactory: InlineElementFactory): InlineElement;

    class ContentTraverser {
        private rootNode;
        private scoper;
        private inlineElementFactory;
        private currentInline;
        private currentBlock;
        constructor(rootNode: Node, scoper: TraversingScoper, inlineElementFactory: InlineElementFactory);
        readonly currentBlockElement: BlockElement;
        getNextBlockElement(): BlockElement;
        getPreviousBlockElement(): BlockElement;
        readonly currentInlineElement: InlineElement;
        getNextInlineElement(): InlineElement;
        getPreviousInlineElement(): InlineElement;
    }

    function getNextLeafSibling(rootNode: Node, startNode: Node): Node;

    function getPreviousLeafSibling(rootNode: Node, startNode: Node): Node;

    function getFirstLeafNode(rootNode: Node): Node;

    function getLastLeafNode(rootNode: Node): Node;

    class ImageInlineElement extends NodeInlineElement {
        constructor(containerNode: Node, parentBlock: BlockElement);
    }

    class InlineElementFactory {
        private customResolvers;
        private defaultResolver;
        constructor(customResolvers?: InlineElementResolver[]);
        resolve(node: Node, rootNode: Node, parentBlock: BlockElement): InlineElement;
    }

    interface InlineElementResolver {
        resolve: (node: Node, rootNode: Node, parentBlock: BlockElement, inlineElementFactory: InlineElementFactory) => InlineElement;
    }

    class LinkInlineElement extends NodeInlineElement {
        constructor(containerNode: Node, parentBlock: BlockElement);
    }

    class NodeInlineElement implements InlineElement {
        private containerNode;
        private parentBlock;
        constructor(containerNode: Node, parentBlock: BlockElement);
        getTextContent(): string;
        getContainerNode(): Node;
        getParentBlock(): BlockElement;
        getStartPoint(): EditorPoint;
        getEndPoint(): EditorPoint;
        isAfter(inlineElement: InlineElement): boolean;
        contains(editorPoint: EditorPoint): boolean;
        applyStyle(styler: (node: Node) => void, fromPoint?: EditorPoint, toPoint?: EditorPoint): void;
    }

    class PartialInlineElement implements InlineElement {
        private inlineElement;
        private startPoint;
        private endPoint;
        constructor(inlineElement: InlineElement, startPoint?: EditorPoint, endPoint?: EditorPoint);
        getDecoratedInline(): InlineElement;
        getContainerNode(): Node;
        getParentBlock(): BlockElement;
        getTextContent(): string;
        getStartPoint(): EditorPoint;
        getEndPoint(): EditorPoint;
        isStartPartial(): boolean;
        isEndPartial(): boolean;
        readonly nextInlineElement: PartialInlineElement;
        readonly previousInlineElement: PartialInlineElement;
        contains(editorPoint: EditorPoint): boolean;
        isAfter(inlineElement: InlineElement): boolean;
        applyStyle(styler: (node: Node) => void, fromPoint?: EditorPoint, toPoint?: EditorPoint): void;
        private getRange();
    }

    class TextInlineElement extends NodeInlineElement {
        constructor(containerNode: Node, parentBlock: BlockElement);
    }

    class BodyScoper implements TraversingScoper {
        private rootNode;
        private inlineElementFactory;
        constructor(rootNode: Node, inlineElementFactory: InlineElementFactory);
        getStartBlockElement(): BlockElement;
        getStartInlineElement(): InlineElement;
        isBlockInScope(blockElement: BlockElement): boolean;
        trimInlineElement(inlineElement: InlineElement): InlineElement;
    }

    class EditorSelection {
        private rootNode;
        private selectionRange;
        private inlineElementFactory;
        private readonly startPoint;
        private readonly endPoint;
        private startInline;
        private endInline;
        private startEndCalculated;
        private startBlock;
        private endBlock;
        constructor(rootNode: Node, selectionRange: Range, inlineElementFactory: InlineElementFactory);
        readonly collapsed: boolean;
        readonly inlineElementBeforeStart: InlineElement;
        readonly startInlineElement: InlineElement;
        readonly endInlineElement: InlineElement;
        readonly startBlockElement: BlockElement;
        readonly endBlockElement: BlockElement;
        trimInlineElement(inlineElement: InlineElement): InlineElement;
        isBlockInScope(blockElement: BlockElement): boolean;
        private calculateStartEndIfNecessory();
        private calculateStartEndInline();
    }

    class SelectionBlockScoper implements TraversingScoper {
        private startPosition;
        private readonly editorSelection;
        private selectionBlock;
        constructor(rootNode: Node, selectionRange: Range, startPosition: ContentPosition, inlineElementFactory: InlineElementFactory);
        getStartBlockElement(): BlockElement;
        getStartInlineElement(): InlineElement;
        getInlineElementBeforeStart(): InlineElement;
        isBlockInScope(blockElement: BlockElement): boolean;
        trimInlineElement(inlineElement: InlineElement): InlineElement;
    }

    class SelectionScoper implements TraversingScoper {
        private readonly editorSelection;
        constructor(rootNode: Node, selectionRange: Range, inlineElementFactory: InlineElementFactory);
        getStartBlockElement(): BlockElement;
        getStartInlineElement(): InlineElement;
        isBlockInScope(blockElement: BlockElement): boolean;
        trimInlineElement(inlineElement: InlineElement): InlineElement;
    }

    function applyFormat(element: HTMLElement, format: DefaultFormat): void;

    function changeElementTag(element: HTMLElement, newTag: string, range?: Range): HTMLElement;

    function contains(container: Node, contained: Node): boolean;

    /**
     * @deprecated Use sanitizeHtml() instead
     */
    function convertInlineCss(sourceHtml: string, additionalStyleNodes?: HTMLStyleElement[]): string;

    /**
     * Sanitize HTML string
     * This function will do the following work:
     * 1. Convert global CSS into inline CSS
     * 2. Remove dangerous HTML tags and attributes
     * 3. Remove useless CSS properties
     * @param html The input HTML
     * @param additionalStyleNodes additional style nodes for inline css converting
     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing
     * @param propertyCallbacks A callback function map to handle HTML properties
     * @param preserveFragmentOnly If set to true, only preserve the html content between <!--StartFragment--> and <!--Endfragment-->
     */
    function sanitizeHtml(html: string, additionalStyleNodes?: HTMLStyleElement[], convertInlineCssOnly?: boolean, propertyCallbacks?: SanitizeHtmlPropertyCallback, preserveFragmentOnly?: boolean, currentStyle?: StyleMap): string;

    /**
     * Callback function set for sanitizeHtml().
     * sanitizeHtml() will check if there is a callback function for a given property name,
     * it will call this function to decide what value to set for this property.
     * Return null will cause this property be deleted, otherwise return the value of the property
     */
    type SanitizeHtmlPropertyCallback = {
        [name: string]: (value: string) => string;
    };

    /**
     * A map from CSS style name to its value
     */
    type StyleMap = {
        [name: string]: string;
    };

    function fromHtml(htmlFragment: string, ownerDocument: HTMLDocument): Node[];

    function getComputedStyle(node: Node, styleName: string): string;

    /**
     * Get computed styles of a node
     * @param node The node to get computed styles from
     * @param styleNames Names of style to get, can be a single name or an array.
     * Default value is font-family, font-size, color, background-color
     * @returns An array of the computed styles
     */
    function getComputedStyles(node: Node, styleNames?: string | string[]): string[];

    function getTagOfNode(node: Node): string;

    function isBlockElement(node: Node): boolean;

    /**
     * Check if position is or encompasses any of targets
     * @param position The doucment position to check
     * @param targets The target position or position array
     */
    function isDocumentPosition(position: DocumentPosition, targets: DocumentPosition | DocumentPosition[]): boolean;

    function isEditorPointAfter(point1: EditorPoint, point2: EditorPoint): boolean;

    /**
     * Check if a given node has visible content
     */
    function isNodeEmpty(node: Node, trim?: boolean): boolean;

    function isTextualInlineElement(inlineElement: InlineElement): boolean;

    function matchWhiteSpaces(source: string): string[];

    function normalizeEditorPoint(container: Node, offset: number): EditorPoint;

    /**
     * Split parent node of the given node before/after the given node.
     * When a parent node contains [A,B,C] and pass B as the given node,
     * If split before, the new nodes will be [A][B,C] and returns [A];
     * otherwise, it will be [A,B][C] and returns [C].
     * @param node The node to split before/after
     * @param splitBefore Whether split before or after
     * @returns The new parent node
     */
    function splitParentNode(node: Node, splitBefore: boolean): Node;

    function unwrap(node: Node): Node;

    function wrap(node: Node, htmlFragment: string): Node;

    function wrapAll(nodes: Node[], htmlFragment?: string): Node;

    class VTable {
        table: HTMLTableElement;
        cells: VCell[][];
        row: number;
        col: number;
        private trs;
        constructor(node: HTMLTableElement | HTMLTableCellElement);
        writeBack(): void;
        applyFormat(format: TableFormat): void;
        forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => void): void;
        forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => void): void;
        getCell(row: number, col: number): VCell;
        getCurrentTd(): HTMLTableCellElement;
        static moveChildren(fromNode: Node, toNode?: Node): void;
        static cloneNode<T extends Node>(node: T): T;
        static cloneCell(cell: VCell): VCell;
        private recalcSpans(row, col);
    }

    interface VCell {
        td?: HTMLTableCellElement;
        spanLeft?: boolean;
        spanAbove?: boolean;
    }

    class Editor {
        private undoService;
        private suspendAddingUndoSnapshot;
        private omitContentEditable;
        private disableRestoreSelectionOnFocus;
        private inIME;
        private core;
        private eventDisposers;
        /**
         * Creates an instance of Editor
         * @param contentDiv The DIV HTML element which will be the container element of editor
         * @param options An optional options object to customize the editor
         */
        constructor(contentDiv: HTMLDivElement, options?: EditorOptions);
        /**
         * Dispose this editor, dispose all plugins and custom data
         */
        dispose(): void;
        /**
         * Get whether this editor is disposed
         * @returns True if editor is disposed, otherwise false
         */
        isDisposed(): boolean;
        /**
         * Insert node into editor
         * @param node The node to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         * @returns true if node is inserted. Otherwise false
         */
        insertNode(node: Node, option?: InsertOption): boolean;
        /**
         * Delete a node from editor content
         * @param node The node to delete
         * @returns true if node is deleted. Otherwise false
         */
        deleteNode(node: Node): boolean;
        /**
         * Replace a node in editor content with another node
         * @param existingNode The existing node to be replaced
         * @param new node to replace to
         * @returns true if node is replaced. Otherwise false
         */
        replaceNode(existingNode: Node, toNode: Node): boolean;
        /**
         * Get InlineElement at given node
         * @param node The node to create InlineElement
         * @requires The InlineElement result
         */
        getInlineElementAtNode(node: Node): InlineElement;
        /**
         * Check if the node falls in the editor content
         * @param node The node to check
         * @returns True if the given node is in editor content, otherwise false
         */
        contains(node: Node): boolean;
        /**
         * Query HTML elements in editor using querySelectorAll() method
         * @param selector Selector string to query
         * @param forEachCallback An optional callback to be invoked on each node in query result
         * @returns HTML Element list of the query result
         */
        queryElements<T extends HTMLElement = HTMLElement>(selector: string, forEachCallback?: (node: T) => void): T[];
        /**
         * Check whether the editor contains any visible content
         * @param trim Whether trime the content string before check. Default is false
         * @returns True if there's no visible content, otherwise false
         */
        isEmpty(trim?: boolean): boolean;
        /**
         * Get current editor content as HTML string
         * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins
         * before return. Use this parameter to remove any temporary content added by plugins.
         * @returns HTML string representing current editor content
         */
        getContent(triggerExtractContentEvent?: boolean): string;
        /**
         * Get plain text content inside editor
         * @returns The text content inside editor
         */
        getTextContent(): string;
        /**
         * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
         * @param content HTML content to set in
         */
        setContent(content: string): void;
        /**
         * Insert HTML content into editor
         * @param HTML content to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         */
        insertContent(content: string, option?: InsertOption): void;
        /**
         * @deprecated Use queryElements instead
         */
        queryContent(selector: string): NodeListOf<Element>;
        /**
         * Get current selection range from Editor.
         * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
         * @returns current selection range, or null if editor never got focus before
         */
        getSelectionRange(): Range;
        /**
         * Get current selection
         * @return current selection object
         */
        getSelection(): Selection;
        /**
         * Check if focus is in editor now
         * @returns true if focus is in editor, otherwise false
         */
        hasFocus(): boolean;
        /**
         * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.
         */
        focus(): void;
        /**
         * Update selection in editor
         * @param selectionRange The selection range to update to
         * @returns true if selection range is updated. Otherwise false.
         */
        updateSelection(selectionRange: Range): boolean;
        /**
         * Save the current selection in editor so that when focus again, the selection can be restored
         */
        saveSelectionRange(): void;
        /**
         * Get a rect representing the location of the cursor.
         * @returns a Rect object representing cursor location
         */
        getCursorRect(): Rect;
        /**
         * Apply inline style to current selection
         * @param styler The callback function to apply style
         */
        applyInlineStyle(styler: (element: HTMLElement) => void): void;
        /**
         * Add a custom DOM event handler to handle events not handled by roosterjs.
         * Caller need to take the responsibility to dispose the handler properly
         * @param eventName DOM event name to handle
         * @param handler Handler callback
         * @returns A dispose function. Call the function to dispose this event handler
         */
        addDomEventHandler(eventName: string, handler: (event: UIEvent) => void): () => void;
        /**
         * Trigger an event to be dispatched to all plugins
         * @param pluginEvent The event object to trigger
         * @param broadcast indicates if the event needs to be dispatched to all plugins
         * True means to all, false means to allow exclusive handling from one plugin unless no one wants that
         */
        triggerEvent(pluginEvent: PluginEvent, broadcast?: boolean): void;
        /**
         * Trigger a ContentChangedEvent
         * @param source Source of this event, by default is 'SetContent'
         * @param data additional data for this event
         */
        triggerContentChangedEvent(source?: ChangeSource | string, data?: any): void;
        /**
         * Undo last edit operation
         */
        undo(): void;
        /**
         * Redo next edit operation
         */
        redo(): void;
        /**
         * Run a callback with undo suspended.
         * @param callback The callback to run
         */
        runWithoutAddingUndoSnapshot(callback: () => void): void;
        /**
         * Add an undo snapshot if undo is not suspended
         */
        addUndoSnapshot(): void;
        /**
         * Whether there is an available undo snapshot
         */
        canUndo(): boolean;
        /**
         * Whether there is an available redo snapshot
         */
        canRedo(): boolean;
        /**
         * Get document which contains this editor
         * @returns The HTML document which contains this editor
         */
        getDocument(): Document;
        /**
         * Get custom data related to this editor
         * @param key Key of the custom data
         * @param getter Getter function. If custom data for the given key doesn't exist,
         * call this function to get one and store it.
         * @param disposer An optional disposer function to dispose this custom data when
         * dispose editor.
         */
        getCustomData<T>(key: string, getter: () => T, disposer?: (value: T) => void): T;
        /**
         * Check if editor is in IME input sequence
         * @returns True if editor is in IME input sequence, otherwise false
         */
        isInIME(): boolean;
        /**
         * Get default format of this editor
         * @returns Default format object of this editor
         */
        getDefaultFormat(): DefaultFormat;
        /**
         * Get a content traverser that can be used to travse content within editor
         * @param scope Content scope type. There are 3 kinds of scoper:
         * 1) SelectionBlockScoper is a block based scoper that restrict traversing within the block where the selection is
         *    it allows traversing from start, end or selection start position
         *    this is commonly used to parse content from cursor as user type up to the begin or end of block
         * 2) SelectionScoper restricts traversing within the selection. It is commonly used for applying style to selection
         * 3) BodyScoper will traverse the entire editor body from the beginning (ignoring the passed in position parameter)
         * @param position Start position of the traverser
         * @returns A content traverser to help travse among InlineElemnt/BlockElement within scope
         */
        getContentTraverser(scope: ContentScope, position?: ContentPosition): ContentTraverser;
        /**
         * Run a callback function asynchronously
         * @param callback The callback function to run
         */
        runAsync(callback: () => void): void;
        private createEventHandlers();
        private stopPropagation;
        private onKeyPress;
        private selectEditorPoint(container, offset);
        private ensureInitialContent();
        private startIdleLoop(interval);
    }

    interface EditorCore {
        document: Document;
        contentDiv: HTMLDivElement;
        plugins: EditorPlugin[];
        inlineElementFactory: InlineElementFactory;
        defaultFormat: DefaultFormat;
        customData: {
            [Key: string]: {
                value: any;
                disposer: (value: any) => void;
            };
        };
        cachedSelectionRange: Range;
        idleLoopHandle: number;
        ignoreIdleEvent: boolean;
        api: CoreApiMap;
    }

    interface CoreApiMap {
        applyInlineStyle: ApplyInlineStyle;
        attachDomEvent: AttachDomEvent;
        focus: Focus;
        getContentTraverser: GetContentTraverser;
        getCustomData: GetCustomData;
        getCursorRect: GetCursorRect;
        getSelectionRange: GetSelectionRange;
        hasFocus: HasFocus;
        insertNode: InsertNode;
        triggerEvent: TriggerEvent;
        updateSelection: UpdateSelection;
    }

    type ApplyInlineStyle = (core: EditorCore, styler: (element: HTMLElement) => void) => void;

    type AttachDomEvent = (core: EditorCore, eventName: string, pluginEventType?: PluginEventType, beforeDispatch?: (event: UIEvent) => void) => () => void;

    type Focus = (core: EditorCore) => void;

    type GetContentTraverser = (core: EditorCore, scope: ContentScope, position?: ContentPosition) => ContentTraverser;

    type GetCustomData = <T>(core: EditorCore, key: string, getter: () => T, disposer?: (value: T) => void) => T;

    type GetCursorRect = (core: EditorCore) => Rect;

    type GetSelectionRange = (core: EditorCore, tryGetFromCache: boolean) => Range;

    type HasFocus = (core: EditorCore) => boolean;

    type InsertNode = (core: EditorCore, node: Node, option: InsertOption) => boolean;

    type TriggerEvent = (core: EditorCore, pluginEvent: PluginEvent, broadcast: boolean) => void;

    type UpdateSelection = (core: EditorCore, range: Range) => boolean;

    interface EditorOptions {
        plugins?: EditorPlugin[];
        defaultFormat?: DefaultFormat;
        undo?: UndoService;
        initialContent?: string;
        idleEventTimeSpanInSecond?: number;
        disableRestoreSelectionOnFocus?: boolean;
        omitContentEditableAttributeChanges?: boolean;
        coreApiOverride?: Partial<CoreApiMap>;
    }

    interface EditorPlugin {
        name?: string;
        initialize: (editor: Editor) => void;
        dispose: () => void;
        willHandleEventExclusively?: (event: PluginEvent) => boolean;
        onPluginEvent?: (event: PluginEvent) => void;
    }

    /**
     * Provides snapshot based undo service for Editor
     */
    class Undo implements UndoService {
        private preserveSnapshots;
        private maxBufferSize;
        private editor;
        private isRestoring;
        private hasNewContent;
        private lastKeyPress;
        private onDropDisposer;
        private onCutDisposer;
        name: 'Undo';
        protected undoSnapshots: UndoSnapshotsService;
        /**
         * Create an instance of Undo
         * @param preserveSnapshots True to preserve the snapshots after dispose, this allows
         * this object to be reused when editor is disposed and created again
         * @param maxBufferSize The max buffer size for snapshots. Default value is 10MB
         */
        constructor(preserveSnapshots?: boolean, maxBufferSize?: number);
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        onPluginEvent(event: PluginEvent): void;
        /**
         * Clear all existing undo snapshots
         */
        clear(): void;
        /**
         * Restore an undo snapshot to editor
         */
        undo(): void;
        /**
         * Restore a redo snapshot to editor
         */
        redo(): void;
        /**
         * Whether there is a snapshot for undo
         */
        canUndo(): boolean;
        /**
         * Whether there is a snapshot for redo
         */
        canRedo(): boolean;
        /**
         * Add an undo snapshot
         */
        addUndoSnapshot(): void;
        protected getSnapshotsManager(): UndoSnapshotsService;
        private restoreSnapshot(delta);
        private onKeyDown(pluginEvent);
        private onKeyPress(pluginEvent);
        private clearRedoForInput();
        private onNativeEvent;
    }

    class UndoSnapshotsService implements UndoSnapshotsService {
        private maxSize;
        private snapshots;
        private totalSize;
        private currentIndex;
        constructor(maxSize?: number);
        canMove(delta: number): boolean;
        move(delta: number): string;
        addSnapshot(snapshot: string): void;
        clearRedo(): void;
    }

    interface UndoService extends EditorPlugin {
        undo: () => void;
        redo: () => void;
        addUndoSnapshot: () => void;
        canUndo: () => boolean;
        canRedo: () => boolean;
        clear: () => void;
    }

    const browserData: BrowserData;

    interface BrowserData {
        isMac: boolean;
        isWin: boolean;
        isWebKit: boolean;
        isIE: boolean;
        isIE11OrGreater: boolean;
        isSafari: boolean;
        isChrome: boolean;
        isFirefox: boolean;
        isEdge: boolean;
    }

    function clearEventDataCache(event: PluginEvent, key: string): void;

    function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T;

    function buildSnapshot(editor: Editor): string;

    function restoreSnapshot(editor: Editor, snapshot: string): void;

    /**
     * Read CursorData from plugin event cache. If not, create one
     * @param event The plugin event, it stores the event cached data for looking up.
     * If passed as null, we will create a new cursor data
     * @param editor The editor instance
     * @returns The cursor data
     */
    function cacheGetCursorEventData(event: PluginEvent, editor: Editor): CursorData;

    /**
     * Clear the cursor data in a plugin event.
     * This is called when the cursor data is changed, e.g, the text is replace with HyperLink
     * @param event The plugin event
     */
    function clearCursorEventDataCache(event: PluginEvent): void;

    class CursorData {
        private editor;
        private cachedTextBeforeCursor;
        private cachedWordBeforeCursor;
        private inlineBeforeCursor;
        private inlineAfterCursor;
        private backwardTraverser;
        private forwardTraverser;
        private backwardTraversingComplete;
        private forwardTraversingComplete;
        private inlineElementsBeforeCursor;
        private firstNonTextInlineBeforeCursor;
        /**
         * Create a new CursorData instance
         * @param editor The editor instance
         */
        constructor(editor: Editor);
        /**
         * Get the word before cursor. The word is determined by scanning backwards till the first white space, the portion
         * between cursor and the white space is the word before cursor
         * @returns The word before cursor
         */
        readonly wordBeforeCursor: string;
        /**
         * Get the inline element before cursor
         * @returns The inlineElement before cursor
         */
        readonly inlineElementBeforeCursor: InlineElement;
        /**
         * Get the inline element after cursor
         * @returns The inline element after cursor
         */
        readonly inlineElementAfterCursor: InlineElement;
        /**
         * Get X number of chars before cursor
         * The actual returned chars may be less than what is requested. e.g, length of text before cursor is less then X
         * @param numChars The X number of chars user want to get
         * @returns The actual chars we get as a string
         */
        getXCharsBeforeCursor(numChars: number): string;
        /**
         * Get text section before cursor till stop condition is met.
         * This offers consumers to retrieve text section by section
         * The section essentially is just an inline element which has Container element
         * so that the consumer can remember it for anchoring popup or verification purpose
         * when cursor moves out of context etc.
         * @param stopFunc The callback stop function
         */
        getTextSectionBeforeCursorTill(stopFunc: (textInlineElement: InlineElement) => boolean): void;
        /**
         * Get first non textual inline element before cursor
         * @returns First non textutal inline element before cursor or null if no such element exists
         */
        getFirstNonTextInlineBeforeCursor(): InlineElement;
        private continueTraversingBackwardTill(stopFunc);
    }

    /**
     * Get the node at selection. If an expectedTag is specified, return the nearest ancestor of current node
     * which matches the tag name, or null if no match found in editor.
     * @param editor The editor instance
     * @param expectedTags The expected tag names. If null, return the element at cursor
     * @param startNode If specified, use this node as start node to search instead of current node
     * @returns The node at cursor or the nearest ancestor with the tag name is specified
     */
    function getNodeAtCursor(editor: Editor, expectedTags?: string | string[], startNode?: Node): Node;

    /**
     * @deprecated Use cacheGetNodeAtCursor instead
     */
    function cacheGetListElement(editor: Editor, event?: PluginEvent): Node;

    /**
     * Get the node at selection from event cache if it exists.
     * If an expectedTag is specified, return the nearest ancestor of current node
     * which matches the tag name, or null if no match found in editor.
     * @param editor The editor instance
     * @param event Event object to get cached object from
     * @param expectedTags The expected tag names. If null, return the element at cursor
     * @returns The element at cursor or the nearest ancestor with the tag name is specified
     */
    function cacheGetNodeAtCursor(editor: Editor, event: PluginEvent, expectedTags: string | string[]): Node;

    /**
     * Query nodes intersected with current selection using a selector
     * @param editor The editor
     * @param selector The selector to query
     * @param nodeContainedByRangeOnly When set to true, only return the nodes contained by current selection. Default value is false
     * @param forEachCallback An optional callback to be invoked on each node in query result
     * @returns The nodes intersected with current selection, returns an empty array if no result is found
     */
    function queryNodesWithSelection<T extends HTMLElement = HTMLElement>(editor: Editor, selector: string, nodeContainedByRangeOnly?: boolean, forEachCallback?: (node: T) => void): T[];

    /**
     * Replace the specified range with a node
     * @param editor The editor instance
     * @param range The range in which content needs to be replaced
     * @param node The node to be inserted
     * @param exactMatch exactMatch is to match exactly
     * @returns True if we complete the replacement, false otherwise
     */
    function replaceRangeWithNode(editor: Editor, range: Range, node: Node, exactMatch: boolean): boolean;

    /**
     * Replace text before cursor with a node
     * @param editor The editor instance
     * @param text The text for matching. We will try to match the text with the text before cursor
     * @param node The node to replace the text with
     * @param exactMatch exactMatch is to match exactly, i.e.
     * In auto linkification, users could type URL followed by some punctuation and hit space. The auto link will kick in on space,
     * at the moment, what is before cursor could be "<URL>,", however, only "<URL>" makes the link. by setting exactMatch = false, it does not match
     * from right before cursor, but can scan through till first same char is seen. On the other hand if set exactMatch = true, it starts the match right
     * before cursor.
     * @param cursorData
     */
    function replaceTextBeforeCursorWithNode(editor: Editor, text: string, node: Node, exactMatch: boolean, cursorData?: CursorData): boolean;

    /**
     * Validate the text matches what's before the cursor, and return the range for it
     * @param editor The editor instance
     * @param text The text to match against
     * @param exactMatch Whether it is an exact match
     * @param cursorData The cursor data
     * @returns The range for the matched text, null if unable to find a match
     */
    function validateAndGetRangeForTextBeforeCursor(editor: Editor, text: string, exactMatch: boolean, cursorData: CursorData): Range;

    /**
     * Get the list state at selection
     * The list state refers to the HTML elements <OL> or <UL>
     * @param editor The editor instance
     * @param event (Optional) The plugin event, it stores the event cached data for looking up.
     * If not passed, we will query the first <LI> node in selection and return the list state of its direct parent
     * @returns The list state. ListState.Numbering indicates <OL>, ListState.Bullets indicates <UL>,
     * ListState.None indicates no <OL> or <UL> elements found at current selection
     */
    function cacheGetListState(editor: Editor, event?: PluginEvent): ListState;

    /**
     * Clear the format in current selection, after cleaning, the format will be
     * changed to default format. The format that get cleaned include B/I/U/font name/
     * font size/text color/background color/align left/align right/align center/superscript/subscript
     * @param editor The editor instance
     */
    function clearFormat(editor: Editor): void;

    /**
     * Insert a hyperlink at cursor.
     * When there is a selection, hyperlink will be applied to the selection,
     * otherwise a hyperlink will be inserted to the cursor position.
     * @param editor Editor object
     * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.
     * When protocol is not specified, a best matched protocol will be predicted.
     * @param altText Optional alt text of the link, will be shown when hover on the link
     * @param displayText Optional display text for the link.
     * If there is a selection, this parameter will be ignored.
     * If not specified, will use link instead
     */
    function createLink(editor: Editor, link: string, altText?: string, displayText?: string): void;

    /**
     * Execute format with undo
     * It tries to add undo snapshot at begin and end of the function. Duplicated snapshot will only be added once
     * @param editor The editor instance
     * @param formatter The callback format function we want to perform, it also creates a fallback node for selection.
     * A fallback node is a node to update selection to if start point or end point is not avaiable/valid
     * @param preserveSelection (Optional) Whether to preserve selection, if set to true,
     * we update the selection to original selection range.
     */
    function execFormatWithUndo(editor: Editor, formatter: Formatter, preserveSelection?: boolean): void;

    /**
     * Formatter function type
     * @param startPoint Current selection start point
     * @param endPoint Current selection end point
     * @returns A fallback node for selection. When original selection range is not valid after format,
     * will try to select this element instead
     */
    type Formatter = (startPoint: EditorPoint, endPoint: EditorPoint) => Node | void | any;

    /**
     * Get format state at cursor
     * A format state is a collection of all format related states, e.g.,
     * bold, italic, underline, font name, font size, etc.
     * @param editor The editor
     * @param (Optional) The plugin event, it stores the event cached data for looking up.
     * In this function the event cache is used to get list state and header level. If not passed,
     * it will query the node within selection to get the info
     * @returns The format state at cursor
     */
    function getFormatState(editor: Editor, event?: PluginEvent): FormatState;

    /**
     * Insert an image to editor at current selection
     * @param editor The editor instance
     * @param imageFile The image file. There are at least 3 ways to obtain the file object:
     * From local file, from clipboard data, from drag-and-drop
     */
    function insertImage(editor: Editor, imageFile: File): void;

    /**
     * Insert table into editor at current selection
     * @param editor The editor instance
     * @param columns Number of columns in table, it also controls the default table cell width:
     * if columns <= 4, width = 120px; if columns <= 6, width = 100px; else width = 70px
     * @param rows Number of rows in table
     * @param format (Optional) The table format. If not passed, the default format will be applied:
     * background color: #FFF; border color: #ABABAB
     */
    function insertTable(editor: Editor, columns: number, rows: number, format?: TableFormat): void;

    /**
     * Edit table with given operation. If there is no table at cursor then no op.
     * @param editor The editor instance
     * @param operation Table operation
     */
    function editTable(editor: Editor, operation: TableOperation): void;

    /**
     * Format table
     * @param table The table to format
     * @param formatName Name of the format to use
     */
    function formatTable(editor: Editor, format: TableFormat, table?: HTMLTableElement): void;

    /**
     * Remove link at selection. If no links at selection, do nothing.
     * If selection contains multiple links, all of the link styles will be removed.
     * If only part of a link is selected, the whole link style will be removed.
     * @param editor The editor instance
     */
    function removeLink(editor: Editor): void;

    /**
     * Set content alignment
     * @param editor The editor instance
     * @param alignment The alignment option:
     * Alignment.Center, Alignment.Left, Alignment.Right
     */
    function setAlignment(editor: Editor, alignment: Alignment): void;

    /**
     * Set background color at current selection
     * @param editor The editor instance
     * @param color The color string, can be any of the predefined color names (e.g, 'red')
     * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setBackgroundColor(editor: Editor, color: string): void;

    /**
     * Set text color at selection
     * @param editor The editor instance
     * @param color The color string, can be any of the predefined color names (e.g, 'red')
     * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setTextColor(editor: Editor, color: string): void;

    /**
     * Change direction for the blocks/paragraph at selection
     * @param editor The editor instance
     * @param dir The direction option:
     * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'
     */
    function setDirection(editor: Editor, dir: Direction): void;

    /**
     * Set font name at selection
     * @param editor The editor instance
     * @param fontName The fontName string, should be a valid CSS font-family style.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setFontName(editor: Editor, fontName: string): void;

    /**
     * Set font size at selection
     * @param editor The editor instance
     * @param fontSize The fontSize string, should be a valid CSS font-size style.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setFontSize(editor: Editor, fontSize: string): void;

    /**
     * Set image alt text for all selected images at selection. If no images is contained
     * in selection, do nothing.
     * The alt attribute provides alternative information for an image if a user for some reason
     * cannot view it (because of slow connection, an error in the src attribute, or if the user
     * uses a screen reader). See https: * @param editor The editor instance
     * @param altText The image alt text
     */
    function setImageAltText(editor: Editor, altText: string): void;

    /**
     * Set indentation at selection
     * If selection contains bullet/numbering list, increase/decrease indentation will
     * increase/decrease the list level by one.
     * @param editor The editor instance
     * @param indentation The indentation option:
     * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation
     */
    function setIndentation(editor: Editor, indentation: Indentation): void;

    /**
     * Toggle bold at selection
     * If selection is collapsed, it will only affect the following input after caret
     * If selection contains only bold text, the bold style will be removed
     * If selection contains only normal text, bold style will be added to the whole selected text
     * If selection contains both bold and normal text, bold stle will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleBold(editor: Editor): void;

    /**
     * Toggle bullet at selection
     * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one
     * If selection contains number list, toggle bullet will convert the number list into bullet list
     * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     * browser execCommand API
     * @param editor The editor instance
     */
    function toggleBullet(editor: Editor): void;

    /**
     * Toggle italic at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only italic text, the italic style will be removed
     * If selection contains only normal text, italic style will be added to the whole selected text
     * If selection contains both italic and normal text, italic stlye will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleItalic(editor: Editor): void;

    /**
     * Toggle numbering at selection
     * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one
     * If selection contains bullet list, toggle numbering will convert the bullet list into number list
     * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     * realization of browser execCommand API
     * @param editor The editor instance
     */
    function toggleNumbering(editor: Editor): void;

    /**
     * Toggle blockquote at selection, if selection already contains any blockquoted elements,
     * the blockquoted elements will be unblockquoted and other elements will take no affect
     * @param editor The editor instance
     * @param styler (Optional) The custom styler for setting the style for the
     * blockquote element
     */
    function toggleBlockQuote(editor: Editor, styler?: (element: HTMLElement) => void): void;

    /**
     * Toggle strikethrough at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only strikethrough text, the strikethrough style will be removed
     * If selection contains only normal text, strikethrough style will be added to the whole selected text
     * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleStrikethrough(editor: Editor): void;

    /**
     * Toggle subscript at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only subscript text, the subscript style will be removed
     * If selection contains only normal text, subscript style will be added to the whole selected text
     * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text
     * If selection contains any superscript text, the behavior is determined by corresponding realization of browser
     * execCommand API
     * @param editor The editor instance
     */
    function toggleSubscript(editor: Editor): void;

    /**
     * Toggle superscript at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only superscript text, the superscript style will be removed
     * If selection contains only normal text, superscript style will be added to the whole selected text
     * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text
     * If selection contains any subscript text, the behavior is determined by corresponding realization of browser
     * execCommand API
     * @param editor The editor instance
     */
    function toggleSuperscript(editor: Editor): void;

    /**
     * Toggle underline at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only underlined text, the underline style will be removed
     * If selection contains only normal text, underline style will be added to the whole selected text
     * If selection contains both underlined and normal text, the underline style will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleUnderline(editor: Editor): void;

    /**
     * Toggle header at selection
     * @param editor The editor instance
     * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to
     * the HTML header element <H1> to <H6>, 0 means no header
     * if passed in param is outside the range, will be rounded to nearest number in the range
     */
    function toggleHeader(editor: Editor, level: number): void;

    /**
     * Try to match a given string with link match rules, return matched link
     * @param url Input url to match
     * @param option Link match option, exact or partial. If it is exact match, we need
     * to check the length of matched link and url
     * @param rules Optional link match rules, if not passed, only the default link match
     * rules will be applied
     * @returns The matched link data, or null if no match found.
     * The link data includes an original url and a normalized url
     */
    function matchLink(url: string): LinkData;

    class DefaultShortcut implements EditorPlugin {
        private editor;
        name: 'DefaultShortcut';
        initialize(editor: Editor): void;
        dispose(): void;
        willHandleEventExclusively(event: PluginEvent): boolean;
        onPluginEvent(event: PluginEvent): void;
    }

    /**
     * An editor plugin that auto linkify text as users type and show a tooltip for existing link
     */
    class HyperLink implements EditorPlugin {
        private getTooltipCallback;
        private target;
        private editor;
        private backspaceToUndo;
        name: 'HyperLink';
        /**
         * Create a new instance of HyperLink class
         * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.
         * Default value is to return the href itself. If null, there will be no tooltip text.
         * @param target (Optional) Target window name for hyperlink. If null, will use "_blank"
         * @param linkMatchRules (Optional) Rules for matching hyperlink. If null, will use defaultLinkMatchRules
         */
        constructor(getTooltipCallback?: (href: string) => string, target?: string);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(event: PluginEvent): void;
        private resetAnchor(a);
        private autoLink(event);
        private processLink(a);
        private removeTempTooltip(content);
        private onClickLink;
        private tryGetHref(element);
        private forEachHyperLink(callback);
    }

    /**
     * An editor plugin to handle content edit event.
     * The following cases are included:
     * 1. Auto increase/decrease indentation on Tab, Shift+tab
     * 2. Enter, Backspace on empty list item
     * 3. Enter, Backspace on empty blockquote line
     */
    class ContentEdit implements EditorPlugin {
        private features;
        private editor;
        private backspaceToUndo;
        name: 'ContentEdit';
        /**
         * Create instance of ContentEdit plugin
         * @param features An optional feature set to determine which features the plugin should provide
         */
        constructor(features?: ContentEditFeatures);
        initialize(editor: Editor): void;
        dispose(): void;
        willHandleEventExclusively(event: PluginEvent): boolean;
        onPluginEvent(event: PluginEvent): void;
        private handleAutoBullet(event);
        private isListEvent(event, interestedKeyCodes);
        private isTabInTable(event);
        private cacheGetTd(event);
        private getBlockQuoteElementFromEvent(event, keyboardEvent);
        private shouldToggleState(event, node);
        private toggleList(event);
        private isCursorAtBeginningOf(node);
    }

    /**
     * Paste plugin, handles onPaste event and paste content into editor
     */
    class Paste implements EditorPlugin {
        private htmlPropertyCallbacks;
        private editor;
        private pasteDisposer;
        name: 'Paste';
        /**
         * Create an instance of Paste
         * @param deprecated Deprecated parameter only used for compatibility with old code
         * @param htmlPropertyCallbacks A callback to help handle html sanitization
         */
        constructor(deprecated?: boolean, htmlPropertyCallbacks?: SanitizeHtmlPropertyCallback);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(event: PluginEvent): void;
        private onPaste;
        /**
         * Paste into editor using passed in clipboardData with original format
         * @param clipboardData The clipboardData to paste
         */
        pasteOriginal(clipboardData: ClipboardData): void;
        /**
         * Paste plain text into editor using passed in clipboardData
         * @param clipboardData The clipboardData to paste
         */
        pasteText(clipboardData: ClipboardData): void;
        /**
         * Paste into editor using passed in clipboardData with curent format
         * @param clipboardData The clipboardData to paste
         */
        pasteAndMergeFormat(clipboardData: ClipboardData): void;
        private detectPasteOption(clipboardData);
        private paste(clipboardData, pasteOption, mergeCurrentFormat?);
        private internalPaste(event);
        private applyTextFormat(node, format);
    }

    /**
     * Feature set for ContentEdit plugin.
     * Call getDefaultContentEditFeatures() to get default feature set.
     */
    interface ContentEditFeatures {
        /**
         * When press Tab in a list, indent current list item
         * @default true
         */
        indentWhenTab: boolean;
        /**
         * When press Shift+Tab in a list, outdent current list item
         * @default true
         */
        outdentWhenShiftTab: boolean;
        /**
         * When press BaskSpace on empty line which is the first item of a list, outdent current list item
         * @default true
         */
        outdentWhenBackspaceOnEmptyFirstLine: boolean;
        /**
         * When press Enter on empty line in a list, outdent current list item
         * @default true
         */
        outdentWhenEnterOnEmptyLine: boolean;
        /**
         * When press Backspace on first char in a list, make current item a new line of previous list item
         * @default false
         */
        mergeInNewLineWhenBackspaceOnFirstChar: boolean;
        /**
         * When press BAckspace on empty line which is the first line of a blockquote, unquote current line
         * @default true
         */
        unquoteWhenBackspaceOnEmptyFirstLine: boolean;
        /**
         * When press Enter on empty line in a blockquote, unquote current line
         * @default true
         */
        unquoteWhenEnterOnEmptyLine: boolean;
        /**
         * When press space after an asterik or number in an empty line, toggle bullet/numbering
         * @default true
         */
        autoBullet: boolean;
        /**
         * When press TAB or SHIFT+TAB key in table cell, jump to next/previous table cell
         * @default true
         */
        tabInTable: boolean;
    }

    /**
     * Get default feature set of ContentEdit plugin
     */
    function getDefaultContentEditFeatures(): ContentEditFeatures;

    /**
     * A watermark plugin to manage watermark string for roosterjs
     */
    class Watermark implements EditorPlugin {
        private watermark;
        private format;
        private editor;
        private isWatermarkShowing;
        private focusDisposer;
        private blurDisposer;
        name: 'Watermark';
        /**
         * Create an instance of Watermark plugin
         * @param watermark The watermark string
         */
        constructor(watermark: string, format?: DefaultFormat);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(event: PluginEvent): void;
        private handleWatermark;
        private showHideWatermark(ignoreCachedState);
        private showWatermark();
        private hideWatermark();
        private removeWartermarkFromHtml(event);
    }

    class TableResize implements EditorPlugin {
        private editor;
        private onMouseOverDisposer;
        private td;
        private pageX;
        private initialPageX;
        name: 'TableResize';
        constructor(isRtl?: boolean);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(event: PluginEvent): void;
        private clickIntoCurrentTd(event);
        private onMouseOver;
        private calcAndShowHandle();
        private adjustHandle(pageX);
        private getPosition(e);
        private getResizeHandle();
        private cancelEvent(e);
        private onMouseDown;
        private onMouseMove;
        private onMouseUp;
        private setTableColumnWidth(width);
        private isRtl(element);
    }

    class ImageResize implements EditorPlugin {
        private minWidth;
        private minHeight;
        private selectionBorderColor;
        private forcePreserveRatio;
        private editor;
        private startPageX;
        private startPageY;
        private startWidth;
        private startHeight;
        private resizeDiv;
        private direction;
        name: 'ImageResize';
        /**
         * Create a new instance of ImageResize
         * @param minWidth Minimum width of image when resize in pixel, default value is 10
         * @param minHeight Minimum height of image when resize in pixel, default value is 10
         * @param selectionBorderColor Color of resize border and handles, default value is #DB626C
         * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false
         */
        constructor(minWidth?: number, minHeight?: number, selectionBorderColor?: string, forcePreserveRatio?: boolean);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(e: PluginEvent): void;
        private select(target);
        private unselect(selectImageAfterUnSelect);
        private startResize;
        private doResize;
        private finishResize;
        private createResizeDiv(target);
        private removeResizeDiv(resizeDiv);
        private removeResizeDivIfAny;
        private extractHtml(html);
        private getSelectedImage();
        private isNorth(direction);
        private isWest(direction);
    }

    /**
     * @deprecated Use ImageResize instead
     */
    class ImageResizePlugin extends ImageResize {
        /**
         * @deprecated Use ImageResize instead
         */
        constructor(minWidth?: number, minHeight?: number, selectionBorderColor?: string, forcePreserveRatio?: boolean);
    }

}