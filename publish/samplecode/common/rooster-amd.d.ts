// Type definitions for roosterjs (Version 6.10.3)
// Generated by dts tool from roosterjs
// Project: https://github.com/Microsoft/roosterjs

/**
 * Create an editor instance with most common options
 * @param contentDiv The html div element needed for creating the editor
 * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are
 * DefalutShortcut, HyperLink, Paste, and ContentEdit, user don't need to add those.
 * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.
 * @returns The editor instance
 */
export function createEditor(contentDiv: HTMLDivElement, additionalPlugins?: EditorPlugin[], initialContent?: string): Editor;

export const enum Alignment {
    Left = 0,
    Center = 1,
    Right = 2,
}

export interface BlockElement {
    getTextContent: () => string;
    getStartNode: () => Node;
    getEndNode: () => Node;
    getContentNodes: () => Node[];
    getFirstInlineElement: () => InlineElement;
    getLastInlineElement: () => InlineElement;
    getInlineElements: () => InlineElement[];
    equals: (blockElement: BlockElement) => boolean;
    isAfter: (blockElement: BlockElement) => boolean;
    isInBlock: (inlineElement: InlineElement) => boolean;
    contains: (node: Node) => boolean;
}

export interface ContentChangedEvent extends PluginEvent {
    source: ChangeSource | string;
    data?: any;
}

export const enum ChangeSource {
    AutoBullet = "AutoBullet",
    AutoLink = "AutoLink",
    CreateLink = "CreateLink",
    Format = "Format",
    ImageResize = "ImageResize",
    Paste = "Paste",
    SetContent = "SetContent",
    Undo = "Undo",
}

/**
 * The position. Mostly used for content insertion and traversing
 * On insertion, we will need to specify where we want the content to be placed (begin, end, selection or outside)
 * On content traversing, we will need to specify the start position of traversing
 */
export const enum ContentPosition {
    /**
     * Begin of the container
     */
    Begin = 0,
    /**
     * End of the container
     */
    End = 1,
    /**
     * Selection start
     */
    SelectionStart = 2,
    /**
     * Outside of editor
     */
    Outside = 3,
}

export const enum ContentScope {
    Block = 0,
    Selection = 1,
    Body = 2,
}

export interface DefaultFormat {
    fontFamily?: string;
    fontSize?: string;
    textColor?: string;
    backgroundColor?: string;
    bold?: boolean;
    italic?: boolean;
    underline?: boolean;
}

export const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
}

export const enum DocumentPosition {
    Same = 0,
    Disconnected = 1,
    Preceding = 2,
    Following = 4,
    Contains = 8,
    ContainedBy = 16,
    ImplementationSpecific = 32,
}

export interface EditorPoint {
    containerNode: Node;
    offset: NodeBoundary | number;
}

export const enum NodeBoundary {
    Begin = 0,
    End = 1,
}

export interface ExtractContentEvent extends PluginEvent {
    content: string;
}

export interface FormatState {
    fontName?: string;
    fontSize?: string;
    isBold?: boolean;
    isItalic?: boolean;
    isUnderline?: boolean;
    backgroundColor?: string;
    textColor?: string;
    isBullet?: boolean;
    isNumbering?: boolean;
    isStrikeThrough?: boolean;
    isBlockQuote?: boolean;
    isSubscript?: boolean;
    isSuperscript?: boolean;
    canUnlink?: boolean;
    canAddImageAltText?: boolean;
    canUndo?: boolean;
    canRedo?: boolean;
    headerLevel?: number;
}

export const enum Indentation {
    Increase = 0,
    Decrease = 1,
}

export interface InlineElement {
    getTextContent: () => string;
    getContainerNode: () => Node;
    getParentBlock: () => BlockElement;
    getStartPoint: () => EditorPoint;
    getEndPoint: () => EditorPoint;
    isAfter: (inlineElement: InlineElement) => boolean;
    contains: (editorPoint: EditorPoint) => boolean;
    applyStyle: (styler: (node: Node) => void, fromPoint?: EditorPoint, toPoint?: EditorPoint) => void;
}

export interface InsertOption {
    position: ContentPosition;
    updateCursor: boolean;
    replaceSelection: boolean;
    insertOnNewLine: boolean;
}

export interface LinkData {
    scheme: string;
    originalUrl: string;
    normalizedUrl: string;
}

export const enum ListState {
    None = 0,
    Bullets = 1,
    Numbering = 2,
}

/**
 * Table format
 */
export interface TableFormat {
    /**
     * Background color for even rows
     */
    bgColorEven: string;
    /**
     * Background color for odd rows
     */
    bgColorOdd: string;
    /**
     * Top border color for each row
     */
    topBorderColor: string;
    /**
     * Bottom border color for each row
     */
    bottomBorderColor: string;
    /**
     * Vertical border color for each row
     */
    verticalBorderColor: string;
}

export const enum TableOperation {
    /**
     * Insert a row above current row
     */
    InsertAbove = 0,
    /**
     * Insert a row below current row
     */
    InsertBelow = 1,
    /**
     * Insert a column on the left of current column
     */
    InsertLeft = 2,
    /**
     * Insert a column on the right of current column
     */
    InsertRight = 3,
    /**
     * Delete the whole table
     */
    DeleteTable = 4,
    /**
     * Delete current column
     */
    DeleteColumn = 5,
    /**
     * Delete current row
     */
    DeleteRow = 6,
    /**
     * Merge current row with the row above
     */
    MergeAbove = 7,
    /**
     * Merge current row with the row below
     */
    MergeBelow = 8,
    /**
     * Merge current column with the column on the left
     */
    MergeLeft = 9,
    /**
     * Merge current column with the column on the right
     */
    MergeRight = 10,
    /**
     * Split current table cell horizontally
     */
    SplitHorizontally = 11,
    /**
     * Split current table cell vertically
     */
    SplitVertically = 12,
}

export const enum NodeType {
    Element = 1,
    Text = 3,
    ProcessingInstruction = 7,
    Comment = 8,
    Document = 9,
    DocumentType = 10,
    DocumentFragment = 11,
}

export interface PluginDomEvent extends PluginEvent {
    rawEvent: Event;
}

export interface PluginEvent {
    eventType: PluginEventType;
    eventDataCache?: {
        [key: string]: any;
    };
}

/**
 * Editor plugin event type
 */
export const enum PluginEventType {
    /**
     * HTML KeyDown event
     */
    KeyDown = 0,
    /**
     * HTML KeyPress event
     */
    KeyPress = 1,
    /**
     * HTML KeyUp event
     */
    KeyUp = 2,
    /**
     * HTML CompositionEnd event
     */
    CompositionEnd = 3,
    /**
     * HTML MouseDown event
     */
    MouseDown = 4,
    /**
     * HTML MouseUp event
     */
    MouseUp = 5,
    /**
     * Content changed event
     */
    ContentChanged = 6,
    /**
     * Extract Content event
     * This event is triggered when getContent() is called with triggerExtractContentEvent = true
     * Plugin can handle this event to remove the UI only markups to return clean HTML
     */
    ExtractContent = 7,
    /**
     * Before Paste event, provide a chance to change paste content
     */
    BeforePaste = 8,
    /**
     * Idle event, fired when user doesn't have any input for a time period (specified in EditorOptions)
     */
    Idle = 9,
}

export interface Rect {
    top: number;
    bottom: number;
    left: number;
    right: number;
}

export interface TraversingScoper {
    getStartBlockElement: () => BlockElement;
    getStartInlineElement: () => InlineElement;
    getInlineElementBeforeStart?: () => InlineElement;
    getInlineElementAfterStart?: () => InlineElement;
    isBlockInScope: (blockElement: BlockElement) => boolean;
    trimInlineElement: (inlineElement: InlineElement) => InlineElement;
}

export interface ClipboardData {
    snapshotBeforePaste: string;
    originalFormat: DefaultFormat;
    types: string[];
    image: File;
    text: string;
    html: string;
    isHtmlFromTempDiv?: boolean;
}

export interface BeforePasteEvent extends PluginEvent {
    clipboardData: ClipboardData;
    fragment: DocumentFragment;
    pasteOption: PasteOption;
}

/**
 * Paste option
 */
export const enum PasteOption {
    /**
     * Paste html with content type "text/html"
     */
    PasteHtml = 0,
    /**
     * Paste plain text with content type "text/plain"
     */
    PasteText = 1,
    /**
     * Paste image from clipboard with content type "image/*"
     */
    PasteImage = 2,
}

export class NodeBlockElement implements BlockElement {
    private containerNode;
    private inlineElementFactory;
    private firstInline;
    private lastInline;
    constructor(containerNode: Node, inlineElementFactory: InlineElementFactory);
    getTextContent(): string;
    getStartNode(): Node;
    getEndNode(): Node;
    getContentNodes(): Node[];
    getFirstInlineElement(): InlineElement;
    getLastInlineElement(): InlineElement;
    getInlineElements(): InlineElement[];
    equals(blockElement: BlockElement): boolean;
    isAfter(blockElement: BlockElement): boolean;
    isInBlock(inlineElement: InlineElement): boolean;
    contains(node: Node): boolean;
}

export class StartEndBlockElement implements BlockElement {
    private rootNode;
    private startNode;
    private endNode;
    private inlineElementFactory;
    private firstInline;
    private lastInline;
    constructor(rootNode: Node, startNode: Node, endNode: Node, inlineElementFactory: InlineElementFactory);
    getTextContent(): string;
    getContentNodes(): Node[];
    getStartNode(): Node;
    getEndNode(): Node;
    getFirstInlineElement(): InlineElement;
    getLastInlineElement(): InlineElement;
    getInlineElements(): InlineElement[];
    equals(blockElement: BlockElement): boolean;
    isAfter(blockElement: BlockElement): boolean;
    isInBlock(inlineElement: InlineElement): boolean;
    contains(node: Node): boolean;
}

export function getBlockElementAtNode(rootNode: Node, node: Node, inlineElementFactory: InlineElementFactory): BlockElement;

export function getFirstBlockElement(rootNode: Node, inlineElementFactory: InlineElementFactory): BlockElement;

export function getLastBlockElement(rootNode: Node, inlineElementFactory: InlineElementFactory): BlockElement;

export function getNextBlockElement(rootNode: Node, blockElement: BlockElement, inlineElementFactory: InlineElementFactory): BlockElement;

export function getPreviousBlockElement(rootNode: Node, blockElement: BlockElement, inlineElementFactory: InlineElementFactory): BlockElement;

export function getFirstInlineElement(rootNode: Node, inlineElementFactory: InlineElementFactory): InlineElement;

export function getLastInlineElement(rootNode: Node, inlineElementFactory: InlineElementFactory): InlineElement;

export function getInlineElementAtNode(rootNode: Node, node: Node, inlineElementFactory: InlineElementFactory): InlineElement;

export function getNextInlineElement(rootNode: Node, inlineElement: InlineElement, inlineElementFactory: InlineElementFactory): InlineElement;

export function getPreviousInlineElement(rootNode: Node, inlineElement: InlineElement, inlineElementFactory: InlineElementFactory): InlineElement;

export function getInlineElementBeforePoint(rootNode: Node, position: EditorPoint, inlineElementFactory: InlineElementFactory): InlineElement;

export function getInlineElementAfterPoint(rootNode: Node, editorPoint: EditorPoint, inlineElementFactory: InlineElementFactory): InlineElement;

export class ContentTraverser {
    private rootNode;
    private scoper;
    private inlineElementFactory;
    private currentInline;
    private currentBlock;
    constructor(rootNode: Node, scoper: TraversingScoper, inlineElementFactory: InlineElementFactory);
    readonly currentBlockElement: BlockElement;
    getNextBlockElement(): BlockElement;
    getPreviousBlockElement(): BlockElement;
    readonly currentInlineElement: InlineElement;
    getNextInlineElement(): InlineElement;
    getPreviousInlineElement(): InlineElement;
}

export function getNextLeafSibling(rootNode: Node, startNode: Node): Node;

export function getPreviousLeafSibling(rootNode: Node, startNode: Node): Node;

export function getFirstLeafNode(rootNode: Node): Node;

export function getLastLeafNode(rootNode: Node): Node;

export class ImageInlineElement extends NodeInlineElement {
    constructor(containerNode: Node, parentBlock: BlockElement);
}

export class InlineElementFactory {
    private customResolvers;
    private defaultResolver;
    constructor(customResolvers?: InlineElementResolver[]);
    resolve(node: Node, rootNode: Node, parentBlock: BlockElement): InlineElement;
}

export interface InlineElementResolver {
    resolve: (node: Node, rootNode: Node, parentBlock: BlockElement, inlineElementFactory: InlineElementFactory) => InlineElement;
}

export class LinkInlineElement extends NodeInlineElement {
    constructor(containerNode: Node, parentBlock: BlockElement);
}

export class NodeInlineElement implements InlineElement {
    private containerNode;
    private parentBlock;
    constructor(containerNode: Node, parentBlock: BlockElement);
    getTextContent(): string;
    getContainerNode(): Node;
    getParentBlock(): BlockElement;
    getStartPoint(): EditorPoint;
    getEndPoint(): EditorPoint;
    isAfter(inlineElement: InlineElement): boolean;
    contains(editorPoint: EditorPoint): boolean;
    applyStyle(styler: (node: Node) => void, fromPoint?: EditorPoint, toPoint?: EditorPoint): void;
}

export class PartialInlineElement implements InlineElement {
    private inlineElement;
    private startPoint;
    private endPoint;
    constructor(inlineElement: InlineElement, startPoint?: EditorPoint, endPoint?: EditorPoint);
    getDecoratedInline(): InlineElement;
    getContainerNode(): Node;
    getParentBlock(): BlockElement;
    getTextContent(): string;
    getStartPoint(): EditorPoint;
    getEndPoint(): EditorPoint;
    isStartPartial(): boolean;
    isEndPartial(): boolean;
    readonly nextInlineElement: PartialInlineElement;
    readonly previousInlineElement: PartialInlineElement;
    contains(editorPoint: EditorPoint): boolean;
    isAfter(inlineElement: InlineElement): boolean;
    applyStyle(styler: (node: Node) => void, fromPoint?: EditorPoint, toPoint?: EditorPoint): void;
    private getRange();
}

export class TextInlineElement extends NodeInlineElement {
    constructor(containerNode: Node, parentBlock: BlockElement);
}

export class BodyScoper implements TraversingScoper {
    private rootNode;
    private inlineElementFactory;
    constructor(rootNode: Node, inlineElementFactory: InlineElementFactory);
    getStartBlockElement(): BlockElement;
    getStartInlineElement(): InlineElement;
    isBlockInScope(blockElement: BlockElement): boolean;
    trimInlineElement(inlineElement: InlineElement): InlineElement;
}

export class EditorSelection {
    private rootNode;
    private selectionRange;
    private inlineElementFactory;
    private readonly startPoint;
    private readonly endPoint;
    private startInline;
    private endInline;
    private startEndCalculated;
    private startBlock;
    private endBlock;
    constructor(rootNode: Node, selectionRange: Range, inlineElementFactory: InlineElementFactory);
    readonly collapsed: boolean;
    readonly inlineElementBeforeStart: InlineElement;
    readonly startInlineElement: InlineElement;
    readonly endInlineElement: InlineElement;
    readonly startBlockElement: BlockElement;
    readonly endBlockElement: BlockElement;
    trimInlineElement(inlineElement: InlineElement): InlineElement;
    isBlockInScope(blockElement: BlockElement): boolean;
    private calculateStartEndIfNecessory();
    private calculateStartEndInline();
}

export class SelectionBlockScoper implements TraversingScoper {
    private startPosition;
    private readonly editorSelection;
    private selectionBlock;
    constructor(rootNode: Node, selectionRange: Range, startPosition: ContentPosition, inlineElementFactory: InlineElementFactory);
    getStartBlockElement(): BlockElement;
    getStartInlineElement(): InlineElement;
    getInlineElementBeforeStart(): InlineElement;
    isBlockInScope(blockElement: BlockElement): boolean;
    trimInlineElement(inlineElement: InlineElement): InlineElement;
}

export class SelectionScoper implements TraversingScoper {
    private readonly editorSelection;
    constructor(rootNode: Node, selectionRange: Range, inlineElementFactory: InlineElementFactory);
    getStartBlockElement(): BlockElement;
    getStartInlineElement(): InlineElement;
    isBlockInScope(blockElement: BlockElement): boolean;
    trimInlineElement(inlineElement: InlineElement): InlineElement;
}

export function applyFormat(element: HTMLElement, format: DefaultFormat): void;

export function changeElementTag(element: HTMLElement, newTag: string, range?: Range): HTMLElement;

export function contains(container: Node, contained: Node): boolean;

/**
 * @deprecated Use sanitizeHtml() instead
 */
export function convertInlineCss(sourceHtml: string, additionalStyleNodes?: HTMLStyleElement[]): string;

/**
 * Sanitize HTML string
 * This function will do the following work:
 * 1. Convert global CSS into inline CSS
 * 2. Remove dangerous HTML tags and attributes
 * 3. Remove useless CSS properties
 * @param html The input HTML
 * @param additionalStyleNodes additional style nodes for inline css converting
 * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing
 * @param propertyCallbacks A callback function map to handle HTML properties
 * @param preserveFragmentOnly If set to true, only preserve the html content between <!--StartFragment--> and <!--Endfragment-->
 */
export function sanitizeHtml(html: string, additionalStyleNodes?: HTMLStyleElement[], convertInlineCssOnly?: boolean, propertyCallbacks?: SanitizeHtmlPropertyCallback, preserveFragmentOnly?: boolean, currentStyle?: StyleMap): string;

/**
 * Callback function set for sanitizeHtml().
 * sanitizeHtml() will check if there is a callback function for a given property name,
 * it will call this function to decide what value to set for this property.
 * Return null will cause this property be deleted, otherwise return the value of the property
 */
export type SanitizeHtmlPropertyCallback = {
    [name: string]: (value: string) => string;
};

/**
 * A map from CSS style name to its value
 */
export type StyleMap = {
    [name: string]: string;
};

export function fromHtml(htmlFragment: string, ownerDocument: HTMLDocument): Node[];

export function getComputedStyle(node: Node, styleName: string): string;

/**
 * Get computed styles of a node
 * @param node The node to get computed styles from
 * @param styleNames Names of style to get, can be a single name or an array.
 * Default value is font-family, font-size, color, background-color
 * @returns An array of the computed styles
 */
export function getComputedStyles(node: Node, styleNames?: string | string[]): string[];

export function getTagOfNode(node: Node): string;

export function isBlockElement(node: Node): boolean;

/**
 * Check if position is or encompasses any of targets
 * @param position The doucment position to check
 * @param targets The target position or position array
 */
export function isDocumentPosition(position: DocumentPosition, targets: DocumentPosition | DocumentPosition[]): boolean;

export function isEditorPointAfter(point1: EditorPoint, point2: EditorPoint): boolean;

/**
 * Check if a given node has visible content
 */
export function isNodeEmpty(node: Node, trim?: boolean): boolean;

export function isTextualInlineElement(inlineElement: InlineElement): boolean;

export function matchWhiteSpaces(source: string): string[];

export function normalizeEditorPoint(container: Node, offset: number): EditorPoint;

/**
 * Split parent node of the given node before/after the given node.
 * When a parent node contains [A,B,C] and pass B as the given node,
 * If split before, the new nodes will be [A][B,C] and returns [A];
 * otherwise, it will be [A,B][C] and returns [C].
 * @param node The node to split before/after
 * @param splitBefore Whether split before or after
 * @returns The new parent node
 */
export function splitParentNode(node: Node, splitBefore: boolean): Node;

export function unwrap(node: Node): Node;

export function wrap(node: Node, htmlFragment: string): Node;

export function wrapAll(nodes: Node[], htmlFragment?: string): Node;

export class VTable {
    table: HTMLTableElement;
    cells: VCell[][];
    row: number;
    col: number;
    private trs;
    constructor(node: HTMLTableElement | HTMLTableCellElement);
    writeBack(): void;
    applyFormat(format: TableFormat): void;
    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => void): void;
    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => void): void;
    getCell(row: number, col: number): VCell;
    getCurrentTd(): HTMLTableCellElement;
    static moveChildren(fromNode: Node, toNode?: Node): void;
    static cloneNode<T extends Node>(node: T): T;
    static cloneCell(cell: VCell): VCell;
    private recalcSpans(row, col);
}

export interface VCell {
    td?: HTMLTableCellElement;
    spanLeft?: boolean;
    spanAbove?: boolean;
}

export class Editor {
    private undoService;
    private suspendAddingUndoSnapshot;
    private omitContentEditable;
    private disableRestoreSelectionOnFocus;
    private inIME;
    private core;
    private eventDisposers;
    /**
     * Creates an instance of Editor
     * @param contentDiv The DIV HTML element which will be the container element of editor
     * @param options An optional options object to customize the editor
     */
    constructor(contentDiv: HTMLDivElement, options?: EditorOptions);
    /**
     * Dispose this editor, dispose all plugins and custom data
     */
    dispose(): void;
    /**
     * Get whether this editor is disposed
     * @returns True if editor is disposed, otherwise false
     */
    isDisposed(): boolean;
    /**
     * Insert node into editor
     * @param node The node to insert
     * @param option Insert options. Default value is:
     *  position: ContentPosition.SelectionStart
     *  updateCursor: true
     *  replaceSelection: true
     *  insertOnNewLine: false
     * @returns true if node is inserted. Otherwise false
     */
    insertNode(node: Node, option?: InsertOption): boolean;
    /**
     * Delete a node from editor content
     * @param node The node to delete
     * @returns true if node is deleted. Otherwise false
     */
    deleteNode(node: Node): boolean;
    /**
     * Replace a node in editor content with another node
     * @param existingNode The existing node to be replaced
     * @param new node to replace to
     * @returns true if node is replaced. Otherwise false
     */
    replaceNode(existingNode: Node, toNode: Node): boolean;
    /**
     * Get InlineElement at given node
     * @param node The node to create InlineElement
     * @requires The InlineElement result
     */
    getInlineElementAtNode(node: Node): InlineElement;
    /**
     * Check if the node falls in the editor content
     * @param node The node to check
     * @returns True if the given node is in editor content, otherwise false
     */
    contains(node: Node): boolean;
    /**
     * Query HTML elements in editor using querySelectorAll() method
     * @param selector Selector string to query
     * @param forEachCallback An optional callback to be invoked on each node in query result
     * @returns HTML Element list of the query result
     */
    queryElements<T extends HTMLElement = HTMLElement>(selector: string, forEachCallback?: (node: T) => void): T[];
    /**
     * Check whether the editor contains any visible content
     * @param trim Whether trime the content string before check. Default is false
     * @returns True if there's no visible content, otherwise false
     */
    isEmpty(trim?: boolean): boolean;
    /**
     * Get current editor content as HTML string
     * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins
     * before return. Use this parameter to remove any temporary content added by plugins.
     * @returns HTML string representing current editor content
     */
    getContent(triggerExtractContentEvent?: boolean): string;
    /**
     * Get plain text content inside editor
     * @returns The text content inside editor
     */
    getTextContent(): string;
    /**
     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
     * @param content HTML content to set in
     */
    setContent(content: string): void;
    /**
     * Insert HTML content into editor
     * @param HTML content to insert
     * @param option Insert options. Default value is:
     *  position: ContentPosition.SelectionStart
     *  updateCursor: true
     *  replaceSelection: true
     *  insertOnNewLine: false
     */
    insertContent(content: string, option?: InsertOption): void;
    /**
     * @deprecated Use queryElements instead
     */
    queryContent(selector: string): NodeListOf<Element>;
    /**
     * Get current selection range from Editor.
     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
     * @returns current selection range, or null if editor never got focus before
     */
    getSelectionRange(): Range;
    /**
     * Get current selection
     * @return current selection object
     */
    getSelection(): Selection;
    /**
     * Check if focus is in editor now
     * @returns true if focus is in editor, otherwise false
     */
    hasFocus(): boolean;
    /**
     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.
     */
    focus(): void;
    /**
     * Update selection in editor
     * @param selectionRange The selection range to update to
     * @returns true if selection range is updated. Otherwise false.
     */
    updateSelection(selectionRange: Range): boolean;
    /**
     * Save the current selection in editor so that when focus again, the selection can be restored
     */
    saveSelectionRange(): void;
    /**
     * Get a rect representing the location of the cursor.
     * @returns a Rect object representing cursor location
     */
    getCursorRect(): Rect;
    /**
     * Apply inline style to current selection
     * @param styler The callback function to apply style
     */
    applyInlineStyle(styler: (element: HTMLElement) => void): void;
    /**
     * Add a custom DOM event handler to handle events not handled by roosterjs.
     * Caller need to take the responsibility to dispose the handler properly
     * @param eventName DOM event name to handle
     * @param handler Handler callback
     * @returns A dispose function. Call the function to dispose this event handler
     */
    addDomEventHandler(eventName: string, handler: (event: UIEvent) => void): () => void;
    /**
     * Trigger an event to be dispatched to all plugins
     * @param pluginEvent The event object to trigger
     * @param broadcast indicates if the event needs to be dispatched to all plugins
     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that
     */
    triggerEvent(pluginEvent: PluginEvent, broadcast?: boolean): void;
    /**
     * Trigger a ContentChangedEvent
     * @param source Source of this event, by default is 'SetContent'
     * @param data additional data for this event
     */
    triggerContentChangedEvent(source?: ChangeSource | string, data?: any): void;
    /**
     * Undo last edit operation
     */
    undo(): void;
    /**
     * Redo next edit operation
     */
    redo(): void;
    /**
     * Run a callback with undo suspended.
     * @param callback The callback to run
     */
    runWithoutAddingUndoSnapshot(callback: () => void): void;
    /**
     * Add an undo snapshot if undo is not suspended
     */
    addUndoSnapshot(): void;
    /**
     * Whether there is an available undo snapshot
     */
    canUndo(): boolean;
    /**
     * Whether there is an available redo snapshot
     */
    canRedo(): boolean;
    /**
     * Get document which contains this editor
     * @returns The HTML document which contains this editor
     */
    getDocument(): Document;
    /**
     * Get custom data related to this editor
     * @param key Key of the custom data
     * @param getter Getter function. If custom data for the given key doesn't exist,
     * call this function to get one and store it.
     * @param disposer An optional disposer function to dispose this custom data when
     * dispose editor.
     */
    getCustomData<T>(key: string, getter: () => T, disposer?: (value: T) => void): T;
    /**
     * Check if editor is in IME input sequence
     * @returns True if editor is in IME input sequence, otherwise false
     */
    isInIME(): boolean;
    /**
     * Get default format of this editor
     * @returns Default format object of this editor
     */
    getDefaultFormat(): DefaultFormat;
    /**
     * Get a content traverser that can be used to travse content within editor
     * @param scope Content scope type. There are 3 kinds of scoper:
     * 1) SelectionBlockScoper is a block based scoper that restrict traversing within the block where the selection is
     *    it allows traversing from start, end or selection start position
     *    this is commonly used to parse content from cursor as user type up to the begin or end of block
     * 2) SelectionScoper restricts traversing within the selection. It is commonly used for applying style to selection
     * 3) BodyScoper will traverse the entire editor body from the beginning (ignoring the passed in position parameter)
     * @param position Start position of the traverser
     * @returns A content traverser to help travse among InlineElemnt/BlockElement within scope
     */
    getContentTraverser(scope: ContentScope, position?: ContentPosition): ContentTraverser;
    /**
     * Run a callback function asynchronously
     * @param callback The callback function to run
     */
    runAsync(callback: () => void): void;
    private createEventHandlers();
    private stopPropagation;
    private onKeyPress;
    private selectEditorPoint(container, offset);
    private ensureInitialContent();
    private startIdleLoop(interval);
}

export interface EditorCore {
    document: Document;
    contentDiv: HTMLDivElement;
    plugins: EditorPlugin[];
    inlineElementFactory: InlineElementFactory;
    defaultFormat: DefaultFormat;
    customData: {
        [Key: string]: {
            value: any;
            disposer: (value: any) => void;
        };
    };
    cachedSelectionRange: Range;
    idleLoopHandle: number;
    ignoreIdleEvent: boolean;
    api: CoreApiMap;
}

export interface CoreApiMap {
    applyInlineStyle: ApplyInlineStyle;
    attachDomEvent: AttachDomEvent;
    focus: Focus;
    getContentTraverser: GetContentTraverser;
    getCustomData: GetCustomData;
    getCursorRect: GetCursorRect;
    getSelectionRange: GetSelectionRange;
    hasFocus: HasFocus;
    insertNode: InsertNode;
    triggerEvent: TriggerEvent;
    updateSelection: UpdateSelection;
}

export type ApplyInlineStyle = (core: EditorCore, styler: (element: HTMLElement) => void) => void;

export type AttachDomEvent = (core: EditorCore, eventName: string, pluginEventType?: PluginEventType, beforeDispatch?: (event: UIEvent) => void) => () => void;

export type Focus = (core: EditorCore) => void;

export type GetContentTraverser = (core: EditorCore, scope: ContentScope, position?: ContentPosition) => ContentTraverser;

export type GetCustomData = <T>(core: EditorCore, key: string, getter: () => T, disposer?: (value: T) => void) => T;

export type GetCursorRect = (core: EditorCore) => Rect;

export type GetSelectionRange = (core: EditorCore, tryGetFromCache: boolean) => Range;

export type HasFocus = (core: EditorCore) => boolean;

export type InsertNode = (core: EditorCore, node: Node, option: InsertOption) => boolean;

export type TriggerEvent = (core: EditorCore, pluginEvent: PluginEvent, broadcast: boolean) => void;

export type UpdateSelection = (core: EditorCore, range: Range) => boolean;

export interface EditorOptions {
    plugins?: EditorPlugin[];
    defaultFormat?: DefaultFormat;
    undo?: UndoService;
    initialContent?: string;
    idleEventTimeSpanInSecond?: number;
    disableRestoreSelectionOnFocus?: boolean;
    omitContentEditableAttributeChanges?: boolean;
    coreApiOverride?: Partial<CoreApiMap>;
}

export interface EditorPlugin {
    name?: string;
    initialize: (editor: Editor) => void;
    dispose: () => void;
    willHandleEventExclusively?: (event: PluginEvent) => boolean;
    onPluginEvent?: (event: PluginEvent) => void;
}

/**
 * Provides snapshot based undo service for Editor
 */
export class Undo implements UndoService {
    private preserveSnapshots;
    private maxBufferSize;
    private editor;
    private isRestoring;
    private hasNewContent;
    private lastKeyPress;
    private onDropDisposer;
    private onCutDisposer;
    name: 'Undo';
    protected undoSnapshots: UndoSnapshotsService;
    /**
     * Create an instance of Undo
     * @param preserveSnapshots True to preserve the snapshots after dispose, this allows
     * this object to be reused when editor is disposed and created again
     * @param maxBufferSize The max buffer size for snapshots. Default value is 10MB
     */
    constructor(preserveSnapshots?: boolean, maxBufferSize?: number);
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    initialize(editor: Editor): void;
    /**
     * Dispose this plugin
     */
    dispose(): void;
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    onPluginEvent(event: PluginEvent): void;
    /**
     * Clear all existing undo snapshots
     */
    clear(): void;
    /**
     * Restore an undo snapshot to editor
     */
    undo(): void;
    /**
     * Restore a redo snapshot to editor
     */
    redo(): void;
    /**
     * Whether there is a snapshot for undo
     */
    canUndo(): boolean;
    /**
     * Whether there is a snapshot for redo
     */
    canRedo(): boolean;
    /**
     * Add an undo snapshot
     */
    addUndoSnapshot(): void;
    protected getSnapshotsManager(): UndoSnapshotsService;
    private restoreSnapshot(delta);
    private onKeyDown(pluginEvent);
    private onKeyPress(pluginEvent);
    private clearRedoForInput();
    private onNativeEvent;
}

export class UndoSnapshotsService implements UndoSnapshotsService {
    private maxSize;
    private snapshots;
    private totalSize;
    private currentIndex;
    constructor(maxSize?: number);
    canMove(delta: number): boolean;
    move(delta: number): string;
    addSnapshot(snapshot: string): void;
    clearRedo(): void;
}

export interface UndoService extends EditorPlugin {
    undo: () => void;
    redo: () => void;
    addUndoSnapshot: () => void;
    canUndo: () => boolean;
    canRedo: () => boolean;
    clear: () => void;
}

export const browserData: BrowserData;

export interface BrowserData {
    isMac: boolean;
    isWin: boolean;
    isWebKit: boolean;
    isIE: boolean;
    isIE11OrGreater: boolean;
    isSafari: boolean;
    isChrome: boolean;
    isFirefox: boolean;
    isEdge: boolean;
}

export function clearEventDataCache(event: PluginEvent, key: string): void;

export function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T;

export function buildSnapshot(editor: Editor): string;

export function restoreSnapshot(editor: Editor, snapshot: string): void;

/**
 * Read CursorData from plugin event cache. If not, create one
 * @param event The plugin event, it stores the event cached data for looking up.
 * If passed as null, we will create a new cursor data
 * @param editor The editor instance
 * @returns The cursor data
 */
export function cacheGetCursorEventData(event: PluginEvent, editor: Editor): CursorData;

/**
 * Clear the cursor data in a plugin event.
 * This is called when the cursor data is changed, e.g, the text is replace with HyperLink
 * @param event The plugin event
 */
export function clearCursorEventDataCache(event: PluginEvent): void;

export class CursorData {
    private editor;
    private cachedTextBeforeCursor;
    private cachedWordBeforeCursor;
    private inlineBeforeCursor;
    private inlineAfterCursor;
    private backwardTraverser;
    private forwardTraverser;
    private backwardTraversingComplete;
    private forwardTraversingComplete;
    private inlineElementsBeforeCursor;
    private firstNonTextInlineBeforeCursor;
    /**
     * Create a new CursorData instance
     * @param editor The editor instance
     */
    constructor(editor: Editor);
    /**
     * Get the word before cursor. The word is determined by scanning backwards till the first white space, the portion
     * between cursor and the white space is the word before cursor
     * @returns The word before cursor
     */
    readonly wordBeforeCursor: string;
    /**
     * Get the inline element before cursor
     * @returns The inlineElement before cursor
     */
    readonly inlineElementBeforeCursor: InlineElement;
    /**
     * Get the inline element after cursor
     * @returns The inline element after cursor
     */
    readonly inlineElementAfterCursor: InlineElement;
    /**
     * Get X number of chars before cursor
     * The actual returned chars may be less than what is requested. e.g, length of text before cursor is less then X
     * @param numChars The X number of chars user want to get
     * @returns The actual chars we get as a string
     */
    getXCharsBeforeCursor(numChars: number): string;
    /**
     * Get text section before cursor till stop condition is met.
     * This offers consumers to retrieve text section by section
     * The section essentially is just an inline element which has Container element
     * so that the consumer can remember it for anchoring popup or verification purpose
     * when cursor moves out of context etc.
     * @param stopFunc The callback stop function
     */
    getTextSectionBeforeCursorTill(stopFunc: (textInlineElement: InlineElement) => boolean): void;
    /**
     * Get first non textual inline element before cursor
     * @returns First non textutal inline element before cursor or null if no such element exists
     */
    getFirstNonTextInlineBeforeCursor(): InlineElement;
    private continueTraversingBackwardTill(stopFunc);
}

/**
 * Get the node at selection. If an expectedTag is specified, return the nearest ancestor of current node
 * which matches the tag name, or null if no match found in editor.
 * @param editor The editor instance
 * @param expectedTags The expected tag names. If null, return the element at cursor
 * @param startNode If specified, use this node as start node to search instead of current node
 * @returns The node at cursor or the nearest ancestor with the tag name is specified
 */
export function getNodeAtCursor(editor: Editor, expectedTags?: string | string[], startNode?: Node): Node;

/**
 * @deprecated Use cacheGetNodeAtCursor instead
 */
export function cacheGetListElement(editor: Editor, event?: PluginEvent): Node;

/**
 * Get the node at selection from event cache if it exists.
 * If an expectedTag is specified, return the nearest ancestor of current node
 * which matches the tag name, or null if no match found in editor.
 * @param editor The editor instance
 * @param event Event object to get cached object from
 * @param expectedTags The expected tag names. If null, return the element at cursor
 * @returns The element at cursor or the nearest ancestor with the tag name is specified
 */
export function cacheGetNodeAtCursor(editor: Editor, event: PluginEvent, expectedTags: string | string[]): Node;

/**
 * Query nodes intersected with current selection using a selector
 * @param editor The editor
 * @param selector The selector to query
 * @param nodeContainedByRangeOnly When set to true, only return the nodes contained by current selection. Default value is false
 * @param forEachCallback An optional callback to be invoked on each node in query result
 * @returns The nodes intersected with current selection, returns an empty array if no result is found
 */
export function queryNodesWithSelection<T extends HTMLElement = HTMLElement>(editor: Editor, selector: string, nodeContainedByRangeOnly?: boolean, forEachCallback?: (node: T) => void): T[];

/**
 * Replace the specified range with a node
 * @param editor The editor instance
 * @param range The range in which content needs to be replaced
 * @param node The node to be inserted
 * @param exactMatch exactMatch is to match exactly
 * @returns True if we complete the replacement, false otherwise
 */
export function replaceRangeWithNode(editor: Editor, range: Range, node: Node, exactMatch: boolean): boolean;

/**
 * Replace text before cursor with a node
 * @param editor The editor instance
 * @param text The text for matching. We will try to match the text with the text before cursor
 * @param node The node to replace the text with
 * @param exactMatch exactMatch is to match exactly, i.e.
 * In auto linkification, users could type URL followed by some punctuation and hit space. The auto link will kick in on space,
 * at the moment, what is before cursor could be "<URL>,", however, only "<URL>" makes the link. by setting exactMatch = false, it does not match
 * from right before cursor, but can scan through till first same char is seen. On the other hand if set exactMatch = true, it starts the match right
 * before cursor.
 * @param cursorData
 */
export function replaceTextBeforeCursorWithNode(editor: Editor, text: string, node: Node, exactMatch: boolean, cursorData?: CursorData): boolean;

/**
 * Validate the text matches what's before the cursor, and return the range for it
 * @param editor The editor instance
 * @param text The text to match against
 * @param exactMatch Whether it is an exact match
 * @param cursorData The cursor data
 * @returns The range for the matched text, null if unable to find a match
 */
export function validateAndGetRangeForTextBeforeCursor(editor: Editor, text: string, exactMatch: boolean, cursorData: CursorData): Range;

/**
 * Get the list state at selection
 * The list state refers to the HTML elements <OL> or <UL>
 * @param editor The editor instance
 * @param event (Optional) The plugin event, it stores the event cached data for looking up.
 * If not passed, we will query the first <LI> node in selection and return the list state of its direct parent
 * @returns The list state. ListState.Numbering indicates <OL>, ListState.Bullets indicates <UL>,
 * ListState.None indicates no <OL> or <UL> elements found at current selection
 */
export function cacheGetListState(editor: Editor, event?: PluginEvent): ListState;

/**
 * Clear the format in current selection, after cleaning, the format will be
 * changed to default format. The format that get cleaned include B/I/U/font name/
 * font size/text color/background color/align left/align right/align center/superscript/subscript
 * @param editor The editor instance
 */
export function clearFormat(editor: Editor): void;

/**
 * Insert a hyperlink at cursor.
 * When there is a selection, hyperlink will be applied to the selection,
 * otherwise a hyperlink will be inserted to the cursor position.
 * @param editor Editor object
 * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.
 * When protocol is not specified, a best matched protocol will be predicted.
 * @param altText Optional alt text of the link, will be shown when hover on the link
 * @param displayText Optional display text for the link.
 * If specified, the display text of link will be replaced with this text.
 * If not specified and there wasn't a link, the link url will be used as display text.
 */
export function createLink(editor: Editor, link: string, altText?: string, displayText?: string): void;

/**
 * Execute format with undo
 * It tries to add undo snapshot at begin and end of the function. Duplicated snapshot will only be added once
 * @param editor The editor instance
 * @param formatter The callback format function we want to perform, it also creates a fallback node for selection.
 * A fallback node is a node to update selection to if start point or end point is not avaiable/valid
 * @param preserveSelection (Optional) Whether to preserve selection, if set to true,
 * we update the selection to original selection range.
 */
export function execFormatWithUndo(editor: Editor, formatter: Formatter, preserveSelection?: boolean): void;

/**
 * Formatter function type
 * @param startPoint Current selection start point
 * @param endPoint Current selection end point
 * @returns A fallback node for selection. When original selection range is not valid after format,
 * will try to select this element instead
 */
export type Formatter = (startPoint: EditorPoint, endPoint: EditorPoint) => Node | void | any;

/**
 * Get format state at cursor
 * A format state is a collection of all format related states, e.g.,
 * bold, italic, underline, font name, font size, etc.
 * @param editor The editor
 * @param (Optional) The plugin event, it stores the event cached data for looking up.
 * In this function the event cache is used to get list state and header level. If not passed,
 * it will query the node within selection to get the info
 * @returns The format state at cursor
 */
export function getFormatState(editor: Editor, event?: PluginEvent): FormatState;

/**
 * Insert an image to editor at current selection
 * @param editor The editor instance
 * @param imageFile The image file. There are at least 3 ways to obtain the file object:
 * From local file, from clipboard data, from drag-and-drop
 */
export function insertImage(editor: Editor, imageFile: File): void;

/**
 * Insert table into editor at current selection
 * @param editor The editor instance
 * @param columns Number of columns in table, it also controls the default table cell width:
 * if columns <= 4, width = 120px; if columns <= 6, width = 100px; else width = 70px
 * @param rows Number of rows in table
 * @param format (Optional) The table format. If not passed, the default format will be applied:
 * background color: #FFF; border color: #ABABAB
 */
export function insertTable(editor: Editor, columns: number, rows: number, format?: TableFormat): void;

/**
 * Edit table with given operation. If there is no table at cursor then no op.
 * @param editor The editor instance
 * @param operation Table operation
 */
export function editTable(editor: Editor, operation: TableOperation): void;

/**
 * Format table
 * @param table The table to format
 * @param formatName Name of the format to use
 */
export function formatTable(editor: Editor, format: TableFormat, table?: HTMLTableElement): void;

/**
 * Remove link at selection. If no links at selection, do nothing.
 * If selection contains multiple links, all of the link styles will be removed.
 * If only part of a link is selected, the whole link style will be removed.
 * @param editor The editor instance
 */
export function removeLink(editor: Editor): void;

/**
 * Set content alignment
 * @param editor The editor instance
 * @param alignment The alignment option:
 * Alignment.Center, Alignment.Left, Alignment.Right
 */
export function setAlignment(editor: Editor, alignment: Alignment): void;

/**
 * Set background color at current selection
 * @param editor The editor instance
 * @param color The color string, can be any of the predefined color names (e.g, 'red')
 * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
 * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
 */
export function setBackgroundColor(editor: Editor, color: string): void;

/**
 * Set text color at selection
 * @param editor The editor instance
 * @param color The color string, can be any of the predefined color names (e.g, 'red')
 * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
 * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
 */
export function setTextColor(editor: Editor, color: string): void;

/**
 * Change direction for the blocks/paragraph at selection
 * @param editor The editor instance
 * @param dir The direction option:
 * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'
 */
export function setDirection(editor: Editor, dir: Direction): void;

/**
 * Set font name at selection
 * @param editor The editor instance
 * @param fontName The fontName string, should be a valid CSS font-family style.
 * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
 */
export function setFontName(editor: Editor, fontName: string): void;

/**
 * Set font size at selection
 * @param editor The editor instance
 * @param fontSize The fontSize string, should be a valid CSS font-size style.
 * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
 */
export function setFontSize(editor: Editor, fontSize: string): void;

/**
 * Set image alt text for all selected images at selection. If no images is contained
 * in selection, do nothing.
 * The alt attribute provides alternative information for an image if a user for some reason
 * cannot view it (because of slow connection, an error in the src attribute, or if the user
 * uses a screen reader). See https: * @param editor The editor instance
 * @param altText The image alt text
 */
export function setImageAltText(editor: Editor, altText: string): void;

/**
 * Set indentation at selection
 * If selection contains bullet/numbering list, increase/decrease indentation will
 * increase/decrease the list level by one.
 * @param editor The editor instance
 * @param indentation The indentation option:
 * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation
 */
export function setIndentation(editor: Editor, indentation: Indentation): void;

/**
 * Toggle bold at selection
 * If selection is collapsed, it will only affect the following input after caret
 * If selection contains only bold text, the bold style will be removed
 * If selection contains only normal text, bold style will be added to the whole selected text
 * If selection contains both bold and normal text, bold stle will be added to the whole selected text
 * @param editor The editor instance
 */
export function toggleBold(editor: Editor): void;

/**
 * Toggle bullet at selection
 * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one
 * If selection contains number list, toggle bullet will convert the number list into bullet list
 * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
 * browser execCommand API
 * @param editor The editor instance
 */
export function toggleBullet(editor: Editor): void;

/**
 * Toggle italic at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only italic text, the italic style will be removed
 * If selection contains only normal text, italic style will be added to the whole selected text
 * If selection contains both italic and normal text, italic stlye will be added to the whole selected text
 * @param editor The editor instance
 */
export function toggleItalic(editor: Editor): void;

/**
 * Toggle numbering at selection
 * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one
 * If selection contains bullet list, toggle numbering will convert the bullet list into number list
 * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
 * realization of browser execCommand API
 * @param editor The editor instance
 */
export function toggleNumbering(editor: Editor): void;

/**
 * Toggle blockquote at selection, if selection already contains any blockquoted elements,
 * the blockquoted elements will be unblockquoted and other elements will take no affect
 * @param editor The editor instance
 * @param styler (Optional) The custom styler for setting the style for the
 * blockquote element
 */
export function toggleBlockQuote(editor: Editor, styler?: (element: HTMLElement) => void): void;

/**
 * Toggle strikethrough at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only strikethrough text, the strikethrough style will be removed
 * If selection contains only normal text, strikethrough style will be added to the whole selected text
 * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text
 * @param editor The editor instance
 */
export function toggleStrikethrough(editor: Editor): void;

/**
 * Toggle subscript at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only subscript text, the subscript style will be removed
 * If selection contains only normal text, subscript style will be added to the whole selected text
 * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text
 * If selection contains any superscript text, the behavior is determined by corresponding realization of browser
 * execCommand API
 * @param editor The editor instance
 */
export function toggleSubscript(editor: Editor): void;

/**
 * Toggle superscript at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only superscript text, the superscript style will be removed
 * If selection contains only normal text, superscript style will be added to the whole selected text
 * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text
 * If selection contains any subscript text, the behavior is determined by corresponding realization of browser
 * execCommand API
 * @param editor The editor instance
 */
export function toggleSuperscript(editor: Editor): void;

/**
 * Toggle underline at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only underlined text, the underline style will be removed
 * If selection contains only normal text, underline style will be added to the whole selected text
 * If selection contains both underlined and normal text, the underline style will be added to the whole selected text
 * @param editor The editor instance
 */
export function toggleUnderline(editor: Editor): void;

/**
 * Toggle header at selection
 * @param editor The editor instance
 * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to
 * the HTML header element <H1> to <H6>, 0 means no header
 * if passed in param is outside the range, will be rounded to nearest number in the range
 */
export function toggleHeader(editor: Editor, level: number): void;

/**
 * Try to match a given string with link match rules, return matched link
 * @param url Input url to match
 * @param option Link match option, exact or partial. If it is exact match, we need
 * to check the length of matched link and url
 * @param rules Optional link match rules, if not passed, only the default link match
 * rules will be applied
 * @returns The matched link data, or null if no match found.
 * The link data includes an original url and a normalized url
 */
export function matchLink(url: string): LinkData;

export class DefaultShortcut implements EditorPlugin {
    private editor;
    name: 'DefaultShortcut';
    initialize(editor: Editor): void;
    dispose(): void;
    willHandleEventExclusively(event: PluginEvent): boolean;
    onPluginEvent(event: PluginEvent): void;
}

/**
 * An editor plugin that auto linkify text as users type and show a tooltip for existing link
 */
export class HyperLink implements EditorPlugin {
    private getTooltipCallback;
    private target;
    private editor;
    private backspaceToUndo;
    name: 'HyperLink';
    /**
     * Create a new instance of HyperLink class
     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.
     * Default value is to return the href itself. If null, there will be no tooltip text.
     * @param target (Optional) Target window name for hyperlink. If null, will use "_blank"
     * @param linkMatchRules (Optional) Rules for matching hyperlink. If null, will use defaultLinkMatchRules
     */
    constructor(getTooltipCallback?: (href: string) => string, target?: string);
    initialize(editor: Editor): void;
    dispose(): void;
    onPluginEvent(event: PluginEvent): void;
    private resetAnchor(a);
    private autoLink(event);
    private processLink(a);
    private removeTempTooltip(content);
    private onClickLink;
    private tryGetHref(element);
    private forEachHyperLink(callback);
}

/**
 * An editor plugin to handle content edit event.
 * The following cases are included:
 * 1. Auto increase/decrease indentation on Tab, Shift+tab
 * 2. Enter, Backspace on empty list item
 * 3. Enter, Backspace on empty blockquote line
 */
export class ContentEdit implements EditorPlugin {
    private features;
    private editor;
    private backspaceToUndo;
    name: 'ContentEdit';
    /**
     * Create instance of ContentEdit plugin
     * @param features An optional feature set to determine which features the plugin should provide
     */
    constructor(features?: ContentEditFeatures);
    initialize(editor: Editor): void;
    dispose(): void;
    willHandleEventExclusively(event: PluginEvent): boolean;
    onPluginEvent(event: PluginEvent): void;
    private handleAutoBullet(event);
    private isListEvent(event, interestedKeyCodes);
    private isTabInTable(event);
    private cacheGetTd(event);
    private getBlockQuoteElementFromEvent(event, keyboardEvent);
    private shouldToggleState(event, node);
    private toggleList(event);
    private isCursorAtBeginningOf(node);
}

/**
 * Paste plugin, handles onPaste event and paste content into editor
 */
export class Paste implements EditorPlugin {
    private htmlPropertyCallbacks;
    private editor;
    private pasteDisposer;
    name: 'Paste';
    /**
     * Create an instance of Paste
     * @param deprecated Deprecated parameter only used for compatibility with old code
     * @param htmlPropertyCallbacks A callback to help handle html sanitization
     */
    constructor(deprecated?: boolean, htmlPropertyCallbacks?: SanitizeHtmlPropertyCallback);
    initialize(editor: Editor): void;
    dispose(): void;
    onPluginEvent(event: PluginEvent): void;
    private onPaste;
    /**
     * Paste into editor using passed in clipboardData with original format
     * @param clipboardData The clipboardData to paste
     */
    pasteOriginal(clipboardData: ClipboardData): void;
    /**
     * Paste plain text into editor using passed in clipboardData
     * @param clipboardData The clipboardData to paste
     */
    pasteText(clipboardData: ClipboardData): void;
    /**
     * Paste into editor using passed in clipboardData with curent format
     * @param clipboardData The clipboardData to paste
     */
    pasteAndMergeFormat(clipboardData: ClipboardData): void;
    private detectPasteOption(clipboardData);
    private paste(clipboardData, pasteOption, mergeCurrentFormat?);
    private internalPaste(event);
    private applyTextFormat(node, format);
}

/**
 * Feature set for ContentEdit plugin.
 * Call getDefaultContentEditFeatures() to get default feature set.
 */
export interface ContentEditFeatures {
    /**
     * When press Tab in a list, indent current list item
     * @default true
     */
    indentWhenTab: boolean;
    /**
     * When press Shift+Tab in a list, outdent current list item
     * @default true
     */
    outdentWhenShiftTab: boolean;
    /**
     * When press BaskSpace on empty line which is the first item of a list, outdent current list item
     * @default true
     */
    outdentWhenBackspaceOnEmptyFirstLine: boolean;
    /**
     * When press Enter on empty line in a list, outdent current list item
     * @default true
     */
    outdentWhenEnterOnEmptyLine: boolean;
    /**
     * When press Backspace on first char in a list, make current item a new line of previous list item
     * @default false
     */
    mergeInNewLineWhenBackspaceOnFirstChar: boolean;
    /**
     * When press BAckspace on empty line which is the first line of a blockquote, unquote current line
     * @default true
     */
    unquoteWhenBackspaceOnEmptyFirstLine: boolean;
    /**
     * When press Enter on empty line in a blockquote, unquote current line
     * @default true
     */
    unquoteWhenEnterOnEmptyLine: boolean;
    /**
     * When press space after an asterik or number in an empty line, toggle bullet/numbering
     * @default true
     */
    autoBullet: boolean;
    /**
     * When press TAB or SHIFT+TAB key in table cell, jump to next/previous table cell
     * @default true
     */
    tabInTable: boolean;
}

/**
 * Get default feature set of ContentEdit plugin
 */
export function getDefaultContentEditFeatures(): ContentEditFeatures;

/**
 * A watermark plugin to manage watermark string for roosterjs
 */
export class Watermark implements EditorPlugin {
    private watermark;
    private format;
    private editor;
    private isWatermarkShowing;
    private focusDisposer;
    private blurDisposer;
    name: 'Watermark';
    /**
     * Create an instance of Watermark plugin
     * @param watermark The watermark string
     */
    constructor(watermark: string, format?: DefaultFormat);
    initialize(editor: Editor): void;
    dispose(): void;
    onPluginEvent(event: PluginEvent): void;
    private handleWatermark;
    private showHideWatermark(ignoreCachedState);
    private showWatermark();
    private hideWatermark();
    private removeWartermarkFromHtml(event);
}

export class TableResize implements EditorPlugin {
    private editor;
    private onMouseOverDisposer;
    private td;
    private pageX;
    private initialPageX;
    name: 'TableResize';
    constructor(isRtl?: boolean);
    initialize(editor: Editor): void;
    dispose(): void;
    onPluginEvent(event: PluginEvent): void;
    private clickIntoCurrentTd(event);
    private onMouseOver;
    private calcAndShowHandle();
    private adjustHandle(pageX);
    private getPosition(e);
    private getResizeHandle();
    private cancelEvent(e);
    private onMouseDown;
    private onMouseMove;
    private onMouseUp;
    private setTableColumnWidth(width);
    private isRtl(element);
}

export class ImageResize implements EditorPlugin {
    private minWidth;
    private minHeight;
    private selectionBorderColor;
    private forcePreserveRatio;
    private editor;
    private startPageX;
    private startPageY;
    private startWidth;
    private startHeight;
    private resizeDiv;
    private direction;
    name: 'ImageResize';
    /**
     * Create a new instance of ImageResize
     * @param minWidth Minimum width of image when resize in pixel, default value is 10
     * @param minHeight Minimum height of image when resize in pixel, default value is 10
     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C
     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false
     */
    constructor(minWidth?: number, minHeight?: number, selectionBorderColor?: string, forcePreserveRatio?: boolean);
    initialize(editor: Editor): void;
    dispose(): void;
    onPluginEvent(e: PluginEvent): void;
    private select(target);
    private unselect(selectImageAfterUnSelect);
    private startResize;
    private doResize;
    private finishResize;
    private createResizeDiv(target);
    private removeResizeDiv(resizeDiv);
    private removeResizeDivIfAny;
    private extractHtml(html);
    private getSelectedImage();
    private isNorth(direction);
    private isWest(direction);
}

/**
 * @deprecated Use ImageResize instead
 */
export class ImageResizePlugin extends ImageResize {
    /**
     * @deprecated Use ImageResize instead
     */
    constructor(minWidth?: number, minHeight?: number, selectionBorderColor?: string, forcePreserveRatio?: boolean);
}

